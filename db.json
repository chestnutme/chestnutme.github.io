{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":0},{"_id":"source/images/b-heap1.jpg","path":"images/b-heap1.jpg","modified":1,"renderable":0},{"_id":"source/images/automaton.png","path":"images/automaton.png","modified":1,"renderable":0},{"_id":"source/images/bellman-ford.png","path":"images/bellman-ford.png","modified":1,"renderable":0},{"_id":"source/images/b-heap2.jpg","path":"images/b-heap2.jpg","modified":1,"renderable":0},{"_id":"source/images/comparsion.png","path":"images/comparsion.png","modified":1,"renderable":0},{"_id":"source/images/dijkstra.png","path":"images/dijkstra.png","modified":1,"renderable":0},{"_id":"source/images/find-set1.gif","path":"images/find-set1.gif","modified":1,"renderable":0},{"_id":"source/images/fib.jpg","path":"images/fib.jpg","modified":1,"renderable":0},{"_id":"source/images/find-set2.gif","path":"images/find-set2.gif","modified":1,"renderable":0},{"_id":"source/images/dag.png","path":"images/dag.png","modified":1,"renderable":0},{"_id":"source/images/graph1.png","path":"images/graph1.png","modified":1,"renderable":0},{"_id":"source/images/bitonic-sorter2.png","path":"images/bitonic-sorter2.png","modified":1,"renderable":0},{"_id":"source/images/graph2.png","path":"images/graph2.png","modified":1,"renderable":0},{"_id":"source/images/kmp1.png","path":"images/kmp1.png","modified":1,"renderable":0},{"_id":"source/images/kmp2.png","path":"images/kmp2.png","modified":1,"renderable":0},{"_id":"source/images/lu.png","path":"images/lu.png","modified":1,"renderable":0},{"_id":"source/images/matrix.png","path":"images/matrix.png","modified":1,"renderable":0},{"_id":"source/images/matrix2.png","path":"images/matrix2.png","modified":1,"renderable":0},{"_id":"source/images/matrix3.png","path":"images/matrix3.png","modified":1,"renderable":0},{"_id":"source/images/mst-path.png","path":"images/mst-path.png","modified":1,"renderable":0},{"_id":"source/images/mst.png","path":"images/mst.png","modified":1,"renderable":0},{"_id":"source/images/n-path.png","path":"images/n-path.png","modified":1,"renderable":0},{"_id":"source/images/robin-karp.png","path":"images/robin-karp.png","modified":1,"renderable":0},{"_id":"source/images/union.jpg","path":"images/union.jpg","modified":1,"renderable":0},{"_id":"source/images/string-match1.png","path":"images/string-match1.png","modified":1,"renderable":0},{"_id":"source/images/bfs.png","path":"images/bfs.png","modified":1,"renderable":0},{"_id":"source/images/b-tree.png","path":"images/b-tree.png","modified":1,"renderable":0},{"_id":"source/images/bitonic-sorter.png","path":"images/bitonic-sorter.png","modified":1,"renderable":0},{"_id":"source/images/dag-path.png","path":"images/dag-path.png","modified":1,"renderable":0},{"_id":"source/images/dfs.png","path":"images/dfs.png","modified":1,"renderable":0},{"_id":"source/images/half-cleaner.png","path":"images/half-cleaner.png","modified":1,"renderable":0},{"_id":"source/images/kruskal.png","path":"images/kruskal.png","modified":1,"renderable":0},{"_id":"source/images/merger2.png","path":"images/merger2.png","modified":1,"renderable":0},{"_id":"source/images/merger1.png","path":"images/merger1.png","modified":1,"renderable":0},{"_id":"source/images/prim.png","path":"images/prim.png","modified":1,"renderable":0},{"_id":"source/images/sorter.png","path":"images/sorter.png","modified":1,"renderable":0},{"_id":"source/images/sortnet.png","path":"images/sortnet.png","modified":1,"renderable":0},{"_id":"source/images/scc.png","path":"images/scc.png","modified":1,"renderable":0},{"_id":"source/images/lab4/UStack2.png","path":"images/lab4/UStack2.png","modified":1,"renderable":0},{"_id":"source/images/lab4/UStack3.png","path":"images/lab4/UStack3.png","modified":1,"renderable":0},{"_id":"source/images/lab4/Ustack1.png","path":"images/lab4/Ustack1.png","modified":1,"renderable":0},{"_id":"source/images/lab4/p1.png","path":"images/lab4/p1.png","modified":1,"renderable":0},{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"source/404.html","hash":"d6cd47ba4ab178269d9e7be773e521a3f74a738b","modified":1503718701598},{"_id":"themes/landscape/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1503718701838},{"_id":"themes/landscape/.npmignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1503718701842},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1503718701838},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1503718701838},{"_id":"themes/landscape/README.md","hash":"c7e83cfe8f2c724fc9cac32bd71bb5faf9ceeddb","modified":1503718701838},{"_id":"themes/landscape/_config.yml","hash":"fb8c98a0f6ff9f962637f329c22699721854cd73","modified":1503718701842},{"_id":"themes/landscape/package.json","hash":"85358dc34311c6662e841584e206a4679183943f","modified":1503718701842},{"_id":"source/_posts/6.828-notes.md","hash":"9f8ae03d464915b197d317e0dabc77ffcd1f710c","modified":1503718701606},{"_id":"source/_posts/CLRS-notes.md","hash":"c9f0721f7fa69e3a3f9264ac0015e2e09560e105","modified":1503718701602},{"_id":"source/_posts/CLRS-notes2.md","hash":"86aa5d562b3e1eb15331c315ec49caa52e4b1145","modified":1503718701618},{"_id":"source/_posts/CLRS-notes3.md","hash":"65c2112887ce643d18b4bba6f79afaa058d0eaf8","modified":1503718701610},{"_id":"source/_posts/CLRS-notes4.md","hash":"2f35986a09a021cf6a0fd93babe7e0bf78a3822b","modified":1503718701618},{"_id":"source/_posts/CLRS-notes5.md","hash":"181de8d7cf972037a4528227d566576ac3ca6450","modified":1503718701610},{"_id":"source/_posts/CLRS-notes6.md","hash":"8da080300e0463033a843fbbf45507de98f0b525","modified":1503718701614},{"_id":"source/_posts/cs-update.md","hash":"19abf811198a076c22e79d95d135e93d6449a273","modified":1503718701618},{"_id":"source/_posts/hw1.md","hash":"01cd6ba20b725e7a110809a9e5f906bfc1b2625b","modified":1503718701598},{"_id":"source/_posts/hw2.md","hash":"46f88f1805de1884944a1cb537be362b1842f7b7","modified":1503718701614},{"_id":"source/_posts/hw4.md","hash":"eaae79bec0a0d52c40f58f6e9d555ea4eaa8d8e0","modified":1503718701598},{"_id":"source/_posts/hw3.md","hash":"aade1bb2c93c5fe101c6352f45e143f5e0da8e10","modified":1503718701618},{"_id":"source/_posts/hw5.md","hash":"524fef5136d3f28d2df70587abb28b4e762d05e9","modified":1503718701602},{"_id":"source/_posts/lab0.md","hash":"2fc46422554add487ceecf4b0c1a5569f74f6dd4","modified":1503718701606},{"_id":"source/_posts/hw6.md","hash":"03c2baeef9ee62099dceb269a4347d77d3a1e9f6","modified":1503718701614},{"_id":"source/_posts/lab1.md","hash":"7ac105205b466e5f8b111964c91598a944f5cf38","modified":1503718701606},{"_id":"source/_posts/lab2.md","hash":"e0abaf2ec36e37951ee8c3ffa485e0a130cdd3ef","modified":1503718701622},{"_id":"source/_posts/lab3_part1.md","hash":"ac4cc747d06aa8decf5351c27b62d588c329da44","modified":1503718701610},{"_id":"source/_posts/lab3_part2.md","hash":"624c8c1e0f7c13cf999f59a053440f13a67deb23","modified":1503718701614},{"_id":"source/_posts/lab4.md","hash":"a35026af51828fab9fbd127632eacbde281f4f06","modified":1503718701602},{"_id":"source/_posts/lab4_part23.md","hash":"234ce0fd2d1ba4cdbcdcec24799cbaa92239e104","modified":1503718701606},{"_id":"source/categories/index.md","hash":"3af594c06478b0c6a7186af3e9ae433efc0006af","modified":1503718701626},{"_id":"source/tags/index.md","hash":"784cd51c7b554f427bbc465795dba19f72f6f51a","modified":1503718701622},{"_id":"source/images/avatar.jpg","hash":"9abebba82d1b9d36875818d14c066aaf85c65148","modified":1503718701630},{"_id":"source/images/b-heap1.jpg","hash":"11cb960c0aad9040002b8fb815de8f5c2daa5cec","modified":1503718701634},{"_id":"source/images/automaton.png","hash":"6f79ea132a1a14247f5d2fa04b6fc0bd50ef4f69","modified":1503718701670},{"_id":"source/images/bellman-ford.png","hash":"2052caa51949b78cf573dfdccbc0a8fc715a245e","modified":1503718701650},{"_id":"source/images/b-heap2.jpg","hash":"2810f01713b2b4750e95f692a53f8aa6221338ca","modified":1503718701638},{"_id":"source/images/comparsion.png","hash":"6ec0050adb25833b8661b1f2528650023bf4169f","modified":1503718701654},{"_id":"source/images/dijkstra.png","hash":"118d3806def1dd2b913f8acf385f02eab7f6b77d","modified":1503718701650},{"_id":"source/images/find-set1.gif","hash":"d6ef2995c3a9be1d5d4178be58b7449a5b6ca755","modified":1503718701630},{"_id":"source/images/fib.jpg","hash":"b25244a5b62e294806d6e8a69cb97c6937e83600","modified":1503718701630},{"_id":"source/images/find-set2.gif","hash":"93d6d46dda4ce12562130f134763fe3eb471134a","modified":1503718701626},{"_id":"source/images/dag.png","hash":"88499953802f73912c247d5e3c413cc463c64d27","modified":1503718701642},{"_id":"source/images/graph1.png","hash":"cd990c4878c9bc4af830a3198f5d21b5ae52594c","modified":1503718701630},{"_id":"source/images/bitonic-sorter2.png","hash":"9635fd8894bf49a8d2b9b0d9b8dddf9eb08f7128","modified":1503718701658},{"_id":"source/images/graph2.png","hash":"49d64b08fe605f9c83bef78b52a0d867561c5104","modified":1503718701634},{"_id":"source/images/kmp1.png","hash":"ff85e355401d65df97221ad21e8be05e614eb7dc","modified":1503718701670},{"_id":"source/images/kmp2.png","hash":"66fe36b7a09940562f4fc9793715fd7939a657e2","modified":1503718701670},{"_id":"source/images/lu.png","hash":"36f681b84c3dfa979fcfcfa9729d4ece9ce1c873","modified":1503718701666},{"_id":"source/images/matrix.png","hash":"b8ff8041a8b36b2c5e694e4fe892bd346de1d65d","modified":1503718701662},{"_id":"source/images/matrix2.png","hash":"4e751b8c530ce491c855f9ad36b339b73247d48a","modified":1503718701662},{"_id":"source/images/matrix3.png","hash":"50e3fc0e1d545b1f8a9934c28c6f4c23b0acdb85","modified":1503718701662},{"_id":"source/images/mst-path.png","hash":"1c6f58595a83ba717a9096752a74e288360eacaf","modified":1503718701646},{"_id":"source/images/mst.png","hash":"c052a7d95918fb4abb1510ace6b7bcdbbee7564b","modified":1503718701642},{"_id":"source/images/n-path.png","hash":"b7c3b652f99507899060ce76ea7ebff93427fd6c","modified":1503718701646},{"_id":"source/images/robin-karp.png","hash":"8e477c91210172cebb43aaeffa05ddfc3316f505","modified":1503718701666},{"_id":"source/images/union.jpg","hash":"8c704e662d21467fa9e23898b2f957ad4283e9a5","modified":1503718701638},{"_id":"source/images/string-match1.png","hash":"5858d374995f4d519eb7009e9622466cb6b0e3f0","modified":1503718701666},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1503718701846},{"_id":"themes/landscape/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1503718701846},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1503718701846},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1503718701850},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1503718701850},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1503718701850},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1503718701854},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1503718701854},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1503718701854},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1503718701858},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1503718701858},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1503718701858},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1503718701862},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1503718701862},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1503718701894},{"_id":"source/images/bfs.png","hash":"9b6f3a804ba7dc0a0399755112bd77a875b41bab","modified":1503718701638},{"_id":"source/images/b-tree.png","hash":"f65efadfad7016210184ff003275bce43de4d4e1","modified":1503718701634},{"_id":"source/images/bitonic-sorter.png","hash":"4a770b7ed0c1d3bc129b195837d78b3321eea8e0","modified":1503718701654},{"_id":"source/images/dag-path.png","hash":"8d26ea640b51da474976f18f6c1db7ef4bf32cd0","modified":1503718701650},{"_id":"source/images/dfs.png","hash":"4f32d19213e3b55c471f5bfdaff21eb2876c3fa1","modified":1503718701638},{"_id":"source/images/half-cleaner.png","hash":"c6a64cfd38d698df214d1b5c990ccfe98c5a948c","modified":1503718701654},{"_id":"source/images/kruskal.png","hash":"e0556819081afe44664c72516c28a576102989e3","modified":1503718701646},{"_id":"source/images/merger2.png","hash":"95118af35d013e089e7c2a33abdf6f3fa7030d7a","modified":1503718701658},{"_id":"source/images/merger1.png","hash":"7c2817c3dd25f0a23c8fbe0c0480066083b5d430","modified":1503718701658},{"_id":"source/images/prim.png","hash":"d0aed0c7469a8d306f6d193c4096cf47209b3fdf","modified":1503718701646},{"_id":"source/images/sorter.png","hash":"346d1f8d4155345ace91c9c39a0cd2ad5b9467eb","modified":1503718701662},{"_id":"source/images/sortnet.png","hash":"499bcc93c8fa2b1d72c2d9861dfe3c41994d6fe5","modified":1503718701654},{"_id":"source/images/scc.png","hash":"c9ac4c58fe3020416a4a36200cf97b609786f575","modified":1503718701642},{"_id":"source/images/lab4/UStack2.png","hash":"916e53b1f052c9608f7de59d04d4e690042cb8f2","modified":1503718701674},{"_id":"source/images/lab4/UStack3.png","hash":"b4afe0730b4c3dffd9ceef016114c2340eab5e16","modified":1503718701678},{"_id":"source/images/lab4/Ustack1.png","hash":"1133abd46fbbe2e5ec4e61fca1a0d65ee7ac48bd","modified":1503718701674},{"_id":"source/images/lab4/p1.png","hash":"16dd97cc783455efa25ec07555633434924a3a2c","modified":1503718701674},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"82a30f81c0e8ba4a8af17acd6cc99e93834e4d5e","modified":1503718701866},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1503718701866},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"931aaaffa0910a48199388ede576184ff15793ee","modified":1503718701866},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1503718701866},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1503718701870},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1503718701870},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"4fe8853e864d192701c03e5cd3a5390287b90612","modified":1503718701870},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"c21ca56f419d01a9f49c27b6be9f4a98402b2aa3","modified":1503718701874},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1503718701874},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1503718701886},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1503718701874},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1503718701886},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1503718701890},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1503718701890},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1503718701890},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1503718701898},{"_id":"themes/landscape/source/css/_variables.styl","hash":"5e37a6571caf87149af83ac1cc0cdef99f117350","modified":1503718701898},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1503718701898},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1503718701930},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1503718701930},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1503718701934},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1503718701934},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1503718701934},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1503718701938},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1503718701938},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1503718701950},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1503718701942},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1503718701938},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1503718701878},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1503718701878},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1503718701882},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1503718701882},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1503718701882},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1503718701886},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1503718701906},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1503718701906},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1503718701902},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1503718701902},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1503718701906},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1503718701910},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1503718701910},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1503718701910},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1503718701914},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1503718701914},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1503718701918},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1503718701918},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1503718701922},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1503718701922},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1503718701926},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1503718701942},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1503718701942},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1503718701946},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1503718701946},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1503718701946},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1503718701950},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1503718701926},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1503718701922},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1503718701930},{"_id":"public/404.html","hash":"9e09018514d5eee1e99339d06f88345801a2e77b","modified":1503720897824},{"_id":"public/tags/index.html","hash":"49188dc2b78e10928ec4eed051109b967a29e08c","modified":1503720897824},{"_id":"public/categories/index.html","hash":"3e17bbf08c913e302e08d1ed9d04abf8ce9be419","modified":1503720897824},{"_id":"public/2017/04/21/hw4/index.html","hash":"6a3b16af948c461d8869d4cb6db2fff3e98e48cc","modified":1503720897824},{"_id":"public/2017/04/09/hw1/index.html","hash":"e068622c51c3cbfbb4cc5b9908e5a890b5e390d5","modified":1503720897824},{"_id":"public/2017/04/08/lab0/index.html","hash":"224a1f4314ab563afb9427f6b05fb01be57311cc","modified":1503720897825},{"_id":"public/2017/04/08/6.828-notes/index.html","hash":"3a11e0b72007696b1a13c907fc0cbd40594642c4","modified":1503720897825},{"_id":"public/page/3/index.html","hash":"028ce08afd295a54b23a7ae5f35617c111ad7abb","modified":1503720897825},{"_id":"public/archives/index.html","hash":"8d2e640a51400e5e1fa9b05df943fe32ca53da65","modified":1503720897825},{"_id":"public/archives/page/2/index.html","hash":"331fac9d6f1ed7fe002a85d5577d3bf9fff3fca1","modified":1503720897825},{"_id":"public/archives/page/3/index.html","hash":"366d2201d4c3500143ff05eabb02361f06126575","modified":1503720897825},{"_id":"public/archives/2017/index.html","hash":"310324ad2acb5a70f17a3d7d0f8bb42a1ce4f2c5","modified":1503720897825},{"_id":"public/archives/2017/page/2/index.html","hash":"2617bc741ca1f9d9a4f86e3cc56c32f5351944e3","modified":1503720897825},{"_id":"public/archives/2017/page/3/index.html","hash":"411e30ed09b4680132b2899472cd6f7eff299da4","modified":1503720897825},{"_id":"public/archives/2017/04/index.html","hash":"9883d79b7748dffea95c02b2fa7c57b4622a3ab3","modified":1503720897825},{"_id":"public/archives/2017/04/page/2/index.html","hash":"48095b8663082851c6b06b5c6778af4803918559","modified":1503720897825},{"_id":"public/archives/2017/05/index.html","hash":"6773de410aff1153a976ed0bf1935384e434f82c","modified":1503720897825},{"_id":"public/tags/algorithm/index.html","hash":"e898d744910212debe4dfdda691fe76492191410","modified":1503720897825},{"_id":"public/tags/data-structure/index.html","hash":"d4bee091ab145de072fa8913cb44987b1a709e81","modified":1503720897825},{"_id":"public/tags/os/index.html","hash":"a3a53bd1d018e6d550efd0e5ee19e95f5a0f0d96","modified":1503720897825},{"_id":"public/tags/os/page/2/index.html","hash":"17b1829ab185a102eaca05faaa0f1f347366aec9","modified":1503720897825},{"_id":"public/tags/xv6/index.html","hash":"b534baf616c6e1fadf642c6f352178ef7276f9a9","modified":1503720897825},{"_id":"public/tags/xv6/page/2/index.html","hash":"c97dd7377ad2cb2b3301b6d6db5ca515153ba738","modified":1503720897826},{"_id":"public/tags/CS/index.html","hash":"da5d8731a093a28310eac3b21dc252cf8a73b13c","modified":1503720897826},{"_id":"public/2017/05/18/CLRS-notes6/index.html","hash":"70296b5ff7666fdb87c269f901b4c586de13e451","modified":1503720897826},{"_id":"public/2017/05/13/lab4_part23/index.html","hash":"460ecd3060f2f9ced0e573dfdcce270a93ec8e0d","modified":1503720897826},{"_id":"public/2017/05/09/CLRS-notes5/index.html","hash":"bf234b909bea36e2cb5db6dcf913bac4aaf34a91","modified":1503720897826},{"_id":"public/2017/05/04/lab4/index.html","hash":"35aafa72873bb792c1fbca143f982d89d21999ed","modified":1503720897826},{"_id":"public/2017/05/02/CLRS-notes4/index.html","hash":"fa8ac20d564d0adb2bd73dae8abd33c8f0530afe","modified":1503720897826},{"_id":"public/2017/04/30/hw6/index.html","hash":"77371e852dbe8b498677b427150860576ad51827","modified":1503720897826},{"_id":"public/2017/04/29/lab3_part2/index.html","hash":"fccc24bf0f07a25f35da0f07f83069341dc23934","modified":1503720897826},{"_id":"public/2017/04/26/lab3_part1/index.html","hash":"8f86d730fc5f97c47015eb56fd89b7bf02a2252a","modified":1503720897826},{"_id":"public/2017/04/24/hw5/index.html","hash":"1db11da942542ea5b85dd4805822d41510af6a64","modified":1503720897826},{"_id":"public/2017/04/22/CLRS-notes3/index.html","hash":"8aae458038d1c8722f976bbc71b878251de8f8ee","modified":1503720897826},{"_id":"public/2017/04/19/hw3/index.html","hash":"7b66b4e4fb15b32e2044df71225b3a6619989ecf","modified":1503720897826},{"_id":"public/2017/04/18/lab2/index.html","hash":"e274d67fd7e337c0243c224ac1d542eb2bb42266","modified":1503720897827},{"_id":"public/2017/04/17/CLRS-notes2/index.html","hash":"7ae522b5aae5de2694f48b5d1a1b6b9443a9bf9c","modified":1503720897827},{"_id":"public/2017/04/16/hw2/index.html","hash":"18d72030e833c39856bc74b0f9fdf306913090f9","modified":1503720897827},{"_id":"public/2017/04/11/CLRS-notes/index.html","hash":"d4c5471d48121e73fabdd95b60c30641c546ebd6","modified":1503720897827},{"_id":"public/2017/04/10/lab1/index.html","hash":"e4ac3123d7583f29d7225261031f60c8ce7d0724","modified":1503720897827},{"_id":"public/2017/04/02/cs-update/index.html","hash":"7a040c5183297249e79869801da92fc5df299bc8","modified":1503720897827},{"_id":"public/index.html","hash":"11b22c73378d32720f2f29d7f0a0bb43b61e7f9e","modified":1503720897827},{"_id":"public/page/2/index.html","hash":"56358b6ea823f493bebea897019396caa320170b","modified":1503720897827},{"_id":"public/images/b-heap1.jpg","hash":"11cb960c0aad9040002b8fb815de8f5c2daa5cec","modified":1503720897837},{"_id":"public/images/automaton.png","hash":"6f79ea132a1a14247f5d2fa04b6fc0bd50ef4f69","modified":1503720897837},{"_id":"public/images/bellman-ford.png","hash":"2052caa51949b78cf573dfdccbc0a8fc715a245e","modified":1503720897837},{"_id":"public/images/b-heap2.jpg","hash":"2810f01713b2b4750e95f692a53f8aa6221338ca","modified":1503720897837},{"_id":"public/images/avatar.jpg","hash":"9abebba82d1b9d36875818d14c066aaf85c65148","modified":1503720897837},{"_id":"public/images/comparsion.png","hash":"6ec0050adb25833b8661b1f2528650023bf4169f","modified":1503720897837},{"_id":"public/images/find-set1.gif","hash":"d6ef2995c3a9be1d5d4178be58b7449a5b6ca755","modified":1503720897837},{"_id":"public/images/dijkstra.png","hash":"118d3806def1dd2b913f8acf385f02eab7f6b77d","modified":1503720897837},{"_id":"public/images/find-set2.gif","hash":"93d6d46dda4ce12562130f134763fe3eb471134a","modified":1503720897837},{"_id":"public/images/fib.jpg","hash":"b25244a5b62e294806d6e8a69cb97c6937e83600","modified":1503720897837},{"_id":"public/images/dag.png","hash":"88499953802f73912c247d5e3c413cc463c64d27","modified":1503720897837},{"_id":"public/images/graph1.png","hash":"cd990c4878c9bc4af830a3198f5d21b5ae52594c","modified":1503720897837},{"_id":"public/images/bitonic-sorter2.png","hash":"9635fd8894bf49a8d2b9b0d9b8dddf9eb08f7128","modified":1503720897837},{"_id":"public/images/graph2.png","hash":"49d64b08fe605f9c83bef78b52a0d867561c5104","modified":1503720897837},{"_id":"public/images/kmp1.png","hash":"ff85e355401d65df97221ad21e8be05e614eb7dc","modified":1503720897838},{"_id":"public/images/kmp2.png","hash":"66fe36b7a09940562f4fc9793715fd7939a657e2","modified":1503720897838},{"_id":"public/images/lu.png","hash":"36f681b84c3dfa979fcfcfa9729d4ece9ce1c873","modified":1503720897838},{"_id":"public/images/matrix.png","hash":"b8ff8041a8b36b2c5e694e4fe892bd346de1d65d","modified":1503720897838},{"_id":"public/images/matrix2.png","hash":"4e751b8c530ce491c855f9ad36b339b73247d48a","modified":1503720897838},{"_id":"public/images/matrix3.png","hash":"50e3fc0e1d545b1f8a9934c28c6f4c23b0acdb85","modified":1503720897838},{"_id":"public/images/mst-path.png","hash":"1c6f58595a83ba717a9096752a74e288360eacaf","modified":1503720897838},{"_id":"public/images/mst.png","hash":"c052a7d95918fb4abb1510ace6b7bcdbbee7564b","modified":1503720897838},{"_id":"public/images/n-path.png","hash":"b7c3b652f99507899060ce76ea7ebff93427fd6c","modified":1503720897838},{"_id":"public/images/union.jpg","hash":"8c704e662d21467fa9e23898b2f957ad4283e9a5","modified":1503720897838},{"_id":"public/images/robin-karp.png","hash":"8e477c91210172cebb43aaeffa05ddfc3316f505","modified":1503720897838},{"_id":"public/images/string-match1.png","hash":"5858d374995f4d519eb7009e9622466cb6b0e3f0","modified":1503720897838},{"_id":"public/images/lab4/UStack2.png","hash":"916e53b1f052c9608f7de59d04d4e690042cb8f2","modified":1503720897838},{"_id":"public/images/lab4/UStack3.png","hash":"b4afe0730b4c3dffd9ceef016114c2340eab5e16","modified":1503720897838},{"_id":"public/images/lab4/Ustack1.png","hash":"1133abd46fbbe2e5ec4e61fca1a0d65ee7ac48bd","modified":1503720897838},{"_id":"public/images/lab4/p1.png","hash":"16dd97cc783455efa25ec07555633434924a3a2c","modified":1503720897838},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1503720897838},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1503720897839},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1503720897839},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1503720897839},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1503720897839},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1503720897839},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1503720897839},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1503720897839},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1503720897839},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1503720897839},{"_id":"public/images/bfs.png","hash":"9b6f3a804ba7dc0a0399755112bd77a875b41bab","modified":1503720898225},{"_id":"public/images/b-tree.png","hash":"f65efadfad7016210184ff003275bce43de4d4e1","modified":1503720898225},{"_id":"public/images/bitonic-sorter.png","hash":"4a770b7ed0c1d3bc129b195837d78b3321eea8e0","modified":1503720898227},{"_id":"public/images/dag-path.png","hash":"8d26ea640b51da474976f18f6c1db7ef4bf32cd0","modified":1503720898227},{"_id":"public/images/dfs.png","hash":"4f32d19213e3b55c471f5bfdaff21eb2876c3fa1","modified":1503720898227},{"_id":"public/images/half-cleaner.png","hash":"c6a64cfd38d698df214d1b5c990ccfe98c5a948c","modified":1503720898227},{"_id":"public/images/kruskal.png","hash":"e0556819081afe44664c72516c28a576102989e3","modified":1503720898227},{"_id":"public/images/merger2.png","hash":"95118af35d013e089e7c2a33abdf6f3fa7030d7a","modified":1503720898227},{"_id":"public/images/merger1.png","hash":"7c2817c3dd25f0a23c8fbe0c0480066083b5d430","modified":1503720898228},{"_id":"public/images/sorter.png","hash":"346d1f8d4155345ace91c9c39a0cd2ad5b9467eb","modified":1503720898228},{"_id":"public/images/sortnet.png","hash":"499bcc93c8fa2b1d72c2d9861dfe3c41994d6fe5","modified":1503720898228},{"_id":"public/images/prim.png","hash":"d0aed0c7469a8d306f6d193c4096cf47209b3fdf","modified":1503720898228},{"_id":"public/images/scc.png","hash":"c9ac4c58fe3020416a4a36200cf97b609786f575","modified":1503720898228},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1503720898228},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1503720898231},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1503720898231},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1503720898232},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1503720898232},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1503720898232},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1503720898232},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1503720898232},{"_id":"public/css/style.css","hash":"fffb3966bf36057a325498aba9ce3a2ea7bd79e1","modified":1503720898232},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1503720898232},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1503720898232},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1503720898236},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1503720898236}],"Category":[],"Data":[],"Page":[{"_content":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"https://qzone.qq.com/gy/404/style/404style.css\">\n</head>\n<body>\n  <script type=\"text/plain\" src=\"http://www.qq.com/404/search_children.js\"\n          charset=\"utf-8\" homePageUrl=\"/\"\n          homePageName=\"回到我的主页\">\n  </script>\n  <script src=\"https://qzone.qq.com/gy/404/data.js\" charset=\"utf-8\"></script>\n  <script src=\"https://qzone.qq.com/gy/404/page.js\" charset=\"utf-8\"></script>\n</body>\n</html>","source":"404.html","raw":"<!DOCTYPE HTML>\n<html>\n<head>\n  <meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\"/>\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\" />\n  <meta name=\"robots\" content=\"all\" />\n  <meta name=\"robots\" content=\"index,follow\"/>\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"https://qzone.qq.com/gy/404/style/404style.css\">\n</head>\n<body>\n  <script type=\"text/plain\" src=\"http://www.qq.com/404/search_children.js\"\n          charset=\"utf-8\" homePageUrl=\"/\"\n          homePageName=\"回到我的主页\">\n  </script>\n  <script src=\"https://qzone.qq.com/gy/404/data.js\" charset=\"utf-8\"></script>\n  <script src=\"https://qzone.qq.com/gy/404/page.js\" charset=\"utf-8\"></script>\n</body>\n</html>","date":"2017-08-26T03:38:21.598Z","updated":"2017-08-26T03:38:21.598Z","path":"404.html","title":"","comments":1,"layout":"page","_id":"cj6sslh9q00003gamh9wol394","content":"<!DOCTYPE HTML>\n<html>\n<head>\n  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n  <meta name=\"robots\" content=\"all\">\n  <meta name=\"robots\" content=\"index,follow\">\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"https://qzone.qq.com/gy/404/style/404style.css\"><!-- hexo-inject:begin --><!-- hexo-inject:end -->\n</head>\n<body>\n  <!-- hexo-inject:begin --><!-- hexo-inject:end --><script type=\"text/plain\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homepageurl=\"/\" homepagename=\"回到我的主页\">\n  </script>\n  <script src=\"https://qzone.qq.com/gy/404/data.js\" charset=\"utf-8\"></script>\n  <script src=\"https://qzone.qq.com/gy/404/page.js\" charset=\"utf-8\"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->\n</body>\n</html>","site":{"data":{}},"excerpt":"","more":"<!DOCTYPE HTML>\n<html>\n<head>\n  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta http-equiv=\"content-type\" content=\"text/html;charset=utf-8;\">\n  <meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n  <meta name=\"robots\" content=\"all\">\n  <meta name=\"robots\" content=\"index,follow\">\n  <link rel=\"stylesheet\" type=\"text/css\" href=\"https://qzone.qq.com/gy/404/style/404style.css\"><!-- hexo-inject:begin --><!-- hexo-inject:end -->\n</head>\n<body>\n  <!-- hexo-inject:begin --><!-- hexo-inject:end --><script type=\"text/plain\" src=\"http://www.qq.com/404/search_children.js\" charset=\"utf-8\" homepageurl=\"/\" homepagename=\"回到我的主页\">\n  </script>\n  <script src=\"https://qzone.qq.com/gy/404/data.js\" charset=\"utf-8\"></script>\n  <script src=\"https://qzone.qq.com/gy/404/page.js\" charset=\"utf-8\"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->\n</body>\n</html>"},{"title":"标签","date":"2017-04-21T09:10:29.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2017-04-21 17:10:29\ntype: \"tags\"\n---\n","updated":"2017-08-26T03:38:21.622Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cj6sslhan00023gamjc07rxq8","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"分类","date":"2017-04-21T09:11:35.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2017-04-21 17:11:35\ntype: \"categories\"\n---\n","updated":"2017-08-26T03:38:21.626Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cj6sslhap00043gam2kuspm1p","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"introduction to algorithms note1","date":"2017-04-10T16:00:00.000Z","_content":"\n# ＜Introduction to algorithms＞笔记\n\n### 摘要\n　　＜introduction to algorithms＞覆盖全面,包含算法/数据结构/基本的离散数学知识;伪代码清晰简洁,适合有一定编程基础用算法实现;注重算法的推导和证明,以及对应的算法设计与分析能力;同时配套MIT课程,资料丰富.这里记录我CLRS的学习笔记,按主题章节对应分类, 以问题-答案形式总结.\n\n\n### Part1 基础\n算法定义/基本的算法设计/递归的复杂度/概率与随机算法\n\n####  Chapter1 什么是算法?\n\n>   算法:\n    $\\require{AMScd}$\n    \\begin{CD}\n    input @>\\text{computing procedure}>> ouput\n    \\end{CD}\n> * 解决一类问题的计算过程, 一个具体问题-实例\n> * 算法最重要的特性: 效率\n\n<!-- more -->\n\n#### Chapter2 如何证明一个算法的正确性?\n> 1.循环不变式:\n　　算法中大量的过程是对同类数据的重复处理,即循环是算法的基本结构.通过循环不变式可以证明经过大量复杂的步骤后,得到要求解的结果.它的结构如下:\n    >> a. 初始化: 迭代之前是循环不变式是正确的(base case)\n    >> b. 保持: 第n次迭代之前正确, 第n次之后保持正确(recursive formula)\n    >> c. 终止: 最终算法正确\n\n> 以插入排序为例：\n\\begin{align}\nA[1]有序 \\\\\\\\\nA[1] \\ldots A[i]有序, 插入后A[1] \\ldots A[i+1]有序 \\\\\\\\\n\\mapsto A[1] \\ldots A[n] 有序\n\\end{align}\n> 2.算法分析\n>> a. 输入规模 n\n>> b. 运行时间: 基本操作数(与n相关)\n>> c. 最坏情况(上界), 平均情况(基于概率分析技术)\n>> d. 运行增长率(rate of growth)\n\n> 3.基本的算法设计方法\n>> a. 增量(increment), 从零构造要求求解的结果(bottom up)\n>> b. 分治(divide and conquer), 分解子问题递归解决合并(top down)\n    divide -> conquer -> combine\n以merge sort为例来说明分治策略:\n\\begin{align}\n\\{A[1] \\ldots A[n]\\}= \\{A[1] \\ldots A[n/2]\\} + \\{A[n/2+1] \\ldots A[n]\\} \\\\\\\\\nrecusively \\, merge \\{A[1] \\ldots A[n/2]\\} or \\{A[n/2+1] \\ldots A[n]\\} \\\\\\\\\nmerge \\{A[1] \\ldots A[n/2]\\} with \\{A[n/2+1] \\ldots A[n]\\}\n\\end{align}\n\n> 4.分治法的分析\n　　分治法的基本理论是递归的解决子问题, 合并为最终解,即如下公式:\n$$\nT(n) =\n\\begin{cases}\n\\Theta(1), & \\text {if n <= c} \\\\\\\\\naT(n/b) + D(n) + C(n), & else \\\\\\\\\n\\end{cases}\n$$\n　　以merge sort为例\n$$\nT(n) =\n\\begin{cases}\nc, & \\text {if n = 1} \\\\\\\\\n2T(n/2) + cn, & \\text {if n > 1} \\\\\\\\\n\\end{cases}\n$$\n如何求解递归式?\n　　考虑到问题的分解, 类似从大的树根分叉出小的树枝, 构造递归树(等价形式),树节点表示时间代价,所有节点之和即为总的运行时间.这也是直观形象理解 **$log_m n$*在复杂度中出现的理由:\n>> m表示问题被分解为m个子问题(m叉树), n表示问题规模, $log_m n$表示递归层数(m叉树的高度)\n\n\n#### Chapter3 如何比较算法的优劣?(运行时间的阶数)\n\n> 1.运行时间与数据规模之间的关系的表达:\n>>渐进:\n$\\Theta(g(n)) = \\\\{f(n): \\exists c\\_1, c\\_2, n\\_0, \\forall n \\geq n\\_0, 0 \\leq c\\_1g(n) \\leq f(n) \\leq c\\_2g(n) \\\\}$\n上界:\n$O(g(n)) = \\\\{f(n): \\exists c, n\\_0, \\forall n \\geq n\\_0, 0 \\leq f(n) \\leq cg(n)\\\\}$\n下界:\n$\\Omega(g(n)) = \\\\{f(n): \\exists c, n\\_0, \\forall n \\geq n\\_0, 0 \\leq cg(n) \\leq f(n)\\\\}$\n\n> 2.把握阶数,忽略低阶项和系数:\n>> $ 2n^2 + 3n + 1 = 2n^2 + \\Theta(n) = \\Theta(n^2)$\n\n> 3.常用阶数:\n>> $1 < \\log n < n < n\\log n < n^2 < n^3 < a^n < n!$\n\n#### Chapter4 如何求解递归式(recurrence)?\n\n> 1.定义:\n　　递归式是一组等式或不等式,它所描述的函数是用在更小的输入下该函数的值来定义的.\n\n> 2.把握大方向，忽略技术细节:\n>> a. 假设自变量为整数: 如实际merge sort的递归式为:\n$$\nT(n) =\n\\begin{cases}\n\\Theta(1), & \\text {if n = 1} \\\\\\\\\nT(\\lceil n/2 \\rceil) + + T(\\lfloor n/2 \\rfloor) + \\Theta(n), & \\text {if n > 1} \\\\\\\\\n\\end{cases}\n$$\n>> b.向上向下取整, 简化边界条件\n\n> 3.解递归式的三个方法: 代还法, 递归树, 主方法\n\n> 3.1 代换法(Substitution method)\n>> 定义:先猜测某个界的存在,再用数学归纳法去证明该猜测的正确性。\n缺点:只能用于解的形式很容易猜的情形。\n总结:这种方法需要经验的积累,可以通过转换为先前见过的类似递归式来求解。\n例子1: 猜测对较大的n, $T(n)=2T(\\lfloor n/2\\rfloor + 17) + n$ 中与 $T(\\lfloor n/2 \\rfloor + 17)$ 与 $T(\\lfloor n/2\\rfloor)$接近\n例子2:\n\\begin{align}\n对T(n)=2T(\\lfloor n/2\\rfloor) + \\log n, 做代换m=\\log n \\\\\\\\\n有T(2^m)=2T(2^{m/2}) + m, 设S(m) = T(2^m) \\\\\\\\\n得 S(m) = 2S(m/2)+m \\\\\\\\\n得该递归式的界是S(m) = O(m\\log m) 代回得: \\\\\\\\\nT(n) = T(2^m) = S(m) = O(m\\log m) = O(\\log n\\log \\log n)\n\\end{align}\n\n> 3.2 递归树方法(Recursion-tree method)\n>> 起因:代换法有时很难得到一个正确的好的猜测值。\n用途:画出一个递归树是一种得到好猜测的直接方法。\n分析(重点):在递归树中,每一个结点都代表递归函数调用集合中一个子问题的代价。将递归树中每一层内的代价相加得到一个每层代价的集合,再将每层的代价相加得到递归式所有层次的总代价。\n总结:递归树最适合用来产生好的猜测,然后用代换法加以验证。递归树的方法非常直观,总的代价就是把所有层次的代价相加起来得到。但是分析这个总代价的规模却不是件很容易的事情,有时需要用到很多数学的知识,如数列求和, 不等式放缩等.\n\n> 3.3 主方法(Master method)\n>> 主方法是最好用的recipe 方法,可以很快估计出递归算法的时间复杂度,主方法总结了常见的情况并给出了一个公式.实际上主方法一直在比较 f(n)与 $N^{\\log_b^a}$ 的规模,然后选取规模大的作为最后的递归式的规模\n定义:\n　　设 a≥1 和 b≥1 是常数f(n)是定义在非负整数上的一个确定的非负函数。又设T(n)也是定义在非负整数上的一个非负函数,且满足递归方程$T(n)=aT(n/b)+f(n)$ 。方程 $T(n)=aT(n/b)+f(n)$ 中的 $n/b$ 可以是$\\lceil n/b\\rceil$,也可以是 $\\lfloor n/b \\rfloor$。那么,在$f(n)$的三类情况下,我们有 T(n)的渐近估计式:\n优点:针对形如 T(n)=aT(n/b)+f(n)的递归式:\n\\begin{align}\n1) 对\\epsilon > 0, f(n)=O(n^{\\log_b^a-\\epsilon}) \\to T(n)=\\Theta(n^{\\log_b^a}) \\\\\\\\\n2) f(n) = \\Theta(n^{\\log_b^a}) \\to T(n)=\\Theta(n^{\\log_b^a}\\log n) \\\\\\\\\n3) 对\\epsilon > 0,f(n)=O(n^{\\log_b^a-\\epsilon}) 且c < 1和 n > N, af(n/b) \\leq cf(n) \\to T(n)=\\Theta(f(n))\n\\end{align}\n缺点:并不能解所有形如上式的递归式的解。因为主方法在第 1 种情况与第2种情况之间、第2种情况与第3种情况之间都存在着一条沟,所以会存在着不能适用的情况。\n\n#### Chapter5 如何将概率引入算法分析中?\n> 1.概率分析: 确定input的分布或假设, 计算期望的运行时间 - 实际上是一个随机变量函数的求解过程\n> 2.在不了解input分布的条件下,通过随机算法引入概率:\n如果一个算法的行为不只是由输入决定,同时也由随机数生成器所产生的数值决定,则称这个算法是随机的。\n> 3.指示器随机变量-- 概率与期望的转换\n$$\n事件A 对应的指示器随机变量的期望期等于事件 A 发生的概率。\\\\\\\\\nI\\\\{A\\\\} =\n\\begin{cases}\n    1, if \\, A \\, happens \\\\\\\\\n    0, else\n\\end{cases}\n$$\n期望的线性性质:\n\\begin{align}\nX = \\sum\\_{i=1}^n X\\_i \\\\\\\\\nE[x] = E[\\sum\\_{i=1}^n X\\_i] = \\sum\\_{i=1}^n E[X\\_i]\n\\end{align}\n\n> 4.如何生成随机数组?\na. 随机优先级法:为数组的每个元素赋一个随机的优先级,再根据这个优先级对数组中的元素进行排序。可证这样得到的数字满足随机的性质。\nb. 原地交换法:依次把A[i]与 A[Random(i+1, Length(A))]进行 swap,得到的新数组也满足随机性。\n>> ```\nfor i ← 1 to n\n    do swap A[i] ↔ A\n```\n\n>考虑到在真正的环境中的输入可能并不是随机的,所以我们可以采用先将输入进行随机打乱的方法来保证输入数据的随机性(方法b),这点在很多算法中得以体现,比如快排有其随机选取种子数来向输入中加入随机化的成分。\n\n### Part2 排序与顺序统计\n\n基本排序算法与对比/求解中集合第i小的数\n\n> 1.排序问题\n输入:n个数的序列$[a\\_1,a\\_2, \\ldots, a\\_n]$ \\\n输出:输入序列的一个重排$[a\\_1',a\\_2',\\ldots a\\_n'],使 a\\_1' \\leq a\\_2' \\leq \\ldots \\leq a\\_n'$\n2.原地排序算法:只有线性个数的元素会被移动到集合之外的排序算法。\n3.第6章介绍堆排序,及其实现的优先级队列\n4.第7章介绍快速排序没,及其对应的分割思想\n5.第8章介绍了基于“比较”排序的算法的下界为$\\Theta(n\\log n)$。并介绍了几种不基于比较的排序方法,它们能突破$\\Omega(n\\log n)$的下界: 计数排序、基数排序、桶排序。\n6.第9章介绍了顺序统计的概念:第i个顺序统计是集合中第i小的数。并介绍了两个算法:\na.最坏情况为$O(n^2)$但平均情况下为线性$O(n)$的算法\nb.最坏情况下为线性$O(n)$的算法\n\n#### Chapter6 如何结合数据结构和排序算法?\n\n> 1.heapsort:$O(n\\log n)$, 原地排序(in place)\n    利用heap的性质(堆顶为max或min)来进行排序\n> 2.heap:\n>> a.逻辑结构为完全二叉树, 高度为$\\log_2(n)$\n>> b.物理结构为数组(非链表, 因为要求随机访问)\n>> c.性质(以大顶堆为例):$A[Parent(i)] \\geq A[i]$\n>> d.方法:\n* max-heapify(A, i): 递归向下调整以i为根的子树, 保持性质c, $O(\\log n)$\n* build-max-heap(A): 调用max-heapify建堆A, $O(n)$\n* heapsort: 原地堆排序, $O(n\\log n)$\n\n>>```\nmax-heapify(A, i)\nl <- Left(i)\nr <- Right(i)\nif l <= heap-size[A] and A[l] > A[i]\n    then largest <- l\n    else largest <- i\nif r <= heap-size[A] and A[r] > A[largest]\n    then largest <- r\nif largest not = i\n    then exchange A[i] <-> A[largest]\n    max-heapify(A, largest)\n```\n\n\n>> ```\nbulid-max-heap(A)\nheap-size[A] <- length[A]\nfor i <- length[A] / 2 downto 1\n    do max-heapity(A, i)\n```\n\n>> ```\nheapsort(A)\nbuild-max-heap(A)\nfor i <- length[A] downto 2\n    do exchange A[i] <-> A[i]\n    heap-size[A] <- heap-size[A] - 1\n    max-heapify(A, 1)\n```\n\n> 3.优先级队列(用堆实现)\n>> a. 方法:\n    * maximum(S):返回最大key的元素 -> 大顶堆堆顶元素\n    * insert(S, x): 插入x -> 插入堆尾并max-heapify(A, n + 1)\n    * extract-max: 在maximum基础上删除max -> swap(A[1], A[n]), max-heaptify(A, 1)\nb. 应用: 操作系统中优先级调度算法, 事件模拟\n\n#### Chapter7 如何实现快速排序?\n> 1.快排: 基于递归思想, 最坏$\\Theta(n^2)$, 平均$O(n\\log n)$, 且由于 $O(n\\log n)$中隐含的常数因子很小,所以快排通常是用于排序的最佳的实用选择(因为其平均性能非常好).\n特性:平均性能非常好、原地排序不需要额外的空间、代码实现机器简洁清晰\n\n> 2.分割partition: 将A[p..r]分割为均小于等于A[q]的A[p..q-1] 和 均大于A[q]的 A[q+1..r]\n>```\npartition(A, p, r)\nx <- A[r]\ni <- p-1\nfor j <- p to r-1\n    do if A[j] <= x\n        then i <- i+1\n            exchange A[i]<-> A[j]\nexchange A[i+1] <-> A[r]\nreturn i+1\n```\n\n> 3.快排, 递归实现\n>```\nquicksort(A, p, r)\nif p < r\n    then q <- partition(A, p, r)\n        quicksort(A, p, q - 1)\n        quicksort(A, q + 1, r)\n```\n\n> 4.快排性能:\n划分是对称的, 生成的递归树亦对称,等同于merge sort;\n划分极度不对称, 生成递归树为单支树, 树高为n, 等同于insert sort;\n因此在真正的应用时很容易出现待排序的数组其实已经是有序的情况下,它在待排数组有序时的效率是最差的$O(n^2)$,所以需要随机化技术来使得划分尽可能均匀对称.\n　　正如第5章所说的,由于工程中的输入可能不随机的,所以我们要将其随机化.有两种可选方案\n>> a.直接对输入数据进行随机化排列\n>> b.采用随机取样的随机化技术。\n采用更高效的(2)随机取样(random sampling):随机选择key元素\n>```\nrandomized-partition(A, p, r)\ni <- random(p, r)\nexchange A[r] <-> A[i]\nreturn partition(A, p, r)\n```\n\n#### Chapter8 排序算法的下界在哪里?\n> 1.任何比较的排序在最坏的情况下都要用$\\Theta(n\\log n)$次比较来进行排序,\n采用决策树来证明:\n\\begin{align}\n高度h, 叶节点个数l的决策树模拟n个元素的比较排序 \\\\\\\\\n\\because n元素有 n!个排列 \\to  n! \\leq l \\\\\\\\\n又\\because l \\leq 2^h \\\\\\\\\n\\therefore n! \\leq l \\leq 2^h \\\\\\\\\n\\therefore h \\geq \\log(n!) = \\Omega(n\\log n)\n\\end{align}\n所以合并排序和堆排序是渐近最优的。但要注意:快排不是渐近最优的,因为它在最坏的情况下是$O(n^2)$\n\n> 2.三种以线性时间运行的排序算法:计数排序、基数排序和桶排序，皆基于非比较的模型．\n\n> 2.1 计数排序: 统计元素个数, 从小到大输出, $\\Theta(n)$\n>```\ncounting-sort(A, B, k)\nfor i <- 0 to k\n    do C[i] = 1\nfor j <- 1 to length[A]\n    do C[A[j]] <- C[A[j]] + 1\nC[i]: 等于i的元素个数\nfor i <- 1 to k\n    do C[i] <- C[i] + C[i-1]\nC[i]: 小于等于i的元素个数\nfor j <- lenght[A]\n    do B[C[A[j]]] <- A[j]\n        C[A[j]] <- C[A[j]] - 1\n```\n>a. 计数排序的一个重要性就是它是稳定的排序算法,这个稳定性是基数排序的基石。\nb. 计数排序的思想简单、高效、可靠．\nc. 缺点在于:\n>>i. 需要很多额外的空间(当前类型的值的范围)\nii. 只能对离散的数据有效,比如int(double不行)\niii.基于假设:输入是小范围内的整数构成的。\n\n> 2.2 基数排序: 基于数位(k), $\\Theta(d(n+k))$\n>```\nradix-sort(A, d)\nfor i <- 1 to d\n    do use a stable sort array A on digit i\n```\n>a. 低位相同时用高一位进行排序,要求基数排序时对每一位进行调用子排序算法时要求这个子排序算法必须是稳定的, 即同Key, 相对顺序不变.\nb. 基数排序与直觉相反:它是按照从低位到高位的顺序排序的。我认为原因在于高有效位对低有效位有着决定性的作用。\n\n> 2.3 桶排序:分割子区间(桶), 桶内排序后输出 $\\Theta(n)$\n>```\nbucket-sort\nn <- length[A]\nfor i <- 1 to n\n    do insert A[i] into list B[nA[i]]\nfor i <- 0 to n-1\n    do sort list B[i] with insert sort\noutput the lists B[0], B[1],..B[n-1] in order\n```\n>a.桶排序也只是期望运行时间能达到线性,对于最坏的情况,它的运行时间取决于它内部使用的子排序算法的运行时间,\n一般为 O(nlgn)。\nb.桶排序基于假设:输入的的元素均匀的分布在区间[0, 1]上。\n\n\n> 3.总结: 所有的线性时间内的排序算法,都作出了一定的假设, 必须建立在一定的输入数据的条件上.\n\n\n#### Chapter9 如何找到第i小的数?\n> 1.the i-th order statistic: 第i小的元素\n    直观的讲, 先排序然后直接选出A[i]就是该问题的解答.但实际上问题只要求第i小的数,排序则是求出了所有元素的次序, 那么是否不需要较大的消耗的排序,而去直接求解呢?\n\n> 2.由简入深\n>> min(max): 线性遍历, $\\Theta(n)$\n>>```\nminimum(A)\nmin <- A[1]\nfor i <- 2 to length[A]\n        do if min > A[i]\n            then min <- A[i]\nreturn min\n```\n>> i-th:随机选择与分割定位: 递归, $\\Theta(n)$\n>>```\nrandomized-select(A, p, r, i)\nif p = r\n        then return A[p]\nq <- randomized-partition(A, p, r)\nk <- q - p + 1\nif i = k\n        then return A[q]\nelseif i < k\n        then return randomized-select(A, p, q-1, i)\nelse\n        return randomized-select(A, q+1, r, i-k)\n```\n\n> 3.在第8章,比较模型中平均情况下需要$\\Theta(n\\log n)$的时间, 输入满足一定假设情况下可以达到线性时间按$O(n)$.以期望线性时间选择i-th的方法以快速排序为模型,如同在快速排序中一样,此算法的思想也是对输入数组进行递归划分。但和快速排序不同的是,快速排序会递归处理划分的两边,而randomized-select只处理划分的一边,并由此将期望的运行时间由$O(n\\log n)$下降到了$O(n)$。\n\n### Part3 数据结构\n\n####\n","source":"_posts/CLRS-notes.md","raw":"\ntitle: introduction to algorithms note1\ndate: 2017/04/11\ntags:\n    - algorithm\n    - data_structure\n\n---\n\n# ＜Introduction to algorithms＞笔记\n\n### 摘要\n　　＜introduction to algorithms＞覆盖全面,包含算法/数据结构/基本的离散数学知识;伪代码清晰简洁,适合有一定编程基础用算法实现;注重算法的推导和证明,以及对应的算法设计与分析能力;同时配套MIT课程,资料丰富.这里记录我CLRS的学习笔记,按主题章节对应分类, 以问题-答案形式总结.\n\n\n### Part1 基础\n算法定义/基本的算法设计/递归的复杂度/概率与随机算法\n\n####  Chapter1 什么是算法?\n\n>   算法:\n    $\\require{AMScd}$\n    \\begin{CD}\n    input @>\\text{computing procedure}>> ouput\n    \\end{CD}\n> * 解决一类问题的计算过程, 一个具体问题-实例\n> * 算法最重要的特性: 效率\n\n<!-- more -->\n\n#### Chapter2 如何证明一个算法的正确性?\n> 1.循环不变式:\n　　算法中大量的过程是对同类数据的重复处理,即循环是算法的基本结构.通过循环不变式可以证明经过大量复杂的步骤后,得到要求解的结果.它的结构如下:\n    >> a. 初始化: 迭代之前是循环不变式是正确的(base case)\n    >> b. 保持: 第n次迭代之前正确, 第n次之后保持正确(recursive formula)\n    >> c. 终止: 最终算法正确\n\n> 以插入排序为例：\n\\begin{align}\nA[1]有序 \\\\\\\\\nA[1] \\ldots A[i]有序, 插入后A[1] \\ldots A[i+1]有序 \\\\\\\\\n\\mapsto A[1] \\ldots A[n] 有序\n\\end{align}\n> 2.算法分析\n>> a. 输入规模 n\n>> b. 运行时间: 基本操作数(与n相关)\n>> c. 最坏情况(上界), 平均情况(基于概率分析技术)\n>> d. 运行增长率(rate of growth)\n\n> 3.基本的算法设计方法\n>> a. 增量(increment), 从零构造要求求解的结果(bottom up)\n>> b. 分治(divide and conquer), 分解子问题递归解决合并(top down)\n    divide -> conquer -> combine\n以merge sort为例来说明分治策略:\n\\begin{align}\n\\{A[1] \\ldots A[n]\\}= \\{A[1] \\ldots A[n/2]\\} + \\{A[n/2+1] \\ldots A[n]\\} \\\\\\\\\nrecusively \\, merge \\{A[1] \\ldots A[n/2]\\} or \\{A[n/2+1] \\ldots A[n]\\} \\\\\\\\\nmerge \\{A[1] \\ldots A[n/2]\\} with \\{A[n/2+1] \\ldots A[n]\\}\n\\end{align}\n\n> 4.分治法的分析\n　　分治法的基本理论是递归的解决子问题, 合并为最终解,即如下公式:\n$$\nT(n) =\n\\begin{cases}\n\\Theta(1), & \\text {if n <= c} \\\\\\\\\naT(n/b) + D(n) + C(n), & else \\\\\\\\\n\\end{cases}\n$$\n　　以merge sort为例\n$$\nT(n) =\n\\begin{cases}\nc, & \\text {if n = 1} \\\\\\\\\n2T(n/2) + cn, & \\text {if n > 1} \\\\\\\\\n\\end{cases}\n$$\n如何求解递归式?\n　　考虑到问题的分解, 类似从大的树根分叉出小的树枝, 构造递归树(等价形式),树节点表示时间代价,所有节点之和即为总的运行时间.这也是直观形象理解 **$log_m n$*在复杂度中出现的理由:\n>> m表示问题被分解为m个子问题(m叉树), n表示问题规模, $log_m n$表示递归层数(m叉树的高度)\n\n\n#### Chapter3 如何比较算法的优劣?(运行时间的阶数)\n\n> 1.运行时间与数据规模之间的关系的表达:\n>>渐进:\n$\\Theta(g(n)) = \\\\{f(n): \\exists c\\_1, c\\_2, n\\_0, \\forall n \\geq n\\_0, 0 \\leq c\\_1g(n) \\leq f(n) \\leq c\\_2g(n) \\\\}$\n上界:\n$O(g(n)) = \\\\{f(n): \\exists c, n\\_0, \\forall n \\geq n\\_0, 0 \\leq f(n) \\leq cg(n)\\\\}$\n下界:\n$\\Omega(g(n)) = \\\\{f(n): \\exists c, n\\_0, \\forall n \\geq n\\_0, 0 \\leq cg(n) \\leq f(n)\\\\}$\n\n> 2.把握阶数,忽略低阶项和系数:\n>> $ 2n^2 + 3n + 1 = 2n^2 + \\Theta(n) = \\Theta(n^2)$\n\n> 3.常用阶数:\n>> $1 < \\log n < n < n\\log n < n^2 < n^3 < a^n < n!$\n\n#### Chapter4 如何求解递归式(recurrence)?\n\n> 1.定义:\n　　递归式是一组等式或不等式,它所描述的函数是用在更小的输入下该函数的值来定义的.\n\n> 2.把握大方向，忽略技术细节:\n>> a. 假设自变量为整数: 如实际merge sort的递归式为:\n$$\nT(n) =\n\\begin{cases}\n\\Theta(1), & \\text {if n = 1} \\\\\\\\\nT(\\lceil n/2 \\rceil) + + T(\\lfloor n/2 \\rfloor) + \\Theta(n), & \\text {if n > 1} \\\\\\\\\n\\end{cases}\n$$\n>> b.向上向下取整, 简化边界条件\n\n> 3.解递归式的三个方法: 代还法, 递归树, 主方法\n\n> 3.1 代换法(Substitution method)\n>> 定义:先猜测某个界的存在,再用数学归纳法去证明该猜测的正确性。\n缺点:只能用于解的形式很容易猜的情形。\n总结:这种方法需要经验的积累,可以通过转换为先前见过的类似递归式来求解。\n例子1: 猜测对较大的n, $T(n)=2T(\\lfloor n/2\\rfloor + 17) + n$ 中与 $T(\\lfloor n/2 \\rfloor + 17)$ 与 $T(\\lfloor n/2\\rfloor)$接近\n例子2:\n\\begin{align}\n对T(n)=2T(\\lfloor n/2\\rfloor) + \\log n, 做代换m=\\log n \\\\\\\\\n有T(2^m)=2T(2^{m/2}) + m, 设S(m) = T(2^m) \\\\\\\\\n得 S(m) = 2S(m/2)+m \\\\\\\\\n得该递归式的界是S(m) = O(m\\log m) 代回得: \\\\\\\\\nT(n) = T(2^m) = S(m) = O(m\\log m) = O(\\log n\\log \\log n)\n\\end{align}\n\n> 3.2 递归树方法(Recursion-tree method)\n>> 起因:代换法有时很难得到一个正确的好的猜测值。\n用途:画出一个递归树是一种得到好猜测的直接方法。\n分析(重点):在递归树中,每一个结点都代表递归函数调用集合中一个子问题的代价。将递归树中每一层内的代价相加得到一个每层代价的集合,再将每层的代价相加得到递归式所有层次的总代价。\n总结:递归树最适合用来产生好的猜测,然后用代换法加以验证。递归树的方法非常直观,总的代价就是把所有层次的代价相加起来得到。但是分析这个总代价的规模却不是件很容易的事情,有时需要用到很多数学的知识,如数列求和, 不等式放缩等.\n\n> 3.3 主方法(Master method)\n>> 主方法是最好用的recipe 方法,可以很快估计出递归算法的时间复杂度,主方法总结了常见的情况并给出了一个公式.实际上主方法一直在比较 f(n)与 $N^{\\log_b^a}$ 的规模,然后选取规模大的作为最后的递归式的规模\n定义:\n　　设 a≥1 和 b≥1 是常数f(n)是定义在非负整数上的一个确定的非负函数。又设T(n)也是定义在非负整数上的一个非负函数,且满足递归方程$T(n)=aT(n/b)+f(n)$ 。方程 $T(n)=aT(n/b)+f(n)$ 中的 $n/b$ 可以是$\\lceil n/b\\rceil$,也可以是 $\\lfloor n/b \\rfloor$。那么,在$f(n)$的三类情况下,我们有 T(n)的渐近估计式:\n优点:针对形如 T(n)=aT(n/b)+f(n)的递归式:\n\\begin{align}\n1) 对\\epsilon > 0, f(n)=O(n^{\\log_b^a-\\epsilon}) \\to T(n)=\\Theta(n^{\\log_b^a}) \\\\\\\\\n2) f(n) = \\Theta(n^{\\log_b^a}) \\to T(n)=\\Theta(n^{\\log_b^a}\\log n) \\\\\\\\\n3) 对\\epsilon > 0,f(n)=O(n^{\\log_b^a-\\epsilon}) 且c < 1和 n > N, af(n/b) \\leq cf(n) \\to T(n)=\\Theta(f(n))\n\\end{align}\n缺点:并不能解所有形如上式的递归式的解。因为主方法在第 1 种情况与第2种情况之间、第2种情况与第3种情况之间都存在着一条沟,所以会存在着不能适用的情况。\n\n#### Chapter5 如何将概率引入算法分析中?\n> 1.概率分析: 确定input的分布或假设, 计算期望的运行时间 - 实际上是一个随机变量函数的求解过程\n> 2.在不了解input分布的条件下,通过随机算法引入概率:\n如果一个算法的行为不只是由输入决定,同时也由随机数生成器所产生的数值决定,则称这个算法是随机的。\n> 3.指示器随机变量-- 概率与期望的转换\n$$\n事件A 对应的指示器随机变量的期望期等于事件 A 发生的概率。\\\\\\\\\nI\\\\{A\\\\} =\n\\begin{cases}\n    1, if \\, A \\, happens \\\\\\\\\n    0, else\n\\end{cases}\n$$\n期望的线性性质:\n\\begin{align}\nX = \\sum\\_{i=1}^n X\\_i \\\\\\\\\nE[x] = E[\\sum\\_{i=1}^n X\\_i] = \\sum\\_{i=1}^n E[X\\_i]\n\\end{align}\n\n> 4.如何生成随机数组?\na. 随机优先级法:为数组的每个元素赋一个随机的优先级,再根据这个优先级对数组中的元素进行排序。可证这样得到的数字满足随机的性质。\nb. 原地交换法:依次把A[i]与 A[Random(i+1, Length(A))]进行 swap,得到的新数组也满足随机性。\n>> ```\nfor i ← 1 to n\n    do swap A[i] ↔ A\n```\n\n>考虑到在真正的环境中的输入可能并不是随机的,所以我们可以采用先将输入进行随机打乱的方法来保证输入数据的随机性(方法b),这点在很多算法中得以体现,比如快排有其随机选取种子数来向输入中加入随机化的成分。\n\n### Part2 排序与顺序统计\n\n基本排序算法与对比/求解中集合第i小的数\n\n> 1.排序问题\n输入:n个数的序列$[a\\_1,a\\_2, \\ldots, a\\_n]$ \\\n输出:输入序列的一个重排$[a\\_1',a\\_2',\\ldots a\\_n'],使 a\\_1' \\leq a\\_2' \\leq \\ldots \\leq a\\_n'$\n2.原地排序算法:只有线性个数的元素会被移动到集合之外的排序算法。\n3.第6章介绍堆排序,及其实现的优先级队列\n4.第7章介绍快速排序没,及其对应的分割思想\n5.第8章介绍了基于“比较”排序的算法的下界为$\\Theta(n\\log n)$。并介绍了几种不基于比较的排序方法,它们能突破$\\Omega(n\\log n)$的下界: 计数排序、基数排序、桶排序。\n6.第9章介绍了顺序统计的概念:第i个顺序统计是集合中第i小的数。并介绍了两个算法:\na.最坏情况为$O(n^2)$但平均情况下为线性$O(n)$的算法\nb.最坏情况下为线性$O(n)$的算法\n\n#### Chapter6 如何结合数据结构和排序算法?\n\n> 1.heapsort:$O(n\\log n)$, 原地排序(in place)\n    利用heap的性质(堆顶为max或min)来进行排序\n> 2.heap:\n>> a.逻辑结构为完全二叉树, 高度为$\\log_2(n)$\n>> b.物理结构为数组(非链表, 因为要求随机访问)\n>> c.性质(以大顶堆为例):$A[Parent(i)] \\geq A[i]$\n>> d.方法:\n* max-heapify(A, i): 递归向下调整以i为根的子树, 保持性质c, $O(\\log n)$\n* build-max-heap(A): 调用max-heapify建堆A, $O(n)$\n* heapsort: 原地堆排序, $O(n\\log n)$\n\n>>```\nmax-heapify(A, i)\nl <- Left(i)\nr <- Right(i)\nif l <= heap-size[A] and A[l] > A[i]\n    then largest <- l\n    else largest <- i\nif r <= heap-size[A] and A[r] > A[largest]\n    then largest <- r\nif largest not = i\n    then exchange A[i] <-> A[largest]\n    max-heapify(A, largest)\n```\n\n\n>> ```\nbulid-max-heap(A)\nheap-size[A] <- length[A]\nfor i <- length[A] / 2 downto 1\n    do max-heapity(A, i)\n```\n\n>> ```\nheapsort(A)\nbuild-max-heap(A)\nfor i <- length[A] downto 2\n    do exchange A[i] <-> A[i]\n    heap-size[A] <- heap-size[A] - 1\n    max-heapify(A, 1)\n```\n\n> 3.优先级队列(用堆实现)\n>> a. 方法:\n    * maximum(S):返回最大key的元素 -> 大顶堆堆顶元素\n    * insert(S, x): 插入x -> 插入堆尾并max-heapify(A, n + 1)\n    * extract-max: 在maximum基础上删除max -> swap(A[1], A[n]), max-heaptify(A, 1)\nb. 应用: 操作系统中优先级调度算法, 事件模拟\n\n#### Chapter7 如何实现快速排序?\n> 1.快排: 基于递归思想, 最坏$\\Theta(n^2)$, 平均$O(n\\log n)$, 且由于 $O(n\\log n)$中隐含的常数因子很小,所以快排通常是用于排序的最佳的实用选择(因为其平均性能非常好).\n特性:平均性能非常好、原地排序不需要额外的空间、代码实现机器简洁清晰\n\n> 2.分割partition: 将A[p..r]分割为均小于等于A[q]的A[p..q-1] 和 均大于A[q]的 A[q+1..r]\n>```\npartition(A, p, r)\nx <- A[r]\ni <- p-1\nfor j <- p to r-1\n    do if A[j] <= x\n        then i <- i+1\n            exchange A[i]<-> A[j]\nexchange A[i+1] <-> A[r]\nreturn i+1\n```\n\n> 3.快排, 递归实现\n>```\nquicksort(A, p, r)\nif p < r\n    then q <- partition(A, p, r)\n        quicksort(A, p, q - 1)\n        quicksort(A, q + 1, r)\n```\n\n> 4.快排性能:\n划分是对称的, 生成的递归树亦对称,等同于merge sort;\n划分极度不对称, 生成递归树为单支树, 树高为n, 等同于insert sort;\n因此在真正的应用时很容易出现待排序的数组其实已经是有序的情况下,它在待排数组有序时的效率是最差的$O(n^2)$,所以需要随机化技术来使得划分尽可能均匀对称.\n　　正如第5章所说的,由于工程中的输入可能不随机的,所以我们要将其随机化.有两种可选方案\n>> a.直接对输入数据进行随机化排列\n>> b.采用随机取样的随机化技术。\n采用更高效的(2)随机取样(random sampling):随机选择key元素\n>```\nrandomized-partition(A, p, r)\ni <- random(p, r)\nexchange A[r] <-> A[i]\nreturn partition(A, p, r)\n```\n\n#### Chapter8 排序算法的下界在哪里?\n> 1.任何比较的排序在最坏的情况下都要用$\\Theta(n\\log n)$次比较来进行排序,\n采用决策树来证明:\n\\begin{align}\n高度h, 叶节点个数l的决策树模拟n个元素的比较排序 \\\\\\\\\n\\because n元素有 n!个排列 \\to  n! \\leq l \\\\\\\\\n又\\because l \\leq 2^h \\\\\\\\\n\\therefore n! \\leq l \\leq 2^h \\\\\\\\\n\\therefore h \\geq \\log(n!) = \\Omega(n\\log n)\n\\end{align}\n所以合并排序和堆排序是渐近最优的。但要注意:快排不是渐近最优的,因为它在最坏的情况下是$O(n^2)$\n\n> 2.三种以线性时间运行的排序算法:计数排序、基数排序和桶排序，皆基于非比较的模型．\n\n> 2.1 计数排序: 统计元素个数, 从小到大输出, $\\Theta(n)$\n>```\ncounting-sort(A, B, k)\nfor i <- 0 to k\n    do C[i] = 1\nfor j <- 1 to length[A]\n    do C[A[j]] <- C[A[j]] + 1\nC[i]: 等于i的元素个数\nfor i <- 1 to k\n    do C[i] <- C[i] + C[i-1]\nC[i]: 小于等于i的元素个数\nfor j <- lenght[A]\n    do B[C[A[j]]] <- A[j]\n        C[A[j]] <- C[A[j]] - 1\n```\n>a. 计数排序的一个重要性就是它是稳定的排序算法,这个稳定性是基数排序的基石。\nb. 计数排序的思想简单、高效、可靠．\nc. 缺点在于:\n>>i. 需要很多额外的空间(当前类型的值的范围)\nii. 只能对离散的数据有效,比如int(double不行)\niii.基于假设:输入是小范围内的整数构成的。\n\n> 2.2 基数排序: 基于数位(k), $\\Theta(d(n+k))$\n>```\nradix-sort(A, d)\nfor i <- 1 to d\n    do use a stable sort array A on digit i\n```\n>a. 低位相同时用高一位进行排序,要求基数排序时对每一位进行调用子排序算法时要求这个子排序算法必须是稳定的, 即同Key, 相对顺序不变.\nb. 基数排序与直觉相反:它是按照从低位到高位的顺序排序的。我认为原因在于高有效位对低有效位有着决定性的作用。\n\n> 2.3 桶排序:分割子区间(桶), 桶内排序后输出 $\\Theta(n)$\n>```\nbucket-sort\nn <- length[A]\nfor i <- 1 to n\n    do insert A[i] into list B[nA[i]]\nfor i <- 0 to n-1\n    do sort list B[i] with insert sort\noutput the lists B[0], B[1],..B[n-1] in order\n```\n>a.桶排序也只是期望运行时间能达到线性,对于最坏的情况,它的运行时间取决于它内部使用的子排序算法的运行时间,\n一般为 O(nlgn)。\nb.桶排序基于假设:输入的的元素均匀的分布在区间[0, 1]上。\n\n\n> 3.总结: 所有的线性时间内的排序算法,都作出了一定的假设, 必须建立在一定的输入数据的条件上.\n\n\n#### Chapter9 如何找到第i小的数?\n> 1.the i-th order statistic: 第i小的元素\n    直观的讲, 先排序然后直接选出A[i]就是该问题的解答.但实际上问题只要求第i小的数,排序则是求出了所有元素的次序, 那么是否不需要较大的消耗的排序,而去直接求解呢?\n\n> 2.由简入深\n>> min(max): 线性遍历, $\\Theta(n)$\n>>```\nminimum(A)\nmin <- A[1]\nfor i <- 2 to length[A]\n        do if min > A[i]\n            then min <- A[i]\nreturn min\n```\n>> i-th:随机选择与分割定位: 递归, $\\Theta(n)$\n>>```\nrandomized-select(A, p, r, i)\nif p = r\n        then return A[p]\nq <- randomized-partition(A, p, r)\nk <- q - p + 1\nif i = k\n        then return A[q]\nelseif i < k\n        then return randomized-select(A, p, q-1, i)\nelse\n        return randomized-select(A, q+1, r, i-k)\n```\n\n> 3.在第8章,比较模型中平均情况下需要$\\Theta(n\\log n)$的时间, 输入满足一定假设情况下可以达到线性时间按$O(n)$.以期望线性时间选择i-th的方法以快速排序为模型,如同在快速排序中一样,此算法的思想也是对输入数组进行递归划分。但和快速排序不同的是,快速排序会递归处理划分的两边,而randomized-select只处理划分的一边,并由此将期望的运行时间由$O(n\\log n)$下降到了$O(n)$。\n\n### Part3 数据结构\n\n####\n","slug":"CLRS-notes","published":1,"updated":"2017-08-26T03:38:21.602Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6sslhah00013game4f4mgya","content":"<h1 id=\"＜Introduction-to-algorithms＞笔记\"><a href=\"#＜Introduction-to-algorithms＞笔记\" class=\"headerlink\" title=\"＜Introduction to algorithms＞笔记\"></a>＜Introduction to algorithms＞笔记</h1><h3 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h3><p>　　＜introduction to algorithms＞覆盖全面,包含算法/数据结构/基本的离散数学知识;伪代码清晰简洁,适合有一定编程基础用算法实现;注重算法的推导和证明,以及对应的算法设计与分析能力;同时配套MIT课程,资料丰富.这里记录我CLRS的学习笔记,按主题章节对应分类, 以问题-答案形式总结.</p>\n<h3 id=\"Part1-基础\"><a href=\"#Part1-基础\" class=\"headerlink\" title=\"Part1 基础\"></a>Part1 基础</h3><p>算法定义/基本的算法设计/递归的复杂度/概率与随机算法</p>\n<h4 id=\"Chapter1-什么是算法\"><a href=\"#Chapter1-什么是算法\" class=\"headerlink\" title=\"Chapter1 什么是算法?\"></a>Chapter1 什么是算法?</h4><blockquote>\n<p>  算法:<br>    $\\require{AMScd}$<br>    \\begin{CD}<br>    input @&gt;\\text{computing procedure}&gt;&gt; ouput<br>    \\end{CD}</p>\n<ul>\n<li>解决一类问题的计算过程, 一个具体问题-实例</li>\n<li>算法最重要的特性: 效率</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<h4 id=\"Chapter2-如何证明一个算法的正确性\"><a href=\"#Chapter2-如何证明一个算法的正确性\" class=\"headerlink\" title=\"Chapter2 如何证明一个算法的正确性?\"></a>Chapter2 如何证明一个算法的正确性?</h4><blockquote>\n<p>1.循环不变式:<br>　　算法中大量的过程是对同类数据的重复处理,即循环是算法的基本结构.通过循环不变式可以证明经过大量复杂的步骤后,得到要求解的结果.它的结构如下:</p>\n<blockquote>\n<p>a. 初始化: 迭代之前是循环不变式是正确的(base case)<br>b. 保持: 第n次迭代之前正确, 第n次之后保持正确(recursive formula)<br>c. 终止: 最终算法正确</p>\n</blockquote>\n<p>以插入排序为例：<br>\\begin{align}<br>A[1]有序 \\\\<br>A[1] \\ldots A[i]有序, 插入后A[1] \\ldots A[i+1]有序 \\\\<br>\\mapsto A[1] \\ldots A[n] 有序<br>\\end{align}<br>2.算法分析</p>\n<blockquote>\n<p>a. 输入规模 n<br>b. 运行时间: 基本操作数(与n相关)<br>c. 最坏情况(上界), 平均情况(基于概率分析技术)<br>d. 运行增长率(rate of growth)</p>\n</blockquote>\n<p>3.基本的算法设计方法</p>\n<blockquote>\n<p>a. 增量(increment), 从零构造要求求解的结果(bottom up)<br>b. 分治(divide and conquer), 分解子问题递归解决合并(top down)<br>    divide -&gt; conquer -&gt; combine<br>以merge sort为例来说明分治策略:<br>\\begin{align}<br>{A[1] \\ldots A[n]}= {A[1] \\ldots A[n/2]} + {A[n/2+1] \\ldots A[n]} \\\\<br>recusively \\, merge {A[1] \\ldots A[n/2]} or {A[n/2+1] \\ldots A[n]} \\\\<br>merge {A[1] \\ldots A[n/2]} with {A[n/2+1] \\ldots A[n]}<br>\\end{align}</p>\n</blockquote>\n<p>4.分治法的分析<br>　　分治法的基本理论是递归的解决子问题, 合并为最终解,即如下公式:<br>$$<br>T(n) =<br>\\begin{cases}<br>\\Theta(1), &amp; \\text {if n &lt;= c} \\\\<br>aT(n/b) + D(n) + C(n), &amp; else \\\\<br>\\end{cases}<br>$$<br>　　以merge sort为例<br>$$<br>T(n) =<br>\\begin{cases}<br>c, &amp; \\text {if n = 1} \\\\<br>2T(n/2) + cn, &amp; \\text {if n &gt; 1} \\\\<br>\\end{cases}<br>$$<br>如何求解递归式?<br>　　考虑到问题的分解, 类似从大的树根分叉出小的树枝, 构造递归树(等价形式),树节点表示时间代价,所有节点之和即为总的运行时间.这也是直观形象理解 <em>*$log_m n$</em>在复杂度中出现的理由:</p>\n<blockquote>\n<p>m表示问题被分解为m个子问题(m叉树), n表示问题规模, $log_m n$表示递归层数(m叉树的高度)</p>\n</blockquote>\n</blockquote>\n<h4 id=\"Chapter3-如何比较算法的优劣-运行时间的阶数\"><a href=\"#Chapter3-如何比较算法的优劣-运行时间的阶数\" class=\"headerlink\" title=\"Chapter3 如何比较算法的优劣?(运行时间的阶数)\"></a>Chapter3 如何比较算法的优劣?(运行时间的阶数)</h4><blockquote>\n<p>1.运行时间与数据规模之间的关系的表达:</p>\n<blockquote>\n<p>渐进:<br>$\\Theta(g(n)) = \\{f(n): \\exists c_1, c_2, n_0, \\forall n \\geq n_0, 0 \\leq c_1g(n) \\leq f(n) \\leq c_2g(n) \\}$<br>上界:<br>$O(g(n)) = \\{f(n): \\exists c, n_0, \\forall n \\geq n_0, 0 \\leq f(n) \\leq cg(n)\\}$<br>下界:<br>$\\Omega(g(n)) = \\{f(n): \\exists c, n_0, \\forall n \\geq n_0, 0 \\leq cg(n) \\leq f(n)\\}$</p>\n</blockquote>\n<p>2.把握阶数,忽略低阶项和系数:</p>\n<blockquote>\n<p>$ 2n^2 + 3n + 1 = 2n^2 + \\Theta(n) = \\Theta(n^2)$</p>\n</blockquote>\n<p>3.常用阶数:</p>\n<blockquote>\n<p>$1 &lt; \\log n &lt; n &lt; n\\log n &lt; n^2 &lt; n^3 &lt; a^n &lt; n!$</p>\n</blockquote>\n</blockquote>\n<h4 id=\"Chapter4-如何求解递归式-recurrence\"><a href=\"#Chapter4-如何求解递归式-recurrence\" class=\"headerlink\" title=\"Chapter4 如何求解递归式(recurrence)?\"></a>Chapter4 如何求解递归式(recurrence)?</h4><blockquote>\n<p>1.定义:<br>　　递归式是一组等式或不等式,它所描述的函数是用在更小的输入下该函数的值来定义的.</p>\n<p>2.把握大方向，忽略技术细节:</p>\n<blockquote>\n<p>a. 假设自变量为整数: 如实际merge sort的递归式为:<br>$$<br>T(n) =<br>\\begin{cases}<br>\\Theta(1), &amp; \\text {if n = 1} \\\\<br>T(\\lceil n/2 \\rceil) + + T(\\lfloor n/2 \\rfloor) + \\Theta(n), &amp; \\text {if n &gt; 1} \\\\<br>\\end{cases}<br>$$<br>b.向上向下取整, 简化边界条件</p>\n</blockquote>\n<p>3.解递归式的三个方法: 代还法, 递归树, 主方法</p>\n<p>3.1 代换法(Substitution method)</p>\n<blockquote>\n<p>定义:先猜测某个界的存在,再用数学归纳法去证明该猜测的正确性。<br>缺点:只能用于解的形式很容易猜的情形。<br>总结:这种方法需要经验的积累,可以通过转换为先前见过的类似递归式来求解。<br>例子1: 猜测对较大的n, $T(n)=2T(\\lfloor n/2\\rfloor + 17) + n$ 中与 $T(\\lfloor n/2 \\rfloor + 17)$ 与 $T(\\lfloor n/2\\rfloor)$接近<br>例子2:<br>\\begin{align}<br>对T(n)=2T(\\lfloor n/2\\rfloor) + \\log n, 做代换m=\\log n \\\\<br>有T(2^m)=2T(2^{m/2}) + m, 设S(m) = T(2^m) \\\\<br>得 S(m) = 2S(m/2)+m \\\\<br>得该递归式的界是S(m) = O(m\\log m) 代回得: \\\\<br>T(n) = T(2^m) = S(m) = O(m\\log m) = O(\\log n\\log \\log n)<br>\\end{align}</p>\n</blockquote>\n<p>3.2 递归树方法(Recursion-tree method)</p>\n<blockquote>\n<p>起因:代换法有时很难得到一个正确的好的猜测值。<br>用途:画出一个递归树是一种得到好猜测的直接方法。<br>分析(重点):在递归树中,每一个结点都代表递归函数调用集合中一个子问题的代价。将递归树中每一层内的代价相加得到一个每层代价的集合,再将每层的代价相加得到递归式所有层次的总代价。<br>总结:递归树最适合用来产生好的猜测,然后用代换法加以验证。递归树的方法非常直观,总的代价就是把所有层次的代价相加起来得到。但是分析这个总代价的规模却不是件很容易的事情,有时需要用到很多数学的知识,如数列求和, 不等式放缩等.</p>\n</blockquote>\n<p>3.3 主方法(Master method)</p>\n<blockquote>\n<p>主方法是最好用的recipe 方法,可以很快估计出递归算法的时间复杂度,主方法总结了常见的情况并给出了一个公式.实际上主方法一直在比较 f(n)与 $N^{\\log_b^a}$ 的规模,然后选取规模大的作为最后的递归式的规模<br>定义:<br>　　设 a≥1 和 b≥1 是常数f(n)是定义在非负整数上的一个确定的非负函数。又设T(n)也是定义在非负整数上的一个非负函数,且满足递归方程$T(n)=aT(n/b)+f(n)$ 。方程 $T(n)=aT(n/b)+f(n)$ 中的 $n/b$ 可以是$\\lceil n/b\\rceil$,也可以是 $\\lfloor n/b \\rfloor$。那么,在$f(n)$的三类情况下,我们有 T(n)的渐近估计式:<br>优点:针对形如 T(n)=aT(n/b)+f(n)的递归式:<br>\\begin{align}<br>1) 对\\epsilon &gt; 0, f(n)=O(n^{\\log_b^a-\\epsilon}) \\to T(n)=\\Theta(n^{\\log_b^a}) \\\\<br>2) f(n) = \\Theta(n^{\\log_b^a}) \\to T(n)=\\Theta(n^{\\log_b^a}\\log n) \\\\<br>3) 对\\epsilon &gt; 0,f(n)=O(n^{\\log_b^a-\\epsilon}) 且c &lt; 1和 n &gt; N, af(n/b) \\leq cf(n) \\to T(n)=\\Theta(f(n))<br>\\end{align}<br>缺点:并不能解所有形如上式的递归式的解。因为主方法在第 1 种情况与第2种情况之间、第2种情况与第3种情况之间都存在着一条沟,所以会存在着不能适用的情况。</p>\n</blockquote>\n</blockquote>\n<h4 id=\"Chapter5-如何将概率引入算法分析中\"><a href=\"#Chapter5-如何将概率引入算法分析中\" class=\"headerlink\" title=\"Chapter5 如何将概率引入算法分析中?\"></a>Chapter5 如何将概率引入算法分析中?</h4><blockquote>\n<p>1.概率分析: 确定input的分布或假设, 计算期望的运行时间 - 实际上是一个随机变量函数的求解过程<br>2.在不了解input分布的条件下,通过随机算法引入概率:<br>如果一个算法的行为不只是由输入决定,同时也由随机数生成器所产生的数值决定,则称这个算法是随机的。<br>3.指示器随机变量– 概率与期望的转换<br>$$<br>事件A 对应的指示器随机变量的期望期等于事件 A 发生的概率。\\\\<br>I\\{A\\} =<br>\\begin{cases}<br>    1, if \\, A \\, happens \\\\<br>    0, else<br>\\end{cases}<br>$$<br>期望的线性性质:<br>\\begin{align}<br>X = \\sum_{i=1}^n X_i \\\\<br>E[x] = E[\\sum_{i=1}^n X_i] = \\sum_{i=1}^n E[X_i]<br>\\end{align}</p>\n<p>4.如何生成随机数组?<br>a. 随机优先级法:为数组的每个元素赋一个随机的优先级,再根据这个优先级对数组中的元素进行排序。可证这样得到的数字满足随机的性质。<br>b. 原地交换法:依次把A[i]与 A[Random(i+1, Length(A))]进行 swap,得到的新数组也满足随机性。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">for i ← 1 to n</div><div class=\"line\">    do swap A[i] ↔ A</div></pre></td></tr></table></figure>\n</blockquote>\n<p>考虑到在真正的环境中的输入可能并不是随机的,所以我们可以采用先将输入进行随机打乱的方法来保证输入数据的随机性(方法b),这点在很多算法中得以体现,比如快排有其随机选取种子数来向输入中加入随机化的成分。</p>\n</blockquote>\n<h3 id=\"Part2-排序与顺序统计\"><a href=\"#Part2-排序与顺序统计\" class=\"headerlink\" title=\"Part2 排序与顺序统计\"></a>Part2 排序与顺序统计</h3><p>基本排序算法与对比/求解中集合第i小的数</p>\n<blockquote>\n<p>1.排序问题<br>输入:n个数的序列$[a_1,a_2, \\ldots, a_n]$ \\<br>输出:输入序列的一个重排$[a_1’,a_2’,\\ldots a_n’],使 a_1’ \\leq a_2’ \\leq \\ldots \\leq a_n’$<br>2.原地排序算法:只有线性个数的元素会被移动到集合之外的排序算法。<br>3.第6章介绍堆排序,及其实现的优先级队列<br>4.第7章介绍快速排序没,及其对应的分割思想<br>5.第8章介绍了基于“比较”排序的算法的下界为$\\Theta(n\\log n)$。并介绍了几种不基于比较的排序方法,它们能突破$\\Omega(n\\log n)$的下界: 计数排序、基数排序、桶排序。<br>6.第9章介绍了顺序统计的概念:第i个顺序统计是集合中第i小的数。并介绍了两个算法:<br>a.最坏情况为$O(n^2)$但平均情况下为线性$O(n)$的算法<br>b.最坏情况下为线性$O(n)$的算法</p>\n</blockquote>\n<h4 id=\"Chapter6-如何结合数据结构和排序算法\"><a href=\"#Chapter6-如何结合数据结构和排序算法\" class=\"headerlink\" title=\"Chapter6 如何结合数据结构和排序算法?\"></a>Chapter6 如何结合数据结构和排序算法?</h4><blockquote>\n<p>1.heapsort:$O(n\\log n)$, 原地排序(in place)<br>    利用heap的性质(堆顶为max或min)来进行排序<br>2.heap:</p>\n<blockquote>\n<p>a.逻辑结构为完全二叉树, 高度为$\\log_2(n)$<br>b.物理结构为数组(非链表, 因为要求随机访问)<br>c.性质(以大顶堆为例):$A[Parent(i)] \\geq A[i]$<br>d.方法:</p>\n<ul>\n<li>max-heapify(A, i): 递归向下调整以i为根的子树, 保持性质c, $O(\\log n)$</li>\n<li>build-max-heap(A): 调用max-heapify建堆A, $O(n)$</li>\n<li>heapsort: 原地堆排序, $O(n\\log n)$</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">max-heapify(A, i)</div><div class=\"line\">l &lt;- Left(i)</div><div class=\"line\">r &lt;- Right(i)</div><div class=\"line\">if l &lt;= heap-size[A] and A[l] &gt; A[i]</div><div class=\"line\">    then largest &lt;- l</div><div class=\"line\">    else largest &lt;- i</div><div class=\"line\">if r &lt;= heap-size[A] and A[r] &gt; A[largest]</div><div class=\"line\">    then largest &lt;- r</div><div class=\"line\">if largest not = i</div><div class=\"line\">    then exchange A[i] &lt;-&gt; A[largest]</div><div class=\"line\">    max-heapify(A, largest)</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">bulid-max-heap(A)</div><div class=\"line\">heap-size[A] &lt;- length[A]</div><div class=\"line\">for i &lt;- length[A] / 2 downto 1</div><div class=\"line\">    do max-heapity(A, i)</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">heapsort(A)</div><div class=\"line\">build-max-heap(A)</div><div class=\"line\">for i &lt;- length[A] downto 2</div><div class=\"line\">    do exchange A[i] &lt;-&gt; A[i]</div><div class=\"line\">    heap-size[A] &lt;- heap-size[A] - 1</div><div class=\"line\">    max-heapify(A, 1)</div></pre></td></tr></table></figure>\n</blockquote>\n<p>3.优先级队列(用堆实现)</p>\n<blockquote>\n<p>a. 方法:</p>\n<pre><code>* maximum(S):返回最大key的元素 -&gt; 大顶堆堆顶元素\n* insert(S, x): 插入x -&gt; 插入堆尾并max-heapify(A, n + 1)\n* extract-max: 在maximum基础上删除max -&gt; swap(A[1], A[n]), max-heaptify(A, 1)\n</code></pre><p>b. 应用: 操作系统中优先级调度算法, 事件模拟</p>\n</blockquote>\n</blockquote>\n<h4 id=\"Chapter7-如何实现快速排序\"><a href=\"#Chapter7-如何实现快速排序\" class=\"headerlink\" title=\"Chapter7 如何实现快速排序?\"></a>Chapter7 如何实现快速排序?</h4><blockquote>\n<p>1.快排: 基于递归思想, 最坏$\\Theta(n^2)$, 平均$O(n\\log n)$, 且由于 $O(n\\log n)$中隐含的常数因子很小,所以快排通常是用于排序的最佳的实用选择(因为其平均性能非常好).<br>特性:平均性能非常好、原地排序不需要额外的空间、代码实现机器简洁清晰</p>\n<p>2.分割partition: 将A[p..r]分割为均小于等于A[q]的A[p..q-1] 和 均大于A[q]的 A[q+1..r]<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">partition(A, p, r)</div><div class=\"line\">x &lt;- A[r]</div><div class=\"line\">i &lt;- p-1</div><div class=\"line\">for j &lt;- p to r-1</div><div class=\"line\">    do if A[j] &lt;= x</div><div class=\"line\">        then i &lt;- i+1</div><div class=\"line\">            exchange A[i]&lt;-&gt; A[j]</div><div class=\"line\">exchange A[i+1] &lt;-&gt; A[r]</div><div class=\"line\">return i+1</div></pre></td></tr></table></figure></p>\n<p>3.快排, 递归实现<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">quicksort(A, p, r)</div><div class=\"line\">if p &lt; r</div><div class=\"line\">    then q &lt;- partition(A, p, r)</div><div class=\"line\">        quicksort(A, p, q - 1)</div><div class=\"line\">        quicksort(A, q + 1, r)</div></pre></td></tr></table></figure></p>\n<p>4.快排性能:<br>划分是对称的, 生成的递归树亦对称,等同于merge sort;<br>划分极度不对称, 生成递归树为单支树, 树高为n, 等同于insert sort;<br>因此在真正的应用时很容易出现待排序的数组其实已经是有序的情况下,它在待排数组有序时的效率是最差的$O(n^2)$,所以需要随机化技术来使得划分尽可能均匀对称.<br>　　正如第5章所说的,由于工程中的输入可能不随机的,所以我们要将其随机化.有两种可选方案</p>\n<blockquote>\n<p>a.直接对输入数据进行随机化排列<br>b.采用随机取样的随机化技术。<br>采用更高效的(2)随机取样(random sampling):随机选择key元素<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">randomized-partition(A, p, r)</div><div class=\"line\">i &lt;- random(p, r)</div><div class=\"line\">exchange A[r] &lt;-&gt; A[i]</div><div class=\"line\">return partition(A, p, r)</div></pre></td></tr></table></figure></p>\n</blockquote>\n</blockquote>\n<h4 id=\"Chapter8-排序算法的下界在哪里\"><a href=\"#Chapter8-排序算法的下界在哪里\" class=\"headerlink\" title=\"Chapter8 排序算法的下界在哪里?\"></a>Chapter8 排序算法的下界在哪里?</h4><blockquote>\n<p>1.任何比较的排序在最坏的情况下都要用$\\Theta(n\\log n)$次比较来进行排序,<br>采用决策树来证明:<br>\\begin{align}<br>高度h, 叶节点个数l的决策树模拟n个元素的比较排序 \\\\<br>\\because n元素有 n!个排列 \\to  n! \\leq l \\\\<br>又\\because l \\leq 2^h \\\\<br>\\therefore n! \\leq l \\leq 2^h \\\\<br>\\therefore h \\geq \\log(n!) = \\Omega(n\\log n)<br>\\end{align}<br>所以合并排序和堆排序是渐近最优的。但要注意:快排不是渐近最优的,因为它在最坏的情况下是$O(n^2)$</p>\n<p>2.三种以线性时间运行的排序算法:计数排序、基数排序和桶排序，皆基于非比较的模型．</p>\n<p>2.1 计数排序: 统计元素个数, 从小到大输出, $\\Theta(n)$<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">counting-sort(A, B, k)</div><div class=\"line\">for i &lt;- 0 to k</div><div class=\"line\">    do C[i] = 1</div><div class=\"line\">for j &lt;- 1 to length[A]</div><div class=\"line\">    do C[A[j]] &lt;- C[A[j]] + 1</div><div class=\"line\">C[i]: 等于i的元素个数</div><div class=\"line\">for i &lt;- 1 to k</div><div class=\"line\">    do C[i] &lt;- C[i] + C[i-1]</div><div class=\"line\">C[i]: 小于等于i的元素个数</div><div class=\"line\">for j &lt;- lenght[A]</div><div class=\"line\">    do B[C[A[j]]] &lt;- A[j]</div><div class=\"line\">        C[A[j]] &lt;- C[A[j]] - 1</div></pre></td></tr></table></figure></p>\n<p>a. 计数排序的一个重要性就是它是稳定的排序算法,这个稳定性是基数排序的基石。<br>b. 计数排序的思想简单、高效、可靠．<br>c. 缺点在于:</p>\n<blockquote>\n<p>i. 需要很多额外的空间(当前类型的值的范围)<br>ii. 只能对离散的数据有效,比如int(double不行)<br>iii.基于假设:输入是小范围内的整数构成的。</p>\n</blockquote>\n<p>2.2 基数排序: 基于数位(k), $\\Theta(d(n+k))$<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">radix-sort(A, d)</div><div class=\"line\">for i &lt;- 1 to d</div><div class=\"line\">    do use a stable sort array A on digit i</div></pre></td></tr></table></figure></p>\n<p>a. 低位相同时用高一位进行排序,要求基数排序时对每一位进行调用子排序算法时要求这个子排序算法必须是稳定的, 即同Key, 相对顺序不变.<br>b. 基数排序与直觉相反:它是按照从低位到高位的顺序排序的。我认为原因在于高有效位对低有效位有着决定性的作用。</p>\n<p>2.3 桶排序:分割子区间(桶), 桶内排序后输出 $\\Theta(n)$<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">bucket-sort</div><div class=\"line\">n &lt;- length[A]</div><div class=\"line\">for i &lt;- 1 to n</div><div class=\"line\">    do insert A[i] into list B[nA[i]]</div><div class=\"line\">for i &lt;- 0 to n-1</div><div class=\"line\">    do sort list B[i] with insert sort</div><div class=\"line\">output the lists B[0], B[1],..B[n-1] in order</div></pre></td></tr></table></figure></p>\n<p>a.桶排序也只是期望运行时间能达到线性,对于最坏的情况,它的运行时间取决于它内部使用的子排序算法的运行时间,<br>一般为 O(nlgn)。<br>b.桶排序基于假设:输入的的元素均匀的分布在区间[0, 1]上。</p>\n<p>3.总结: 所有的线性时间内的排序算法,都作出了一定的假设, 必须建立在一定的输入数据的条件上.</p>\n</blockquote>\n<h4 id=\"Chapter9-如何找到第i小的数\"><a href=\"#Chapter9-如何找到第i小的数\" class=\"headerlink\" title=\"Chapter9 如何找到第i小的数?\"></a>Chapter9 如何找到第i小的数?</h4><blockquote>\n<p>1.the i-th order statistic: 第i小的元素<br>    直观的讲, 先排序然后直接选出A[i]就是该问题的解答.但实际上问题只要求第i小的数,排序则是求出了所有元素的次序, 那么是否不需要较大的消耗的排序,而去直接求解呢?</p>\n<p>2.由简入深</p>\n<blockquote>\n<p>min(max): 线性遍历, $\\Theta(n)$<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">minimum(A)</div><div class=\"line\">min &lt;- A[1]</div><div class=\"line\">for i &lt;- 2 to length[A]</div><div class=\"line\">        do if min &gt; A[i]</div><div class=\"line\">            then min &lt;- A[i]</div><div class=\"line\">return min</div></pre></td></tr></table></figure></p>\n<p>i-th:随机选择与分割定位: 递归, $\\Theta(n)$<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">randomized-select(A, p, r, i)</div><div class=\"line\">if p = r</div><div class=\"line\">        then return A[p]</div><div class=\"line\">q &lt;- randomized-partition(A, p, r)</div><div class=\"line\">k &lt;- q - p + 1</div><div class=\"line\">if i = k</div><div class=\"line\">        then return A[q]</div><div class=\"line\">elseif i &lt; k</div><div class=\"line\">        then return randomized-select(A, p, q-1, i)</div><div class=\"line\">else</div><div class=\"line\">        return randomized-select(A, q+1, r, i-k)</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>3.在第8章,比较模型中平均情况下需要$\\Theta(n\\log n)$的时间, 输入满足一定假设情况下可以达到线性时间按$O(n)$.以期望线性时间选择i-th的方法以快速排序为模型,如同在快速排序中一样,此算法的思想也是对输入数组进行递归划分。但和快速排序不同的是,快速排序会递归处理划分的两边,而randomized-select只处理划分的一边,并由此将期望的运行时间由$O(n\\log n)$下降到了$O(n)$。</p>\n</blockquote>\n<h3 id=\"Part3-数据结构\"><a href=\"#Part3-数据结构\" class=\"headerlink\" title=\"Part3 数据结构\"></a>Part3 数据结构</h3><p>####</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"＜Introduction-to-algorithms＞笔记\"><a href=\"#＜Introduction-to-algorithms＞笔记\" class=\"headerlink\" title=\"＜Introduction to algorithms＞笔记\"></a>＜Introduction to algorithms＞笔记</h1><h3 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h3><p>　　＜introduction to algorithms＞覆盖全面,包含算法/数据结构/基本的离散数学知识;伪代码清晰简洁,适合有一定编程基础用算法实现;注重算法的推导和证明,以及对应的算法设计与分析能力;同时配套MIT课程,资料丰富.这里记录我CLRS的学习笔记,按主题章节对应分类, 以问题-答案形式总结.</p>\n<h3 id=\"Part1-基础\"><a href=\"#Part1-基础\" class=\"headerlink\" title=\"Part1 基础\"></a>Part1 基础</h3><p>算法定义/基本的算法设计/递归的复杂度/概率与随机算法</p>\n<h4 id=\"Chapter1-什么是算法\"><a href=\"#Chapter1-什么是算法\" class=\"headerlink\" title=\"Chapter1 什么是算法?\"></a>Chapter1 什么是算法?</h4><blockquote>\n<p>  算法:<br>    $\\require{AMScd}$<br>    \\begin{CD}<br>    input @&gt;\\text{computing procedure}&gt;&gt; ouput<br>    \\end{CD}</p>\n<ul>\n<li>解决一类问题的计算过程, 一个具体问题-实例</li>\n<li>算法最重要的特性: 效率</li>\n</ul>\n</blockquote>","more":"<h4 id=\"Chapter2-如何证明一个算法的正确性\"><a href=\"#Chapter2-如何证明一个算法的正确性\" class=\"headerlink\" title=\"Chapter2 如何证明一个算法的正确性?\"></a>Chapter2 如何证明一个算法的正确性?</h4><blockquote>\n<p>1.循环不变式:<br>　　算法中大量的过程是对同类数据的重复处理,即循环是算法的基本结构.通过循环不变式可以证明经过大量复杂的步骤后,得到要求解的结果.它的结构如下:</p>\n<blockquote>\n<p>a. 初始化: 迭代之前是循环不变式是正确的(base case)<br>b. 保持: 第n次迭代之前正确, 第n次之后保持正确(recursive formula)<br>c. 终止: 最终算法正确</p>\n</blockquote>\n<p>以插入排序为例：<br>\\begin{align}<br>A[1]有序 \\\\<br>A[1] \\ldots A[i]有序, 插入后A[1] \\ldots A[i+1]有序 \\\\<br>\\mapsto A[1] \\ldots A[n] 有序<br>\\end{align}<br>2.算法分析</p>\n<blockquote>\n<p>a. 输入规模 n<br>b. 运行时间: 基本操作数(与n相关)<br>c. 最坏情况(上界), 平均情况(基于概率分析技术)<br>d. 运行增长率(rate of growth)</p>\n</blockquote>\n<p>3.基本的算法设计方法</p>\n<blockquote>\n<p>a. 增量(increment), 从零构造要求求解的结果(bottom up)<br>b. 分治(divide and conquer), 分解子问题递归解决合并(top down)<br>    divide -&gt; conquer -&gt; combine<br>以merge sort为例来说明分治策略:<br>\\begin{align}<br>{A[1] \\ldots A[n]}= {A[1] \\ldots A[n/2]} + {A[n/2+1] \\ldots A[n]} \\\\<br>recusively \\, merge {A[1] \\ldots A[n/2]} or {A[n/2+1] \\ldots A[n]} \\\\<br>merge {A[1] \\ldots A[n/2]} with {A[n/2+1] \\ldots A[n]}<br>\\end{align}</p>\n</blockquote>\n<p>4.分治法的分析<br>　　分治法的基本理论是递归的解决子问题, 合并为最终解,即如下公式:<br>$$<br>T(n) =<br>\\begin{cases}<br>\\Theta(1), &amp; \\text {if n &lt;= c} \\\\<br>aT(n/b) + D(n) + C(n), &amp; else \\\\<br>\\end{cases}<br>$$<br>　　以merge sort为例<br>$$<br>T(n) =<br>\\begin{cases}<br>c, &amp; \\text {if n = 1} \\\\<br>2T(n/2) + cn, &amp; \\text {if n &gt; 1} \\\\<br>\\end{cases}<br>$$<br>如何求解递归式?<br>　　考虑到问题的分解, 类似从大的树根分叉出小的树枝, 构造递归树(等价形式),树节点表示时间代价,所有节点之和即为总的运行时间.这也是直观形象理解 <em>*$log_m n$</em>在复杂度中出现的理由:</p>\n<blockquote>\n<p>m表示问题被分解为m个子问题(m叉树), n表示问题规模, $log_m n$表示递归层数(m叉树的高度)</p>\n</blockquote>\n</blockquote>\n<h4 id=\"Chapter3-如何比较算法的优劣-运行时间的阶数\"><a href=\"#Chapter3-如何比较算法的优劣-运行时间的阶数\" class=\"headerlink\" title=\"Chapter3 如何比较算法的优劣?(运行时间的阶数)\"></a>Chapter3 如何比较算法的优劣?(运行时间的阶数)</h4><blockquote>\n<p>1.运行时间与数据规模之间的关系的表达:</p>\n<blockquote>\n<p>渐进:<br>$\\Theta(g(n)) = \\{f(n): \\exists c_1, c_2, n_0, \\forall n \\geq n_0, 0 \\leq c_1g(n) \\leq f(n) \\leq c_2g(n) \\}$<br>上界:<br>$O(g(n)) = \\{f(n): \\exists c, n_0, \\forall n \\geq n_0, 0 \\leq f(n) \\leq cg(n)\\}$<br>下界:<br>$\\Omega(g(n)) = \\{f(n): \\exists c, n_0, \\forall n \\geq n_0, 0 \\leq cg(n) \\leq f(n)\\}$</p>\n</blockquote>\n<p>2.把握阶数,忽略低阶项和系数:</p>\n<blockquote>\n<p>$ 2n^2 + 3n + 1 = 2n^2 + \\Theta(n) = \\Theta(n^2)$</p>\n</blockquote>\n<p>3.常用阶数:</p>\n<blockquote>\n<p>$1 &lt; \\log n &lt; n &lt; n\\log n &lt; n^2 &lt; n^3 &lt; a^n &lt; n!$</p>\n</blockquote>\n</blockquote>\n<h4 id=\"Chapter4-如何求解递归式-recurrence\"><a href=\"#Chapter4-如何求解递归式-recurrence\" class=\"headerlink\" title=\"Chapter4 如何求解递归式(recurrence)?\"></a>Chapter4 如何求解递归式(recurrence)?</h4><blockquote>\n<p>1.定义:<br>　　递归式是一组等式或不等式,它所描述的函数是用在更小的输入下该函数的值来定义的.</p>\n<p>2.把握大方向，忽略技术细节:</p>\n<blockquote>\n<p>a. 假设自变量为整数: 如实际merge sort的递归式为:<br>$$<br>T(n) =<br>\\begin{cases}<br>\\Theta(1), &amp; \\text {if n = 1} \\\\<br>T(\\lceil n/2 \\rceil) + + T(\\lfloor n/2 \\rfloor) + \\Theta(n), &amp; \\text {if n &gt; 1} \\\\<br>\\end{cases}<br>$$<br>b.向上向下取整, 简化边界条件</p>\n</blockquote>\n<p>3.解递归式的三个方法: 代还法, 递归树, 主方法</p>\n<p>3.1 代换法(Substitution method)</p>\n<blockquote>\n<p>定义:先猜测某个界的存在,再用数学归纳法去证明该猜测的正确性。<br>缺点:只能用于解的形式很容易猜的情形。<br>总结:这种方法需要经验的积累,可以通过转换为先前见过的类似递归式来求解。<br>例子1: 猜测对较大的n, $T(n)=2T(\\lfloor n/2\\rfloor + 17) + n$ 中与 $T(\\lfloor n/2 \\rfloor + 17)$ 与 $T(\\lfloor n/2\\rfloor)$接近<br>例子2:<br>\\begin{align}<br>对T(n)=2T(\\lfloor n/2\\rfloor) + \\log n, 做代换m=\\log n \\\\<br>有T(2^m)=2T(2^{m/2}) + m, 设S(m) = T(2^m) \\\\<br>得 S(m) = 2S(m/2)+m \\\\<br>得该递归式的界是S(m) = O(m\\log m) 代回得: \\\\<br>T(n) = T(2^m) = S(m) = O(m\\log m) = O(\\log n\\log \\log n)<br>\\end{align}</p>\n</blockquote>\n<p>3.2 递归树方法(Recursion-tree method)</p>\n<blockquote>\n<p>起因:代换法有时很难得到一个正确的好的猜测值。<br>用途:画出一个递归树是一种得到好猜测的直接方法。<br>分析(重点):在递归树中,每一个结点都代表递归函数调用集合中一个子问题的代价。将递归树中每一层内的代价相加得到一个每层代价的集合,再将每层的代价相加得到递归式所有层次的总代价。<br>总结:递归树最适合用来产生好的猜测,然后用代换法加以验证。递归树的方法非常直观,总的代价就是把所有层次的代价相加起来得到。但是分析这个总代价的规模却不是件很容易的事情,有时需要用到很多数学的知识,如数列求和, 不等式放缩等.</p>\n</blockquote>\n<p>3.3 主方法(Master method)</p>\n<blockquote>\n<p>主方法是最好用的recipe 方法,可以很快估计出递归算法的时间复杂度,主方法总结了常见的情况并给出了一个公式.实际上主方法一直在比较 f(n)与 $N^{\\log_b^a}$ 的规模,然后选取规模大的作为最后的递归式的规模<br>定义:<br>　　设 a≥1 和 b≥1 是常数f(n)是定义在非负整数上的一个确定的非负函数。又设T(n)也是定义在非负整数上的一个非负函数,且满足递归方程$T(n)=aT(n/b)+f(n)$ 。方程 $T(n)=aT(n/b)+f(n)$ 中的 $n/b$ 可以是$\\lceil n/b\\rceil$,也可以是 $\\lfloor n/b \\rfloor$。那么,在$f(n)$的三类情况下,我们有 T(n)的渐近估计式:<br>优点:针对形如 T(n)=aT(n/b)+f(n)的递归式:<br>\\begin{align}<br>1) 对\\epsilon &gt; 0, f(n)=O(n^{\\log_b^a-\\epsilon}) \\to T(n)=\\Theta(n^{\\log_b^a}) \\\\<br>2) f(n) = \\Theta(n^{\\log_b^a}) \\to T(n)=\\Theta(n^{\\log_b^a}\\log n) \\\\<br>3) 对\\epsilon &gt; 0,f(n)=O(n^{\\log_b^a-\\epsilon}) 且c &lt; 1和 n &gt; N, af(n/b) \\leq cf(n) \\to T(n)=\\Theta(f(n))<br>\\end{align}<br>缺点:并不能解所有形如上式的递归式的解。因为主方法在第 1 种情况与第2种情况之间、第2种情况与第3种情况之间都存在着一条沟,所以会存在着不能适用的情况。</p>\n</blockquote>\n</blockquote>\n<h4 id=\"Chapter5-如何将概率引入算法分析中\"><a href=\"#Chapter5-如何将概率引入算法分析中\" class=\"headerlink\" title=\"Chapter5 如何将概率引入算法分析中?\"></a>Chapter5 如何将概率引入算法分析中?</h4><blockquote>\n<p>1.概率分析: 确定input的分布或假设, 计算期望的运行时间 - 实际上是一个随机变量函数的求解过程<br>2.在不了解input分布的条件下,通过随机算法引入概率:<br>如果一个算法的行为不只是由输入决定,同时也由随机数生成器所产生的数值决定,则称这个算法是随机的。<br>3.指示器随机变量– 概率与期望的转换<br>$$<br>事件A 对应的指示器随机变量的期望期等于事件 A 发生的概率。\\\\<br>I\\{A\\} =<br>\\begin{cases}<br>    1, if \\, A \\, happens \\\\<br>    0, else<br>\\end{cases}<br>$$<br>期望的线性性质:<br>\\begin{align}<br>X = \\sum_{i=1}^n X_i \\\\<br>E[x] = E[\\sum_{i=1}^n X_i] = \\sum_{i=1}^n E[X_i]<br>\\end{align}</p>\n<p>4.如何生成随机数组?<br>a. 随机优先级法:为数组的每个元素赋一个随机的优先级,再根据这个优先级对数组中的元素进行排序。可证这样得到的数字满足随机的性质。<br>b. 原地交换法:依次把A[i]与 A[Random(i+1, Length(A))]进行 swap,得到的新数组也满足随机性。</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">for i ← 1 to n</div><div class=\"line\">    do swap A[i] ↔ A</div></pre></td></tr></table></figure>\n</blockquote>\n<p>考虑到在真正的环境中的输入可能并不是随机的,所以我们可以采用先将输入进行随机打乱的方法来保证输入数据的随机性(方法b),这点在很多算法中得以体现,比如快排有其随机选取种子数来向输入中加入随机化的成分。</p>\n</blockquote>\n<h3 id=\"Part2-排序与顺序统计\"><a href=\"#Part2-排序与顺序统计\" class=\"headerlink\" title=\"Part2 排序与顺序统计\"></a>Part2 排序与顺序统计</h3><p>基本排序算法与对比/求解中集合第i小的数</p>\n<blockquote>\n<p>1.排序问题<br>输入:n个数的序列$[a_1,a_2, \\ldots, a_n]$ \\<br>输出:输入序列的一个重排$[a_1’,a_2’,\\ldots a_n’],使 a_1’ \\leq a_2’ \\leq \\ldots \\leq a_n’$<br>2.原地排序算法:只有线性个数的元素会被移动到集合之外的排序算法。<br>3.第6章介绍堆排序,及其实现的优先级队列<br>4.第7章介绍快速排序没,及其对应的分割思想<br>5.第8章介绍了基于“比较”排序的算法的下界为$\\Theta(n\\log n)$。并介绍了几种不基于比较的排序方法,它们能突破$\\Omega(n\\log n)$的下界: 计数排序、基数排序、桶排序。<br>6.第9章介绍了顺序统计的概念:第i个顺序统计是集合中第i小的数。并介绍了两个算法:<br>a.最坏情况为$O(n^2)$但平均情况下为线性$O(n)$的算法<br>b.最坏情况下为线性$O(n)$的算法</p>\n</blockquote>\n<h4 id=\"Chapter6-如何结合数据结构和排序算法\"><a href=\"#Chapter6-如何结合数据结构和排序算法\" class=\"headerlink\" title=\"Chapter6 如何结合数据结构和排序算法?\"></a>Chapter6 如何结合数据结构和排序算法?</h4><blockquote>\n<p>1.heapsort:$O(n\\log n)$, 原地排序(in place)<br>    利用heap的性质(堆顶为max或min)来进行排序<br>2.heap:</p>\n<blockquote>\n<p>a.逻辑结构为完全二叉树, 高度为$\\log_2(n)$<br>b.物理结构为数组(非链表, 因为要求随机访问)<br>c.性质(以大顶堆为例):$A[Parent(i)] \\geq A[i]$<br>d.方法:</p>\n<ul>\n<li>max-heapify(A, i): 递归向下调整以i为根的子树, 保持性质c, $O(\\log n)$</li>\n<li>build-max-heap(A): 调用max-heapify建堆A, $O(n)$</li>\n<li>heapsort: 原地堆排序, $O(n\\log n)$</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">max-heapify(A, i)</div><div class=\"line\">l &lt;- Left(i)</div><div class=\"line\">r &lt;- Right(i)</div><div class=\"line\">if l &lt;= heap-size[A] and A[l] &gt; A[i]</div><div class=\"line\">    then largest &lt;- l</div><div class=\"line\">    else largest &lt;- i</div><div class=\"line\">if r &lt;= heap-size[A] and A[r] &gt; A[largest]</div><div class=\"line\">    then largest &lt;- r</div><div class=\"line\">if largest not = i</div><div class=\"line\">    then exchange A[i] &lt;-&gt; A[largest]</div><div class=\"line\">    max-heapify(A, largest)</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">bulid-max-heap(A)</div><div class=\"line\">heap-size[A] &lt;- length[A]</div><div class=\"line\">for i &lt;- length[A] / 2 downto 1</div><div class=\"line\">    do max-heapity(A, i)</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">heapsort(A)</div><div class=\"line\">build-max-heap(A)</div><div class=\"line\">for i &lt;- length[A] downto 2</div><div class=\"line\">    do exchange A[i] &lt;-&gt; A[i]</div><div class=\"line\">    heap-size[A] &lt;- heap-size[A] - 1</div><div class=\"line\">    max-heapify(A, 1)</div></pre></td></tr></table></figure>\n</blockquote>\n<p>3.优先级队列(用堆实现)</p>\n<blockquote>\n<p>a. 方法:</p>\n<pre><code>* maximum(S):返回最大key的元素 -&gt; 大顶堆堆顶元素\n* insert(S, x): 插入x -&gt; 插入堆尾并max-heapify(A, n + 1)\n* extract-max: 在maximum基础上删除max -&gt; swap(A[1], A[n]), max-heaptify(A, 1)\n</code></pre><p>b. 应用: 操作系统中优先级调度算法, 事件模拟</p>\n</blockquote>\n</blockquote>\n<h4 id=\"Chapter7-如何实现快速排序\"><a href=\"#Chapter7-如何实现快速排序\" class=\"headerlink\" title=\"Chapter7 如何实现快速排序?\"></a>Chapter7 如何实现快速排序?</h4><blockquote>\n<p>1.快排: 基于递归思想, 最坏$\\Theta(n^2)$, 平均$O(n\\log n)$, 且由于 $O(n\\log n)$中隐含的常数因子很小,所以快排通常是用于排序的最佳的实用选择(因为其平均性能非常好).<br>特性:平均性能非常好、原地排序不需要额外的空间、代码实现机器简洁清晰</p>\n<p>2.分割partition: 将A[p..r]分割为均小于等于A[q]的A[p..q-1] 和 均大于A[q]的 A[q+1..r]<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">partition(A, p, r)</div><div class=\"line\">x &lt;- A[r]</div><div class=\"line\">i &lt;- p-1</div><div class=\"line\">for j &lt;- p to r-1</div><div class=\"line\">    do if A[j] &lt;= x</div><div class=\"line\">        then i &lt;- i+1</div><div class=\"line\">            exchange A[i]&lt;-&gt; A[j]</div><div class=\"line\">exchange A[i+1] &lt;-&gt; A[r]</div><div class=\"line\">return i+1</div></pre></td></tr></table></figure></p>\n<p>3.快排, 递归实现<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">quicksort(A, p, r)</div><div class=\"line\">if p &lt; r</div><div class=\"line\">    then q &lt;- partition(A, p, r)</div><div class=\"line\">        quicksort(A, p, q - 1)</div><div class=\"line\">        quicksort(A, q + 1, r)</div></pre></td></tr></table></figure></p>\n<p>4.快排性能:<br>划分是对称的, 生成的递归树亦对称,等同于merge sort;<br>划分极度不对称, 生成递归树为单支树, 树高为n, 等同于insert sort;<br>因此在真正的应用时很容易出现待排序的数组其实已经是有序的情况下,它在待排数组有序时的效率是最差的$O(n^2)$,所以需要随机化技术来使得划分尽可能均匀对称.<br>　　正如第5章所说的,由于工程中的输入可能不随机的,所以我们要将其随机化.有两种可选方案</p>\n<blockquote>\n<p>a.直接对输入数据进行随机化排列<br>b.采用随机取样的随机化技术。<br>采用更高效的(2)随机取样(random sampling):随机选择key元素<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">randomized-partition(A, p, r)</div><div class=\"line\">i &lt;- random(p, r)</div><div class=\"line\">exchange A[r] &lt;-&gt; A[i]</div><div class=\"line\">return partition(A, p, r)</div></pre></td></tr></table></figure></p>\n</blockquote>\n</blockquote>\n<h4 id=\"Chapter8-排序算法的下界在哪里\"><a href=\"#Chapter8-排序算法的下界在哪里\" class=\"headerlink\" title=\"Chapter8 排序算法的下界在哪里?\"></a>Chapter8 排序算法的下界在哪里?</h4><blockquote>\n<p>1.任何比较的排序在最坏的情况下都要用$\\Theta(n\\log n)$次比较来进行排序,<br>采用决策树来证明:<br>\\begin{align}<br>高度h, 叶节点个数l的决策树模拟n个元素的比较排序 \\\\<br>\\because n元素有 n!个排列 \\to  n! \\leq l \\\\<br>又\\because l \\leq 2^h \\\\<br>\\therefore n! \\leq l \\leq 2^h \\\\<br>\\therefore h \\geq \\log(n!) = \\Omega(n\\log n)<br>\\end{align}<br>所以合并排序和堆排序是渐近最优的。但要注意:快排不是渐近最优的,因为它在最坏的情况下是$O(n^2)$</p>\n<p>2.三种以线性时间运行的排序算法:计数排序、基数排序和桶排序，皆基于非比较的模型．</p>\n<p>2.1 计数排序: 统计元素个数, 从小到大输出, $\\Theta(n)$<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">counting-sort(A, B, k)</div><div class=\"line\">for i &lt;- 0 to k</div><div class=\"line\">    do C[i] = 1</div><div class=\"line\">for j &lt;- 1 to length[A]</div><div class=\"line\">    do C[A[j]] &lt;- C[A[j]] + 1</div><div class=\"line\">C[i]: 等于i的元素个数</div><div class=\"line\">for i &lt;- 1 to k</div><div class=\"line\">    do C[i] &lt;- C[i] + C[i-1]</div><div class=\"line\">C[i]: 小于等于i的元素个数</div><div class=\"line\">for j &lt;- lenght[A]</div><div class=\"line\">    do B[C[A[j]]] &lt;- A[j]</div><div class=\"line\">        C[A[j]] &lt;- C[A[j]] - 1</div></pre></td></tr></table></figure></p>\n<p>a. 计数排序的一个重要性就是它是稳定的排序算法,这个稳定性是基数排序的基石。<br>b. 计数排序的思想简单、高效、可靠．<br>c. 缺点在于:</p>\n<blockquote>\n<p>i. 需要很多额外的空间(当前类型的值的范围)<br>ii. 只能对离散的数据有效,比如int(double不行)<br>iii.基于假设:输入是小范围内的整数构成的。</p>\n</blockquote>\n<p>2.2 基数排序: 基于数位(k), $\\Theta(d(n+k))$<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">radix-sort(A, d)</div><div class=\"line\">for i &lt;- 1 to d</div><div class=\"line\">    do use a stable sort array A on digit i</div></pre></td></tr></table></figure></p>\n<p>a. 低位相同时用高一位进行排序,要求基数排序时对每一位进行调用子排序算法时要求这个子排序算法必须是稳定的, 即同Key, 相对顺序不变.<br>b. 基数排序与直觉相反:它是按照从低位到高位的顺序排序的。我认为原因在于高有效位对低有效位有着决定性的作用。</p>\n<p>2.3 桶排序:分割子区间(桶), 桶内排序后输出 $\\Theta(n)$<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">bucket-sort</div><div class=\"line\">n &lt;- length[A]</div><div class=\"line\">for i &lt;- 1 to n</div><div class=\"line\">    do insert A[i] into list B[nA[i]]</div><div class=\"line\">for i &lt;- 0 to n-1</div><div class=\"line\">    do sort list B[i] with insert sort</div><div class=\"line\">output the lists B[0], B[1],..B[n-1] in order</div></pre></td></tr></table></figure></p>\n<p>a.桶排序也只是期望运行时间能达到线性,对于最坏的情况,它的运行时间取决于它内部使用的子排序算法的运行时间,<br>一般为 O(nlgn)。<br>b.桶排序基于假设:输入的的元素均匀的分布在区间[0, 1]上。</p>\n<p>3.总结: 所有的线性时间内的排序算法,都作出了一定的假设, 必须建立在一定的输入数据的条件上.</p>\n</blockquote>\n<h4 id=\"Chapter9-如何找到第i小的数\"><a href=\"#Chapter9-如何找到第i小的数\" class=\"headerlink\" title=\"Chapter9 如何找到第i小的数?\"></a>Chapter9 如何找到第i小的数?</h4><blockquote>\n<p>1.the i-th order statistic: 第i小的元素<br>    直观的讲, 先排序然后直接选出A[i]就是该问题的解答.但实际上问题只要求第i小的数,排序则是求出了所有元素的次序, 那么是否不需要较大的消耗的排序,而去直接求解呢?</p>\n<p>2.由简入深</p>\n<blockquote>\n<p>min(max): 线性遍历, $\\Theta(n)$<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">minimum(A)</div><div class=\"line\">min &lt;- A[1]</div><div class=\"line\">for i &lt;- 2 to length[A]</div><div class=\"line\">        do if min &gt; A[i]</div><div class=\"line\">            then min &lt;- A[i]</div><div class=\"line\">return min</div></pre></td></tr></table></figure></p>\n<p>i-th:随机选择与分割定位: 递归, $\\Theta(n)$<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">randomized-select(A, p, r, i)</div><div class=\"line\">if p = r</div><div class=\"line\">        then return A[p]</div><div class=\"line\">q &lt;- randomized-partition(A, p, r)</div><div class=\"line\">k &lt;- q - p + 1</div><div class=\"line\">if i = k</div><div class=\"line\">        then return A[q]</div><div class=\"line\">elseif i &lt; k</div><div class=\"line\">        then return randomized-select(A, p, q-1, i)</div><div class=\"line\">else</div><div class=\"line\">        return randomized-select(A, q+1, r, i-k)</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>3.在第8章,比较模型中平均情况下需要$\\Theta(n\\log n)$的时间, 输入满足一定假设情况下可以达到线性时间按$O(n)$.以期望线性时间选择i-th的方法以快速排序为模型,如同在快速排序中一样,此算法的思想也是对输入数组进行递归划分。但和快速排序不同的是,快速排序会递归处理划分的两边,而randomized-select只处理划分的一边,并由此将期望的运行时间由$O(n\\log n)$下降到了$O(n)$。</p>\n</blockquote>\n<h3 id=\"Part3-数据结构\"><a href=\"#Part3-数据结构\" class=\"headerlink\" title=\"Part3 数据结构\"></a>Part3 数据结构</h3><p>####</p>"},{"title":"MIT-6.828-notes","date":"2017-04-07T16:00:00.000Z","_content":"\n# MIT 6.828笔记\n\n### 摘要\n　　MIT的课程[6.828 Operating System Engineering](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-828-operating-system-engineering-fall-2012/index.htm) 是一门os实验课程,是2006年后MIT基于Sixth Edition Unix(简称V6)开发的教学用os,受到广泛的赞誉，国内清华的ucore就有参考xv6实现．在学习[Operating Systems Concepts](https://book.douban.com/subject/10076960/)的os理论之后，有一个完整的peoject实践是极好的．基于想要深入os的好奇心,这系列博客将记录我的6.828学习笔记.\n\n### 目标\n> 1. 实践os的概念, 重点在kernel\n> 2. 增强C的代码能力\n> 3. 大型项目的结构组织,源代码的阅读理解\n\n### 笔记格式\n\n6.828课程涵盖两个方面的主题和对应的学习:\n> * xv6 -> 完整的操作系统的理论与设计\n> * JOS课程 -> 动手实践完成lab\n\n因此,笔记格式主要为\n> * note x: xv6以及理论笔记\n> * lab x:  project笔记\n> * hw x:   homework笔记\n\n### 笔记链接:\n#### Lab:\n> * lab 0: [实验环境搭建](https://chestnutme.github.io/2017/04/08/lab0/)\n> * lab 1: [启动pc](https://chestnutme.github.io/2017/04/10/lab1/)\n> * lab 2: [内存管理](https://chestnutme.github.io/2017/04/18/lab2/)\n> * lab 3: 用户空间\n>> * [Part1](https://chestnutme.github.io/2017/04/26/lab3-part1)\n>> * [Part2](https://chestnutme.github.io/2017/04/29/lab3-part2)\n>> *\n#### Homework:\n> * hw1: [boot xv6](https://chestnutme.github.io/2017/04/09/hw1/)\n> * hw2: [shell](https://chestnutme.github.io/2017/04/16/hw2/)\n> * hw3: [system call](https://chestnutme.github.io/2017/04/19/hw3/)\n> * hw4: [lazy page allocation](https://chestnutme.github.io/2017/04/21/hw4/)\n> * hw5: [cpu alarm](https://chestnutme.github.io/2017/04/24/hw5/)\n#### Note\n> * note 1: [chapter0](https://chestnutme.github.io/2017/04/16/note1/)\n### 参考链接\n> 1. [MIT 6.868](https://pdos.csail.mit.edu/6.828/2016/schedule.html), 2016年课程主页, 所有相关资源(没有lecture video).\n> 2. [OCW课程](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-828-operating-system-engineering-fall-2012/index.htm) MIT的开放课程,2012版.\n> 3. [课程视频 on youtube](https://www.youtube.com/watch?v=kDRHsNauoxk&list=PLfciLKR3SgqNJKKIKUliWoNBBH1VHL3AP)\n","source":"_posts/6.828-notes.md","raw":"title: MIT-6.828-notes\ndate: 2017/04/08\ntags:\n\t- os\n\t- xv6\n\n---\n\n# MIT 6.828笔记\n\n### 摘要\n　　MIT的课程[6.828 Operating System Engineering](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-828-operating-system-engineering-fall-2012/index.htm) 是一门os实验课程,是2006年后MIT基于Sixth Edition Unix(简称V6)开发的教学用os,受到广泛的赞誉，国内清华的ucore就有参考xv6实现．在学习[Operating Systems Concepts](https://book.douban.com/subject/10076960/)的os理论之后，有一个完整的peoject实践是极好的．基于想要深入os的好奇心,这系列博客将记录我的6.828学习笔记.\n\n### 目标\n> 1. 实践os的概念, 重点在kernel\n> 2. 增强C的代码能力\n> 3. 大型项目的结构组织,源代码的阅读理解\n\n### 笔记格式\n\n6.828课程涵盖两个方面的主题和对应的学习:\n> * xv6 -> 完整的操作系统的理论与设计\n> * JOS课程 -> 动手实践完成lab\n\n因此,笔记格式主要为\n> * note x: xv6以及理论笔记\n> * lab x:  project笔记\n> * hw x:   homework笔记\n\n### 笔记链接:\n#### Lab:\n> * lab 0: [实验环境搭建](https://chestnutme.github.io/2017/04/08/lab0/)\n> * lab 1: [启动pc](https://chestnutme.github.io/2017/04/10/lab1/)\n> * lab 2: [内存管理](https://chestnutme.github.io/2017/04/18/lab2/)\n> * lab 3: 用户空间\n>> * [Part1](https://chestnutme.github.io/2017/04/26/lab3-part1)\n>> * [Part2](https://chestnutme.github.io/2017/04/29/lab3-part2)\n>> *\n#### Homework:\n> * hw1: [boot xv6](https://chestnutme.github.io/2017/04/09/hw1/)\n> * hw2: [shell](https://chestnutme.github.io/2017/04/16/hw2/)\n> * hw3: [system call](https://chestnutme.github.io/2017/04/19/hw3/)\n> * hw4: [lazy page allocation](https://chestnutme.github.io/2017/04/21/hw4/)\n> * hw5: [cpu alarm](https://chestnutme.github.io/2017/04/24/hw5/)\n#### Note\n> * note 1: [chapter0](https://chestnutme.github.io/2017/04/16/note1/)\n### 参考链接\n> 1. [MIT 6.868](https://pdos.csail.mit.edu/6.828/2016/schedule.html), 2016年课程主页, 所有相关资源(没有lecture video).\n> 2. [OCW课程](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-828-operating-system-engineering-fall-2012/index.htm) MIT的开放课程,2012版.\n> 3. [课程视频 on youtube](https://www.youtube.com/watch?v=kDRHsNauoxk&list=PLfciLKR3SgqNJKKIKUliWoNBBH1VHL3AP)\n","slug":"6.828-notes","published":1,"updated":"2017-08-26T03:38:21.606Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6sslhan00033gamoc2r9912","content":"<h1 id=\"MIT-6-828笔记\"><a href=\"#MIT-6-828笔记\" class=\"headerlink\" title=\"MIT 6.828笔记\"></a>MIT 6.828笔记</h1><h3 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h3><p>　　MIT的课程<a href=\"https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-828-operating-system-engineering-fall-2012/index.htm\" target=\"_blank\" rel=\"external\">6.828 Operating System Engineering</a> 是一门os实验课程,是2006年后MIT基于Sixth Edition Unix(简称V6)开发的教学用os,受到广泛的赞誉，国内清华的ucore就有参考xv6实现．在学习<a href=\"https://book.douban.com/subject/10076960/\" target=\"_blank\" rel=\"external\">Operating Systems Concepts</a>的os理论之后，有一个完整的peoject实践是极好的．基于想要深入os的好奇心,这系列博客将记录我的6.828学习笔记.</p>\n<h3 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h3><blockquote>\n<ol>\n<li>实践os的概念, 重点在kernel</li>\n<li>增强C的代码能力</li>\n<li>大型项目的结构组织,源代码的阅读理解</li>\n</ol>\n</blockquote>\n<h3 id=\"笔记格式\"><a href=\"#笔记格式\" class=\"headerlink\" title=\"笔记格式\"></a>笔记格式</h3><p>6.828课程涵盖两个方面的主题和对应的学习:</p>\n<blockquote>\n<ul>\n<li>xv6 -&gt; 完整的操作系统的理论与设计</li>\n<li>JOS课程 -&gt; 动手实践完成lab</li>\n</ul>\n</blockquote>\n<p>因此,笔记格式主要为</p>\n<blockquote>\n<ul>\n<li>note x: xv6以及理论笔记</li>\n<li>lab x:  project笔记</li>\n<li>hw x:   homework笔记</li>\n</ul>\n</blockquote>\n<h3 id=\"笔记链接\"><a href=\"#笔记链接\" class=\"headerlink\" title=\"笔记链接:\"></a>笔记链接:</h3><h4 id=\"Lab\"><a href=\"#Lab\" class=\"headerlink\" title=\"Lab:\"></a>Lab:</h4><blockquote>\n<ul>\n<li>lab 0: <a href=\"https://chestnutme.github.io/2017/04/08/lab0/\" target=\"_blank\" rel=\"external\">实验环境搭建</a></li>\n<li>lab 1: <a href=\"https://chestnutme.github.io/2017/04/10/lab1/\" target=\"_blank\" rel=\"external\">启动pc</a></li>\n<li>lab 2: <a href=\"https://chestnutme.github.io/2017/04/18/lab2/\" target=\"_blank\" rel=\"external\">内存管理</a></li>\n<li>lab 3: 用户空间<blockquote>\n<ul>\n<li><a href=\"https://chestnutme.github.io/2017/04/26/lab3-part1\" target=\"_blank\" rel=\"external\">Part1</a></li>\n<li><a href=\"https://chestnutme.github.io/2017/04/29/lab3-part2\" target=\"_blank\" rel=\"external\">Part2</a><br>*<h4 id=\"Homework\"><a href=\"#Homework\" class=\"headerlink\" title=\"Homework:\"></a>Homework:</h4></li>\n</ul>\n</blockquote>\n</li>\n<li>hw1: <a href=\"https://chestnutme.github.io/2017/04/09/hw1/\" target=\"_blank\" rel=\"external\">boot xv6</a></li>\n<li>hw2: <a href=\"https://chestnutme.github.io/2017/04/16/hw2/\" target=\"_blank\" rel=\"external\">shell</a></li>\n<li>hw3: <a href=\"https://chestnutme.github.io/2017/04/19/hw3/\" target=\"_blank\" rel=\"external\">system call</a></li>\n<li>hw4: <a href=\"https://chestnutme.github.io/2017/04/21/hw4/\" target=\"_blank\" rel=\"external\">lazy page allocation</a></li>\n<li>hw5: <a href=\"https://chestnutme.github.io/2017/04/24/hw5/\" target=\"_blank\" rel=\"external\">cpu alarm</a><h4 id=\"Note\"><a href=\"#Note\" class=\"headerlink\" title=\"Note\"></a>Note</h4></li>\n<li>note 1: <a href=\"https://chestnutme.github.io/2017/04/16/note1/\" target=\"_blank\" rel=\"external\">chapter0</a><h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3></li>\n</ul>\n<ol>\n<li><a href=\"https://pdos.csail.mit.edu/6.828/2016/schedule.html\" target=\"_blank\" rel=\"external\">MIT 6.868</a>, 2016年课程主页, 所有相关资源(没有lecture video).</li>\n<li><a href=\"https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-828-operating-system-engineering-fall-2012/index.htm\" target=\"_blank\" rel=\"external\">OCW课程</a> MIT的开放课程,2012版.</li>\n<li><a href=\"https://www.youtube.com/watch?v=kDRHsNauoxk&amp;list=PLfciLKR3SgqNJKKIKUliWoNBBH1VHL3AP\" target=\"_blank\" rel=\"external\">课程视频 on youtube</a></li>\n</ol>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"MIT-6-828笔记\"><a href=\"#MIT-6-828笔记\" class=\"headerlink\" title=\"MIT 6.828笔记\"></a>MIT 6.828笔记</h1><h3 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h3><p>　　MIT的课程<a href=\"https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-828-operating-system-engineering-fall-2012/index.htm\" target=\"_blank\" rel=\"external\">6.828 Operating System Engineering</a> 是一门os实验课程,是2006年后MIT基于Sixth Edition Unix(简称V6)开发的教学用os,受到广泛的赞誉，国内清华的ucore就有参考xv6实现．在学习<a href=\"https://book.douban.com/subject/10076960/\" target=\"_blank\" rel=\"external\">Operating Systems Concepts</a>的os理论之后，有一个完整的peoject实践是极好的．基于想要深入os的好奇心,这系列博客将记录我的6.828学习笔记.</p>\n<h3 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h3><blockquote>\n<ol>\n<li>实践os的概念, 重点在kernel</li>\n<li>增强C的代码能力</li>\n<li>大型项目的结构组织,源代码的阅读理解</li>\n</ol>\n</blockquote>\n<h3 id=\"笔记格式\"><a href=\"#笔记格式\" class=\"headerlink\" title=\"笔记格式\"></a>笔记格式</h3><p>6.828课程涵盖两个方面的主题和对应的学习:</p>\n<blockquote>\n<ul>\n<li>xv6 -&gt; 完整的操作系统的理论与设计</li>\n<li>JOS课程 -&gt; 动手实践完成lab</li>\n</ul>\n</blockquote>\n<p>因此,笔记格式主要为</p>\n<blockquote>\n<ul>\n<li>note x: xv6以及理论笔记</li>\n<li>lab x:  project笔记</li>\n<li>hw x:   homework笔记</li>\n</ul>\n</blockquote>\n<h3 id=\"笔记链接\"><a href=\"#笔记链接\" class=\"headerlink\" title=\"笔记链接:\"></a>笔记链接:</h3><h4 id=\"Lab\"><a href=\"#Lab\" class=\"headerlink\" title=\"Lab:\"></a>Lab:</h4><blockquote>\n<ul>\n<li>lab 0: <a href=\"https://chestnutme.github.io/2017/04/08/lab0/\" target=\"_blank\" rel=\"external\">实验环境搭建</a></li>\n<li>lab 1: <a href=\"https://chestnutme.github.io/2017/04/10/lab1/\" target=\"_blank\" rel=\"external\">启动pc</a></li>\n<li>lab 2: <a href=\"https://chestnutme.github.io/2017/04/18/lab2/\" target=\"_blank\" rel=\"external\">内存管理</a></li>\n<li>lab 3: 用户空间<blockquote>\n<ul>\n<li><a href=\"https://chestnutme.github.io/2017/04/26/lab3-part1\" target=\"_blank\" rel=\"external\">Part1</a></li>\n<li><a href=\"https://chestnutme.github.io/2017/04/29/lab3-part2\" target=\"_blank\" rel=\"external\">Part2</a><br>*<h4 id=\"Homework\"><a href=\"#Homework\" class=\"headerlink\" title=\"Homework:\"></a>Homework:</h4></li>\n</ul>\n</blockquote>\n</li>\n<li>hw1: <a href=\"https://chestnutme.github.io/2017/04/09/hw1/\" target=\"_blank\" rel=\"external\">boot xv6</a></li>\n<li>hw2: <a href=\"https://chestnutme.github.io/2017/04/16/hw2/\" target=\"_blank\" rel=\"external\">shell</a></li>\n<li>hw3: <a href=\"https://chestnutme.github.io/2017/04/19/hw3/\" target=\"_blank\" rel=\"external\">system call</a></li>\n<li>hw4: <a href=\"https://chestnutme.github.io/2017/04/21/hw4/\" target=\"_blank\" rel=\"external\">lazy page allocation</a></li>\n<li>hw5: <a href=\"https://chestnutme.github.io/2017/04/24/hw5/\" target=\"_blank\" rel=\"external\">cpu alarm</a><h4 id=\"Note\"><a href=\"#Note\" class=\"headerlink\" title=\"Note\"></a>Note</h4></li>\n<li>note 1: <a href=\"https://chestnutme.github.io/2017/04/16/note1/\" target=\"_blank\" rel=\"external\">chapter0</a><h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3></li>\n</ul>\n<ol>\n<li><a href=\"https://pdos.csail.mit.edu/6.828/2016/schedule.html\" target=\"_blank\" rel=\"external\">MIT 6.868</a>, 2016年课程主页, 所有相关资源(没有lecture video).</li>\n<li><a href=\"https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-828-operating-system-engineering-fall-2012/index.htm\" target=\"_blank\" rel=\"external\">OCW课程</a> MIT的开放课程,2012版.</li>\n<li><a href=\"https://www.youtube.com/watch?v=kDRHsNauoxk&amp;list=PLfciLKR3SgqNJKKIKUliWoNBBH1VHL3AP\" target=\"_blank\" rel=\"external\">课程视频 on youtube</a></li>\n</ol>\n</blockquote>\n"},{"title":"introduction to algorithms note2","date":"2017-04-16T16:00:00.000Z","_content":"\n# ＜Introduction to algorithms＞笔记\n\n### Part3: 数据结构\n> 1. 动态集合:随着时间改变而变化\n> 2. 关键字(keyword) -> 全序集(排序)\n> 3. 基本操作\n>> * `search(S, k)`\n>> * `insert(S, x)`\n>> * `delete(S, x)`\n>> * `maximum/minimum(S)`\n>> * `successor/predecessor(S, x)`\n\n<!-- more -->\n\n#### Chapter10 基本数据结构实现动态集合?\n1. stack\n> - LIFO: 后进先出\n> - data\n>> ```\nSequence S; #可由数组或链表实现\nint top;\n```\n> - method\n>> ```\nstack-empty(S): O(1)\n  if top[S] = 0\n    then return true\n    else return false\n\npush(S, x): O(1)\n  top[S] <- top[S] + 1\n  S[top[S]] <- x\n\npop(S): O(1)\n   if stack-empty(S)\n    then error \"underflow\"\n    else top[S] <- top[S] - 1\n      return S[top[S] + 1]\n\n#若考虑实现stack的底层数据结构是静态的, 即栈容量有限,可能会上溢\nstack-full(S): O(1)\n if top[S] == size(S)\n    then return true\n    else return false\n\n```\n> - apply:\n>> 函数调用-递归\n>> 括号匹配与表达式求值\n\n2. queue\n在第6章排序中由heap实现了priority_queue, 是特殊一类queue:在queue上实现了优先级.基本的queue:\n> - FIFO: 先进先出\n> - data:\n>> ```\nSequence S;\nint head, tail;\nint length;\n```\n> - method\n>> ```\nenqueue(Q, x): O(1)\n  Q[tail[Q]] <- x\n  if tail[Q] = length[Q]\n    then tail[Q] <- 1\n    else tail[Q] <- tail[Q] + 1\n\ndequeue(Q): O(1)\n  x <- Q[head[Q]]\n  if head[Q] = length[Q]\n    then head[Q] <- 1\n    else head[Q] <- head[Q] + 1\n  return x\n>> ```\n> - apply:\n>> * FIFO算法; 先来先服务\n* 层次算法: 层次遍历, BFS\n\n3. linkedlist\n与数组的线性序是由下标决定(连续储存, 随机访问)不同, 链表的顺序由指针确定(易动态扩充)\n> - data:\n>> ```\nDatatype data\npointer next, prev\n```\n> - method:\n```\nsearch(L, k): O(n)\n  x <- head[L]\n  while x  != NULL and key[x] != k\n    do x <- next[x]\n  return x\n\ninsert(L, x): O(1) 头插法\n  next[x] <- head[L]\n  if head[L] != NULL\n    then prev[head[L]] <- x\n  head[L] <- x\n  prev[x] <- NULL\n\ndelete(L, x): x is pointer, O(1); x is key, O(n)\n  if prev[x] != NULL\n    then next[prev[x]] <- next[x]\n    else head[L] <- next[x]\n  if next[x] != NULL\n    then prev[next[x]] <- prev[x]\n```\n> - techique: 哨兵(sentinel)\n>> - 简化了边界条件, 代码实现更简洁,紧凑\n>> ```\nsearch(L, k)\n  x <- next[nil[L]]\n  while x != nil[L] and key[x] != k\n    do x <- next[x]\n  return x\n\ninsert(L, x)\n  next[x] <- next[nil[L]]\n  prev[next[nil[L]]] <- x\n  next[nil[L]] <- x\n  prev[x] <- nil[L]\n\ndelete(L, x)\n  next[prev[x]] <- next[x]\n  prev[next[x]] <- prev[x]\n```\n> - apply:\n数组和链表作为两种基本的线性结构, 两者实现的功能基本相同, 但各有优劣:数组由下标实现随机访问, 可以实现二分,快排等高效算法, 但容量受限,动态增删复杂度高;链表只能线性遍历, 查找排序效率低, 但由于指针特性,易于动态增删, 常用于管理动态的内容.\n\n4. 静态数组和分配释放\n在某些编程语言(如fortran)中没有指针的概念, 可以添加2个域储存prev, next对象的下标,模拟指针的功能.\n另外,动态增删元素时要向内存申请或释放内存, 一种机制是添加tag, 但最后销毁整个数据结构时处理, 一种则是C中的malloc/free机制,实现内存的分配和回收.\n\n5. 有根树\n将前驱后置的思想推广到任意同构的数据结构上, 自然导出了链接实现的树结构上, 这节只讨论树的基本结构:\n> - binary tree\n>> - node:\n>> ```\ndata\npointer left, right\n```\n\n>> - multi tree\n>> - node:\n>>> * data:\n>>> * pointer left-child, right-sibling #左孩子右兄弟表示法\n\n#### Chapter10 如何实现映射关系的数据结构?\n1. hash table: key ->(mapto) identifier\n> 　在散列表中查找一个元素的时间与在链表中查找一个元素的时候相同,在最坏情况为 $O(n)$,但期望时间为 $O(1)$.在实践中,散列表的效率是很高的,一般可认为是$O(1)$, 基本的字典操作只需要$O(1)$的平均时间.\n当待排序的关键字集合是静态的(即当关键字集合一旦存入后不再改变),\"完全散列\"能够在$O(1)$的最坏情况时间内支持关键字查找。当待排序的关键字的集合是静态的(即当关键字集合一旦存入后不需要再改变),“完全散列”能够在 O(1)的最坏时间内支持查找操作。\n\n２. 散列方法\n> 1. 直接寻址\n  适用于关键字个数小于可能的关键字总数(一般是表长)\n  但如果关键字的全集U很大,但实际关键字集合k很小, 则会造成大量空间的浪费.\n> ```\nsearch(T, k)\n  return T[k]\n\ninsert(T, x)\n  T[key[x]] <- x\n\ndelete(T, x)\n  T[key[x]] <- NULL\n```\n\n> 2. 散列表\n关键字集合k映射到长为m的散列表T上,即:\n\\begin{align}\nhash-func: h: U -> \\{0, 1, \\ldots ,m-1\\} \\\\\\\\\n即 k \\mapsto h(k)\n\\end{align}\n问题: 碰撞(collision)two key -> one position\n> 解决碰撞的方法:\n>> 1. 好的hash-func, 尽可能减少碰撞\n>> 2. 链接法(chaining): 散列到同一位置的存入链表中\n>> ```\nsearch(T, x): O(1)\n  search for an element with key in list T[h(k)]\n\ninsert(T, x): O(1)\n  insert x at the head of list T[h(key[x])]\n\ndelete(T, x): O(1)\n  delete x from the list T[h(key[x])]\n```\n在众多的简单的解决碰撞的方法中,我觉得比较好的是通过链表法解决碰撞,虽然这个方法的理论最坏效率为 O(n),但是在平均情况下,它的性能也是非常好的,实现简单又高效。\n\n\n3. hash-func\n> 1. 好的hash-func\n\\begin{align}\n对random \\, k \\, 0 \\leq k < 1,\\\\\\\\\nh(k) = \\lfloor km \\rfloor\n\\end{align}\n\n> 2. 多数的散列函数都假定关键字域为自然数集$N$,如果所给关键字不是自然数,则必须有一种方法来将它们解释为自然数。\n>> a. 除法散列法:\n一般选取 m 的值为与2的整数幂不大接近的质数\n>> $$h(k) = k\\mod m$$\n>> b. 乘法散列法:\n构造散列函数的乘法方法包含两个步骤:首先用关键字剩上常数 A(0<A<1),并抽取 kA 的小数部分;然后用m剩以这个值,再取结果的底。\n>> $$h(k) = \\lfloor m(kA \\mod 1) \\rfloor$$\n>> c.全域散列:全域散列的基本思想是在执行开始时,就从一族仔细设计的函数中,随机地选择一个作为散列函数。\ni. 全域散列表是一种使用“链接法”来解决碰撞问题的散列表方法。\nii. 随机化保证了对于任何输入,算法都具有较好的平均性能。\niii. 全域的散列函数组:设$H$为一组散列函数,它将给定的关键字域$U$映射到{0,1,...,m-1}中,这样的一个函数组称为是全域的.如果从$H$中随机地选择一个散列函数,当关键字K≠J时,两者发生碰撞的概率不大于1/m。\niv.常用的一个全域散列函数类:\n首先选择一个足够大的质数p,使得每一个可能的关键字k都落到0到p-1的范围内,包括首尾的0和p-1.这里我们假设全域是0–15, p为17。设集合Zp {0, 1, 2, ,...,p-1},集合Zp'为{1, 2, 3,...,p-1}。由于 p 是质数,\n我们可以定义散列函数\n$h(a, b, k) = ((a*k + b) \\mod p) \\mod m$\n其中a属于Zp,b属于Zp'。由所有这样的a和b构成的散列函数,组成了函数簇,即全域散列。\nv.明白这个散列函数的选取是在“执行开始”随机的选取一个是很重要的,要不然就会不明白到时候怎么进行查找。这里所谓的随机性应该这样理解:对于某一个散列表来说,它在初始化时已经把a,b固定了,但是对于一个还未初始化的全域散列表来说,a,b是随机选取的。\n\n4. 开放寻址法:所有的元素都放在散列表里\n> * 开放寻址法的好处就在于它根本不用指针,而是计算出要存取的各个pos。这样一来,由于不用存储指针就节省了空间,从而可以用同样的空间来提供更多的pos,其潜在的效果就是可以减少碰撞,提高查找速度。\n> * 开放寻址法很像一个启发式的搜索,它的最坏性能也是 O(n),只不过散列函数为它提供了启发信息从而使得一般的平均性能会很好。\n> * 在开放寻址法中,对散列元素的删除操作执行起来比较困难,因为删除操作会影响查找操作。解决办法是在pos里的值,被删除后置一个特定的值tag标记删除,而不是直接删除导致查找断开.\n> * 探查法\n线性探查、二次探查和双重散列都是对最基本的数组法的改进.\n>> 1. 线性探查 linear probing\n>> $$h(k,i) = (h'(k)+i) \\mod m$$\n>> $$h' = U \\mapsto [0, 1, \\ldots, m-1]$$\n>> 2. 二次探查 quadrating probing\n>> $$h(k,i) = (h'(k) + c_1i+ c_2i^2) \\mod m$$\n>> 3. 双重探查\n双重散列是用于开放寻址的最好方法之一,因为它所产生的排列具有随机选择的排列的许多特性.\n>> $$h(k,i) = (h_1(k) + ih_2(k)) \\mod m$$\n\n\n5. 完全散列:\n> 如果某一种散列技术在进行查找时,其最坏情况内存访问次数为$O(1)$的话,则称其为完全散列。书上使用了一种两级的散列方案,每一级都采用全域散列.通常利用一种两级的散列方案,每一级上都采用全域散列.\n完全散列的关键在于:二次散列表中要求没有碰撞.这是通过确保槽的个数是关键字的个数的平方来实现的。\n\n#### Chapter12 如何用树结构实现动态集合?\n1. 二叉查找树 binary search tree\n> * define:\n> $$key[left[x]] \\leq key[x] \\bigcup key[right[x]] \\geq key[x]$$\n> * method\n> ```\ninorder-walk(x): $O(n)$\n  if x != NULL\n    then inorder-walk(left[x])\n      visit key[x]\n      inorder-walk[right[x]]\n\nsearch(x, k): $O(h)$\n  if x = NULL or k = key[x]\n    then return x\n  if k < key[x]\n    then return search(left[x], k)\n    else return search(right[x], k)\n\nminimum(x): $O(h)$\n  while left[x] != NULL\n    do x <- left[x]\n  return x\n\nmaximum(x): $O(h)$\n  while right[x] != NULL\n    do x <- right[x]\n  return x\n\nsuccessor(x): $O(h)$, 中序后继\n  if right[x] != NULL\n    then return minimum(right[x])\n  y <- p[x]\n  while y != NULL and x = right[y]\n    do x <- y\n      y <- p[y]\n  return y\n\npredecessor(x): $O(h)$ 中序前驱\n  if left[x] != NULL\n    then return maxinum(left[x])\n  y < p[x]\n  while y != NUll and x = left[y]\n    do x <- y\n      y <- p[y]\n  return y\n\ninsert(T, k): $O(h)$\n  y <- NUll\n  x <- root[T]\n  while x != NUll\n    do y <- x\n      if key[k] < key[x]\n        then x <- left[x]\n        else x <- right[x]\n  p[x] <- u\n  if y = NUll\n    then root[T] <- x #tree T is empty\n    else if key[k] < key[y]\n      then left[y] <- k\n      else right[y] <- k\n\ndelete(T, k): $O(h)$\n  if left[k] = NUll or right[k] = NUll\n    then y <- k\n    else y <- successor(k)\n  if left[y] != NUll\n    then x <- left[y]\n    else x <- right[y]\n  if x != NUll\n    then p[x] <- p[y]\n  if p[y] = NUll\n    then root[T] <- x\n    else if y = left[p[y]]\n      then left[p[y]] <- x\n      else right[p[y]] <- de\n  if y != k\n    then key[k] <- key[y]\n      copy y's satellite date into k\n  return y\n```\n> BST的删除情况较复杂, 有难度的地方就是在删除同时存在左右子树的结点时需要进行处理.理解后可以概括为:对于这样的结点 x,找到 x 结点的前趋(或后继)y,将 x 的值替换为 y 的值,然后递归删除 y 结点就可以了。因为 y 一定没有右子树(后继对应没有左子树),所以递归删除的时候就是很简单的情况了。\n\n\n#### Chapter13 如何降低树高,提高二叉树的操作效率?\n从12章可以看到, BST的性能与树高直接相关.如果BST是单支树,则效率会降到$O(n)$, 如果树较为均匀平衡, 则效率提升到$O(\\log n)$.红黑树即是一种自平衡的二叉查找树, 具有很好的时间性能.\n> - define\n>> * node: color, key, left, right, p\n>> * 性质:\n>>> 1. 每个结点或是红色,或是是黑色。\n>>> 2. 根结点是黑的。\n>>> 3. 所有的叶结点(NULL)是黑色的。(NULL 被视为一个哨兵结点,所有应该指向 NULL 的指针,都看成指向了 NULL 结点。)\n>>> 4. 如果一个结点是红色的,则它的两个儿子节点都是黑色的。\n>>> 5. 对每个结点,从该结点到其子孙结点的所有路径上包含相同数目的黑结点。\n>>> 6. 黑高度的定义: 从某个结点出发(不包括该结点)到达一个叶结点的任意一条路径上,黑色结点的个数成为该结点x的黑高度.红黑树的黑高度定义为其根结点的黑高度.\n> - 哨兵 nil[T] 代表所有的空节点, 其color=black\n\n> - 性能:\n红黑树是一种近似平衡的二叉树),它能保证在最坏的情况下,基本的动态集合操作的时间为 O(lgn)。通过对任何一条从根到叶子的路径上各个结点着色方式的限制,红黑树确保没有一条路径会比其它路径长出两倍,因而是接近平衡的。\n注:全黑结点的满二叉树也满足红黑树的定义。满二叉树的效率本身就非常高,它是效率最好的二叉树之一.\n\n> - method\n>> *  旋转操作(左旋和右旋):\n旋转操作是一种能保持二叉查找树性质的查找树局部操作。\n所有对红黑树结构的修改都只能通过左右旋来完成,这样才能保证修改后的红黑树首先是一棵二叉查找树。\n```\nleft-rotate(T, x)\n  y <- right[x]\n  right[x] <- left[y]\n  p[left[y]] <- x\n  p[y] <- p[x]\n  if p[x] = nil[T]\n    then root[t] <- y\n    else if x = left[p[x]]\n      then ledt[p[x]] <- y\n      else right[p[x]] <- y\n  left[y] <- y\n  p[x] <- y\n```\n>> * 插入操作:\n将结点Z插入树T中,就好像T是一棵普通的二叉查找树一样,然后将Z着为红色。为保证红黑性质能继续保持,我们调用一个辅助程序来对结点重新着色并旋转。插入结点Z的位置的确应该和普通二叉查找树一样,因为红黑树本身就首先是一棵二叉查找树;然后将Z着为红色,是为了保证性质5的正确性,因为性质5如果被破坏了是最难以恢复的;到这里,有可能被破坏的性质就只剩下性质2和性质4了,这都可以通过后来的辅助程序进行修复的。\n插入操作可能破坏的性质:\ni. 性质2:当被一棵空树进行插入操作时发生;\nii. 性质4:当新结点被插入到红色结点之后时发生;\n```\ninsert(T, k)\n  y <- nil[T]\n  x <- root[T]\n  while x != nil[T]\n    do y <- x\n      if key[k] < key[x]\n        then x <- left[x]\n        else x <- right[x]\n  p[x] <- y\n  if y = nil[T]\n    then root[T] <- k\n    else if key[k] < key[y]\n      then left[y] <- k\n      else right[y] <- k\n  left[k] <- nil[T]\n  right[k] <- nil[T]\n  color[k] <- red\n  insert-fixup(T, k)\n```\n\n>> * 删除操作:\n和插入操作一样,先用BST的删除结点操作,然后调用相应的辅助函数做相应的调整。\n首先只有被删除的结点为黑结点时才需要进行调整,理由如下:\ni. 树中各结点的黑高度都没有变化\nii. 不存在两个相邻的红色结点\niii. 因为如果被删除的点是红色,就不可能是根,所以根仍然是黑色的\n当被删除了黑结点之后,红黑树的性质5被破坏,上面说过了性质5被破坏后的修复难度是最大的。所以这里的修复过程使用了一个很新的思想,即视为被删除的结点的子结点有额外的一种黑色,当这一重额外的黑色存在之后,性质5就得到了继续。然后再通过转移的方法逐步把这一重额外的黑色逐渐向上转移直到根或者红色的结点,最后消除这一重额外的黑色。\n删除操作中可能被破坏的性质:\ni. 性质2:当y是根时,且 y 的一个孩子是红色,若此时这个孩子成为根结点;\nii. 性质4:当x和p[y]都是红色时;\niii.性质5:包含y的路径中,黑高度都减少了;\n>> ```\ndelete(T, k)\n  if left[k] = nil[T] or right[k] = nil[T]\n    then y <- k\n    else y <- successor(k)\n  if left[y] != nil[T]\n    then x <- left[y]\n    else x <- right[y]\n  p[x] <- p[y]\n    then root[T] <- x\n    else if y = left[p[y]]\n      then left[p[y]] <- x\n      else right[p[y]] <- x\n  if y != k\n    then key[k] <- key[y]\n      copy y's satelite date into z\n  if color[y] = black\n    then delete-fixup(T, x)\n  return y\n```\n\n> - 红黑树是真正的在实际中得到大量应用的复杂数据结构:C++STL中的关联容器 map,set都是红黑树的应用(所以标准库容器的效率太好了,;Linux 内核中的用户态地址空间管理也使用了红黑树。\n\n#### Chapter14 数据规模扩大后,如何扩展数据结构?\n> 1. 实际的工程中,极少会去创造新的数据结构,通常是对标准的数据结构附加一些信息,并添加一些新的操作以支持应用的要求。\n> 2. 动态顺序统计(Dynamic order statistics)\n关于顺序统计这个问题，在中位数和顺序统计量介绍了在O(n)时间内获取一组数据中第i小的数据。在算导第十四章介绍了另外一种方式来求第i小的数据，它的算法复杂度为$O(\\log n)$，但却要依赖于另外一种数据结构顺序统计树(order statistic tree)。\n顺序统计树，是从红黑树扩展而来。相较于红黑树，一个顺序统计树的结点x，比一个红黑树的结点要多拥有一个字段size.size为以x为根结点的子树所包含的所有结点的数目(也包括x本身)。可以得出一条结论：\n> $$x.size=x.left.size+x.right.size+1$$\n> 在一棵顺序统计树中，可以很轻便的求该树中第 i小的结点：\n> ```\nOS-SELECT(x, i)\n    r = x.left.size + i\n    if i == r\n        return x\n    else if i < r\n        return OS-SELECT(x.left, i)\n    else\n        return OS-SELECT(x.right, i - r)\n```\n> 如上面的伪码所示，先求出 x 结点的排位r,因x不小于其左子树的所有结点，\n所以r = x.left.size + 1。\n若r等于i自不必说。若r大于i，说明所找的数，排在x之前，应从排在x之前的数中找第i小的数。即，从x的左子树中找第i小的数。若r小于i，则应该在比r大的数中找第i-r小的数，即在x的右子树中找第i-r小的数。同样也可以在O(lg n)的时间内求得指定结点的排位:\n> ```\nOS-RANK(T, x)\n    r = x.left.size + 1\n    y = x\n    while y != T.root\n        if y == y.p.right\n            r = r+ y.p.left.size + 1\n        y = y.p\n    return r\n```\n> 因为size记录的是以当前结点为根结点的子树所包含的所有结点的数目(也包括当前节点本身)，所以左侧伪码通过统计从x到根结点这条路径中本身为右孩子的结点本身以及它们的的左孩子的size来求得x的排位。\n顺序统计树以红黑树为基础进行扩展,所以红黑树的原有操作我们都可以继承下来。但是它增加了一个字段size,对于红黑树的删除和插入操作，我们不得不进\n\n> 2. 数据结构的扩张:指在实际应用数据结构时对标准的数据结构中增加一些信息、编入一些新的操作等等。附加的信息必须能够为该数据结构上的常规操作所更新和维护。\n> 3. 对一种数据结构的扩张过程可以分为四个步骤:\n>> 1. 选择基础的数据结构\n>> 2. 确定要在基础数据结构中添加哪些信息\n>> 3. 验证可用基础数据结构上的基本修改操作来维护这些新添加的信息\n>> 4. 设计新的操作\n> 5. 红黑树的扩张定理:当结点中新添加的信息可以由该结点和它的左右子树来决定,那么就可以在不影响时间复杂度的前提下在插入和删除等操作中对红黑树的这些附加信息进行维护。\n","source":"_posts/CLRS-notes2.md","raw":"title: introduction to algorithms note2\ntags:\n  - algorithm\n  - data_structure\ndate: 2017/04/17\n\n---\n\n# ＜Introduction to algorithms＞笔记\n\n### Part3: 数据结构\n> 1. 动态集合:随着时间改变而变化\n> 2. 关键字(keyword) -> 全序集(排序)\n> 3. 基本操作\n>> * `search(S, k)`\n>> * `insert(S, x)`\n>> * `delete(S, x)`\n>> * `maximum/minimum(S)`\n>> * `successor/predecessor(S, x)`\n\n<!-- more -->\n\n#### Chapter10 基本数据结构实现动态集合?\n1. stack\n> - LIFO: 后进先出\n> - data\n>> ```\nSequence S; #可由数组或链表实现\nint top;\n```\n> - method\n>> ```\nstack-empty(S): O(1)\n  if top[S] = 0\n    then return true\n    else return false\n\npush(S, x): O(1)\n  top[S] <- top[S] + 1\n  S[top[S]] <- x\n\npop(S): O(1)\n   if stack-empty(S)\n    then error \"underflow\"\n    else top[S] <- top[S] - 1\n      return S[top[S] + 1]\n\n#若考虑实现stack的底层数据结构是静态的, 即栈容量有限,可能会上溢\nstack-full(S): O(1)\n if top[S] == size(S)\n    then return true\n    else return false\n\n```\n> - apply:\n>> 函数调用-递归\n>> 括号匹配与表达式求值\n\n2. queue\n在第6章排序中由heap实现了priority_queue, 是特殊一类queue:在queue上实现了优先级.基本的queue:\n> - FIFO: 先进先出\n> - data:\n>> ```\nSequence S;\nint head, tail;\nint length;\n```\n> - method\n>> ```\nenqueue(Q, x): O(1)\n  Q[tail[Q]] <- x\n  if tail[Q] = length[Q]\n    then tail[Q] <- 1\n    else tail[Q] <- tail[Q] + 1\n\ndequeue(Q): O(1)\n  x <- Q[head[Q]]\n  if head[Q] = length[Q]\n    then head[Q] <- 1\n    else head[Q] <- head[Q] + 1\n  return x\n>> ```\n> - apply:\n>> * FIFO算法; 先来先服务\n* 层次算法: 层次遍历, BFS\n\n3. linkedlist\n与数组的线性序是由下标决定(连续储存, 随机访问)不同, 链表的顺序由指针确定(易动态扩充)\n> - data:\n>> ```\nDatatype data\npointer next, prev\n```\n> - method:\n```\nsearch(L, k): O(n)\n  x <- head[L]\n  while x  != NULL and key[x] != k\n    do x <- next[x]\n  return x\n\ninsert(L, x): O(1) 头插法\n  next[x] <- head[L]\n  if head[L] != NULL\n    then prev[head[L]] <- x\n  head[L] <- x\n  prev[x] <- NULL\n\ndelete(L, x): x is pointer, O(1); x is key, O(n)\n  if prev[x] != NULL\n    then next[prev[x]] <- next[x]\n    else head[L] <- next[x]\n  if next[x] != NULL\n    then prev[next[x]] <- prev[x]\n```\n> - techique: 哨兵(sentinel)\n>> - 简化了边界条件, 代码实现更简洁,紧凑\n>> ```\nsearch(L, k)\n  x <- next[nil[L]]\n  while x != nil[L] and key[x] != k\n    do x <- next[x]\n  return x\n\ninsert(L, x)\n  next[x] <- next[nil[L]]\n  prev[next[nil[L]]] <- x\n  next[nil[L]] <- x\n  prev[x] <- nil[L]\n\ndelete(L, x)\n  next[prev[x]] <- next[x]\n  prev[next[x]] <- prev[x]\n```\n> - apply:\n数组和链表作为两种基本的线性结构, 两者实现的功能基本相同, 但各有优劣:数组由下标实现随机访问, 可以实现二分,快排等高效算法, 但容量受限,动态增删复杂度高;链表只能线性遍历, 查找排序效率低, 但由于指针特性,易于动态增删, 常用于管理动态的内容.\n\n4. 静态数组和分配释放\n在某些编程语言(如fortran)中没有指针的概念, 可以添加2个域储存prev, next对象的下标,模拟指针的功能.\n另外,动态增删元素时要向内存申请或释放内存, 一种机制是添加tag, 但最后销毁整个数据结构时处理, 一种则是C中的malloc/free机制,实现内存的分配和回收.\n\n5. 有根树\n将前驱后置的思想推广到任意同构的数据结构上, 自然导出了链接实现的树结构上, 这节只讨论树的基本结构:\n> - binary tree\n>> - node:\n>> ```\ndata\npointer left, right\n```\n\n>> - multi tree\n>> - node:\n>>> * data:\n>>> * pointer left-child, right-sibling #左孩子右兄弟表示法\n\n#### Chapter10 如何实现映射关系的数据结构?\n1. hash table: key ->(mapto) identifier\n> 　在散列表中查找一个元素的时间与在链表中查找一个元素的时候相同,在最坏情况为 $O(n)$,但期望时间为 $O(1)$.在实践中,散列表的效率是很高的,一般可认为是$O(1)$, 基本的字典操作只需要$O(1)$的平均时间.\n当待排序的关键字集合是静态的(即当关键字集合一旦存入后不再改变),\"完全散列\"能够在$O(1)$的最坏情况时间内支持关键字查找。当待排序的关键字的集合是静态的(即当关键字集合一旦存入后不需要再改变),“完全散列”能够在 O(1)的最坏时间内支持查找操作。\n\n２. 散列方法\n> 1. 直接寻址\n  适用于关键字个数小于可能的关键字总数(一般是表长)\n  但如果关键字的全集U很大,但实际关键字集合k很小, 则会造成大量空间的浪费.\n> ```\nsearch(T, k)\n  return T[k]\n\ninsert(T, x)\n  T[key[x]] <- x\n\ndelete(T, x)\n  T[key[x]] <- NULL\n```\n\n> 2. 散列表\n关键字集合k映射到长为m的散列表T上,即:\n\\begin{align}\nhash-func: h: U -> \\{0, 1, \\ldots ,m-1\\} \\\\\\\\\n即 k \\mapsto h(k)\n\\end{align}\n问题: 碰撞(collision)two key -> one position\n> 解决碰撞的方法:\n>> 1. 好的hash-func, 尽可能减少碰撞\n>> 2. 链接法(chaining): 散列到同一位置的存入链表中\n>> ```\nsearch(T, x): O(1)\n  search for an element with key in list T[h(k)]\n\ninsert(T, x): O(1)\n  insert x at the head of list T[h(key[x])]\n\ndelete(T, x): O(1)\n  delete x from the list T[h(key[x])]\n```\n在众多的简单的解决碰撞的方法中,我觉得比较好的是通过链表法解决碰撞,虽然这个方法的理论最坏效率为 O(n),但是在平均情况下,它的性能也是非常好的,实现简单又高效。\n\n\n3. hash-func\n> 1. 好的hash-func\n\\begin{align}\n对random \\, k \\, 0 \\leq k < 1,\\\\\\\\\nh(k) = \\lfloor km \\rfloor\n\\end{align}\n\n> 2. 多数的散列函数都假定关键字域为自然数集$N$,如果所给关键字不是自然数,则必须有一种方法来将它们解释为自然数。\n>> a. 除法散列法:\n一般选取 m 的值为与2的整数幂不大接近的质数\n>> $$h(k) = k\\mod m$$\n>> b. 乘法散列法:\n构造散列函数的乘法方法包含两个步骤:首先用关键字剩上常数 A(0<A<1),并抽取 kA 的小数部分;然后用m剩以这个值,再取结果的底。\n>> $$h(k) = \\lfloor m(kA \\mod 1) \\rfloor$$\n>> c.全域散列:全域散列的基本思想是在执行开始时,就从一族仔细设计的函数中,随机地选择一个作为散列函数。\ni. 全域散列表是一种使用“链接法”来解决碰撞问题的散列表方法。\nii. 随机化保证了对于任何输入,算法都具有较好的平均性能。\niii. 全域的散列函数组:设$H$为一组散列函数,它将给定的关键字域$U$映射到{0,1,...,m-1}中,这样的一个函数组称为是全域的.如果从$H$中随机地选择一个散列函数,当关键字K≠J时,两者发生碰撞的概率不大于1/m。\niv.常用的一个全域散列函数类:\n首先选择一个足够大的质数p,使得每一个可能的关键字k都落到0到p-1的范围内,包括首尾的0和p-1.这里我们假设全域是0–15, p为17。设集合Zp {0, 1, 2, ,...,p-1},集合Zp'为{1, 2, 3,...,p-1}。由于 p 是质数,\n我们可以定义散列函数\n$h(a, b, k) = ((a*k + b) \\mod p) \\mod m$\n其中a属于Zp,b属于Zp'。由所有这样的a和b构成的散列函数,组成了函数簇,即全域散列。\nv.明白这个散列函数的选取是在“执行开始”随机的选取一个是很重要的,要不然就会不明白到时候怎么进行查找。这里所谓的随机性应该这样理解:对于某一个散列表来说,它在初始化时已经把a,b固定了,但是对于一个还未初始化的全域散列表来说,a,b是随机选取的。\n\n4. 开放寻址法:所有的元素都放在散列表里\n> * 开放寻址法的好处就在于它根本不用指针,而是计算出要存取的各个pos。这样一来,由于不用存储指针就节省了空间,从而可以用同样的空间来提供更多的pos,其潜在的效果就是可以减少碰撞,提高查找速度。\n> * 开放寻址法很像一个启发式的搜索,它的最坏性能也是 O(n),只不过散列函数为它提供了启发信息从而使得一般的平均性能会很好。\n> * 在开放寻址法中,对散列元素的删除操作执行起来比较困难,因为删除操作会影响查找操作。解决办法是在pos里的值,被删除后置一个特定的值tag标记删除,而不是直接删除导致查找断开.\n> * 探查法\n线性探查、二次探查和双重散列都是对最基本的数组法的改进.\n>> 1. 线性探查 linear probing\n>> $$h(k,i) = (h'(k)+i) \\mod m$$\n>> $$h' = U \\mapsto [0, 1, \\ldots, m-1]$$\n>> 2. 二次探查 quadrating probing\n>> $$h(k,i) = (h'(k) + c_1i+ c_2i^2) \\mod m$$\n>> 3. 双重探查\n双重散列是用于开放寻址的最好方法之一,因为它所产生的排列具有随机选择的排列的许多特性.\n>> $$h(k,i) = (h_1(k) + ih_2(k)) \\mod m$$\n\n\n5. 完全散列:\n> 如果某一种散列技术在进行查找时,其最坏情况内存访问次数为$O(1)$的话,则称其为完全散列。书上使用了一种两级的散列方案,每一级都采用全域散列.通常利用一种两级的散列方案,每一级上都采用全域散列.\n完全散列的关键在于:二次散列表中要求没有碰撞.这是通过确保槽的个数是关键字的个数的平方来实现的。\n\n#### Chapter12 如何用树结构实现动态集合?\n1. 二叉查找树 binary search tree\n> * define:\n> $$key[left[x]] \\leq key[x] \\bigcup key[right[x]] \\geq key[x]$$\n> * method\n> ```\ninorder-walk(x): $O(n)$\n  if x != NULL\n    then inorder-walk(left[x])\n      visit key[x]\n      inorder-walk[right[x]]\n\nsearch(x, k): $O(h)$\n  if x = NULL or k = key[x]\n    then return x\n  if k < key[x]\n    then return search(left[x], k)\n    else return search(right[x], k)\n\nminimum(x): $O(h)$\n  while left[x] != NULL\n    do x <- left[x]\n  return x\n\nmaximum(x): $O(h)$\n  while right[x] != NULL\n    do x <- right[x]\n  return x\n\nsuccessor(x): $O(h)$, 中序后继\n  if right[x] != NULL\n    then return minimum(right[x])\n  y <- p[x]\n  while y != NULL and x = right[y]\n    do x <- y\n      y <- p[y]\n  return y\n\npredecessor(x): $O(h)$ 中序前驱\n  if left[x] != NULL\n    then return maxinum(left[x])\n  y < p[x]\n  while y != NUll and x = left[y]\n    do x <- y\n      y <- p[y]\n  return y\n\ninsert(T, k): $O(h)$\n  y <- NUll\n  x <- root[T]\n  while x != NUll\n    do y <- x\n      if key[k] < key[x]\n        then x <- left[x]\n        else x <- right[x]\n  p[x] <- u\n  if y = NUll\n    then root[T] <- x #tree T is empty\n    else if key[k] < key[y]\n      then left[y] <- k\n      else right[y] <- k\n\ndelete(T, k): $O(h)$\n  if left[k] = NUll or right[k] = NUll\n    then y <- k\n    else y <- successor(k)\n  if left[y] != NUll\n    then x <- left[y]\n    else x <- right[y]\n  if x != NUll\n    then p[x] <- p[y]\n  if p[y] = NUll\n    then root[T] <- x\n    else if y = left[p[y]]\n      then left[p[y]] <- x\n      else right[p[y]] <- de\n  if y != k\n    then key[k] <- key[y]\n      copy y's satellite date into k\n  return y\n```\n> BST的删除情况较复杂, 有难度的地方就是在删除同时存在左右子树的结点时需要进行处理.理解后可以概括为:对于这样的结点 x,找到 x 结点的前趋(或后继)y,将 x 的值替换为 y 的值,然后递归删除 y 结点就可以了。因为 y 一定没有右子树(后继对应没有左子树),所以递归删除的时候就是很简单的情况了。\n\n\n#### Chapter13 如何降低树高,提高二叉树的操作效率?\n从12章可以看到, BST的性能与树高直接相关.如果BST是单支树,则效率会降到$O(n)$, 如果树较为均匀平衡, 则效率提升到$O(\\log n)$.红黑树即是一种自平衡的二叉查找树, 具有很好的时间性能.\n> - define\n>> * node: color, key, left, right, p\n>> * 性质:\n>>> 1. 每个结点或是红色,或是是黑色。\n>>> 2. 根结点是黑的。\n>>> 3. 所有的叶结点(NULL)是黑色的。(NULL 被视为一个哨兵结点,所有应该指向 NULL 的指针,都看成指向了 NULL 结点。)\n>>> 4. 如果一个结点是红色的,则它的两个儿子节点都是黑色的。\n>>> 5. 对每个结点,从该结点到其子孙结点的所有路径上包含相同数目的黑结点。\n>>> 6. 黑高度的定义: 从某个结点出发(不包括该结点)到达一个叶结点的任意一条路径上,黑色结点的个数成为该结点x的黑高度.红黑树的黑高度定义为其根结点的黑高度.\n> - 哨兵 nil[T] 代表所有的空节点, 其color=black\n\n> - 性能:\n红黑树是一种近似平衡的二叉树),它能保证在最坏的情况下,基本的动态集合操作的时间为 O(lgn)。通过对任何一条从根到叶子的路径上各个结点着色方式的限制,红黑树确保没有一条路径会比其它路径长出两倍,因而是接近平衡的。\n注:全黑结点的满二叉树也满足红黑树的定义。满二叉树的效率本身就非常高,它是效率最好的二叉树之一.\n\n> - method\n>> *  旋转操作(左旋和右旋):\n旋转操作是一种能保持二叉查找树性质的查找树局部操作。\n所有对红黑树结构的修改都只能通过左右旋来完成,这样才能保证修改后的红黑树首先是一棵二叉查找树。\n```\nleft-rotate(T, x)\n  y <- right[x]\n  right[x] <- left[y]\n  p[left[y]] <- x\n  p[y] <- p[x]\n  if p[x] = nil[T]\n    then root[t] <- y\n    else if x = left[p[x]]\n      then ledt[p[x]] <- y\n      else right[p[x]] <- y\n  left[y] <- y\n  p[x] <- y\n```\n>> * 插入操作:\n将结点Z插入树T中,就好像T是一棵普通的二叉查找树一样,然后将Z着为红色。为保证红黑性质能继续保持,我们调用一个辅助程序来对结点重新着色并旋转。插入结点Z的位置的确应该和普通二叉查找树一样,因为红黑树本身就首先是一棵二叉查找树;然后将Z着为红色,是为了保证性质5的正确性,因为性质5如果被破坏了是最难以恢复的;到这里,有可能被破坏的性质就只剩下性质2和性质4了,这都可以通过后来的辅助程序进行修复的。\n插入操作可能破坏的性质:\ni. 性质2:当被一棵空树进行插入操作时发生;\nii. 性质4:当新结点被插入到红色结点之后时发生;\n```\ninsert(T, k)\n  y <- nil[T]\n  x <- root[T]\n  while x != nil[T]\n    do y <- x\n      if key[k] < key[x]\n        then x <- left[x]\n        else x <- right[x]\n  p[x] <- y\n  if y = nil[T]\n    then root[T] <- k\n    else if key[k] < key[y]\n      then left[y] <- k\n      else right[y] <- k\n  left[k] <- nil[T]\n  right[k] <- nil[T]\n  color[k] <- red\n  insert-fixup(T, k)\n```\n\n>> * 删除操作:\n和插入操作一样,先用BST的删除结点操作,然后调用相应的辅助函数做相应的调整。\n首先只有被删除的结点为黑结点时才需要进行调整,理由如下:\ni. 树中各结点的黑高度都没有变化\nii. 不存在两个相邻的红色结点\niii. 因为如果被删除的点是红色,就不可能是根,所以根仍然是黑色的\n当被删除了黑结点之后,红黑树的性质5被破坏,上面说过了性质5被破坏后的修复难度是最大的。所以这里的修复过程使用了一个很新的思想,即视为被删除的结点的子结点有额外的一种黑色,当这一重额外的黑色存在之后,性质5就得到了继续。然后再通过转移的方法逐步把这一重额外的黑色逐渐向上转移直到根或者红色的结点,最后消除这一重额外的黑色。\n删除操作中可能被破坏的性质:\ni. 性质2:当y是根时,且 y 的一个孩子是红色,若此时这个孩子成为根结点;\nii. 性质4:当x和p[y]都是红色时;\niii.性质5:包含y的路径中,黑高度都减少了;\n>> ```\ndelete(T, k)\n  if left[k] = nil[T] or right[k] = nil[T]\n    then y <- k\n    else y <- successor(k)\n  if left[y] != nil[T]\n    then x <- left[y]\n    else x <- right[y]\n  p[x] <- p[y]\n    then root[T] <- x\n    else if y = left[p[y]]\n      then left[p[y]] <- x\n      else right[p[y]] <- x\n  if y != k\n    then key[k] <- key[y]\n      copy y's satelite date into z\n  if color[y] = black\n    then delete-fixup(T, x)\n  return y\n```\n\n> - 红黑树是真正的在实际中得到大量应用的复杂数据结构:C++STL中的关联容器 map,set都是红黑树的应用(所以标准库容器的效率太好了,;Linux 内核中的用户态地址空间管理也使用了红黑树。\n\n#### Chapter14 数据规模扩大后,如何扩展数据结构?\n> 1. 实际的工程中,极少会去创造新的数据结构,通常是对标准的数据结构附加一些信息,并添加一些新的操作以支持应用的要求。\n> 2. 动态顺序统计(Dynamic order statistics)\n关于顺序统计这个问题，在中位数和顺序统计量介绍了在O(n)时间内获取一组数据中第i小的数据。在算导第十四章介绍了另外一种方式来求第i小的数据，它的算法复杂度为$O(\\log n)$，但却要依赖于另外一种数据结构顺序统计树(order statistic tree)。\n顺序统计树，是从红黑树扩展而来。相较于红黑树，一个顺序统计树的结点x，比一个红黑树的结点要多拥有一个字段size.size为以x为根结点的子树所包含的所有结点的数目(也包括x本身)。可以得出一条结论：\n> $$x.size=x.left.size+x.right.size+1$$\n> 在一棵顺序统计树中，可以很轻便的求该树中第 i小的结点：\n> ```\nOS-SELECT(x, i)\n    r = x.left.size + i\n    if i == r\n        return x\n    else if i < r\n        return OS-SELECT(x.left, i)\n    else\n        return OS-SELECT(x.right, i - r)\n```\n> 如上面的伪码所示，先求出 x 结点的排位r,因x不小于其左子树的所有结点，\n所以r = x.left.size + 1。\n若r等于i自不必说。若r大于i，说明所找的数，排在x之前，应从排在x之前的数中找第i小的数。即，从x的左子树中找第i小的数。若r小于i，则应该在比r大的数中找第i-r小的数，即在x的右子树中找第i-r小的数。同样也可以在O(lg n)的时间内求得指定结点的排位:\n> ```\nOS-RANK(T, x)\n    r = x.left.size + 1\n    y = x\n    while y != T.root\n        if y == y.p.right\n            r = r+ y.p.left.size + 1\n        y = y.p\n    return r\n```\n> 因为size记录的是以当前结点为根结点的子树所包含的所有结点的数目(也包括当前节点本身)，所以左侧伪码通过统计从x到根结点这条路径中本身为右孩子的结点本身以及它们的的左孩子的size来求得x的排位。\n顺序统计树以红黑树为基础进行扩展,所以红黑树的原有操作我们都可以继承下来。但是它增加了一个字段size,对于红黑树的删除和插入操作，我们不得不进\n\n> 2. 数据结构的扩张:指在实际应用数据结构时对标准的数据结构中增加一些信息、编入一些新的操作等等。附加的信息必须能够为该数据结构上的常规操作所更新和维护。\n> 3. 对一种数据结构的扩张过程可以分为四个步骤:\n>> 1. 选择基础的数据结构\n>> 2. 确定要在基础数据结构中添加哪些信息\n>> 3. 验证可用基础数据结构上的基本修改操作来维护这些新添加的信息\n>> 4. 设计新的操作\n> 5. 红黑树的扩张定理:当结点中新添加的信息可以由该结点和它的左右子树来决定,那么就可以在不影响时间复杂度的前提下在插入和删除等操作中对红黑树的这些附加信息进行维护。\n","slug":"CLRS-notes2","published":1,"updated":"2017-08-26T03:38:21.618Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6sslhas00063gamqhyyfepg","content":"<h1 id=\"＜Introduction-to-algorithms＞笔记\"><a href=\"#＜Introduction-to-algorithms＞笔记\" class=\"headerlink\" title=\"＜Introduction to algorithms＞笔记\"></a>＜Introduction to algorithms＞笔记</h1><h3 id=\"Part3-数据结构\"><a href=\"#Part3-数据结构\" class=\"headerlink\" title=\"Part3: 数据结构\"></a>Part3: 数据结构</h3><blockquote>\n<ol>\n<li>动态集合:随着时间改变而变化</li>\n<li>关键字(keyword) -&gt; 全序集(排序)</li>\n<li>基本操作<blockquote>\n<ul>\n<li><code>search(S, k)</code></li>\n<li><code>insert(S, x)</code></li>\n<li><code>delete(S, x)</code></li>\n<li><code>maximum/minimum(S)</code></li>\n<li><code>successor/predecessor(S, x)</code></li>\n</ul>\n</blockquote>\n</li>\n</ol>\n</blockquote>\n<a id=\"more\"></a>\n<h4 id=\"Chapter10-基本数据结构实现动态集合\"><a href=\"#Chapter10-基本数据结构实现动态集合\" class=\"headerlink\" title=\"Chapter10 基本数据结构实现动态集合?\"></a>Chapter10 基本数据结构实现动态集合?</h4><ol>\n<li>stack<blockquote>\n<ul>\n<li>LIFO: 后进先出</li>\n<li>data<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Sequence S; #可由数组或链表实现</div><div class=\"line\">int top;</div></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<blockquote>\n<ul>\n<li><p>method</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">stack-empty(S): O(1)</div><div class=\"line\">  if top[S] = 0</div><div class=\"line\">    then return true</div><div class=\"line\">    else return false</div><div class=\"line\"></div><div class=\"line\">push(S, x): O(1)</div><div class=\"line\">  top[S] &lt;- top[S] + 1</div><div class=\"line\">  S[top[S]] &lt;- x</div><div class=\"line\"></div><div class=\"line\">pop(S): O(1)</div><div class=\"line\">   if stack-empty(S)</div><div class=\"line\">    then error &quot;underflow&quot;</div><div class=\"line\">    else top[S] &lt;- top[S] - 1</div><div class=\"line\">      return S[top[S] + 1]</div><div class=\"line\"></div><div class=\"line\">#若考虑实现stack的底层数据结构是静态的, 即栈容量有限,可能会上溢</div><div class=\"line\">stack-full(S): O(1)</div><div class=\"line\"> if top[S] == size(S)</div><div class=\"line\">    then return true</div><div class=\"line\">    else return false</div></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li><p>apply:</p>\n<blockquote>\n<p>函数调用-递归<br>括号匹配与表达式求值</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<ol>\n<li>queue<br>在第6章排序中由heap实现了priority_queue, 是特殊一类queue:在queue上实现了优先级.基本的queue:<blockquote>\n<ul>\n<li>FIFO: 先进先出</li>\n<li>data:<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Sequence S;</div><div class=\"line\">int head, tail;</div><div class=\"line\">int length;</div></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<blockquote>\n<ul>\n<li><p>method</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">enqueue(Q, x): O(1)</div><div class=\"line\">  Q[tail[Q]] &lt;- x</div><div class=\"line\">  if tail[Q] = length[Q]</div><div class=\"line\">    then tail[Q] &lt;- 1</div><div class=\"line\">    else tail[Q] &lt;- tail[Q] + 1</div><div class=\"line\"></div><div class=\"line\">dequeue(Q): O(1)</div><div class=\"line\">  x &lt;- Q[head[Q]]</div><div class=\"line\">  if head[Q] = length[Q]</div><div class=\"line\">    then head[Q] &lt;- 1</div><div class=\"line\">    else head[Q] &lt;- head[Q] + 1</div><div class=\"line\">  return x</div><div class=\"line\">&gt;&gt;</div></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li><p>apply:</p>\n<blockquote>\n<ul>\n<li>FIFO算法; 先来先服务</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li>层次算法: 层次遍历, BFS</li>\n</ul>\n</blockquote>\n<ol>\n<li>linkedlist<br>与数组的线性序是由下标决定(连续储存, 随机访问)不同, 链表的顺序由指针确定(易动态扩充)<blockquote>\n<ul>\n<li>data:<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Datatype data</div><div class=\"line\">pointer next, prev</div></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<blockquote>\n<ul>\n<li><p>method:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">search(L, k): O(n)</div><div class=\"line\">  x &lt;- head[L]</div><div class=\"line\">  while x  != NULL and key[x] != k</div><div class=\"line\">    do x &lt;- next[x]</div><div class=\"line\">  return x</div><div class=\"line\"></div><div class=\"line\">insert(L, x): O(1) 头插法</div><div class=\"line\">  next[x] &lt;- head[L]</div><div class=\"line\">  if head[L] != NULL</div><div class=\"line\">    then prev[head[L]] &lt;- x</div><div class=\"line\">  head[L] &lt;- x</div><div class=\"line\">  prev[x] &lt;- NULL</div><div class=\"line\"></div><div class=\"line\">delete(L, x): x is pointer, O(1); x is key, O(n)</div><div class=\"line\">  if prev[x] != NULL</div><div class=\"line\">    then next[prev[x]] &lt;- next[x]</div><div class=\"line\">    else head[L] &lt;- next[x]</div><div class=\"line\">  if next[x] != NULL</div><div class=\"line\">    then prev[next[x]] &lt;- prev[x]</div></pre></td></tr></table></figure>\n</li>\n<li><p>techique: 哨兵(sentinel)</p>\n<blockquote>\n<ul>\n<li>简化了边界条件, 代码实现更简洁,紧凑<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">search(L, k)</div><div class=\"line\">  x &lt;- next[nil[L]]</div><div class=\"line\">  while x != nil[L] and key[x] != k</div><div class=\"line\">    do x &lt;- next[x]</div><div class=\"line\">  return x</div><div class=\"line\"></div><div class=\"line\">insert(L, x)</div><div class=\"line\">  next[x] &lt;- next[nil[L]]</div><div class=\"line\">  prev[next[nil[L]]] &lt;- x</div><div class=\"line\">  next[nil[L]] &lt;- x</div><div class=\"line\">  prev[x] &lt;- nil[L]</div><div class=\"line\"></div><div class=\"line\">delete(L, x)</div><div class=\"line\">  next[prev[x]] &lt;- next[x]</div><div class=\"line\">  prev[next[x]] &lt;- prev[x]</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n</li>\n<li><p>apply:<br>数组和链表作为两种基本的线性结构, 两者实现的功能基本相同, 但各有优劣:数组由下标实现随机访问, 可以实现二分,快排等高效算法, 但容量受限,动态增删复杂度高;链表只能线性遍历, 查找排序效率低, 但由于指针特性,易于动态增删, 常用于管理动态的内容.</p>\n</li>\n</ul>\n</blockquote>\n<ol>\n<li><p>静态数组和分配释放<br>在某些编程语言(如fortran)中没有指针的概念, 可以添加2个域储存prev, next对象的下标,模拟指针的功能.<br>另外,动态增删元素时要向内存申请或释放内存, 一种机制是添加tag, 但最后销毁整个数据结构时处理, 一种则是C中的malloc/free机制,实现内存的分配和回收.</p>\n</li>\n<li><p>有根树<br>将前驱后置的思想推广到任意同构的数据结构上, 自然导出了链接实现的树结构上, 这节只讨论树的基本结构:</p>\n<blockquote>\n<ul>\n<li>binary tree<blockquote>\n<ul>\n<li>node:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">data</div><div class=\"line\">pointer left, right</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<blockquote>\n<blockquote>\n<ul>\n<li>multi tree</li>\n<li>node:<blockquote>\n<ul>\n<li>data:</li>\n<li>pointer left-child, right-sibling #左孩子右兄弟表示法</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n</blockquote>\n<h4 id=\"Chapter10-如何实现映射关系的数据结构\"><a href=\"#Chapter10-如何实现映射关系的数据结构\" class=\"headerlink\" title=\"Chapter10 如何实现映射关系的数据结构?\"></a>Chapter10 如何实现映射关系的数据结构?</h4><ol>\n<li>hash table: key -&gt;(mapto) identifier<blockquote>\n<p>　在散列表中查找一个元素的时间与在链表中查找一个元素的时候相同,在最坏情况为 $O(n)$,但期望时间为 $O(1)$.在实践中,散列表的效率是很高的,一般可认为是$O(1)$, 基本的字典操作只需要$O(1)$的平均时间.<br>当待排序的关键字集合是静态的(即当关键字集合一旦存入后不再改变),”完全散列”能够在$O(1)$的最坏情况时间内支持关键字查找。当待排序的关键字的集合是静态的(即当关键字集合一旦存入后不需要再改变),“完全散列”能够在 O(1)的最坏时间内支持查找操作。</p>\n</blockquote>\n</li>\n</ol>\n<p>２. 散列方法</p>\n<blockquote>\n<ol>\n<li><p>直接寻址<br>适用于关键字个数小于可能的关键字总数(一般是表长)<br>但如果关键字的全集U很大,但实际关键字集合k很小, 则会造成大量空间的浪费.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">search(T, k)</div><div class=\"line\">  return T[k]</div><div class=\"line\"></div><div class=\"line\">insert(T, x)</div><div class=\"line\">  T[key[x]] &lt;- x</div><div class=\"line\"></div><div class=\"line\">delete(T, x)</div><div class=\"line\">  T[key[x]] &lt;- NULL</div></pre></td></tr></table></figure>\n</li>\n<li><p>散列表<br>关键字集合k映射到长为m的散列表T上,即:<br>\\begin{align}<br>hash-func: h: U -&gt; {0, 1, \\ldots ,m-1} \\\\<br>即 k \\mapsto h(k)<br>\\end{align}<br>问题: 碰撞(collision)two key -&gt; one position<br>解决碰撞的方法:</p>\n<blockquote>\n<ol>\n<li>好的hash-func, 尽可能减少碰撞</li>\n<li>链接法(chaining): 散列到同一位置的存入链表中<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">search(T, x): O(1)</div><div class=\"line\">  search for an element with key in list T[h(k)]</div><div class=\"line\"></div><div class=\"line\">insert(T, x): O(1)</div><div class=\"line\">  insert x at the head of list T[h(key[x])]</div><div class=\"line\"></div><div class=\"line\">delete(T, x): O(1)</div><div class=\"line\">  delete x from the list T[h(key[x])]</div></pre></td></tr></table></figure>\n</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n</blockquote>\n<p>在众多的简单的解决碰撞的方法中,我觉得比较好的是通过链表法解决碰撞,虽然这个方法的理论最坏效率为 O(n),但是在平均情况下,它的性能也是非常好的,实现简单又高效。</p>\n<ol>\n<li>hash-func<blockquote>\n<ol>\n<li>好的hash-func<br>\\begin{align}<br>对random \\, k \\, 0 \\leq k &lt; 1,\\\\<br>h(k) = \\lfloor km \\rfloor<br>\\end{align}</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n<blockquote>\n<ol>\n<li>多数的散列函数都假定关键字域为自然数集$N$,如果所给关键字不是自然数,则必须有一种方法来将它们解释为自然数。<blockquote>\n<p>a. 除法散列法:<br>一般选取 m 的值为与2的整数幂不大接近的质数<br>$$h(k) = k\\mod m$$<br>b. 乘法散列法:<br>构造散列函数的乘法方法包含两个步骤:首先用关键字剩上常数 A(0&lt;A&lt;1),并抽取 kA 的小数部分;然后用m剩以这个值,再取结果的底。<br>$$h(k) = \\lfloor m(kA \\mod 1) \\rfloor$$<br>c.全域散列:全域散列的基本思想是在执行开始时,就从一族仔细设计的函数中,随机地选择一个作为散列函数。<br>i. 全域散列表是一种使用“链接法”来解决碰撞问题的散列表方法。<br>ii. 随机化保证了对于任何输入,算法都具有较好的平均性能。<br>iii. 全域的散列函数组:设$H$为一组散列函数,它将给定的关键字域$U$映射到{0,1,…,m-1}中,这样的一个函数组称为是全域的.如果从$H$中随机地选择一个散列函数,当关键字K≠J时,两者发生碰撞的概率不大于1/m。<br>iv.常用的一个全域散列函数类:<br>首先选择一个足够大的质数p,使得每一个可能的关键字k都落到0到p-1的范围内,包括首尾的0和p-1.这里我们假设全域是0–15, p为17。设集合Zp {0, 1, 2, ,…,p-1},集合Zp’为{1, 2, 3,…,p-1}。由于 p 是质数,<br>我们可以定义散列函数<br>$h(a, b, k) = ((a*k + b) \\mod p) \\mod m$<br>其中a属于Zp,b属于Zp’。由所有这样的a和b构成的散列函数,组成了函数簇,即全域散列。<br>v.明白这个散列函数的选取是在“执行开始”随机的选取一个是很重要的,要不然就会不明白到时候怎么进行查找。这里所谓的随机性应该这样理解:对于某一个散列表来说,它在初始化时已经把a,b固定了,但是对于一个还未初始化的全域散列表来说,a,b是随机选取的。</p>\n</blockquote>\n</li>\n</ol>\n</blockquote>\n<ol>\n<li>开放寻址法:所有的元素都放在散列表里<blockquote>\n<ul>\n<li>开放寻址法的好处就在于它根本不用指针,而是计算出要存取的各个pos。这样一来,由于不用存储指针就节省了空间,从而可以用同样的空间来提供更多的pos,其潜在的效果就是可以减少碰撞,提高查找速度。</li>\n<li>开放寻址法很像一个启发式的搜索,它的最坏性能也是 O(n),只不过散列函数为它提供了启发信息从而使得一般的平均性能会很好。</li>\n<li>在开放寻址法中,对散列元素的删除操作执行起来比较困难,因为删除操作会影响查找操作。解决办法是在pos里的值,被删除后置一个特定的值tag标记删除,而不是直接删除导致查找断开.</li>\n<li>探查法<br>线性探查、二次探查和双重散列都是对最基本的数组法的改进.<blockquote>\n<ol>\n<li>线性探查 linear probing<br>$$h(k,i) = (h’(k)+i) \\mod m$$<br>$$h’ = U \\mapsto [0, 1, \\ldots, m-1]$$</li>\n<li>二次探查 quadrating probing<br>$$h(k,i) = (h’(k) + c_1i+ c_2i^2) \\mod m$$</li>\n<li>双重探查<br>双重散列是用于开放寻址的最好方法之一,因为它所产生的排列具有随机选择的排列的许多特性.<br>$$h(k,i) = (h_1(k) + ih_2(k)) \\mod m$$</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<ol>\n<li>完全散列:<blockquote>\n<p>如果某一种散列技术在进行查找时,其最坏情况内存访问次数为$O(1)$的话,则称其为完全散列。书上使用了一种两级的散列方案,每一级都采用全域散列.通常利用一种两级的散列方案,每一级上都采用全域散列.<br>完全散列的关键在于:二次散列表中要求没有碰撞.这是通过确保槽的个数是关键字的个数的平方来实现的。</p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"Chapter12-如何用树结构实现动态集合\"><a href=\"#Chapter12-如何用树结构实现动态集合\" class=\"headerlink\" title=\"Chapter12 如何用树结构实现动态集合?\"></a>Chapter12 如何用树结构实现动态集合?</h4><ol>\n<li>二叉查找树 binary search tree<blockquote>\n<ul>\n<li>define:<br>$$key[left[x]] \\leq key[x] \\bigcup key[right[x]] \\geq key[x]$$</li>\n<li>method<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div></pre></td><td class=\"code\"><pre><div class=\"line\">inorder-walk(x): $O(n)$</div><div class=\"line\">  if x != NULL</div><div class=\"line\">    then inorder-walk(left[x])</div><div class=\"line\">      visit key[x]</div><div class=\"line\">      inorder-walk[right[x]]</div><div class=\"line\"></div><div class=\"line\">search(x, k): $O(h)$</div><div class=\"line\">  if x = NULL or k = key[x]</div><div class=\"line\">    then return x</div><div class=\"line\">  if k &lt; key[x]</div><div class=\"line\">    then return search(left[x], k)</div><div class=\"line\">    else return search(right[x], k)</div><div class=\"line\"></div><div class=\"line\">minimum(x): $O(h)$</div><div class=\"line\">  while left[x] != NULL</div><div class=\"line\">    do x &lt;- left[x]</div><div class=\"line\">  return x</div><div class=\"line\"></div><div class=\"line\">maximum(x): $O(h)$</div><div class=\"line\">  while right[x] != NULL</div><div class=\"line\">    do x &lt;- right[x]</div><div class=\"line\">  return x</div><div class=\"line\"></div><div class=\"line\">successor(x): $O(h)$, 中序后继</div><div class=\"line\">  if right[x] != NULL</div><div class=\"line\">    then return minimum(right[x])</div><div class=\"line\">  y &lt;- p[x]</div><div class=\"line\">  while y != NULL and x = right[y]</div><div class=\"line\">    do x &lt;- y</div><div class=\"line\">      y &lt;- p[y]</div><div class=\"line\">  return y</div><div class=\"line\"></div><div class=\"line\">predecessor(x): $O(h)$ 中序前驱</div><div class=\"line\">  if left[x] != NULL</div><div class=\"line\">    then return maxinum(left[x])</div><div class=\"line\">  y &lt; p[x]</div><div class=\"line\">  while y != NUll and x = left[y]</div><div class=\"line\">    do x &lt;- y</div><div class=\"line\">      y &lt;- p[y]</div><div class=\"line\">  return y</div><div class=\"line\"></div><div class=\"line\">insert(T, k): $O(h)$</div><div class=\"line\">  y &lt;- NUll</div><div class=\"line\">  x &lt;- root[T]</div><div class=\"line\">  while x != NUll</div><div class=\"line\">    do y &lt;- x</div><div class=\"line\">      if key[k] &lt; key[x]</div><div class=\"line\">        then x &lt;- left[x]</div><div class=\"line\">        else x &lt;- right[x]</div><div class=\"line\">  p[x] &lt;- u</div><div class=\"line\">  if y = NUll</div><div class=\"line\">    then root[T] &lt;- x #tree T is empty</div><div class=\"line\">    else if key[k] &lt; key[y]</div><div class=\"line\">      then left[y] &lt;- k</div><div class=\"line\">      else right[y] &lt;- k</div><div class=\"line\"></div><div class=\"line\">delete(T, k): $O(h)$</div><div class=\"line\">  if left[k] = NUll or right[k] = NUll</div><div class=\"line\">    then y &lt;- k</div><div class=\"line\">    else y &lt;- successor(k)</div><div class=\"line\">  if left[y] != NUll</div><div class=\"line\">    then x &lt;- left[y]</div><div class=\"line\">    else x &lt;- right[y]</div><div class=\"line\">  if x != NUll</div><div class=\"line\">    then p[x] &lt;- p[y]</div><div class=\"line\">  if p[y] = NUll</div><div class=\"line\">    then root[T] &lt;- x</div><div class=\"line\">    else if y = left[p[y]]</div><div class=\"line\">      then left[p[y]] &lt;- x</div><div class=\"line\">      else right[p[y]] &lt;- de</div><div class=\"line\">  if y != k</div><div class=\"line\">    then key[k] &lt;- key[y]</div><div class=\"line\">      copy y&apos;s satellite date into k</div><div class=\"line\">  return y</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<blockquote>\n<p>BST的删除情况较复杂, 有难度的地方就是在删除同时存在左右子树的结点时需要进行处理.理解后可以概括为:对于这样的结点 x,找到 x 结点的前趋(或后继)y,将 x 的值替换为 y 的值,然后递归删除 y 结点就可以了。因为 y 一定没有右子树(后继对应没有左子树),所以递归删除的时候就是很简单的情况了。</p>\n</blockquote>\n<h4 id=\"Chapter13-如何降低树高-提高二叉树的操作效率\"><a href=\"#Chapter13-如何降低树高-提高二叉树的操作效率\" class=\"headerlink\" title=\"Chapter13 如何降低树高,提高二叉树的操作效率?\"></a>Chapter13 如何降低树高,提高二叉树的操作效率?</h4><p>从12章可以看到, BST的性能与树高直接相关.如果BST是单支树,则效率会降到$O(n)$, 如果树较为均匀平衡, 则效率提升到$O(\\log n)$.红黑树即是一种自平衡的二叉查找树, 具有很好的时间性能.</p>\n<blockquote>\n<ul>\n<li>define<blockquote>\n<ul>\n<li>node: color, key, left, right, p</li>\n<li>性质:<blockquote>\n<ol>\n<li>每个结点或是红色,或是是黑色。</li>\n<li>根结点是黑的。</li>\n<li>所有的叶结点(NULL)是黑色的。(NULL 被视为一个哨兵结点,所有应该指向 NULL 的指针,都看成指向了 NULL 结点。)</li>\n<li>如果一个结点是红色的,则它的两个儿子节点都是黑色的。</li>\n<li>对每个结点,从该结点到其子孙结点的所有路径上包含相同数目的黑结点。</li>\n<li>黑高度的定义: 从某个结点出发(不包括该结点)到达一个叶结点的任意一条路径上,黑色结点的个数成为该结点x的黑高度.红黑树的黑高度定义为其根结点的黑高度.</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n</li>\n<li><p>哨兵 nil[T] 代表所有的空节点, 其color=black</p>\n</li>\n<li><p>性能:<br>红黑树是一种近似平衡的二叉树),它能保证在最坏的情况下,基本的动态集合操作的时间为 O(lgn)。通过对任何一条从根到叶子的路径上各个结点着色方式的限制,红黑树确保没有一条路径会比其它路径长出两倍,因而是接近平衡的。<br>注:全黑结点的满二叉树也满足红黑树的定义。满二叉树的效率本身就非常高,它是效率最好的二叉树之一.</p>\n</li>\n<li><p>method</p>\n<blockquote>\n<ul>\n<li>旋转操作(左旋和右旋):<br>旋转操作是一种能保持二叉查找树性质的查找树局部操作。<br>所有对红黑树结构的修改都只能通过左右旋来完成,这样才能保证修改后的红黑树首先是一棵二叉查找树。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">left-rotate(T, x)</div><div class=\"line\">  y &lt;- right[x]</div><div class=\"line\">  right[x] &lt;- left[y]</div><div class=\"line\">  p[left[y]] &lt;- x</div><div class=\"line\">  p[y] &lt;- p[x]</div><div class=\"line\">  if p[x] = nil[T]</div><div class=\"line\">    then root[t] &lt;- y</div><div class=\"line\">    else if x = left[p[x]]</div><div class=\"line\">      then ledt[p[x]] &lt;- y</div><div class=\"line\">      else right[p[x]] &lt;- y</div><div class=\"line\">  left[y] &lt;- y</div><div class=\"line\">  p[x] &lt;- y</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li><p>插入操作:<br>将结点Z插入树T中,就好像T是一棵普通的二叉查找树一样,然后将Z着为红色。为保证红黑性质能继续保持,我们调用一个辅助程序来对结点重新着色并旋转。插入结点Z的位置的确应该和普通二叉查找树一样,因为红黑树本身就首先是一棵二叉查找树;然后将Z着为红色,是为了保证性质5的正确性,因为性质5如果被破坏了是最难以恢复的;到这里,有可能被破坏的性质就只剩下性质2和性质4了,这都可以通过后来的辅助程序进行修复的。<br>插入操作可能破坏的性质:<br>i. 性质2:当被一棵空树进行插入操作时发生;<br>ii. 性质4:当新结点被插入到红色结点之后时发生;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">insert(T, k)</div><div class=\"line\">  y &lt;- nil[T]</div><div class=\"line\">  x &lt;- root[T]</div><div class=\"line\">  while x != nil[T]</div><div class=\"line\">    do y &lt;- x</div><div class=\"line\">      if key[k] &lt; key[x]</div><div class=\"line\">        then x &lt;- left[x]</div><div class=\"line\">        else x &lt;- right[x]</div><div class=\"line\">  p[x] &lt;- y</div><div class=\"line\">  if y = nil[T]</div><div class=\"line\">    then root[T] &lt;- k</div><div class=\"line\">    else if key[k] &lt; key[y]</div><div class=\"line\">      then left[y] &lt;- k</div><div class=\"line\">      else right[y] &lt;- k</div><div class=\"line\">  left[k] &lt;- nil[T]</div><div class=\"line\">  right[k] &lt;- nil[T]</div><div class=\"line\">  color[k] &lt;- red</div><div class=\"line\">  insert-fixup(T, k)</div></pre></td></tr></table></figure>\n</li>\n<li><p>删除操作:<br>和插入操作一样,先用BST的删除结点操作,然后调用相应的辅助函数做相应的调整。<br>首先只有被删除的结点为黑结点时才需要进行调整,理由如下:<br>i. 树中各结点的黑高度都没有变化<br>ii. 不存在两个相邻的红色结点<br>iii. 因为如果被删除的点是红色,就不可能是根,所以根仍然是黑色的<br>当被删除了黑结点之后,红黑树的性质5被破坏,上面说过了性质5被破坏后的修复难度是最大的。所以这里的修复过程使用了一个很新的思想,即视为被删除的结点的子结点有额外的一种黑色,当这一重额外的黑色存在之后,性质5就得到了继续。然后再通过转移的方法逐步把这一重额外的黑色逐渐向上转移直到根或者红色的结点,最后消除这一重额外的黑色。<br>删除操作中可能被破坏的性质:<br>i. 性质2:当y是根时,且 y 的一个孩子是红色,若此时这个孩子成为根结点;<br>ii. 性质4:当x和p[y]都是红色时;<br>iii.性质5:包含y的路径中,黑高度都减少了;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">delete(T, k)</div><div class=\"line\">  if left[k] = nil[T] or right[k] = nil[T]</div><div class=\"line\">    then y &lt;- k</div><div class=\"line\">    else y &lt;- successor(k)</div><div class=\"line\">  if left[y] != nil[T]</div><div class=\"line\">    then x &lt;- left[y]</div><div class=\"line\">    else x &lt;- right[y]</div><div class=\"line\">  p[x] &lt;- p[y]</div><div class=\"line\">    then root[T] &lt;- x</div><div class=\"line\">    else if y = left[p[y]]</div><div class=\"line\">      then left[p[y]] &lt;- x</div><div class=\"line\">      else right[p[y]] &lt;- x</div><div class=\"line\">  if y != k</div><div class=\"line\">    then key[k] &lt;- key[y]</div><div class=\"line\">      copy y&apos;s satelite date into z</div><div class=\"line\">  if color[y] = black</div><div class=\"line\">    then delete-fixup(T, x)</div><div class=\"line\">  return y</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li>红黑树是真正的在实际中得到大量应用的复杂数据结构:C++STL中的关联容器 map,set都是红黑树的应用(所以标准库容器的效率太好了,;Linux 内核中的用户态地址空间管理也使用了红黑树。</li>\n</ul>\n</blockquote>\n<h4 id=\"Chapter14-数据规模扩大后-如何扩展数据结构\"><a href=\"#Chapter14-数据规模扩大后-如何扩展数据结构\" class=\"headerlink\" title=\"Chapter14 数据规模扩大后,如何扩展数据结构?\"></a>Chapter14 数据规模扩大后,如何扩展数据结构?</h4><blockquote>\n<ol>\n<li>实际的工程中,极少会去创造新的数据结构,通常是对标准的数据结构附加一些信息,并添加一些新的操作以支持应用的要求。</li>\n<li>动态顺序统计(Dynamic order statistics)<br>关于顺序统计这个问题，在中位数和顺序统计量介绍了在O(n)时间内获取一组数据中第i小的数据。在算导第十四章介绍了另外一种方式来求第i小的数据，它的算法复杂度为$O(\\log n)$，但却要依赖于另外一种数据结构顺序统计树(order statistic tree)。<br>顺序统计树，是从红黑树扩展而来。相较于红黑树，一个顺序统计树的结点x，比一个红黑树的结点要多拥有一个字段size.size为以x为根结点的子树所包含的所有结点的数目(也包括x本身)。可以得出一条结论：<br>$$x.size=x.left.size+x.right.size+1$$<br>在一棵顺序统计树中，可以很轻便的求该树中第 i小的结点：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">OS-SELECT(x, i)</div><div class=\"line\">    r = x.left.size + i</div><div class=\"line\">    if i == r</div><div class=\"line\">        return x</div><div class=\"line\">    else if i &lt; r</div><div class=\"line\">        return OS-SELECT(x.left, i)</div><div class=\"line\">    else</div><div class=\"line\">        return OS-SELECT(x.right, i - r)</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>如上面的伪码所示，先求出 x 结点的排位r,因x不小于其左子树的所有结点，<br>所以r = x.left.size + 1。<br>若r等于i自不必说。若r大于i，说明所找的数，排在x之前，应从排在x之前的数中找第i小的数。即，从x的左子树中找第i小的数。若r小于i，则应该在比r大的数中找第i-r小的数，即在x的右子树中找第i-r小的数。同样也可以在O(lg n)的时间内求得指定结点的排位:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">OS-RANK(T, x)</div><div class=\"line\">    r = x.left.size + 1</div><div class=\"line\">    y = x</div><div class=\"line\">    while y != T.root</div><div class=\"line\">        if y == y.p.right</div><div class=\"line\">            r = r+ y.p.left.size + 1</div><div class=\"line\">        y = y.p</div><div class=\"line\">    return r</div></pre></td></tr></table></figure></p>\n<p>因为size记录的是以当前结点为根结点的子树所包含的所有结点的数目(也包括当前节点本身)，所以左侧伪码通过统计从x到根结点这条路径中本身为右孩子的结点本身以及它们的的左孩子的size来求得x的排位。<br>顺序统计树以红黑树为基础进行扩展,所以红黑树的原有操作我们都可以继承下来。但是它增加了一个字段size,对于红黑树的删除和插入操作，我们不得不进</p>\n<ol>\n<li>数据结构的扩张:指在实际应用数据结构时对标准的数据结构中增加一些信息、编入一些新的操作等等。附加的信息必须能够为该数据结构上的常规操作所更新和维护。</li>\n<li>对一种数据结构的扩张过程可以分为四个步骤:<blockquote>\n<ol>\n<li>选择基础的数据结构</li>\n<li>确定要在基础数据结构中添加哪些信息</li>\n<li>验证可用基础数据结构上的基本修改操作来维护这些新添加的信息</li>\n<li>设计新的操作</li>\n</ol>\n</blockquote>\n</li>\n<li>红黑树的扩张定理:当结点中新添加的信息可以由该结点和它的左右子树来决定,那么就可以在不影响时间复杂度的前提下在插入和删除等操作中对红黑树的这些附加信息进行维护。</li>\n</ol>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"＜Introduction-to-algorithms＞笔记\"><a href=\"#＜Introduction-to-algorithms＞笔记\" class=\"headerlink\" title=\"＜Introduction to algorithms＞笔记\"></a>＜Introduction to algorithms＞笔记</h1><h3 id=\"Part3-数据结构\"><a href=\"#Part3-数据结构\" class=\"headerlink\" title=\"Part3: 数据结构\"></a>Part3: 数据结构</h3><blockquote>\n<ol>\n<li>动态集合:随着时间改变而变化</li>\n<li>关键字(keyword) -&gt; 全序集(排序)</li>\n<li>基本操作<blockquote>\n<ul>\n<li><code>search(S, k)</code></li>\n<li><code>insert(S, x)</code></li>\n<li><code>delete(S, x)</code></li>\n<li><code>maximum/minimum(S)</code></li>\n<li><code>successor/predecessor(S, x)</code></li>\n</ul>\n</blockquote>\n</li>\n</ol>\n</blockquote>","more":"<h4 id=\"Chapter10-基本数据结构实现动态集合\"><a href=\"#Chapter10-基本数据结构实现动态集合\" class=\"headerlink\" title=\"Chapter10 基本数据结构实现动态集合?\"></a>Chapter10 基本数据结构实现动态集合?</h4><ol>\n<li>stack<blockquote>\n<ul>\n<li>LIFO: 后进先出</li>\n<li>data<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Sequence S; #可由数组或链表实现</div><div class=\"line\">int top;</div></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<blockquote>\n<ul>\n<li><p>method</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">stack-empty(S): O(1)</div><div class=\"line\">  if top[S] = 0</div><div class=\"line\">    then return true</div><div class=\"line\">    else return false</div><div class=\"line\"></div><div class=\"line\">push(S, x): O(1)</div><div class=\"line\">  top[S] &lt;- top[S] + 1</div><div class=\"line\">  S[top[S]] &lt;- x</div><div class=\"line\"></div><div class=\"line\">pop(S): O(1)</div><div class=\"line\">   if stack-empty(S)</div><div class=\"line\">    then error &quot;underflow&quot;</div><div class=\"line\">    else top[S] &lt;- top[S] - 1</div><div class=\"line\">      return S[top[S] + 1]</div><div class=\"line\"></div><div class=\"line\">#若考虑实现stack的底层数据结构是静态的, 即栈容量有限,可能会上溢</div><div class=\"line\">stack-full(S): O(1)</div><div class=\"line\"> if top[S] == size(S)</div><div class=\"line\">    then return true</div><div class=\"line\">    else return false</div></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li><p>apply:</p>\n<blockquote>\n<p>函数调用-递归<br>括号匹配与表达式求值</p>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n<ol>\n<li>queue<br>在第6章排序中由heap实现了priority_queue, 是特殊一类queue:在queue上实现了优先级.基本的queue:<blockquote>\n<ul>\n<li>FIFO: 先进先出</li>\n<li>data:<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">Sequence S;</div><div class=\"line\">int head, tail;</div><div class=\"line\">int length;</div></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<blockquote>\n<ul>\n<li><p>method</p>\n<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">enqueue(Q, x): O(1)</div><div class=\"line\">  Q[tail[Q]] &lt;- x</div><div class=\"line\">  if tail[Q] = length[Q]</div><div class=\"line\">    then tail[Q] &lt;- 1</div><div class=\"line\">    else tail[Q] &lt;- tail[Q] + 1</div><div class=\"line\"></div><div class=\"line\">dequeue(Q): O(1)</div><div class=\"line\">  x &lt;- Q[head[Q]]</div><div class=\"line\">  if head[Q] = length[Q]</div><div class=\"line\">    then head[Q] &lt;- 1</div><div class=\"line\">    else head[Q] &lt;- head[Q] + 1</div><div class=\"line\">  return x</div><div class=\"line\">&gt;&gt;</div></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li><p>apply:</p>\n<blockquote>\n<ul>\n<li>FIFO算法; 先来先服务</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<ul>\n<li>层次算法: 层次遍历, BFS</li>\n</ul>\n</blockquote>\n<ol>\n<li>linkedlist<br>与数组的线性序是由下标决定(连续储存, 随机访问)不同, 链表的顺序由指针确定(易动态扩充)<blockquote>\n<ul>\n<li>data:<blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Datatype data</div><div class=\"line\">pointer next, prev</div></pre></td></tr></table></figure>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<blockquote>\n<ul>\n<li><p>method:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">search(L, k): O(n)</div><div class=\"line\">  x &lt;- head[L]</div><div class=\"line\">  while x  != NULL and key[x] != k</div><div class=\"line\">    do x &lt;- next[x]</div><div class=\"line\">  return x</div><div class=\"line\"></div><div class=\"line\">insert(L, x): O(1) 头插法</div><div class=\"line\">  next[x] &lt;- head[L]</div><div class=\"line\">  if head[L] != NULL</div><div class=\"line\">    then prev[head[L]] &lt;- x</div><div class=\"line\">  head[L] &lt;- x</div><div class=\"line\">  prev[x] &lt;- NULL</div><div class=\"line\"></div><div class=\"line\">delete(L, x): x is pointer, O(1); x is key, O(n)</div><div class=\"line\">  if prev[x] != NULL</div><div class=\"line\">    then next[prev[x]] &lt;- next[x]</div><div class=\"line\">    else head[L] &lt;- next[x]</div><div class=\"line\">  if next[x] != NULL</div><div class=\"line\">    then prev[next[x]] &lt;- prev[x]</div></pre></td></tr></table></figure>\n</li>\n<li><p>techique: 哨兵(sentinel)</p>\n<blockquote>\n<ul>\n<li>简化了边界条件, 代码实现更简洁,紧凑<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">search(L, k)</div><div class=\"line\">  x &lt;- next[nil[L]]</div><div class=\"line\">  while x != nil[L] and key[x] != k</div><div class=\"line\">    do x &lt;- next[x]</div><div class=\"line\">  return x</div><div class=\"line\"></div><div class=\"line\">insert(L, x)</div><div class=\"line\">  next[x] &lt;- next[nil[L]]</div><div class=\"line\">  prev[next[nil[L]]] &lt;- x</div><div class=\"line\">  next[nil[L]] &lt;- x</div><div class=\"line\">  prev[x] &lt;- nil[L]</div><div class=\"line\"></div><div class=\"line\">delete(L, x)</div><div class=\"line\">  next[prev[x]] &lt;- next[x]</div><div class=\"line\">  prev[next[x]] &lt;- prev[x]</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n</li>\n<li><p>apply:<br>数组和链表作为两种基本的线性结构, 两者实现的功能基本相同, 但各有优劣:数组由下标实现随机访问, 可以实现二分,快排等高效算法, 但容量受限,动态增删复杂度高;链表只能线性遍历, 查找排序效率低, 但由于指针特性,易于动态增删, 常用于管理动态的内容.</p>\n</li>\n</ul>\n</blockquote>\n<ol>\n<li><p>静态数组和分配释放<br>在某些编程语言(如fortran)中没有指针的概念, 可以添加2个域储存prev, next对象的下标,模拟指针的功能.<br>另外,动态增删元素时要向内存申请或释放内存, 一种机制是添加tag, 但最后销毁整个数据结构时处理, 一种则是C中的malloc/free机制,实现内存的分配和回收.</p>\n</li>\n<li><p>有根树<br>将前驱后置的思想推广到任意同构的数据结构上, 自然导出了链接实现的树结构上, 这节只讨论树的基本结构:</p>\n<blockquote>\n<ul>\n<li>binary tree<blockquote>\n<ul>\n<li>node:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">data</div><div class=\"line\">pointer left, right</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<blockquote>\n<blockquote>\n<ul>\n<li>multi tree</li>\n<li>node:<blockquote>\n<ul>\n<li>data:</li>\n<li>pointer left-child, right-sibling #左孩子右兄弟表示法</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n</blockquote>\n<h4 id=\"Chapter10-如何实现映射关系的数据结构\"><a href=\"#Chapter10-如何实现映射关系的数据结构\" class=\"headerlink\" title=\"Chapter10 如何实现映射关系的数据结构?\"></a>Chapter10 如何实现映射关系的数据结构?</h4><ol>\n<li>hash table: key -&gt;(mapto) identifier<blockquote>\n<p>　在散列表中查找一个元素的时间与在链表中查找一个元素的时候相同,在最坏情况为 $O(n)$,但期望时间为 $O(1)$.在实践中,散列表的效率是很高的,一般可认为是$O(1)$, 基本的字典操作只需要$O(1)$的平均时间.<br>当待排序的关键字集合是静态的(即当关键字集合一旦存入后不再改变),”完全散列”能够在$O(1)$的最坏情况时间内支持关键字查找。当待排序的关键字的集合是静态的(即当关键字集合一旦存入后不需要再改变),“完全散列”能够在 O(1)的最坏时间内支持查找操作。</p>\n</blockquote>\n</li>\n</ol>\n<p>２. 散列方法</p>\n<blockquote>\n<ol>\n<li><p>直接寻址<br>适用于关键字个数小于可能的关键字总数(一般是表长)<br>但如果关键字的全集U很大,但实际关键字集合k很小, 则会造成大量空间的浪费.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">search(T, k)</div><div class=\"line\">  return T[k]</div><div class=\"line\"></div><div class=\"line\">insert(T, x)</div><div class=\"line\">  T[key[x]] &lt;- x</div><div class=\"line\"></div><div class=\"line\">delete(T, x)</div><div class=\"line\">  T[key[x]] &lt;- NULL</div></pre></td></tr></table></figure>\n</li>\n<li><p>散列表<br>关键字集合k映射到长为m的散列表T上,即:<br>\\begin{align}<br>hash-func: h: U -&gt; {0, 1, \\ldots ,m-1} \\\\<br>即 k \\mapsto h(k)<br>\\end{align}<br>问题: 碰撞(collision)two key -&gt; one position<br>解决碰撞的方法:</p>\n<blockquote>\n<ol>\n<li>好的hash-func, 尽可能减少碰撞</li>\n<li>链接法(chaining): 散列到同一位置的存入链表中<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">search(T, x): O(1)</div><div class=\"line\">  search for an element with key in list T[h(k)]</div><div class=\"line\"></div><div class=\"line\">insert(T, x): O(1)</div><div class=\"line\">  insert x at the head of list T[h(key[x])]</div><div class=\"line\"></div><div class=\"line\">delete(T, x): O(1)</div><div class=\"line\">  delete x from the list T[h(key[x])]</div></pre></td></tr></table></figure>\n</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n</blockquote>\n<p>在众多的简单的解决碰撞的方法中,我觉得比较好的是通过链表法解决碰撞,虽然这个方法的理论最坏效率为 O(n),但是在平均情况下,它的性能也是非常好的,实现简单又高效。</p>\n<ol>\n<li>hash-func<blockquote>\n<ol>\n<li>好的hash-func<br>\\begin{align}<br>对random \\, k \\, 0 \\leq k &lt; 1,\\\\<br>h(k) = \\lfloor km \\rfloor<br>\\end{align}</li>\n</ol>\n</blockquote>\n</li>\n</ol>\n<blockquote>\n<ol>\n<li>多数的散列函数都假定关键字域为自然数集$N$,如果所给关键字不是自然数,则必须有一种方法来将它们解释为自然数。<blockquote>\n<p>a. 除法散列法:<br>一般选取 m 的值为与2的整数幂不大接近的质数<br>$$h(k) = k\\mod m$$<br>b. 乘法散列法:<br>构造散列函数的乘法方法包含两个步骤:首先用关键字剩上常数 A(0&lt;A&lt;1),并抽取 kA 的小数部分;然后用m剩以这个值,再取结果的底。<br>$$h(k) = \\lfloor m(kA \\mod 1) \\rfloor$$<br>c.全域散列:全域散列的基本思想是在执行开始时,就从一族仔细设计的函数中,随机地选择一个作为散列函数。<br>i. 全域散列表是一种使用“链接法”来解决碰撞问题的散列表方法。<br>ii. 随机化保证了对于任何输入,算法都具有较好的平均性能。<br>iii. 全域的散列函数组:设$H$为一组散列函数,它将给定的关键字域$U$映射到{0,1,…,m-1}中,这样的一个函数组称为是全域的.如果从$H$中随机地选择一个散列函数,当关键字K≠J时,两者发生碰撞的概率不大于1/m。<br>iv.常用的一个全域散列函数类:<br>首先选择一个足够大的质数p,使得每一个可能的关键字k都落到0到p-1的范围内,包括首尾的0和p-1.这里我们假设全域是0–15, p为17。设集合Zp {0, 1, 2, ,…,p-1},集合Zp’为{1, 2, 3,…,p-1}。由于 p 是质数,<br>我们可以定义散列函数<br>$h(a, b, k) = ((a*k + b) \\mod p) \\mod m$<br>其中a属于Zp,b属于Zp’。由所有这样的a和b构成的散列函数,组成了函数簇,即全域散列。<br>v.明白这个散列函数的选取是在“执行开始”随机的选取一个是很重要的,要不然就会不明白到时候怎么进行查找。这里所谓的随机性应该这样理解:对于某一个散列表来说,它在初始化时已经把a,b固定了,但是对于一个还未初始化的全域散列表来说,a,b是随机选取的。</p>\n</blockquote>\n</li>\n</ol>\n</blockquote>\n<ol>\n<li>开放寻址法:所有的元素都放在散列表里<blockquote>\n<ul>\n<li>开放寻址法的好处就在于它根本不用指针,而是计算出要存取的各个pos。这样一来,由于不用存储指针就节省了空间,从而可以用同样的空间来提供更多的pos,其潜在的效果就是可以减少碰撞,提高查找速度。</li>\n<li>开放寻址法很像一个启发式的搜索,它的最坏性能也是 O(n),只不过散列函数为它提供了启发信息从而使得一般的平均性能会很好。</li>\n<li>在开放寻址法中,对散列元素的删除操作执行起来比较困难,因为删除操作会影响查找操作。解决办法是在pos里的值,被删除后置一个特定的值tag标记删除,而不是直接删除导致查找断开.</li>\n<li>探查法<br>线性探查、二次探查和双重散列都是对最基本的数组法的改进.<blockquote>\n<ol>\n<li>线性探查 linear probing<br>$$h(k,i) = (h’(k)+i) \\mod m$$<br>$$h’ = U \\mapsto [0, 1, \\ldots, m-1]$$</li>\n<li>二次探查 quadrating probing<br>$$h(k,i) = (h’(k) + c_1i+ c_2i^2) \\mod m$$</li>\n<li>双重探查<br>双重散列是用于开放寻址的最好方法之一,因为它所产生的排列具有随机选择的排列的许多特性.<br>$$h(k,i) = (h_1(k) + ih_2(k)) \\mod m$$</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<ol>\n<li>完全散列:<blockquote>\n<p>如果某一种散列技术在进行查找时,其最坏情况内存访问次数为$O(1)$的话,则称其为完全散列。书上使用了一种两级的散列方案,每一级都采用全域散列.通常利用一种两级的散列方案,每一级上都采用全域散列.<br>完全散列的关键在于:二次散列表中要求没有碰撞.这是通过确保槽的个数是关键字的个数的平方来实现的。</p>\n</blockquote>\n</li>\n</ol>\n<h4 id=\"Chapter12-如何用树结构实现动态集合\"><a href=\"#Chapter12-如何用树结构实现动态集合\" class=\"headerlink\" title=\"Chapter12 如何用树结构实现动态集合?\"></a>Chapter12 如何用树结构实现动态集合?</h4><ol>\n<li>二叉查找树 binary search tree<blockquote>\n<ul>\n<li>define:<br>$$key[left[x]] \\leq key[x] \\bigcup key[right[x]] \\geq key[x]$$</li>\n<li>method<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div></pre></td><td class=\"code\"><pre><div class=\"line\">inorder-walk(x): $O(n)$</div><div class=\"line\">  if x != NULL</div><div class=\"line\">    then inorder-walk(left[x])</div><div class=\"line\">      visit key[x]</div><div class=\"line\">      inorder-walk[right[x]]</div><div class=\"line\"></div><div class=\"line\">search(x, k): $O(h)$</div><div class=\"line\">  if x = NULL or k = key[x]</div><div class=\"line\">    then return x</div><div class=\"line\">  if k &lt; key[x]</div><div class=\"line\">    then return search(left[x], k)</div><div class=\"line\">    else return search(right[x], k)</div><div class=\"line\"></div><div class=\"line\">minimum(x): $O(h)$</div><div class=\"line\">  while left[x] != NULL</div><div class=\"line\">    do x &lt;- left[x]</div><div class=\"line\">  return x</div><div class=\"line\"></div><div class=\"line\">maximum(x): $O(h)$</div><div class=\"line\">  while right[x] != NULL</div><div class=\"line\">    do x &lt;- right[x]</div><div class=\"line\">  return x</div><div class=\"line\"></div><div class=\"line\">successor(x): $O(h)$, 中序后继</div><div class=\"line\">  if right[x] != NULL</div><div class=\"line\">    then return minimum(right[x])</div><div class=\"line\">  y &lt;- p[x]</div><div class=\"line\">  while y != NULL and x = right[y]</div><div class=\"line\">    do x &lt;- y</div><div class=\"line\">      y &lt;- p[y]</div><div class=\"line\">  return y</div><div class=\"line\"></div><div class=\"line\">predecessor(x): $O(h)$ 中序前驱</div><div class=\"line\">  if left[x] != NULL</div><div class=\"line\">    then return maxinum(left[x])</div><div class=\"line\">  y &lt; p[x]</div><div class=\"line\">  while y != NUll and x = left[y]</div><div class=\"line\">    do x &lt;- y</div><div class=\"line\">      y &lt;- p[y]</div><div class=\"line\">  return y</div><div class=\"line\"></div><div class=\"line\">insert(T, k): $O(h)$</div><div class=\"line\">  y &lt;- NUll</div><div class=\"line\">  x &lt;- root[T]</div><div class=\"line\">  while x != NUll</div><div class=\"line\">    do y &lt;- x</div><div class=\"line\">      if key[k] &lt; key[x]</div><div class=\"line\">        then x &lt;- left[x]</div><div class=\"line\">        else x &lt;- right[x]</div><div class=\"line\">  p[x] &lt;- u</div><div class=\"line\">  if y = NUll</div><div class=\"line\">    then root[T] &lt;- x #tree T is empty</div><div class=\"line\">    else if key[k] &lt; key[y]</div><div class=\"line\">      then left[y] &lt;- k</div><div class=\"line\">      else right[y] &lt;- k</div><div class=\"line\"></div><div class=\"line\">delete(T, k): $O(h)$</div><div class=\"line\">  if left[k] = NUll or right[k] = NUll</div><div class=\"line\">    then y &lt;- k</div><div class=\"line\">    else y &lt;- successor(k)</div><div class=\"line\">  if left[y] != NUll</div><div class=\"line\">    then x &lt;- left[y]</div><div class=\"line\">    else x &lt;- right[y]</div><div class=\"line\">  if x != NUll</div><div class=\"line\">    then p[x] &lt;- p[y]</div><div class=\"line\">  if p[y] = NUll</div><div class=\"line\">    then root[T] &lt;- x</div><div class=\"line\">    else if y = left[p[y]]</div><div class=\"line\">      then left[p[y]] &lt;- x</div><div class=\"line\">      else right[p[y]] &lt;- de</div><div class=\"line\">  if y != k</div><div class=\"line\">    then key[k] &lt;- key[y]</div><div class=\"line\">      copy y&apos;s satellite date into k</div><div class=\"line\">  return y</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n</li>\n</ol>\n<blockquote>\n<p>BST的删除情况较复杂, 有难度的地方就是在删除同时存在左右子树的结点时需要进行处理.理解后可以概括为:对于这样的结点 x,找到 x 结点的前趋(或后继)y,将 x 的值替换为 y 的值,然后递归删除 y 结点就可以了。因为 y 一定没有右子树(后继对应没有左子树),所以递归删除的时候就是很简单的情况了。</p>\n</blockquote>\n<h4 id=\"Chapter13-如何降低树高-提高二叉树的操作效率\"><a href=\"#Chapter13-如何降低树高-提高二叉树的操作效率\" class=\"headerlink\" title=\"Chapter13 如何降低树高,提高二叉树的操作效率?\"></a>Chapter13 如何降低树高,提高二叉树的操作效率?</h4><p>从12章可以看到, BST的性能与树高直接相关.如果BST是单支树,则效率会降到$O(n)$, 如果树较为均匀平衡, 则效率提升到$O(\\log n)$.红黑树即是一种自平衡的二叉查找树, 具有很好的时间性能.</p>\n<blockquote>\n<ul>\n<li>define<blockquote>\n<ul>\n<li>node: color, key, left, right, p</li>\n<li>性质:<blockquote>\n<ol>\n<li>每个结点或是红色,或是是黑色。</li>\n<li>根结点是黑的。</li>\n<li>所有的叶结点(NULL)是黑色的。(NULL 被视为一个哨兵结点,所有应该指向 NULL 的指针,都看成指向了 NULL 结点。)</li>\n<li>如果一个结点是红色的,则它的两个儿子节点都是黑色的。</li>\n<li>对每个结点,从该结点到其子孙结点的所有路径上包含相同数目的黑结点。</li>\n<li>黑高度的定义: 从某个结点出发(不包括该结点)到达一个叶结点的任意一条路径上,黑色结点的个数成为该结点x的黑高度.红黑树的黑高度定义为其根结点的黑高度.</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n</blockquote>\n</li>\n<li><p>哨兵 nil[T] 代表所有的空节点, 其color=black</p>\n</li>\n<li><p>性能:<br>红黑树是一种近似平衡的二叉树),它能保证在最坏的情况下,基本的动态集合操作的时间为 O(lgn)。通过对任何一条从根到叶子的路径上各个结点着色方式的限制,红黑树确保没有一条路径会比其它路径长出两倍,因而是接近平衡的。<br>注:全黑结点的满二叉树也满足红黑树的定义。满二叉树的效率本身就非常高,它是效率最好的二叉树之一.</p>\n</li>\n<li><p>method</p>\n<blockquote>\n<ul>\n<li>旋转操作(左旋和右旋):<br>旋转操作是一种能保持二叉查找树性质的查找树局部操作。<br>所有对红黑树结构的修改都只能通过左右旋来完成,这样才能保证修改后的红黑树首先是一棵二叉查找树。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">left-rotate(T, x)</div><div class=\"line\">  y &lt;- right[x]</div><div class=\"line\">  right[x] &lt;- left[y]</div><div class=\"line\">  p[left[y]] &lt;- x</div><div class=\"line\">  p[y] &lt;- p[x]</div><div class=\"line\">  if p[x] = nil[T]</div><div class=\"line\">    then root[t] &lt;- y</div><div class=\"line\">    else if x = left[p[x]]</div><div class=\"line\">      then ledt[p[x]] &lt;- y</div><div class=\"line\">      else right[p[x]] &lt;- y</div><div class=\"line\">  left[y] &lt;- y</div><div class=\"line\">  p[x] &lt;- y</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<blockquote>\n<ul>\n<li><p>插入操作:<br>将结点Z插入树T中,就好像T是一棵普通的二叉查找树一样,然后将Z着为红色。为保证红黑性质能继续保持,我们调用一个辅助程序来对结点重新着色并旋转。插入结点Z的位置的确应该和普通二叉查找树一样,因为红黑树本身就首先是一棵二叉查找树;然后将Z着为红色,是为了保证性质5的正确性,因为性质5如果被破坏了是最难以恢复的;到这里,有可能被破坏的性质就只剩下性质2和性质4了,这都可以通过后来的辅助程序进行修复的。<br>插入操作可能破坏的性质:<br>i. 性质2:当被一棵空树进行插入操作时发生;<br>ii. 性质4:当新结点被插入到红色结点之后时发生;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">insert(T, k)</div><div class=\"line\">  y &lt;- nil[T]</div><div class=\"line\">  x &lt;- root[T]</div><div class=\"line\">  while x != nil[T]</div><div class=\"line\">    do y &lt;- x</div><div class=\"line\">      if key[k] &lt; key[x]</div><div class=\"line\">        then x &lt;- left[x]</div><div class=\"line\">        else x &lt;- right[x]</div><div class=\"line\">  p[x] &lt;- y</div><div class=\"line\">  if y = nil[T]</div><div class=\"line\">    then root[T] &lt;- k</div><div class=\"line\">    else if key[k] &lt; key[y]</div><div class=\"line\">      then left[y] &lt;- k</div><div class=\"line\">      else right[y] &lt;- k</div><div class=\"line\">  left[k] &lt;- nil[T]</div><div class=\"line\">  right[k] &lt;- nil[T]</div><div class=\"line\">  color[k] &lt;- red</div><div class=\"line\">  insert-fixup(T, k)</div></pre></td></tr></table></figure>\n</li>\n<li><p>删除操作:<br>和插入操作一样,先用BST的删除结点操作,然后调用相应的辅助函数做相应的调整。<br>首先只有被删除的结点为黑结点时才需要进行调整,理由如下:<br>i. 树中各结点的黑高度都没有变化<br>ii. 不存在两个相邻的红色结点<br>iii. 因为如果被删除的点是红色,就不可能是根,所以根仍然是黑色的<br>当被删除了黑结点之后,红黑树的性质5被破坏,上面说过了性质5被破坏后的修复难度是最大的。所以这里的修复过程使用了一个很新的思想,即视为被删除的结点的子结点有额外的一种黑色,当这一重额外的黑色存在之后,性质5就得到了继续。然后再通过转移的方法逐步把这一重额外的黑色逐渐向上转移直到根或者红色的结点,最后消除这一重额外的黑色。<br>删除操作中可能被破坏的性质:<br>i. 性质2:当y是根时,且 y 的一个孩子是红色,若此时这个孩子成为根结点;<br>ii. 性质4:当x和p[y]都是红色时;<br>iii.性质5:包含y的路径中,黑高度都减少了;</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">delete(T, k)</div><div class=\"line\">  if left[k] = nil[T] or right[k] = nil[T]</div><div class=\"line\">    then y &lt;- k</div><div class=\"line\">    else y &lt;- successor(k)</div><div class=\"line\">  if left[y] != nil[T]</div><div class=\"line\">    then x &lt;- left[y]</div><div class=\"line\">    else x &lt;- right[y]</div><div class=\"line\">  p[x] &lt;- p[y]</div><div class=\"line\">    then root[T] &lt;- x</div><div class=\"line\">    else if y = left[p[y]]</div><div class=\"line\">      then left[p[y]] &lt;- x</div><div class=\"line\">      else right[p[y]] &lt;- x</div><div class=\"line\">  if y != k</div><div class=\"line\">    then key[k] &lt;- key[y]</div><div class=\"line\">      copy y&apos;s satelite date into z</div><div class=\"line\">  if color[y] = black</div><div class=\"line\">    then delete-fixup(T, x)</div><div class=\"line\">  return y</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<ul>\n<li>红黑树是真正的在实际中得到大量应用的复杂数据结构:C++STL中的关联容器 map,set都是红黑树的应用(所以标准库容器的效率太好了,;Linux 内核中的用户态地址空间管理也使用了红黑树。</li>\n</ul>\n</blockquote>\n<h4 id=\"Chapter14-数据规模扩大后-如何扩展数据结构\"><a href=\"#Chapter14-数据规模扩大后-如何扩展数据结构\" class=\"headerlink\" title=\"Chapter14 数据规模扩大后,如何扩展数据结构?\"></a>Chapter14 数据规模扩大后,如何扩展数据结构?</h4><blockquote>\n<ol>\n<li>实际的工程中,极少会去创造新的数据结构,通常是对标准的数据结构附加一些信息,并添加一些新的操作以支持应用的要求。</li>\n<li>动态顺序统计(Dynamic order statistics)<br>关于顺序统计这个问题，在中位数和顺序统计量介绍了在O(n)时间内获取一组数据中第i小的数据。在算导第十四章介绍了另外一种方式来求第i小的数据，它的算法复杂度为$O(\\log n)$，但却要依赖于另外一种数据结构顺序统计树(order statistic tree)。<br>顺序统计树，是从红黑树扩展而来。相较于红黑树，一个顺序统计树的结点x，比一个红黑树的结点要多拥有一个字段size.size为以x为根结点的子树所包含的所有结点的数目(也包括x本身)。可以得出一条结论：<br>$$x.size=x.left.size+x.right.size+1$$<br>在一棵顺序统计树中，可以很轻便的求该树中第 i小的结点：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">OS-SELECT(x, i)</div><div class=\"line\">    r = x.left.size + i</div><div class=\"line\">    if i == r</div><div class=\"line\">        return x</div><div class=\"line\">    else if i &lt; r</div><div class=\"line\">        return OS-SELECT(x.left, i)</div><div class=\"line\">    else</div><div class=\"line\">        return OS-SELECT(x.right, i - r)</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>如上面的伪码所示，先求出 x 结点的排位r,因x不小于其左子树的所有结点，<br>所以r = x.left.size + 1。<br>若r等于i自不必说。若r大于i，说明所找的数，排在x之前，应从排在x之前的数中找第i小的数。即，从x的左子树中找第i小的数。若r小于i，则应该在比r大的数中找第i-r小的数，即在x的右子树中找第i-r小的数。同样也可以在O(lg n)的时间内求得指定结点的排位:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">OS-RANK(T, x)</div><div class=\"line\">    r = x.left.size + 1</div><div class=\"line\">    y = x</div><div class=\"line\">    while y != T.root</div><div class=\"line\">        if y == y.p.right</div><div class=\"line\">            r = r+ y.p.left.size + 1</div><div class=\"line\">        y = y.p</div><div class=\"line\">    return r</div></pre></td></tr></table></figure></p>\n<p>因为size记录的是以当前结点为根结点的子树所包含的所有结点的数目(也包括当前节点本身)，所以左侧伪码通过统计从x到根结点这条路径中本身为右孩子的结点本身以及它们的的左孩子的size来求得x的排位。<br>顺序统计树以红黑树为基础进行扩展,所以红黑树的原有操作我们都可以继承下来。但是它增加了一个字段size,对于红黑树的删除和插入操作，我们不得不进</p>\n<ol>\n<li>数据结构的扩张:指在实际应用数据结构时对标准的数据结构中增加一些信息、编入一些新的操作等等。附加的信息必须能够为该数据结构上的常规操作所更新和维护。</li>\n<li>对一种数据结构的扩张过程可以分为四个步骤:<blockquote>\n<ol>\n<li>选择基础的数据结构</li>\n<li>确定要在基础数据结构中添加哪些信息</li>\n<li>验证可用基础数据结构上的基本修改操作来维护这些新添加的信息</li>\n<li>设计新的操作</li>\n</ol>\n</blockquote>\n</li>\n<li>红黑树的扩张定理:当结点中新添加的信息可以由该结点和它的左右子树来决定,那么就可以在不影响时间复杂度的前提下在插入和删除等操作中对红黑树的这些附加信息进行维护。</li>\n</ol>\n</blockquote>"},{"title":"introduction to algorithms note3","date":"2017-04-21T16:00:00.000Z","_content":"\n# ＜Introduction to algorithms＞笔记\n\n### Part4 高级设计和分析技术\npart1-3中学习的普遍应用的算法思想和技术如下:\n* 分治法 divide and conquer\n* 随机化 randomize\n* 递归求解 recursion\n\n在面对一个计算问题时, 一般的直接解法是暴力破解,即穷举法.从一定意义上讲,所有的最优化问题都可以通过穷举法来解决,但是这在时间上是不可接受的.要更高效的求解问题, 需要学习对高效算法的设计分析技术\n所有的高效算法都是为了加快速度:\n1. 动态规划:保存子问题的解,以备重复使用\n2. 贪心算法:用局部最优解来求全局最优解\n3. 平摊分析是用来分析算法的工具,它本身并不是一种算法.\n\n* 动态规划 dynamic programming\n> * 动态规划通常应用于最优化问题,即要做出一组选择以达到一个最优解时.在做选择的同时,经常出现同样形式的子问题.关键技术是存储这些子问题每一个的解,以备它重复出现.\n\n* 贪心算法 greedy algorithm\n> * 贪心算法通常也是应用于最优化问题,该算法的思想是以局部最优的方式来做每一个选择.采用贪心算法可以比动态规划更快地得出一个最优解,但是关键是不容易判断贪心算法所得到的是否真的是最优解.\n\n* 平摊分析 amortized analysis\n> * 平摊分析是一种用来分析执行一系列类似操作的算法的工具.在一个操作序列中,不可能每一个都以其已知的最坏情况运行,某些操作的代价高些,而其它的低一些.平摊分析不分别计算每一次操作的代价确定一系列代价的界,而是对整个操作序列的真实代价限界.\n\n<!-- more -->\n#### Chapter15 如何利用已经计算出的子问题?\n\n1.动态规划与分治法之间的区别:\n* 分治法是指将问题分成一些独立的子问题,递归的求解各子问题,合并子问题得到原问题的解\n* 动态规划适用于这些子问题不是独立的情况,也就是各子问题包含公共子问题.\n对公共子问题,分治法会重复的求解,而动态规划则是只求解一次,保存结果到一张表中,从而避免了重复计算.\n\n以斐波那契数列的计算fib(5)为例\n- 分治法计算如下:\n```\nfib(n):\n  return fib(n-1) + fib(n-2)\nfib(5) = fib(4) + fib(3)\n       = (fib(3) + fib(2)) + (fib(2) + fib(1))\n       = ((fib(2) + fib(1)) + fib(2)) + (fib(2) + fib(1))\n```\n可以看到, fib(2)和fib(1)重复计算多次, 导致时间复杂度为$O(2^n)$\n- 动态规划计算如下\n```\narray Fib[];\nFib[1] = 1, Fib[2] = 1;\nfib(n):\n  if Fib(n) != 0\n    return Fib(n)\n    else return fib(n-1) + fib(n-2)\n```\n每次计算的结果记录在Fib(n)中, 如果计算过程中需要直接取出记录即可, 减少了很多重复计算, 算法复杂度降为$O(n)$\n\n2.**最优化问题**:\n具有多个可行的解, 每个解有一个值,具有最优(Max or Min)值的解是一个最优解.\n动态规划多用于最优化问题, 其设计可以分为 4 个步骤:\n> 1. 描述最优解的子结构\n> 2. 递归定义最优解的值\n> 3. 按自底向上的方法计算最优解的值\n> 4. 由计算出的结果反向构造出一个最优解\n> 动态规划最重要的是要找出最优解的子结构\n\n以解决**矩阵链式乘法**为例来梳理动态规划的步骤:\n> 1.问题背景:\n给定n个矩阵构成的序列链 $(A\\_1, A\\_2, \\ldots, A\\_n)$, 计算乘积:\n> $$A\\_1 A\\_2 \\ldots A\\_n \\qquad (15.1)$$\n> 要计算式(15.1), 考虑计算两个矩阵相乘的子程序`matrix-multiply(A, B)`\n```\nmatrix-multiply(A, B)\nif columns[A] != rows[B]\n  then error \"imcompatible dimensions\"\n  else for i <- 1 to rows[A]\n    do for j <- 1 to columns[B]\n      do C[i, j] <- 0\n        for k <- 1 to columns[A]\n          do C[i, j] <- C[i, j] + A[i, k] * B[k, j]\n```\n> 矩阵的乘积是按括号给出的计算顺序来计算的, 以矩阵链 $(A\\_1, A\\_2, A\\_3, A\\_4)$ 为例, 就有5种计算顺序:\n> \\begin{align}\n(A\\_1(A\\_2(A\\_3A\\_4))) \\\\\\\\\n(A\\_1((A\\_2A\\_3)A\\_4)) \\\\\\\\\n...\n\\end{align}\n> 以标量乘法次数来衡量复杂度, 从`matrix-multiply(A, B)`得到,\n> A阶数p*q, B阶数q*r -> 复杂度$O(pqr)$\n> 不同的括号顺序导致的矩阵乘积代价不同, 如何求解最小化的代价(即最少的标量乘法次数)的方案?\n\n> 2.问题求解\n如果穷举可能的全部括号方案,可以得到一个结果, 但显然代价太大.设P(n)为矩阵链的加括号方案数, 有:\n> $$\nP(N) =\n\\begin{cases}\n1, \\text {if n = 1} \\\\\\\\\n\\sum\\_{k=1}^{n=1}P(k)P(n-k),\\text {if n >= 2}\n\\end{cases}\n$$\n> 其复杂度为 $O(2^n)$,指数复杂度, 显然穷举搜索不是好的策略.\n> a. 最优子结构\n> \\begin{align}\n记A\\_{i \\dots j} 为乘积A\\_iA\\_{i+1} \\dots A\\_j \\\\\\\\\n对 i\\leq k < j, 复杂度为 \\\\\\\\\nO(A\\_{i \\dots j}) = O(A\\_{i \\dots k}) + O(A\\_{k+1 \\dots j}) + O(A\\_{i \\dots k} * A\\_{k+1 \\dots j}) \\\\\\\\\n\\because 如果A\\_{k+1} \\dots A\\_j的最优加括号方案不是A\\_iA\\_{i+1} \\dots A\\_j的最优加括号方案的子链,\\\\\\\\\n则用A\\_{k+1} \\dots A\\_j的最优加括号方案得到的O(A\\_{i \\dots j})更小 \\\\\\\\\n\\therefore 最优子结构: \\\\\\\\\nA\\_{k+1} \\dots A\\_j的最优加括号方案是A\\_iA\\_{i+1} \\dots A\\_j的最优加括号方案的子链\n\\end{align}\n\n> b. 递归求解\n> 根据子问题的最优解递归定量定义最优解的代价\n> \\begin{align}\n记m[i,j]为计算A\\_{i \\dots j}的标量乘法次数的最小值 \\\\\\\\\nm[i, j] =\n\\begin{cases}\n0, \\text {if i = j} \\\\\\\\\nmin\\_{i \\leq k < j}\\\\{m[i,k] + m[k+1,j] + p\\_{i-1} p\\_k p\\_j \\\\},else\n\\end{cases}\n记s[i, j] = k 为最优加括号方案的子链分裂点k\n\\end{align}\n\n> c. 计算最优代价\n> 这个递归式在递归树的不同分支上会多次遇到同一子问题(即重复的矩阵子链,类似斐波那契数列的递归解法), 即有明显的**公共子问题**的特点.因此如果直接递归的求解递归式,会陷入对相同子链的重复计算,增加算法复杂度, 所以采用自底向上的表格法计算最优代价如下\n> \\begin{align}\n设A\\_i的阶数p\\_{i-1}\\*p\\_i, i = 1,2,\\dots,n \\\\\\\\\n则矩阵链[A\\_1, A\\_2, \\ldots, A\\_n的阶数序列记为 p=[p\\_0,p\\_1,\\dots,p\\_n] \\\\\\\\\n表m[1\\dots n, 1\\dots n]记录m[i, j]的代价 \\\\\\\\\n表s[1\\dots n, 1\\dots n]记录计算m[i,j]取得最优代价的k值 \\\\\\\\\n\\end{align}\n```\nmatrix-chain-order(p)\n  n <- length[p] - 1 # 矩阵链长度n\n  for i <- 1 to n\n    do m[i,i] <- 0 #长度为1的链代价为0\n  for l <- 2 to n #计算长度为l的链的代价\n    do for i <- 1 to n - l + 1\n      do j <- i + l - 1\n        m[i,j] <- INT\n        for k <- i to j - 1\n          do q <- m[i,k] + m[k+1,j] + p(i-1)p(k)p(j)\n            if q < m[i,j]\n              then m[i,j] <- q;s[i,j] <- k\n  return m and s\n```\n> `matrix-chain-order`算法从长度为1的链开始循环计算, 每次计算m[i,j]时仅依赖于已经计算出的m[i,k]和m[k+1,j], 这正是核存储公共子问题的解,以减少重复计算的核心方法.\n\n> d. 构造最优解\n  `matirx-chain-order`计算了最少的标量乘法次数,但并没有给出如何加括号确定矩阵相乘的方案.此时s[i,j]发挥作用,知按最优方案计算$A\\_{1 \\dots n}$, 最后一步递归的子链相乘次序是$A\\_{1 \\dots s[1,n]}A\\_{s[1,n]+1 \\dots n}$, 之前的则递归的进行.递归输出最优方案的算法如下\n```\nprint-optimal-parens(s, i, j)\n  if i = j\n    then print \"A\"(i)\n    else print \"(\"\n      print-optimal-parens(s, i, s[i,j])\n      print-optimal-parens(s, s[i,j]+1, j)\n      print \")\"\n```\n\n3.**动态规划基础**\n从矩阵链乘法问题我们可以归纳,采用动态规划方法求解最优化问题的两个要素:\n* **最优子结构 Optimal substructure**\n\n> 如果问题的一个最优解中包含了子问题的最优解,则该问题具有最优子结构;而当一个问题具有最优子结构时,提示我们动态规划可能会适用.在矩阵链乘法问题中,$A\\_iA\\_{i+1} \\dots A\\_j$的最优加括号方案就包括了$A\\_iA\\_{i+1} \\dots A\\_k$和$A\\_kA\\_{k+1} \\dots A\\_j$这两个自问的最优解.\n那么如何寻找最优子结构?有下面的模式可以遵循:\n> 1. 问题的解一般是一种决策或选择.矩阵链乘法问题即选择在哪里分裂矩阵链\n> 2. 对给定的问题,假设已知的是一个导致最优解的选择\n> 3. 已知这个选择后,确定子问题,和如何描述子问题\n> 4. 使用剪贴技术(cut and paste)用来证明在问题的一个最优解中,使用的子\n\n> 问题的解本身也必须是最优的.即用反证法,\"剪除\"非最优问题的解再\"贴上\"最优解,证明可以得到原问题的更好的解,与假设已经得到的最优解相矛盾.\n最优子结构在问题域中以两种方式变化(在找出这两个问题的解之后,构造出原问题的最优子结构往往就不是难事了):\n> 1. 有多少个子问题被用在原问题的一个最优解中\n> 2. 在决定一个最优解中使用哪些子问题有多少个选择\n\n> 非正式地:一个动态规划算法的运行时间依赖于两个因素的乘积:子问题的总个数和每个子问题中有多少种选择.问题解的代价通常是子问题的代价加上选择本身带来的开销.例如,在矩阵链乘法问题中,选择矩阵$A\\_k$分裂为子链, 再加上选择的代价$p\\_{i-1}p\\_kp\\_j$.\n动态规划能够消除重复计算子问题是因为它与普通递归相反,它是通过自下而上的方式来进行求解的.动态规划正是一个递归的反向展开的过程:\n在满足1.最优子结构 2.重叠子问题这2个条件下,通过把递归从下至上的进行展开以避免重复计算子问题从而加速了最终问题的求解的过程.\n> **注**: 在不能应用最优子结构的时间,就一定不能假设它能够应用.\n\n* **重叠子问题 Overlapping subproblems**\n\n> 最优化问题要求解原问题的递归算法可反复解同样的子问题,而不是产生新的子问题.\n一般的,不同的子问题的数目是输入规模的一个多项式.这样,动态规划算法才能充分利用重叠的子问题,减少计算量.即通过每个子问题只解一次,把解保存在一个需要时就可以查看的表中,而每次查表只需要常数时间.\n> 如在矩阵链乘法中,`matrix-chain-order`解更大问题时,反复取出较小的子问题.比如m[3,4]计算被使用四次:在计算m[2,4],m[1,4],m[3,5]和m[3,6]被使用.相比较的,如果采用低效率的递归程序产生的递归树,反复计算m[i,j],导致复杂度骤升到$O(2^n)$\n```\nrecursive-matirc-chain(p, i, j)\n  if i = j\n    then return 0\n  m[i,j] <- INT\n  for k <- i to j - 1\n    do q <- recursive-matirc-chain(p, i, k) + recursive-matirc-chain(p, k+1, j) + p(i-1)p(k)p(i)\n    if q < m[i, j]\n      then m[i,j] <- q\n  return m[i,j]\n```\n\n4.**备忘录方法 memorandum method**\n> 备忘录方法:这种方法是动态规划的一个变形,它本质上与动态规划相同,但是比动态规划更好理解.步骤如下:\n1. 使用普通的递归结构,自上而下的解决问题.\n2. 当在递归算法的执行中每一次遇到一个子问题时,就计算它的解并填入一个表中.以后每次遇到该子问题时,只要查看并返回表中先前填入的值即可.\n\n> 从这段描述可以看出:动态规划与递归时做备忘录的本质是完全相同的,所以说备忘录方法与普通的动态递归本质完全相同,没有孰优孰劣之分,哪个方便用哪个.\n\n> 从备忘录方法求解矩阵链问题如下:\n```\nmemoized-matirx-chain(p)\n  n <- length[p] - 1\n  for i <- i to n\n    do for j <- i to n\n      do m[i,j] <- INT\n  return lookup-chain(p, 1, n)\n\n#查表\nlookup-chain(p, i, j)\n  if m[i,j] < INT\n    then return m[i,j]\n  if i = j\n    then m[i,j] <- 0\n    else for k <- i to j - 1\n      do q <- lookup-chain(p,i,k) + lookup-chain(p,k+1,j)+p(i-1)p(k)p(j)\n      if q < m[i,j]\n        then m[i,j] <- q\n  return m[i,j]\n```\n> 备忘录方法与动态递归方法的比较:\n> 1. 如果所有的子问题都至少要被计算一次,则一个自底向上的动态规划算法通常比一个自顶向下的做备忘录算法好出一个常数因子.因为动态规划没有使用递归的代价,只用到了循环,所以常数因子肯定比递归要好一些.\n> 2. 此外,在有些问题中,还可以用动态规划算法中的表存取模式来进一步的减少时间和空间上的需求;或者,如果子问题中\n的某些子问题根本没有必须求解,做备忘录的方法有着只解那些肯定要求解的子问题的优点.(而且这点是自动获得的,那些不必要计算的子问题在备忘录方法中会被自动的抛弃)\n\n> 备忘录方法总结:由“是否所有的子问题都至少需要被计算一次”来决定使用动态规划还是备忘录.这两种方法没孰优孰劣之分,因为它们的本质思想是完全一样的;消除重复子问题.\n\n\n#### Chapter16 局部最优能得到全局最优吗?\n\n最优化问题如果采用动态规划可能设计分析过于复杂,这时可以选择贪心算法.\n贪心算法使所作的选择看起来都是当前最佳的,期望通所做的局部最优选择来产生一个全局最优解.对算法中的每一个决策点,做一个当时看起来是最佳的选择,这种启发式策略并不是总能产生最优解的.\n\n1.活动选择问题\n> 有一个需要使用每个资源的n个活动组成的集合$S= {a\\_1,a\\_2,\\dots,a\\_n}$,资源每次只能由一个活动使用.每个活动$a\\_i$都有一个开始时间$s\\_i$和结束时间$f\\_i$,且 $0 < s\\_i < f\\_i < \\infty$.一旦被选择后,活动$a\\_i$就占据半开时间区间 $[s\\_i,f\\_i)$ .如果 $[s\\_i,f\\_i] [s\\_j,f\\_j)$ 互不重叠,则称 $a\\_i$和 $a\\_j$两个活动是兼容的.该问题就是要找出一个由互相兼容的活动组成的最大子集.\n> 动态规划与贪心求解该问题\n> a. 最优子结构\n子问题空间:\n> $$S\\_{ij} = \\\\{a\\_k \\in S: f\\_i \\leq s\\_k < f\\_k \\leq s\\_j \\\\}$$\n> 定义子问题解空间 $S\\_{ij}$ 是S的子集,其中的每个获得都是互相兼容的.即每个活动都是在 $a\\_i$ 结束之后开始,且在 $a\\_i$ 开始之前结束.为了方便计算,添加两个虚构活动 $a\\_0$ 和 $a\\_{n+1}$ ,其中$f\\_0=0,s\\_{n+1}= \\infty$.\n按活动结束时间单调递增排序\n> $$f\\_0 \\leq f\\_1 \\leq \\dots \\leq f\\_n \\leq f\\_{n+1}$$\n> 可以得到：当$i \\geq j$时,$S\\_{i,j}$ 为空集.如果活动按照结束时间单调递增排序,子问题空间被用来从 $S\\_{i,j}$ 中选择最大兼容活动子集,其中 $0≤i＜j≤n+1$,所以其他的 $S\\_{i,j}$ 都是空集.\n> 最优子结构为:假设 $S\\_{ij}$ 的最优解 $A\\_{ij}$ 包含活动 $a\\_k$,则对 $S\\_{ik}$ 的解 $A\\_{ik}$ 和 $S\\_{kj}$ 的解 $A\\_{kj}$ 必定是最优的.通过一个活动 $a\\_k$ 将问题分成两个子问题,下面的公式可以计算出$S\\_{ij}$的解 $A\\_{ij}$:\n> $$A\\_{ij} = A\\_{ik} \\bigcup \\\\{a\\_k\\\\} \\bigcup A\\_{kj}$$\n\n> b.一个递归解\n设c[i, j]为 $S\\_{ij}$ 中最大兼容子集中的活动数目,当 $S\\_{ij}$ 为空集时,c[i, j]=0；当$S\\_{ij}$非空时,若 $a\\_k$ 在 $S\\_{ij}$ 的最大兼容子集中被使用,则则问题 $S\\_{ik}$ 和 $S\\_{kj}$ 的最大兼容子集也被使用,故可得到$c[i, j] = c[i, k] + c[k, j] + 1$\n故有\n> $$\nc[i, j] =\n\\begin{cases}\n0, if \\, S\\_{ij} = \\emptyset \\\\\\\\\nmax\\_{i<k<j}\\\\{c[i,k]+c[j,k]+1\\\\},else\n\\end{cases}$$\n\n> c.最优解计算过程\n采用动态规划可以直接解决,但针对活动选择问题可以有效简化，认真分析可以得出以下定理：对于任意非空子问题 $S\\_{ij}$ ，设 $a\\_m$ 是 $S\\_{ij}$ 中具有最早结束时间的活动,\n> $$f\\_m = min \\\\{ f\\_k: a\\_k \\in  S\\_{ij} \\\\}$$\n> 有:\n> 1.  $a\\_m$ 在 $S\\_{ij}$ 中的某最大兼容活动子集中被使用.\n> 2.  $S\\_{im}$ 为空，所以选择 $a\\_m$ 将使子问题 $S\\_{mj}$ 为唯一可能非空的子问题.\n\n> 有这个定理，就简化了问题，使得最优解中只使用一个子问题，在解决子问题 $S\\_{ij}$ 时，在 $S\\_{ij}$ 中选择最早结束时间的那个活动.这样的贪心决策,使得剩下的,未调度的时间最大化.\n贪心算法自顶向下地解决每个问题，解决子问题 $S\\_{ij}$ ，先找到 $S\\_{ij}$ 中最早结束的活动 $a\\_m$ ，然后将 $a\\_m$ 添加到最优解活动集合中，再来解决子问题 $S\\_{mj}$ .\n递归解法如下:\n```\nrecursive-activity-selector(s, f, i, j)\n  m <- i + 1\n  while m < j and s(m) < f(i)\n    do m <- m + 1\n  if m < j\n    then return {a(m)} and recursive-activity-selector(s, f, m, j)\n    else return none\n```\n> 根据尾递归的形式转化为迭代算法:\n```\ngreedy-activity-selector(s, f)\n  n <- length[s]\n  A <- {a(i)}\n  i <- 1\n  for m <- 2 to n\n    do if s(m) > f(i)\n      then A <- A and {a(m)}\n        i <- m\n  return A\n```\n\n2.动态规划与贪心的关系\n> 从活动选择问题可以看到, 我们先用动态规划的思想解决, 继而发现可以增强条件,使用在动态规划基础上的贪心算法, 更高效的解决问题.贪心算法基础上有一个动态规划算法来证明其正确性,所以说安全的(能够取得最优解的).所以动态规划其实是“安全的贪心算法”的基础.无论如何,在每一个贪心算法的下面,几乎总是会有一个更加复杂的动态规划解.贪心算法实现简单速度快,但是证明贪心的正确性往往是很困难的,要在本已经较为复杂的动态规划证明上确定贪心的正确性.\n\n3.贪心算法的一般步骤:\n> 1. 将优化问题转化成这样的一个问题,即先做出选择(对应于动态规划的先解决子问题再选择),再解决剩下的一个子问题.\n> 2. 证明原问题总是有一个最优解是做贪心选择得到的,从而说明贪心选择的安全.\n> 3. 说明在做出贪心选择后,剩余的子问题具有这样的一个性质.即如果将子问题的最优解和我们所做的贪心选择联合起来,就可以得出原问题的一个最优解.\n\n> 正确使用贪心算法的2个关键要素:贪心选择性质 和最优子结构.\n> 1. **贪心选择性质**:一个全局最优解可以通过局部最优(贪心)选择来达到;即当考虑做何选择时,我们只考虑对当前问题最佳的选择而不考虑子问题的结果.\n> 2. **最优子结构**:一个问题的最优解包含了其子问题的最优解.\n\n> 对应的,要使用贪心算法就必须先证明以下两个性质:\n> 1. 每一步所做的贪心选择最终能产生一个全局最优解.在证明中先考察一个全局最优解,然后证明对该解加以修改,使其采用贪心选择,这个选择将原问题变为一个相似的、但更小的问题.\n> 2. 子问题的最优解与所做的贪心选择合并后,的确可以得到原问题的一个最优解.\n\n4.应用\n > 一般地,就算证明不出来贪心算法能给出最优解,但是它一般都至少能给出次优解.所以贪心算法在实际的应用中是非常的普及的.\n\n#### Chapter17 较复杂的操作怎样平摊到所有操作上?\n1.**平摊分析 amortized analysis**\n在平摊分析中,执行一系列数据结构操作所需要的时间是通过对执行所有操作所花费的时间求平均而得到的.平摊分析表明不能总以最坏情况来衡量算法,因为最坏的情况并不经常会发生,甚至在绝大多数应用中最坏情况出现的次数是极少的.\n> 平摊分析与平均情况分析的不同之处在于它不牵涉到概率;平摊分析保证在最坏情况下,每个操作具有平均性能.通过平摊分析,可以获得对某种特定数据结构的认识,这种认识有助于优化设计.\n一个例子是 `C++ STL` 中 `vector.push_back` 操作,一般情况下`push_back`追加到`vector`只需要复杂度$O(1)$, 但在`vector`达到容量限度时,`vector`先要动态扩展,然后`push_back`,复杂度升到$O(n)$,这种最坏情况出现次数相对于一般情况出现很少,对所有操作求平均后,每个`push_back`具有 $O(1)$的性能.\n\n2.平摊分析的三种方法:\n> * 聚集分析:指分析一系列操作的总时间的上节$T(n)$, 平均代价即为$T(n)/n$\n> * 记账法:对每次操作的对象进行预先记账,补偿实际代价高于帐的操作\n> * 势能方法:与记账法类似,但将每次预留的势能视为是整个数据结构共享的,整体维护\n\n\n3.**聚集分析: aggregate analysis**\n> 由N个操作所构成的序列的总时间在最坏的情况下为$T(n)$,则每个操作的平均代价(平摊代价)为$T(n)/n$.以前的时间复杂度分析都是以单次操作为对象的分析它的最坏时间复杂度,而聚集分析所分析的是N次操作的总时间的最坏情况.\n聚集分析:由序列的总最坏时间 -> 单次的平摊时间\n> 以`stack`的操作为例(增加一个操作`multipop`, 连续出栈)\n```\npush(S, x): O(1)\npop(S): O(1)\nmultipop(S, k): O(n)\n  while not stack-empty(S) and k != 0\n    do pop(s)\n      k <- k - 1\n```\n> 则n个包含`push`和`pop`的序列总代价为 $O(n)$ , 但加上复杂度为 $O(n)$ 的`multipop`操作后,应该如何计算?\n任意stack操作的最坏时间复杂度为$O(n)$, 故N个操作的代价是 $O(2^n)$.但这个界明显过大, 因为不可能出现连续n次`multipop`的情况.\n但从`pop`和`push`对应的角度考虑,\n因为一个对象入栈后最多出栈一次, 将`multipop`视为`pop`的连续操作\n所以`pop`的次数 $\\leq$ `push`的次数\nn个序列的总时间代价为$O(n)$,平均代价为$O(n)/n=O(1)$\n\n\n4.**记账法: bookkeeping method**\n> 对序列操作中的每一个操作收取一定的费用,当所收取的费用比它实际应支付的费用多时就把多余的部分当作存款(credit)存起来,一个操作的平摊代价可以看作两部分:实际代价和存款(或被储蓄或被用完).其要素为:\n> 1. 存款可以用来在以后补偿那些其平摊代价低于其实际代价的操作.\n> 2. 如果希望通过对平摊代价的分析来说明每次操作的最坏情况平均代价较小,则操作序列的总平摊代价就必须是该序列的总的实际代价的一个上界.因为平摊代价是最坏时的平均代价,即存款不能为负.\n> 3. 存款不能为负,因为记账法是不允许欠账的,否则就不能满足平摊代价是操作总时间的最坏情况的平均这个定义.\n\n> 对于前面的stack操作,各操作的实际代价和平摊代价如下:\n\n|操作             |实际代价         |平摊代价       |\n|----------------|----------------|------------- |\n|push            |1               |2             |\n|pop             |1               |0             |\n|multipop        |min(k, s)       |0             |\n> 平摊代价当每次入栈时记账支付2元,其中1元支付该`push`操作的实际代价,还有1元用于支付该元素被`pop`出来时的代价.则可以保证在任何时间内都不会有欠账,故`pop`操作可以不收取任何费用.\n\n\n5.**势能方法: potential method**\n> 将已预付的工作作为一种“势能”保存,它在需要时可以释放出来,以支付后面的操作.势能是与整个数据结构而不是其中的个别对象发生联系的.相对比, 记账法中的账与个别对象发生联系,比如栈操作时支付的2元就记在入栈的那个元素上)\n> \\begin{align}\n初始数据结构D\\_0, 记c\\_i为第i个操作的实际代价 \\\\\\\\\nD\\_i为数据结构D\\_{i-1}作用第i操作的的结果 \\\\\\\\\n势函数\\Phi: D\\_i \\mapsto \\Phi(D\\_i) \\\\\\\\\n平摊代价 \\hat{c\\_i} = c\\_i + \\Phi(D\\_i) - \\Phi(D\\_{i-1}) \\\\\\\\\n总平摊代价 \\sum\\_{i=1}^n\\hat{c\\_i} = \\sum\\_{i=1}^n(c\\_i + \\Phi(D\\_i) - \\Phi(D\\_{i-1})) = \\sum\\_{i=1}^n c\\_i + \\Phi(D\\_n) - \\Phi(D\\_0)\n\\end{align}\n\n> 仍然以`stack`操作为例,\n> \\begin{align}\n定义势函数\\Phi 为stack中对象个数 \\\\\\\\\n初始空stack D\\_0, \\Phi(D\\_0) = 0 \\\\\\\\\npush操作: \\\\\\\\\n\\hat{c\\_i} = c\\_i + \\Phi(D\\_i) - \\Phi(D\\_{i-1}) = 1 + (s+1) - s = 2 \\\\\\\\\nmultipop操作: \\\\\\\\\n\\hat{c\\_i} = c\\_i + \\Phi(D\\_i) - \\Phi(D\\_{i-1}) = k + (s -k) - s = 0 \\\\\\\\\n\\therefore 每一操作平摊代价为O(1) \\\\\\\\\n\\therefore n个操作最坏代价为O(n)\n\\end{align}\n","source":"_posts/CLRS-notes3.md","raw":"title: introduction to algorithms note3\ntags:\n  - algorithm\n  - data_structure\ndate: 2017/04/22\n\n----\n\n# ＜Introduction to algorithms＞笔记\n\n### Part4 高级设计和分析技术\npart1-3中学习的普遍应用的算法思想和技术如下:\n* 分治法 divide and conquer\n* 随机化 randomize\n* 递归求解 recursion\n\n在面对一个计算问题时, 一般的直接解法是暴力破解,即穷举法.从一定意义上讲,所有的最优化问题都可以通过穷举法来解决,但是这在时间上是不可接受的.要更高效的求解问题, 需要学习对高效算法的设计分析技术\n所有的高效算法都是为了加快速度:\n1. 动态规划:保存子问题的解,以备重复使用\n2. 贪心算法:用局部最优解来求全局最优解\n3. 平摊分析是用来分析算法的工具,它本身并不是一种算法.\n\n* 动态规划 dynamic programming\n> * 动态规划通常应用于最优化问题,即要做出一组选择以达到一个最优解时.在做选择的同时,经常出现同样形式的子问题.关键技术是存储这些子问题每一个的解,以备它重复出现.\n\n* 贪心算法 greedy algorithm\n> * 贪心算法通常也是应用于最优化问题,该算法的思想是以局部最优的方式来做每一个选择.采用贪心算法可以比动态规划更快地得出一个最优解,但是关键是不容易判断贪心算法所得到的是否真的是最优解.\n\n* 平摊分析 amortized analysis\n> * 平摊分析是一种用来分析执行一系列类似操作的算法的工具.在一个操作序列中,不可能每一个都以其已知的最坏情况运行,某些操作的代价高些,而其它的低一些.平摊分析不分别计算每一次操作的代价确定一系列代价的界,而是对整个操作序列的真实代价限界.\n\n<!-- more -->\n#### Chapter15 如何利用已经计算出的子问题?\n\n1.动态规划与分治法之间的区别:\n* 分治法是指将问题分成一些独立的子问题,递归的求解各子问题,合并子问题得到原问题的解\n* 动态规划适用于这些子问题不是独立的情况,也就是各子问题包含公共子问题.\n对公共子问题,分治法会重复的求解,而动态规划则是只求解一次,保存结果到一张表中,从而避免了重复计算.\n\n以斐波那契数列的计算fib(5)为例\n- 分治法计算如下:\n```\nfib(n):\n  return fib(n-1) + fib(n-2)\nfib(5) = fib(4) + fib(3)\n       = (fib(3) + fib(2)) + (fib(2) + fib(1))\n       = ((fib(2) + fib(1)) + fib(2)) + (fib(2) + fib(1))\n```\n可以看到, fib(2)和fib(1)重复计算多次, 导致时间复杂度为$O(2^n)$\n- 动态规划计算如下\n```\narray Fib[];\nFib[1] = 1, Fib[2] = 1;\nfib(n):\n  if Fib(n) != 0\n    return Fib(n)\n    else return fib(n-1) + fib(n-2)\n```\n每次计算的结果记录在Fib(n)中, 如果计算过程中需要直接取出记录即可, 减少了很多重复计算, 算法复杂度降为$O(n)$\n\n2.**最优化问题**:\n具有多个可行的解, 每个解有一个值,具有最优(Max or Min)值的解是一个最优解.\n动态规划多用于最优化问题, 其设计可以分为 4 个步骤:\n> 1. 描述最优解的子结构\n> 2. 递归定义最优解的值\n> 3. 按自底向上的方法计算最优解的值\n> 4. 由计算出的结果反向构造出一个最优解\n> 动态规划最重要的是要找出最优解的子结构\n\n以解决**矩阵链式乘法**为例来梳理动态规划的步骤:\n> 1.问题背景:\n给定n个矩阵构成的序列链 $(A\\_1, A\\_2, \\ldots, A\\_n)$, 计算乘积:\n> $$A\\_1 A\\_2 \\ldots A\\_n \\qquad (15.1)$$\n> 要计算式(15.1), 考虑计算两个矩阵相乘的子程序`matrix-multiply(A, B)`\n```\nmatrix-multiply(A, B)\nif columns[A] != rows[B]\n  then error \"imcompatible dimensions\"\n  else for i <- 1 to rows[A]\n    do for j <- 1 to columns[B]\n      do C[i, j] <- 0\n        for k <- 1 to columns[A]\n          do C[i, j] <- C[i, j] + A[i, k] * B[k, j]\n```\n> 矩阵的乘积是按括号给出的计算顺序来计算的, 以矩阵链 $(A\\_1, A\\_2, A\\_3, A\\_4)$ 为例, 就有5种计算顺序:\n> \\begin{align}\n(A\\_1(A\\_2(A\\_3A\\_4))) \\\\\\\\\n(A\\_1((A\\_2A\\_3)A\\_4)) \\\\\\\\\n...\n\\end{align}\n> 以标量乘法次数来衡量复杂度, 从`matrix-multiply(A, B)`得到,\n> A阶数p*q, B阶数q*r -> 复杂度$O(pqr)$\n> 不同的括号顺序导致的矩阵乘积代价不同, 如何求解最小化的代价(即最少的标量乘法次数)的方案?\n\n> 2.问题求解\n如果穷举可能的全部括号方案,可以得到一个结果, 但显然代价太大.设P(n)为矩阵链的加括号方案数, 有:\n> $$\nP(N) =\n\\begin{cases}\n1, \\text {if n = 1} \\\\\\\\\n\\sum\\_{k=1}^{n=1}P(k)P(n-k),\\text {if n >= 2}\n\\end{cases}\n$$\n> 其复杂度为 $O(2^n)$,指数复杂度, 显然穷举搜索不是好的策略.\n> a. 最优子结构\n> \\begin{align}\n记A\\_{i \\dots j} 为乘积A\\_iA\\_{i+1} \\dots A\\_j \\\\\\\\\n对 i\\leq k < j, 复杂度为 \\\\\\\\\nO(A\\_{i \\dots j}) = O(A\\_{i \\dots k}) + O(A\\_{k+1 \\dots j}) + O(A\\_{i \\dots k} * A\\_{k+1 \\dots j}) \\\\\\\\\n\\because 如果A\\_{k+1} \\dots A\\_j的最优加括号方案不是A\\_iA\\_{i+1} \\dots A\\_j的最优加括号方案的子链,\\\\\\\\\n则用A\\_{k+1} \\dots A\\_j的最优加括号方案得到的O(A\\_{i \\dots j})更小 \\\\\\\\\n\\therefore 最优子结构: \\\\\\\\\nA\\_{k+1} \\dots A\\_j的最优加括号方案是A\\_iA\\_{i+1} \\dots A\\_j的最优加括号方案的子链\n\\end{align}\n\n> b. 递归求解\n> 根据子问题的最优解递归定量定义最优解的代价\n> \\begin{align}\n记m[i,j]为计算A\\_{i \\dots j}的标量乘法次数的最小值 \\\\\\\\\nm[i, j] =\n\\begin{cases}\n0, \\text {if i = j} \\\\\\\\\nmin\\_{i \\leq k < j}\\\\{m[i,k] + m[k+1,j] + p\\_{i-1} p\\_k p\\_j \\\\},else\n\\end{cases}\n记s[i, j] = k 为最优加括号方案的子链分裂点k\n\\end{align}\n\n> c. 计算最优代价\n> 这个递归式在递归树的不同分支上会多次遇到同一子问题(即重复的矩阵子链,类似斐波那契数列的递归解法), 即有明显的**公共子问题**的特点.因此如果直接递归的求解递归式,会陷入对相同子链的重复计算,增加算法复杂度, 所以采用自底向上的表格法计算最优代价如下\n> \\begin{align}\n设A\\_i的阶数p\\_{i-1}\\*p\\_i, i = 1,2,\\dots,n \\\\\\\\\n则矩阵链[A\\_1, A\\_2, \\ldots, A\\_n的阶数序列记为 p=[p\\_0,p\\_1,\\dots,p\\_n] \\\\\\\\\n表m[1\\dots n, 1\\dots n]记录m[i, j]的代价 \\\\\\\\\n表s[1\\dots n, 1\\dots n]记录计算m[i,j]取得最优代价的k值 \\\\\\\\\n\\end{align}\n```\nmatrix-chain-order(p)\n  n <- length[p] - 1 # 矩阵链长度n\n  for i <- 1 to n\n    do m[i,i] <- 0 #长度为1的链代价为0\n  for l <- 2 to n #计算长度为l的链的代价\n    do for i <- 1 to n - l + 1\n      do j <- i + l - 1\n        m[i,j] <- INT\n        for k <- i to j - 1\n          do q <- m[i,k] + m[k+1,j] + p(i-1)p(k)p(j)\n            if q < m[i,j]\n              then m[i,j] <- q;s[i,j] <- k\n  return m and s\n```\n> `matrix-chain-order`算法从长度为1的链开始循环计算, 每次计算m[i,j]时仅依赖于已经计算出的m[i,k]和m[k+1,j], 这正是核存储公共子问题的解,以减少重复计算的核心方法.\n\n> d. 构造最优解\n  `matirx-chain-order`计算了最少的标量乘法次数,但并没有给出如何加括号确定矩阵相乘的方案.此时s[i,j]发挥作用,知按最优方案计算$A\\_{1 \\dots n}$, 最后一步递归的子链相乘次序是$A\\_{1 \\dots s[1,n]}A\\_{s[1,n]+1 \\dots n}$, 之前的则递归的进行.递归输出最优方案的算法如下\n```\nprint-optimal-parens(s, i, j)\n  if i = j\n    then print \"A\"(i)\n    else print \"(\"\n      print-optimal-parens(s, i, s[i,j])\n      print-optimal-parens(s, s[i,j]+1, j)\n      print \")\"\n```\n\n3.**动态规划基础**\n从矩阵链乘法问题我们可以归纳,采用动态规划方法求解最优化问题的两个要素:\n* **最优子结构 Optimal substructure**\n\n> 如果问题的一个最优解中包含了子问题的最优解,则该问题具有最优子结构;而当一个问题具有最优子结构时,提示我们动态规划可能会适用.在矩阵链乘法问题中,$A\\_iA\\_{i+1} \\dots A\\_j$的最优加括号方案就包括了$A\\_iA\\_{i+1} \\dots A\\_k$和$A\\_kA\\_{k+1} \\dots A\\_j$这两个自问的最优解.\n那么如何寻找最优子结构?有下面的模式可以遵循:\n> 1. 问题的解一般是一种决策或选择.矩阵链乘法问题即选择在哪里分裂矩阵链\n> 2. 对给定的问题,假设已知的是一个导致最优解的选择\n> 3. 已知这个选择后,确定子问题,和如何描述子问题\n> 4. 使用剪贴技术(cut and paste)用来证明在问题的一个最优解中,使用的子\n\n> 问题的解本身也必须是最优的.即用反证法,\"剪除\"非最优问题的解再\"贴上\"最优解,证明可以得到原问题的更好的解,与假设已经得到的最优解相矛盾.\n最优子结构在问题域中以两种方式变化(在找出这两个问题的解之后,构造出原问题的最优子结构往往就不是难事了):\n> 1. 有多少个子问题被用在原问题的一个最优解中\n> 2. 在决定一个最优解中使用哪些子问题有多少个选择\n\n> 非正式地:一个动态规划算法的运行时间依赖于两个因素的乘积:子问题的总个数和每个子问题中有多少种选择.问题解的代价通常是子问题的代价加上选择本身带来的开销.例如,在矩阵链乘法问题中,选择矩阵$A\\_k$分裂为子链, 再加上选择的代价$p\\_{i-1}p\\_kp\\_j$.\n动态规划能够消除重复计算子问题是因为它与普通递归相反,它是通过自下而上的方式来进行求解的.动态规划正是一个递归的反向展开的过程:\n在满足1.最优子结构 2.重叠子问题这2个条件下,通过把递归从下至上的进行展开以避免重复计算子问题从而加速了最终问题的求解的过程.\n> **注**: 在不能应用最优子结构的时间,就一定不能假设它能够应用.\n\n* **重叠子问题 Overlapping subproblems**\n\n> 最优化问题要求解原问题的递归算法可反复解同样的子问题,而不是产生新的子问题.\n一般的,不同的子问题的数目是输入规模的一个多项式.这样,动态规划算法才能充分利用重叠的子问题,减少计算量.即通过每个子问题只解一次,把解保存在一个需要时就可以查看的表中,而每次查表只需要常数时间.\n> 如在矩阵链乘法中,`matrix-chain-order`解更大问题时,反复取出较小的子问题.比如m[3,4]计算被使用四次:在计算m[2,4],m[1,4],m[3,5]和m[3,6]被使用.相比较的,如果采用低效率的递归程序产生的递归树,反复计算m[i,j],导致复杂度骤升到$O(2^n)$\n```\nrecursive-matirc-chain(p, i, j)\n  if i = j\n    then return 0\n  m[i,j] <- INT\n  for k <- i to j - 1\n    do q <- recursive-matirc-chain(p, i, k) + recursive-matirc-chain(p, k+1, j) + p(i-1)p(k)p(i)\n    if q < m[i, j]\n      then m[i,j] <- q\n  return m[i,j]\n```\n\n4.**备忘录方法 memorandum method**\n> 备忘录方法:这种方法是动态规划的一个变形,它本质上与动态规划相同,但是比动态规划更好理解.步骤如下:\n1. 使用普通的递归结构,自上而下的解决问题.\n2. 当在递归算法的执行中每一次遇到一个子问题时,就计算它的解并填入一个表中.以后每次遇到该子问题时,只要查看并返回表中先前填入的值即可.\n\n> 从这段描述可以看出:动态规划与递归时做备忘录的本质是完全相同的,所以说备忘录方法与普通的动态递归本质完全相同,没有孰优孰劣之分,哪个方便用哪个.\n\n> 从备忘录方法求解矩阵链问题如下:\n```\nmemoized-matirx-chain(p)\n  n <- length[p] - 1\n  for i <- i to n\n    do for j <- i to n\n      do m[i,j] <- INT\n  return lookup-chain(p, 1, n)\n\n#查表\nlookup-chain(p, i, j)\n  if m[i,j] < INT\n    then return m[i,j]\n  if i = j\n    then m[i,j] <- 0\n    else for k <- i to j - 1\n      do q <- lookup-chain(p,i,k) + lookup-chain(p,k+1,j)+p(i-1)p(k)p(j)\n      if q < m[i,j]\n        then m[i,j] <- q\n  return m[i,j]\n```\n> 备忘录方法与动态递归方法的比较:\n> 1. 如果所有的子问题都至少要被计算一次,则一个自底向上的动态规划算法通常比一个自顶向下的做备忘录算法好出一个常数因子.因为动态规划没有使用递归的代价,只用到了循环,所以常数因子肯定比递归要好一些.\n> 2. 此外,在有些问题中,还可以用动态规划算法中的表存取模式来进一步的减少时间和空间上的需求;或者,如果子问题中\n的某些子问题根本没有必须求解,做备忘录的方法有着只解那些肯定要求解的子问题的优点.(而且这点是自动获得的,那些不必要计算的子问题在备忘录方法中会被自动的抛弃)\n\n> 备忘录方法总结:由“是否所有的子问题都至少需要被计算一次”来决定使用动态规划还是备忘录.这两种方法没孰优孰劣之分,因为它们的本质思想是完全一样的;消除重复子问题.\n\n\n#### Chapter16 局部最优能得到全局最优吗?\n\n最优化问题如果采用动态规划可能设计分析过于复杂,这时可以选择贪心算法.\n贪心算法使所作的选择看起来都是当前最佳的,期望通所做的局部最优选择来产生一个全局最优解.对算法中的每一个决策点,做一个当时看起来是最佳的选择,这种启发式策略并不是总能产生最优解的.\n\n1.活动选择问题\n> 有一个需要使用每个资源的n个活动组成的集合$S= {a\\_1,a\\_2,\\dots,a\\_n}$,资源每次只能由一个活动使用.每个活动$a\\_i$都有一个开始时间$s\\_i$和结束时间$f\\_i$,且 $0 < s\\_i < f\\_i < \\infty$.一旦被选择后,活动$a\\_i$就占据半开时间区间 $[s\\_i,f\\_i)$ .如果 $[s\\_i,f\\_i] [s\\_j,f\\_j)$ 互不重叠,则称 $a\\_i$和 $a\\_j$两个活动是兼容的.该问题就是要找出一个由互相兼容的活动组成的最大子集.\n> 动态规划与贪心求解该问题\n> a. 最优子结构\n子问题空间:\n> $$S\\_{ij} = \\\\{a\\_k \\in S: f\\_i \\leq s\\_k < f\\_k \\leq s\\_j \\\\}$$\n> 定义子问题解空间 $S\\_{ij}$ 是S的子集,其中的每个获得都是互相兼容的.即每个活动都是在 $a\\_i$ 结束之后开始,且在 $a\\_i$ 开始之前结束.为了方便计算,添加两个虚构活动 $a\\_0$ 和 $a\\_{n+1}$ ,其中$f\\_0=0,s\\_{n+1}= \\infty$.\n按活动结束时间单调递增排序\n> $$f\\_0 \\leq f\\_1 \\leq \\dots \\leq f\\_n \\leq f\\_{n+1}$$\n> 可以得到：当$i \\geq j$时,$S\\_{i,j}$ 为空集.如果活动按照结束时间单调递增排序,子问题空间被用来从 $S\\_{i,j}$ 中选择最大兼容活动子集,其中 $0≤i＜j≤n+1$,所以其他的 $S\\_{i,j}$ 都是空集.\n> 最优子结构为:假设 $S\\_{ij}$ 的最优解 $A\\_{ij}$ 包含活动 $a\\_k$,则对 $S\\_{ik}$ 的解 $A\\_{ik}$ 和 $S\\_{kj}$ 的解 $A\\_{kj}$ 必定是最优的.通过一个活动 $a\\_k$ 将问题分成两个子问题,下面的公式可以计算出$S\\_{ij}$的解 $A\\_{ij}$:\n> $$A\\_{ij} = A\\_{ik} \\bigcup \\\\{a\\_k\\\\} \\bigcup A\\_{kj}$$\n\n> b.一个递归解\n设c[i, j]为 $S\\_{ij}$ 中最大兼容子集中的活动数目,当 $S\\_{ij}$ 为空集时,c[i, j]=0；当$S\\_{ij}$非空时,若 $a\\_k$ 在 $S\\_{ij}$ 的最大兼容子集中被使用,则则问题 $S\\_{ik}$ 和 $S\\_{kj}$ 的最大兼容子集也被使用,故可得到$c[i, j] = c[i, k] + c[k, j] + 1$\n故有\n> $$\nc[i, j] =\n\\begin{cases}\n0, if \\, S\\_{ij} = \\emptyset \\\\\\\\\nmax\\_{i<k<j}\\\\{c[i,k]+c[j,k]+1\\\\},else\n\\end{cases}$$\n\n> c.最优解计算过程\n采用动态规划可以直接解决,但针对活动选择问题可以有效简化，认真分析可以得出以下定理：对于任意非空子问题 $S\\_{ij}$ ，设 $a\\_m$ 是 $S\\_{ij}$ 中具有最早结束时间的活动,\n> $$f\\_m = min \\\\{ f\\_k: a\\_k \\in  S\\_{ij} \\\\}$$\n> 有:\n> 1.  $a\\_m$ 在 $S\\_{ij}$ 中的某最大兼容活动子集中被使用.\n> 2.  $S\\_{im}$ 为空，所以选择 $a\\_m$ 将使子问题 $S\\_{mj}$ 为唯一可能非空的子问题.\n\n> 有这个定理，就简化了问题，使得最优解中只使用一个子问题，在解决子问题 $S\\_{ij}$ 时，在 $S\\_{ij}$ 中选择最早结束时间的那个活动.这样的贪心决策,使得剩下的,未调度的时间最大化.\n贪心算法自顶向下地解决每个问题，解决子问题 $S\\_{ij}$ ，先找到 $S\\_{ij}$ 中最早结束的活动 $a\\_m$ ，然后将 $a\\_m$ 添加到最优解活动集合中，再来解决子问题 $S\\_{mj}$ .\n递归解法如下:\n```\nrecursive-activity-selector(s, f, i, j)\n  m <- i + 1\n  while m < j and s(m) < f(i)\n    do m <- m + 1\n  if m < j\n    then return {a(m)} and recursive-activity-selector(s, f, m, j)\n    else return none\n```\n> 根据尾递归的形式转化为迭代算法:\n```\ngreedy-activity-selector(s, f)\n  n <- length[s]\n  A <- {a(i)}\n  i <- 1\n  for m <- 2 to n\n    do if s(m) > f(i)\n      then A <- A and {a(m)}\n        i <- m\n  return A\n```\n\n2.动态规划与贪心的关系\n> 从活动选择问题可以看到, 我们先用动态规划的思想解决, 继而发现可以增强条件,使用在动态规划基础上的贪心算法, 更高效的解决问题.贪心算法基础上有一个动态规划算法来证明其正确性,所以说安全的(能够取得最优解的).所以动态规划其实是“安全的贪心算法”的基础.无论如何,在每一个贪心算法的下面,几乎总是会有一个更加复杂的动态规划解.贪心算法实现简单速度快,但是证明贪心的正确性往往是很困难的,要在本已经较为复杂的动态规划证明上确定贪心的正确性.\n\n3.贪心算法的一般步骤:\n> 1. 将优化问题转化成这样的一个问题,即先做出选择(对应于动态规划的先解决子问题再选择),再解决剩下的一个子问题.\n> 2. 证明原问题总是有一个最优解是做贪心选择得到的,从而说明贪心选择的安全.\n> 3. 说明在做出贪心选择后,剩余的子问题具有这样的一个性质.即如果将子问题的最优解和我们所做的贪心选择联合起来,就可以得出原问题的一个最优解.\n\n> 正确使用贪心算法的2个关键要素:贪心选择性质 和最优子结构.\n> 1. **贪心选择性质**:一个全局最优解可以通过局部最优(贪心)选择来达到;即当考虑做何选择时,我们只考虑对当前问题最佳的选择而不考虑子问题的结果.\n> 2. **最优子结构**:一个问题的最优解包含了其子问题的最优解.\n\n> 对应的,要使用贪心算法就必须先证明以下两个性质:\n> 1. 每一步所做的贪心选择最终能产生一个全局最优解.在证明中先考察一个全局最优解,然后证明对该解加以修改,使其采用贪心选择,这个选择将原问题变为一个相似的、但更小的问题.\n> 2. 子问题的最优解与所做的贪心选择合并后,的确可以得到原问题的一个最优解.\n\n4.应用\n > 一般地,就算证明不出来贪心算法能给出最优解,但是它一般都至少能给出次优解.所以贪心算法在实际的应用中是非常的普及的.\n\n#### Chapter17 较复杂的操作怎样平摊到所有操作上?\n1.**平摊分析 amortized analysis**\n在平摊分析中,执行一系列数据结构操作所需要的时间是通过对执行所有操作所花费的时间求平均而得到的.平摊分析表明不能总以最坏情况来衡量算法,因为最坏的情况并不经常会发生,甚至在绝大多数应用中最坏情况出现的次数是极少的.\n> 平摊分析与平均情况分析的不同之处在于它不牵涉到概率;平摊分析保证在最坏情况下,每个操作具有平均性能.通过平摊分析,可以获得对某种特定数据结构的认识,这种认识有助于优化设计.\n一个例子是 `C++ STL` 中 `vector.push_back` 操作,一般情况下`push_back`追加到`vector`只需要复杂度$O(1)$, 但在`vector`达到容量限度时,`vector`先要动态扩展,然后`push_back`,复杂度升到$O(n)$,这种最坏情况出现次数相对于一般情况出现很少,对所有操作求平均后,每个`push_back`具有 $O(1)$的性能.\n\n2.平摊分析的三种方法:\n> * 聚集分析:指分析一系列操作的总时间的上节$T(n)$, 平均代价即为$T(n)/n$\n> * 记账法:对每次操作的对象进行预先记账,补偿实际代价高于帐的操作\n> * 势能方法:与记账法类似,但将每次预留的势能视为是整个数据结构共享的,整体维护\n\n\n3.**聚集分析: aggregate analysis**\n> 由N个操作所构成的序列的总时间在最坏的情况下为$T(n)$,则每个操作的平均代价(平摊代价)为$T(n)/n$.以前的时间复杂度分析都是以单次操作为对象的分析它的最坏时间复杂度,而聚集分析所分析的是N次操作的总时间的最坏情况.\n聚集分析:由序列的总最坏时间 -> 单次的平摊时间\n> 以`stack`的操作为例(增加一个操作`multipop`, 连续出栈)\n```\npush(S, x): O(1)\npop(S): O(1)\nmultipop(S, k): O(n)\n  while not stack-empty(S) and k != 0\n    do pop(s)\n      k <- k - 1\n```\n> 则n个包含`push`和`pop`的序列总代价为 $O(n)$ , 但加上复杂度为 $O(n)$ 的`multipop`操作后,应该如何计算?\n任意stack操作的最坏时间复杂度为$O(n)$, 故N个操作的代价是 $O(2^n)$.但这个界明显过大, 因为不可能出现连续n次`multipop`的情况.\n但从`pop`和`push`对应的角度考虑,\n因为一个对象入栈后最多出栈一次, 将`multipop`视为`pop`的连续操作\n所以`pop`的次数 $\\leq$ `push`的次数\nn个序列的总时间代价为$O(n)$,平均代价为$O(n)/n=O(1)$\n\n\n4.**记账法: bookkeeping method**\n> 对序列操作中的每一个操作收取一定的费用,当所收取的费用比它实际应支付的费用多时就把多余的部分当作存款(credit)存起来,一个操作的平摊代价可以看作两部分:实际代价和存款(或被储蓄或被用完).其要素为:\n> 1. 存款可以用来在以后补偿那些其平摊代价低于其实际代价的操作.\n> 2. 如果希望通过对平摊代价的分析来说明每次操作的最坏情况平均代价较小,则操作序列的总平摊代价就必须是该序列的总的实际代价的一个上界.因为平摊代价是最坏时的平均代价,即存款不能为负.\n> 3. 存款不能为负,因为记账法是不允许欠账的,否则就不能满足平摊代价是操作总时间的最坏情况的平均这个定义.\n\n> 对于前面的stack操作,各操作的实际代价和平摊代价如下:\n\n|操作             |实际代价         |平摊代价       |\n|----------------|----------------|------------- |\n|push            |1               |2             |\n|pop             |1               |0             |\n|multipop        |min(k, s)       |0             |\n> 平摊代价当每次入栈时记账支付2元,其中1元支付该`push`操作的实际代价,还有1元用于支付该元素被`pop`出来时的代价.则可以保证在任何时间内都不会有欠账,故`pop`操作可以不收取任何费用.\n\n\n5.**势能方法: potential method**\n> 将已预付的工作作为一种“势能”保存,它在需要时可以释放出来,以支付后面的操作.势能是与整个数据结构而不是其中的个别对象发生联系的.相对比, 记账法中的账与个别对象发生联系,比如栈操作时支付的2元就记在入栈的那个元素上)\n> \\begin{align}\n初始数据结构D\\_0, 记c\\_i为第i个操作的实际代价 \\\\\\\\\nD\\_i为数据结构D\\_{i-1}作用第i操作的的结果 \\\\\\\\\n势函数\\Phi: D\\_i \\mapsto \\Phi(D\\_i) \\\\\\\\\n平摊代价 \\hat{c\\_i} = c\\_i + \\Phi(D\\_i) - \\Phi(D\\_{i-1}) \\\\\\\\\n总平摊代价 \\sum\\_{i=1}^n\\hat{c\\_i} = \\sum\\_{i=1}^n(c\\_i + \\Phi(D\\_i) - \\Phi(D\\_{i-1})) = \\sum\\_{i=1}^n c\\_i + \\Phi(D\\_n) - \\Phi(D\\_0)\n\\end{align}\n\n> 仍然以`stack`操作为例,\n> \\begin{align}\n定义势函数\\Phi 为stack中对象个数 \\\\\\\\\n初始空stack D\\_0, \\Phi(D\\_0) = 0 \\\\\\\\\npush操作: \\\\\\\\\n\\hat{c\\_i} = c\\_i + \\Phi(D\\_i) - \\Phi(D\\_{i-1}) = 1 + (s+1) - s = 2 \\\\\\\\\nmultipop操作: \\\\\\\\\n\\hat{c\\_i} = c\\_i + \\Phi(D\\_i) - \\Phi(D\\_{i-1}) = k + (s -k) - s = 0 \\\\\\\\\n\\therefore 每一操作平摊代价为O(1) \\\\\\\\\n\\therefore n个操作最坏代价为O(n)\n\\end{align}\n","slug":"CLRS-notes3","published":1,"updated":"2017-08-26T03:38:21.610Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6sslhau00073gamluxzb7kq","content":"<h1 id=\"＜Introduction-to-algorithms＞笔记\"><a href=\"#＜Introduction-to-algorithms＞笔记\" class=\"headerlink\" title=\"＜Introduction to algorithms＞笔记\"></a>＜Introduction to algorithms＞笔记</h1><h3 id=\"Part4-高级设计和分析技术\"><a href=\"#Part4-高级设计和分析技术\" class=\"headerlink\" title=\"Part4 高级设计和分析技术\"></a>Part4 高级设计和分析技术</h3><p>part1-3中学习的普遍应用的算法思想和技术如下:</p>\n<ul>\n<li>分治法 divide and conquer</li>\n<li>随机化 randomize</li>\n<li>递归求解 recursion</li>\n</ul>\n<p>在面对一个计算问题时, 一般的直接解法是暴力破解,即穷举法.从一定意义上讲,所有的最优化问题都可以通过穷举法来解决,但是这在时间上是不可接受的.要更高效的求解问题, 需要学习对高效算法的设计分析技术<br>所有的高效算法都是为了加快速度:</p>\n<ol>\n<li>动态规划:保存子问题的解,以备重复使用</li>\n<li>贪心算法:用局部最优解来求全局最优解</li>\n<li>平摊分析是用来分析算法的工具,它本身并不是一种算法.</li>\n</ol>\n<ul>\n<li><p>动态规划 dynamic programming</p>\n<blockquote>\n<ul>\n<li>动态规划通常应用于最优化问题,即要做出一组选择以达到一个最优解时.在做选择的同时,经常出现同样形式的子问题.关键技术是存储这些子问题每一个的解,以备它重复出现.</li>\n</ul>\n</blockquote>\n</li>\n<li><p>贪心算法 greedy algorithm</p>\n<blockquote>\n<ul>\n<li>贪心算法通常也是应用于最优化问题,该算法的思想是以局部最优的方式来做每一个选择.采用贪心算法可以比动态规划更快地得出一个最优解,但是关键是不容易判断贪心算法所得到的是否真的是最优解.</li>\n</ul>\n</blockquote>\n</li>\n<li><p>平摊分析 amortized analysis</p>\n<blockquote>\n<ul>\n<li>平摊分析是一种用来分析执行一系列类似操作的算法的工具.在一个操作序列中,不可能每一个都以其已知的最坏情况运行,某些操作的代价高些,而其它的低一些.平摊分析不分别计算每一次操作的代价确定一系列代价的界,而是对整个操作序列的真实代价限界.</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<a id=\"more\"></a>\n<h4 id=\"Chapter15-如何利用已经计算出的子问题\"><a href=\"#Chapter15-如何利用已经计算出的子问题\" class=\"headerlink\" title=\"Chapter15 如何利用已经计算出的子问题?\"></a>Chapter15 如何利用已经计算出的子问题?</h4><p>1.动态规划与分治法之间的区别:</p>\n<ul>\n<li>分治法是指将问题分成一些独立的子问题,递归的求解各子问题,合并子问题得到原问题的解</li>\n<li>动态规划适用于这些子问题不是独立的情况,也就是各子问题包含公共子问题.<br>对公共子问题,分治法会重复的求解,而动态规划则是只求解一次,保存结果到一张表中,从而避免了重复计算.</li>\n</ul>\n<p>以斐波那契数列的计算fib(5)为例</p>\n<ul>\n<li>分治法计算如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">fib(n):</div><div class=\"line\">  return fib(n-1) + fib(n-2)</div><div class=\"line\">fib(5) = fib(4) + fib(3)</div><div class=\"line\">       = (fib(3) + fib(2)) + (fib(2) + fib(1))</div><div class=\"line\">       = ((fib(2) + fib(1)) + fib(2)) + (fib(2) + fib(1))</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>可以看到, fib(2)和fib(1)重复计算多次, 导致时间复杂度为$O(2^n)$</p>\n<ul>\n<li>动态规划计算如下<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">array Fib[];</div><div class=\"line\">Fib[1] = 1, Fib[2] = 1;</div><div class=\"line\">fib(n):</div><div class=\"line\">  if Fib(n) != 0</div><div class=\"line\">    return Fib(n)</div><div class=\"line\">    else return fib(n-1) + fib(n-2)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>每次计算的结果记录在Fib(n)中, 如果计算过程中需要直接取出记录即可, 减少了很多重复计算, 算法复杂度降为$O(n)$</p>\n<p>2.<strong>最优化问题</strong>:<br>具有多个可行的解, 每个解有一个值,具有最优(Max or Min)值的解是一个最优解.<br>动态规划多用于最优化问题, 其设计可以分为 4 个步骤:</p>\n<blockquote>\n<ol>\n<li>描述最优解的子结构</li>\n<li>递归定义最优解的值</li>\n<li>按自底向上的方法计算最优解的值</li>\n<li>由计算出的结果反向构造出一个最优解<br>动态规划最重要的是要找出最优解的子结构</li>\n</ol>\n</blockquote>\n<p>以解决<strong>矩阵链式乘法</strong>为例来梳理动态规划的步骤:</p>\n<blockquote>\n<p>1.问题背景:<br>给定n个矩阵构成的序列链 $(A_1, A_2, \\ldots, A_n)$, 计算乘积:<br>$$A_1 A_2 \\ldots A_n \\qquad (15.1)$$<br>要计算式(15.1), 考虑计算两个矩阵相乘的子程序<code>matrix-multiply(A, B)</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">matrix-multiply(A, B)</div><div class=\"line\">if columns[A] != rows[B]</div><div class=\"line\">  then error &quot;imcompatible dimensions&quot;</div><div class=\"line\">  else for i &lt;- 1 to rows[A]</div><div class=\"line\">    do for j &lt;- 1 to columns[B]</div><div class=\"line\">      do C[i, j] &lt;- 0</div><div class=\"line\">        for k &lt;- 1 to columns[A]</div><div class=\"line\">          do C[i, j] &lt;- C[i, j] + A[i, k] * B[k, j]</div></pre></td></tr></table></figure></p>\n<p>矩阵的乘积是按括号给出的计算顺序来计算的, 以矩阵链 $(A_1, A_2, A_3, A_4)$ 为例, 就有5种计算顺序:<br>\\begin{align}<br>(A_1(A_2(A_3A_4))) \\\\<br>(A_1((A_2A_3)A_4)) \\\\<br>…<br>\\end{align}<br>以标量乘法次数来衡量复杂度, 从<code>matrix-multiply(A, B)</code>得到,<br>A阶数p<em>q, B阶数q</em>r -&gt; 复杂度$O(pqr)$<br>不同的括号顺序导致的矩阵乘积代价不同, 如何求解最小化的代价(即最少的标量乘法次数)的方案?</p>\n<p>2.问题求解<br>如果穷举可能的全部括号方案,可以得到一个结果, 但显然代价太大.设P(n)为矩阵链的加括号方案数, 有:<br>$$<br>P(N) =<br>\\begin{cases}<br>1, \\text {if n = 1} \\\\<br>\\sum_{k=1}^{n=1}P(k)P(n-k),\\text {if n &gt;= 2}<br>\\end{cases}<br>$$<br>其复杂度为 $O(2^n)$,指数复杂度, 显然穷举搜索不是好的策略.<br>a. 最优子结构<br>\\begin{align}<br>记A_{i \\dots j} 为乘积A_iA_{i+1} \\dots A_j \\\\<br>对 i\\leq k &lt; j, 复杂度为 \\\\<br>O(A_{i \\dots j}) = O(A_{i \\dots k}) + O(A_{k+1 \\dots j}) + O(A_{i \\dots k} * A_{k+1 \\dots j}) \\\\<br>\\because 如果A_{k+1} \\dots A_j的最优加括号方案不是A_iA_{i+1} \\dots A_j的最优加括号方案的子链,\\\\<br>则用A_{k+1} \\dots A_j的最优加括号方案得到的O(A_{i \\dots j})更小 \\\\<br>\\therefore 最优子结构: \\\\<br>A_{k+1} \\dots A_j的最优加括号方案是A_iA_{i+1} \\dots A_j的最优加括号方案的子链<br>\\end{align}</p>\n<p>b. 递归求解<br>根据子问题的最优解递归定量定义最优解的代价<br>\\begin{align}<br>记m[i,j]为计算A_{i \\dots j}的标量乘法次数的最小值 \\\\<br>m[i, j] =<br>\\begin{cases}<br>0, \\text {if i = j} \\\\<br>min_{i \\leq k &lt; j}\\{m[i,k] + m[k+1,j] + p_{i-1} p_k p_j \\},else<br>\\end{cases}<br>记s[i, j] = k 为最优加括号方案的子链分裂点k<br>\\end{align}</p>\n<p>c. 计算最优代价<br>这个递归式在递归树的不同分支上会多次遇到同一子问题(即重复的矩阵子链,类似斐波那契数列的递归解法), 即有明显的<strong>公共子问题</strong>的特点.因此如果直接递归的求解递归式,会陷入对相同子链的重复计算,增加算法复杂度, 所以采用自底向上的表格法计算最优代价如下<br>\\begin{align}<br>设A_i的阶数p_{i-1}*p_i, i = 1,2,\\dots,n \\\\<br>则矩阵链[A_1, A_2, \\ldots, A_n的阶数序列记为 p=[p_0,p_1,\\dots,p_n] \\\\<br>表m[1\\dots n, 1\\dots n]记录m[i, j]的代价 \\\\<br>表s[1\\dots n, 1\\dots n]记录计算m[i,j]取得最优代价的k值 \\\\<br>\\end{align}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">matrix-chain-order(p)</div><div class=\"line\">  n &lt;- length[p] - 1 # 矩阵链长度n</div><div class=\"line\">  for i &lt;- 1 to n</div><div class=\"line\">    do m[i,i] &lt;- 0 #长度为1的链代价为0</div><div class=\"line\">  for l &lt;- 2 to n #计算长度为l的链的代价</div><div class=\"line\">    do for i &lt;- 1 to n - l + 1</div><div class=\"line\">      do j &lt;- i + l - 1</div><div class=\"line\">        m[i,j] &lt;- INT</div><div class=\"line\">        for k &lt;- i to j - 1</div><div class=\"line\">          do q &lt;- m[i,k] + m[k+1,j] + p(i-1)p(k)p(j)</div><div class=\"line\">            if q &lt; m[i,j]</div><div class=\"line\">              then m[i,j] &lt;- q;s[i,j] &lt;- k</div><div class=\"line\">  return m and s</div></pre></td></tr></table></figure></p>\n<p><code>matrix-chain-order</code>算法从长度为1的链开始循环计算, 每次计算m[i,j]时仅依赖于已经计算出的m[i,k]和m[k+1,j], 这正是核存储公共子问题的解,以减少重复计算的核心方法.</p>\n<p>d. 构造最优解<br>  <code>matirx-chain-order</code>计算了最少的标量乘法次数,但并没有给出如何加括号确定矩阵相乘的方案.此时s[i,j]发挥作用,知按最优方案计算$A_{1 \\dots n}$, 最后一步递归的子链相乘次序是$A_{1 \\dots s[1,n]}A_{s[1,n]+1 \\dots n}$, 之前的则递归的进行.递归输出最优方案的算法如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">print-optimal-parens(s, i, j)</div><div class=\"line\">  if i = j</div><div class=\"line\">    then print &quot;A&quot;(i)</div><div class=\"line\">    else print &quot;(&quot;</div><div class=\"line\">      print-optimal-parens(s, i, s[i,j])</div><div class=\"line\">      print-optimal-parens(s, s[i,j]+1, j)</div><div class=\"line\">      print &quot;)&quot;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>3.<strong>动态规划基础</strong><br>从矩阵链乘法问题我们可以归纳,采用动态规划方法求解最优化问题的两个要素:</p>\n<ul>\n<li><strong>最优子结构 Optimal substructure</strong></li>\n</ul>\n<blockquote>\n<p>如果问题的一个最优解中包含了子问题的最优解,则该问题具有最优子结构;而当一个问题具有最优子结构时,提示我们动态规划可能会适用.在矩阵链乘法问题中,$A_iA_{i+1} \\dots A_j$的最优加括号方案就包括了$A_iA_{i+1} \\dots A_k$和$A_kA_{k+1} \\dots A_j$这两个自问的最优解.<br>那么如何寻找最优子结构?有下面的模式可以遵循:</p>\n<ol>\n<li>问题的解一般是一种决策或选择.矩阵链乘法问题即选择在哪里分裂矩阵链</li>\n<li>对给定的问题,假设已知的是一个导致最优解的选择</li>\n<li>已知这个选择后,确定子问题,和如何描述子问题</li>\n<li>使用剪贴技术(cut and paste)用来证明在问题的一个最优解中,使用的子</li>\n</ol>\n<p>问题的解本身也必须是最优的.即用反证法,”剪除”非最优问题的解再”贴上”最优解,证明可以得到原问题的更好的解,与假设已经得到的最优解相矛盾.<br>最优子结构在问题域中以两种方式变化(在找出这两个问题的解之后,构造出原问题的最优子结构往往就不是难事了):</p>\n<ol>\n<li>有多少个子问题被用在原问题的一个最优解中</li>\n<li>在决定一个最优解中使用哪些子问题有多少个选择</li>\n</ol>\n<p>非正式地:一个动态规划算法的运行时间依赖于两个因素的乘积:子问题的总个数和每个子问题中有多少种选择.问题解的代价通常是子问题的代价加上选择本身带来的开销.例如,在矩阵链乘法问题中,选择矩阵$A_k$分裂为子链, 再加上选择的代价$p_{i-1}p_kp_j$.<br>动态规划能够消除重复计算子问题是因为它与普通递归相反,它是通过自下而上的方式来进行求解的.动态规划正是一个递归的反向展开的过程:<br>在满足1.最优子结构 2.重叠子问题这2个条件下,通过把递归从下至上的进行展开以避免重复计算子问题从而加速了最终问题的求解的过程.<br><strong>注</strong>: 在不能应用最优子结构的时间,就一定不能假设它能够应用.</p>\n</blockquote>\n<ul>\n<li><strong>重叠子问题 Overlapping subproblems</strong></li>\n</ul>\n<blockquote>\n<p>最优化问题要求解原问题的递归算法可反复解同样的子问题,而不是产生新的子问题.<br>一般的,不同的子问题的数目是输入规模的一个多项式.这样,动态规划算法才能充分利用重叠的子问题,减少计算量.即通过每个子问题只解一次,把解保存在一个需要时就可以查看的表中,而每次查表只需要常数时间.<br>如在矩阵链乘法中,<code>matrix-chain-order</code>解更大问题时,反复取出较小的子问题.比如m[3,4]计算被使用四次:在计算m[2,4],m[1,4],m[3,5]和m[3,6]被使用.相比较的,如果采用低效率的递归程序产生的递归树,反复计算m[i,j],导致复杂度骤升到$O(2^n)$<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">recursive-matirc-chain(p, i, j)</div><div class=\"line\">  if i = j</div><div class=\"line\">    then return 0</div><div class=\"line\">  m[i,j] &lt;- INT</div><div class=\"line\">  for k &lt;- i to j - 1</div><div class=\"line\">    do q &lt;- recursive-matirc-chain(p, i, k) + recursive-matirc-chain(p, k+1, j) + p(i-1)p(k)p(i)</div><div class=\"line\">    if q &lt; m[i, j]</div><div class=\"line\">      then m[i,j] &lt;- q</div><div class=\"line\">  return m[i,j]</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>4.<strong>备忘录方法 memorandum method</strong></p>\n<blockquote>\n<p>备忘录方法:这种方法是动态规划的一个变形,它本质上与动态规划相同,但是比动态规划更好理解.步骤如下:</p>\n<ol>\n<li>使用普通的递归结构,自上而下的解决问题.</li>\n<li>当在递归算法的执行中每一次遇到一个子问题时,就计算它的解并填入一个表中.以后每次遇到该子问题时,只要查看并返回表中先前填入的值即可.</li>\n</ol>\n<p>从这段描述可以看出:动态规划与递归时做备忘录的本质是完全相同的,所以说备忘录方法与普通的动态递归本质完全相同,没有孰优孰劣之分,哪个方便用哪个.</p>\n<p>从备忘录方法求解矩阵链问题如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">memoized-matirx-chain(p)</div><div class=\"line\">  n &lt;- length[p] - 1</div><div class=\"line\">  for i &lt;- i to n</div><div class=\"line\">    do for j &lt;- i to n</div><div class=\"line\">      do m[i,j] &lt;- INT</div><div class=\"line\">  return lookup-chain(p, 1, n)</div><div class=\"line\"></div><div class=\"line\">#查表</div><div class=\"line\">lookup-chain(p, i, j)</div><div class=\"line\">  if m[i,j] &lt; INT</div><div class=\"line\">    then return m[i,j]</div><div class=\"line\">  if i = j</div><div class=\"line\">    then m[i,j] &lt;- 0</div><div class=\"line\">    else for k &lt;- i to j - 1</div><div class=\"line\">      do q &lt;- lookup-chain(p,i,k) + lookup-chain(p,k+1,j)+p(i-1)p(k)p(j)</div><div class=\"line\">      if q &lt; m[i,j]</div><div class=\"line\">        then m[i,j] &lt;- q</div><div class=\"line\">  return m[i,j]</div></pre></td></tr></table></figure></p>\n<p>备忘录方法与动态递归方法的比较:</p>\n<ol>\n<li>如果所有的子问题都至少要被计算一次,则一个自底向上的动态规划算法通常比一个自顶向下的做备忘录算法好出一个常数因子.因为动态规划没有使用递归的代价,只用到了循环,所以常数因子肯定比递归要好一些.</li>\n<li>此外,在有些问题中,还可以用动态规划算法中的表存取模式来进一步的减少时间和空间上的需求;或者,如果子问题中<br>的某些子问题根本没有必须求解,做备忘录的方法有着只解那些肯定要求解的子问题的优点.(而且这点是自动获得的,那些不必要计算的子问题在备忘录方法中会被自动的抛弃)</li>\n</ol>\n<p>备忘录方法总结:由“是否所有的子问题都至少需要被计算一次”来决定使用动态规划还是备忘录.这两种方法没孰优孰劣之分,因为它们的本质思想是完全一样的;消除重复子问题.</p>\n</blockquote>\n<h4 id=\"Chapter16-局部最优能得到全局最优吗\"><a href=\"#Chapter16-局部最优能得到全局最优吗\" class=\"headerlink\" title=\"Chapter16 局部最优能得到全局最优吗?\"></a>Chapter16 局部最优能得到全局最优吗?</h4><p>最优化问题如果采用动态规划可能设计分析过于复杂,这时可以选择贪心算法.<br>贪心算法使所作的选择看起来都是当前最佳的,期望通所做的局部最优选择来产生一个全局最优解.对算法中的每一个决策点,做一个当时看起来是最佳的选择,这种启发式策略并不是总能产生最优解的.</p>\n<p>1.活动选择问题</p>\n<blockquote>\n<p>有一个需要使用每个资源的n个活动组成的集合$S= {a_1,a_2,\\dots,a_n}$,资源每次只能由一个活动使用.每个活动$a_i$都有一个开始时间$s_i$和结束时间$f_i$,且 $0 &lt; s_i &lt; f_i &lt; \\infty$.一旦被选择后,活动$a_i$就占据半开时间区间 $[s_i,f_i)$ .如果 $[s_i,f_i] [s_j,f_j)$ 互不重叠,则称 $a_i$和 $a_j$两个活动是兼容的.该问题就是要找出一个由互相兼容的活动组成的最大子集.<br>动态规划与贪心求解该问题<br>a. 最优子结构<br>子问题空间:<br>$$S_{ij} = \\{a_k \\in S: f_i \\leq s_k &lt; f_k \\leq s_j \\}$$<br>定义子问题解空间 $S_{ij}$ 是S的子集,其中的每个获得都是互相兼容的.即每个活动都是在 $a_i$ 结束之后开始,且在 $a_i$ 开始之前结束.为了方便计算,添加两个虚构活动 $a_0$ 和 $a_{n+1}$ ,其中$f_0=0,s_{n+1}= \\infty$.<br>按活动结束时间单调递增排序<br>$$f_0 \\leq f_1 \\leq \\dots \\leq f_n \\leq f_{n+1}$$<br>可以得到：当$i \\geq j$时,$S_{i,j}$ 为空集.如果活动按照结束时间单调递增排序,子问题空间被用来从 $S_{i,j}$ 中选择最大兼容活动子集,其中 $0≤i＜j≤n+1$,所以其他的 $S_{i,j}$ 都是空集.<br>最优子结构为:假设 $S_{ij}$ 的最优解 $A_{ij}$ 包含活动 $a_k$,则对 $S_{ik}$ 的解 $A_{ik}$ 和 $S_{kj}$ 的解 $A_{kj}$ 必定是最优的.通过一个活动 $a_k$ 将问题分成两个子问题,下面的公式可以计算出$S_{ij}$的解 $A_{ij}$:<br>$$A_{ij} = A_{ik} \\bigcup \\{a_k\\} \\bigcup A_{kj}$$</p>\n<p>b.一个递归解<br>设c[i, j]为 $S_{ij}$ 中最大兼容子集中的活动数目,当 $S_{ij}$ 为空集时,c[i, j]=0；当$S_{ij}$非空时,若 $a_k$ 在 $S_{ij}$ 的最大兼容子集中被使用,则则问题 $S_{ik}$ 和 $S_{kj}$ 的最大兼容子集也被使用,故可得到$c[i, j] = c[i, k] + c[k, j] + 1$<br>故有<br>$$<br>c[i, j] =<br>\\begin{cases}<br>0, if \\, S_{ij} = \\emptyset \\\\<br>max_{i&lt;k&lt;j}\\{c[i,k]+c[j,k]+1\\},else<br>\\end{cases}$$</p>\n<p>c.最优解计算过程<br>采用动态规划可以直接解决,但针对活动选择问题可以有效简化，认真分析可以得出以下定理：对于任意非空子问题 $S_{ij}$ ，设 $a_m$ 是 $S_{ij}$ 中具有最早结束时间的活动,<br>$$f_m = min \\{ f_k: a_k \\in  S_{ij} \\}$$<br>有:</p>\n<ol>\n<li>$a_m$ 在 $S_{ij}$ 中的某最大兼容活动子集中被使用.</li>\n<li>$S_{im}$ 为空，所以选择 $a_m$ 将使子问题 $S_{mj}$ 为唯一可能非空的子问题.</li>\n</ol>\n<p>有这个定理，就简化了问题，使得最优解中只使用一个子问题，在解决子问题 $S_{ij}$ 时，在 $S_{ij}$ 中选择最早结束时间的那个活动.这样的贪心决策,使得剩下的,未调度的时间最大化.<br>贪心算法自顶向下地解决每个问题，解决子问题 $S_{ij}$ ，先找到 $S_{ij}$ 中最早结束的活动 $a_m$ ，然后将 $a_m$ 添加到最优解活动集合中，再来解决子问题 $S_{mj}$ .<br>递归解法如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">recursive-activity-selector(s, f, i, j)</div><div class=\"line\">  m &lt;- i + 1</div><div class=\"line\">  while m &lt; j and s(m) &lt; f(i)</div><div class=\"line\">    do m &lt;- m + 1</div><div class=\"line\">  if m &lt; j</div><div class=\"line\">    then return &#123;a(m)&#125; and recursive-activity-selector(s, f, m, j)</div><div class=\"line\">    else return none</div></pre></td></tr></table></figure></p>\n<p>根据尾递归的形式转化为迭代算法:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">greedy-activity-selector(s, f)</div><div class=\"line\">  n &lt;- length[s]</div><div class=\"line\">  A &lt;- &#123;a(i)&#125;</div><div class=\"line\">  i &lt;- 1</div><div class=\"line\">  for m &lt;- 2 to n</div><div class=\"line\">    do if s(m) &gt; f(i)</div><div class=\"line\">      then A &lt;- A and &#123;a(m)&#125;</div><div class=\"line\">        i &lt;- m</div><div class=\"line\">  return A</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>2.动态规划与贪心的关系</p>\n<blockquote>\n<p>从活动选择问题可以看到, 我们先用动态规划的思想解决, 继而发现可以增强条件,使用在动态规划基础上的贪心算法, 更高效的解决问题.贪心算法基础上有一个动态规划算法来证明其正确性,所以说安全的(能够取得最优解的).所以动态规划其实是“安全的贪心算法”的基础.无论如何,在每一个贪心算法的下面,几乎总是会有一个更加复杂的动态规划解.贪心算法实现简单速度快,但是证明贪心的正确性往往是很困难的,要在本已经较为复杂的动态规划证明上确定贪心的正确性.</p>\n</blockquote>\n<p>3.贪心算法的一般步骤:</p>\n<blockquote>\n<ol>\n<li>将优化问题转化成这样的一个问题,即先做出选择(对应于动态规划的先解决子问题再选择),再解决剩下的一个子问题.</li>\n<li>证明原问题总是有一个最优解是做贪心选择得到的,从而说明贪心选择的安全.</li>\n<li>说明在做出贪心选择后,剩余的子问题具有这样的一个性质.即如果将子问题的最优解和我们所做的贪心选择联合起来,就可以得出原问题的一个最优解.</li>\n</ol>\n<p>正确使用贪心算法的2个关键要素:贪心选择性质 和最优子结构.</p>\n<ol>\n<li><strong>贪心选择性质</strong>:一个全局最优解可以通过局部最优(贪心)选择来达到;即当考虑做何选择时,我们只考虑对当前问题最佳的选择而不考虑子问题的结果.</li>\n<li><strong>最优子结构</strong>:一个问题的最优解包含了其子问题的最优解.</li>\n</ol>\n<p>对应的,要使用贪心算法就必须先证明以下两个性质:</p>\n<ol>\n<li>每一步所做的贪心选择最终能产生一个全局最优解.在证明中先考察一个全局最优解,然后证明对该解加以修改,使其采用贪心选择,这个选择将原问题变为一个相似的、但更小的问题.</li>\n<li>子问题的最优解与所做的贪心选择合并后,的确可以得到原问题的一个最优解.</li>\n</ol>\n</blockquote>\n<p>4.应用</p>\n<blockquote>\n<p>一般地,就算证明不出来贪心算法能给出最优解,但是它一般都至少能给出次优解.所以贪心算法在实际的应用中是非常的普及的.</p>\n</blockquote>\n<h4 id=\"Chapter17-较复杂的操作怎样平摊到所有操作上\"><a href=\"#Chapter17-较复杂的操作怎样平摊到所有操作上\" class=\"headerlink\" title=\"Chapter17 较复杂的操作怎样平摊到所有操作上?\"></a>Chapter17 较复杂的操作怎样平摊到所有操作上?</h4><p>1.<strong>平摊分析 amortized analysis</strong><br>在平摊分析中,执行一系列数据结构操作所需要的时间是通过对执行所有操作所花费的时间求平均而得到的.平摊分析表明不能总以最坏情况来衡量算法,因为最坏的情况并不经常会发生,甚至在绝大多数应用中最坏情况出现的次数是极少的.</p>\n<blockquote>\n<p>平摊分析与平均情况分析的不同之处在于它不牵涉到概率;平摊分析保证在最坏情况下,每个操作具有平均性能.通过平摊分析,可以获得对某种特定数据结构的认识,这种认识有助于优化设计.<br>一个例子是 <code>C++ STL</code> 中 <code>vector.push_back</code> 操作,一般情况下<code>push_back</code>追加到<code>vector</code>只需要复杂度$O(1)$, 但在<code>vector</code>达到容量限度时,<code>vector</code>先要动态扩展,然后<code>push_back</code>,复杂度升到$O(n)$,这种最坏情况出现次数相对于一般情况出现很少,对所有操作求平均后,每个<code>push_back</code>具有 $O(1)$的性能.</p>\n</blockquote>\n<p>2.平摊分析的三种方法:</p>\n<blockquote>\n<ul>\n<li>聚集分析:指分析一系列操作的总时间的上节$T(n)$, 平均代价即为$T(n)/n$</li>\n<li>记账法:对每次操作的对象进行预先记账,补偿实际代价高于帐的操作</li>\n<li>势能方法:与记账法类似,但将每次预留的势能视为是整个数据结构共享的,整体维护</li>\n</ul>\n</blockquote>\n<p>3.<strong>聚集分析: aggregate analysis</strong></p>\n<blockquote>\n<p>由N个操作所构成的序列的总时间在最坏的情况下为$T(n)$,则每个操作的平均代价(平摊代价)为$T(n)/n$.以前的时间复杂度分析都是以单次操作为对象的分析它的最坏时间复杂度,而聚集分析所分析的是N次操作的总时间的最坏情况.<br>聚集分析:由序列的总最坏时间 -&gt; 单次的平摊时间<br>以<code>stack</code>的操作为例(增加一个操作<code>multipop</code>, 连续出栈)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">push(S, x): O(1)</div><div class=\"line\">pop(S): O(1)</div><div class=\"line\">multipop(S, k): O(n)</div><div class=\"line\">  while not stack-empty(S) and k != 0</div><div class=\"line\">    do pop(s)</div><div class=\"line\">      k &lt;- k - 1</div></pre></td></tr></table></figure></p>\n<p>则n个包含<code>push</code>和<code>pop</code>的序列总代价为 $O(n)$ , 但加上复杂度为 $O(n)$ 的<code>multipop</code>操作后,应该如何计算?<br>任意stack操作的最坏时间复杂度为$O(n)$, 故N个操作的代价是 $O(2^n)$.但这个界明显过大, 因为不可能出现连续n次<code>multipop</code>的情况.<br>但从<code>pop</code>和<code>push</code>对应的角度考虑,<br>因为一个对象入栈后最多出栈一次, 将<code>multipop</code>视为<code>pop</code>的连续操作<br>所以<code>pop</code>的次数 $\\leq$ <code>push</code>的次数<br>n个序列的总时间代价为$O(n)$,平均代价为$O(n)/n=O(1)$</p>\n</blockquote>\n<p>4.<strong>记账法: bookkeeping method</strong></p>\n<blockquote>\n<p>对序列操作中的每一个操作收取一定的费用,当所收取的费用比它实际应支付的费用多时就把多余的部分当作存款(credit)存起来,一个操作的平摊代价可以看作两部分:实际代价和存款(或被储蓄或被用完).其要素为:</p>\n<ol>\n<li>存款可以用来在以后补偿那些其平摊代价低于其实际代价的操作.</li>\n<li>如果希望通过对平摊代价的分析来说明每次操作的最坏情况平均代价较小,则操作序列的总平摊代价就必须是该序列的总的实际代价的一个上界.因为平摊代价是最坏时的平均代价,即存款不能为负.</li>\n<li>存款不能为负,因为记账法是不允许欠账的,否则就不能满足平摊代价是操作总时间的最坏情况的平均这个定义.</li>\n</ol>\n<p>对于前面的stack操作,各操作的实际代价和平摊代价如下:</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>实际代价</th>\n<th>平摊代价</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>push</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>pop</td>\n<td>1</td>\n<td>0</td>\n</tr>\n<tr>\n<td>multipop</td>\n<td>min(k, s)</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>平摊代价当每次入栈时记账支付2元,其中1元支付该<code>push</code>操作的实际代价,还有1元用于支付该元素被<code>pop</code>出来时的代价.则可以保证在任何时间内都不会有欠账,故<code>pop</code>操作可以不收取任何费用.</p>\n</blockquote>\n<p>5.<strong>势能方法: potential method</strong></p>\n<blockquote>\n<p>将已预付的工作作为一种“势能”保存,它在需要时可以释放出来,以支付后面的操作.势能是与整个数据结构而不是其中的个别对象发生联系的.相对比, 记账法中的账与个别对象发生联系,比如栈操作时支付的2元就记在入栈的那个元素上)<br>\\begin{align}<br>初始数据结构D_0, 记c_i为第i个操作的实际代价 \\\\<br>D_i为数据结构D_{i-1}作用第i操作的的结果 \\\\<br>势函数\\Phi: D_i \\mapsto \\Phi(D_i) \\\\<br>平摊代价 \\hat{c_i} = c_i + \\Phi(D_i) - \\Phi(D_{i-1}) \\\\<br>总平摊代价 \\sum_{i=1}^n\\hat{c_i} = \\sum_{i=1}^n(c_i + \\Phi(D_i) - \\Phi(D_{i-1})) = \\sum_{i=1}^n c_i + \\Phi(D_n) - \\Phi(D_0)<br>\\end{align}</p>\n<p>仍然以<code>stack</code>操作为例,<br>\\begin{align}<br>定义势函数\\Phi 为stack中对象个数 \\\\<br>初始空stack D_0, \\Phi(D_0) = 0 \\\\<br>push操作: \\\\<br>\\hat{c_i} = c_i + \\Phi(D_i) - \\Phi(D_{i-1}) = 1 + (s+1) - s = 2 \\\\<br>multipop操作: \\\\<br>\\hat{c_i} = c_i + \\Phi(D_i) - \\Phi(D_{i-1}) = k + (s -k) - s = 0 \\\\<br>\\therefore 每一操作平摊代价为O(1) \\\\<br>\\therefore n个操作最坏代价为O(n)<br>\\end{align}</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"＜Introduction-to-algorithms＞笔记\"><a href=\"#＜Introduction-to-algorithms＞笔记\" class=\"headerlink\" title=\"＜Introduction to algorithms＞笔记\"></a>＜Introduction to algorithms＞笔记</h1><h3 id=\"Part4-高级设计和分析技术\"><a href=\"#Part4-高级设计和分析技术\" class=\"headerlink\" title=\"Part4 高级设计和分析技术\"></a>Part4 高级设计和分析技术</h3><p>part1-3中学习的普遍应用的算法思想和技术如下:</p>\n<ul>\n<li>分治法 divide and conquer</li>\n<li>随机化 randomize</li>\n<li>递归求解 recursion</li>\n</ul>\n<p>在面对一个计算问题时, 一般的直接解法是暴力破解,即穷举法.从一定意义上讲,所有的最优化问题都可以通过穷举法来解决,但是这在时间上是不可接受的.要更高效的求解问题, 需要学习对高效算法的设计分析技术<br>所有的高效算法都是为了加快速度:</p>\n<ol>\n<li>动态规划:保存子问题的解,以备重复使用</li>\n<li>贪心算法:用局部最优解来求全局最优解</li>\n<li>平摊分析是用来分析算法的工具,它本身并不是一种算法.</li>\n</ol>\n<ul>\n<li><p>动态规划 dynamic programming</p>\n<blockquote>\n<ul>\n<li>动态规划通常应用于最优化问题,即要做出一组选择以达到一个最优解时.在做选择的同时,经常出现同样形式的子问题.关键技术是存储这些子问题每一个的解,以备它重复出现.</li>\n</ul>\n</blockquote>\n</li>\n<li><p>贪心算法 greedy algorithm</p>\n<blockquote>\n<ul>\n<li>贪心算法通常也是应用于最优化问题,该算法的思想是以局部最优的方式来做每一个选择.采用贪心算法可以比动态规划更快地得出一个最优解,但是关键是不容易判断贪心算法所得到的是否真的是最优解.</li>\n</ul>\n</blockquote>\n</li>\n<li><p>平摊分析 amortized analysis</p>\n<blockquote>\n<ul>\n<li>平摊分析是一种用来分析执行一系列类似操作的算法的工具.在一个操作序列中,不可能每一个都以其已知的最坏情况运行,某些操作的代价高些,而其它的低一些.平摊分析不分别计算每一次操作的代价确定一系列代价的界,而是对整个操作序列的真实代价限界.</li>\n</ul>\n</blockquote>\n</li>\n</ul>","more":"<h4 id=\"Chapter15-如何利用已经计算出的子问题\"><a href=\"#Chapter15-如何利用已经计算出的子问题\" class=\"headerlink\" title=\"Chapter15 如何利用已经计算出的子问题?\"></a>Chapter15 如何利用已经计算出的子问题?</h4><p>1.动态规划与分治法之间的区别:</p>\n<ul>\n<li>分治法是指将问题分成一些独立的子问题,递归的求解各子问题,合并子问题得到原问题的解</li>\n<li>动态规划适用于这些子问题不是独立的情况,也就是各子问题包含公共子问题.<br>对公共子问题,分治法会重复的求解,而动态规划则是只求解一次,保存结果到一张表中,从而避免了重复计算.</li>\n</ul>\n<p>以斐波那契数列的计算fib(5)为例</p>\n<ul>\n<li>分治法计算如下:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">fib(n):</div><div class=\"line\">  return fib(n-1) + fib(n-2)</div><div class=\"line\">fib(5) = fib(4) + fib(3)</div><div class=\"line\">       = (fib(3) + fib(2)) + (fib(2) + fib(1))</div><div class=\"line\">       = ((fib(2) + fib(1)) + fib(2)) + (fib(2) + fib(1))</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>可以看到, fib(2)和fib(1)重复计算多次, 导致时间复杂度为$O(2^n)$</p>\n<ul>\n<li>动态规划计算如下<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">array Fib[];</div><div class=\"line\">Fib[1] = 1, Fib[2] = 1;</div><div class=\"line\">fib(n):</div><div class=\"line\">  if Fib(n) != 0</div><div class=\"line\">    return Fib(n)</div><div class=\"line\">    else return fib(n-1) + fib(n-2)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>每次计算的结果记录在Fib(n)中, 如果计算过程中需要直接取出记录即可, 减少了很多重复计算, 算法复杂度降为$O(n)$</p>\n<p>2.<strong>最优化问题</strong>:<br>具有多个可行的解, 每个解有一个值,具有最优(Max or Min)值的解是一个最优解.<br>动态规划多用于最优化问题, 其设计可以分为 4 个步骤:</p>\n<blockquote>\n<ol>\n<li>描述最优解的子结构</li>\n<li>递归定义最优解的值</li>\n<li>按自底向上的方法计算最优解的值</li>\n<li>由计算出的结果反向构造出一个最优解<br>动态规划最重要的是要找出最优解的子结构</li>\n</ol>\n</blockquote>\n<p>以解决<strong>矩阵链式乘法</strong>为例来梳理动态规划的步骤:</p>\n<blockquote>\n<p>1.问题背景:<br>给定n个矩阵构成的序列链 $(A_1, A_2, \\ldots, A_n)$, 计算乘积:<br>$$A_1 A_2 \\ldots A_n \\qquad (15.1)$$<br>要计算式(15.1), 考虑计算两个矩阵相乘的子程序<code>matrix-multiply(A, B)</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">matrix-multiply(A, B)</div><div class=\"line\">if columns[A] != rows[B]</div><div class=\"line\">  then error &quot;imcompatible dimensions&quot;</div><div class=\"line\">  else for i &lt;- 1 to rows[A]</div><div class=\"line\">    do for j &lt;- 1 to columns[B]</div><div class=\"line\">      do C[i, j] &lt;- 0</div><div class=\"line\">        for k &lt;- 1 to columns[A]</div><div class=\"line\">          do C[i, j] &lt;- C[i, j] + A[i, k] * B[k, j]</div></pre></td></tr></table></figure></p>\n<p>矩阵的乘积是按括号给出的计算顺序来计算的, 以矩阵链 $(A_1, A_2, A_3, A_4)$ 为例, 就有5种计算顺序:<br>\\begin{align}<br>(A_1(A_2(A_3A_4))) \\\\<br>(A_1((A_2A_3)A_4)) \\\\<br>…<br>\\end{align}<br>以标量乘法次数来衡量复杂度, 从<code>matrix-multiply(A, B)</code>得到,<br>A阶数p<em>q, B阶数q</em>r -&gt; 复杂度$O(pqr)$<br>不同的括号顺序导致的矩阵乘积代价不同, 如何求解最小化的代价(即最少的标量乘法次数)的方案?</p>\n<p>2.问题求解<br>如果穷举可能的全部括号方案,可以得到一个结果, 但显然代价太大.设P(n)为矩阵链的加括号方案数, 有:<br>$$<br>P(N) =<br>\\begin{cases}<br>1, \\text {if n = 1} \\\\<br>\\sum_{k=1}^{n=1}P(k)P(n-k),\\text {if n &gt;= 2}<br>\\end{cases}<br>$$<br>其复杂度为 $O(2^n)$,指数复杂度, 显然穷举搜索不是好的策略.<br>a. 最优子结构<br>\\begin{align}<br>记A_{i \\dots j} 为乘积A_iA_{i+1} \\dots A_j \\\\<br>对 i\\leq k &lt; j, 复杂度为 \\\\<br>O(A_{i \\dots j}) = O(A_{i \\dots k}) + O(A_{k+1 \\dots j}) + O(A_{i \\dots k} * A_{k+1 \\dots j}) \\\\<br>\\because 如果A_{k+1} \\dots A_j的最优加括号方案不是A_iA_{i+1} \\dots A_j的最优加括号方案的子链,\\\\<br>则用A_{k+1} \\dots A_j的最优加括号方案得到的O(A_{i \\dots j})更小 \\\\<br>\\therefore 最优子结构: \\\\<br>A_{k+1} \\dots A_j的最优加括号方案是A_iA_{i+1} \\dots A_j的最优加括号方案的子链<br>\\end{align}</p>\n<p>b. 递归求解<br>根据子问题的最优解递归定量定义最优解的代价<br>\\begin{align}<br>记m[i,j]为计算A_{i \\dots j}的标量乘法次数的最小值 \\\\<br>m[i, j] =<br>\\begin{cases}<br>0, \\text {if i = j} \\\\<br>min_{i \\leq k &lt; j}\\{m[i,k] + m[k+1,j] + p_{i-1} p_k p_j \\},else<br>\\end{cases}<br>记s[i, j] = k 为最优加括号方案的子链分裂点k<br>\\end{align}</p>\n<p>c. 计算最优代价<br>这个递归式在递归树的不同分支上会多次遇到同一子问题(即重复的矩阵子链,类似斐波那契数列的递归解法), 即有明显的<strong>公共子问题</strong>的特点.因此如果直接递归的求解递归式,会陷入对相同子链的重复计算,增加算法复杂度, 所以采用自底向上的表格法计算最优代价如下<br>\\begin{align}<br>设A_i的阶数p_{i-1}*p_i, i = 1,2,\\dots,n \\\\<br>则矩阵链[A_1, A_2, \\ldots, A_n的阶数序列记为 p=[p_0,p_1,\\dots,p_n] \\\\<br>表m[1\\dots n, 1\\dots n]记录m[i, j]的代价 \\\\<br>表s[1\\dots n, 1\\dots n]记录计算m[i,j]取得最优代价的k值 \\\\<br>\\end{align}<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">matrix-chain-order(p)</div><div class=\"line\">  n &lt;- length[p] - 1 # 矩阵链长度n</div><div class=\"line\">  for i &lt;- 1 to n</div><div class=\"line\">    do m[i,i] &lt;- 0 #长度为1的链代价为0</div><div class=\"line\">  for l &lt;- 2 to n #计算长度为l的链的代价</div><div class=\"line\">    do for i &lt;- 1 to n - l + 1</div><div class=\"line\">      do j &lt;- i + l - 1</div><div class=\"line\">        m[i,j] &lt;- INT</div><div class=\"line\">        for k &lt;- i to j - 1</div><div class=\"line\">          do q &lt;- m[i,k] + m[k+1,j] + p(i-1)p(k)p(j)</div><div class=\"line\">            if q &lt; m[i,j]</div><div class=\"line\">              then m[i,j] &lt;- q;s[i,j] &lt;- k</div><div class=\"line\">  return m and s</div></pre></td></tr></table></figure></p>\n<p><code>matrix-chain-order</code>算法从长度为1的链开始循环计算, 每次计算m[i,j]时仅依赖于已经计算出的m[i,k]和m[k+1,j], 这正是核存储公共子问题的解,以减少重复计算的核心方法.</p>\n<p>d. 构造最优解<br>  <code>matirx-chain-order</code>计算了最少的标量乘法次数,但并没有给出如何加括号确定矩阵相乘的方案.此时s[i,j]发挥作用,知按最优方案计算$A_{1 \\dots n}$, 最后一步递归的子链相乘次序是$A_{1 \\dots s[1,n]}A_{s[1,n]+1 \\dots n}$, 之前的则递归的进行.递归输出最优方案的算法如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">print-optimal-parens(s, i, j)</div><div class=\"line\">  if i = j</div><div class=\"line\">    then print &quot;A&quot;(i)</div><div class=\"line\">    else print &quot;(&quot;</div><div class=\"line\">      print-optimal-parens(s, i, s[i,j])</div><div class=\"line\">      print-optimal-parens(s, s[i,j]+1, j)</div><div class=\"line\">      print &quot;)&quot;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>3.<strong>动态规划基础</strong><br>从矩阵链乘法问题我们可以归纳,采用动态规划方法求解最优化问题的两个要素:</p>\n<ul>\n<li><strong>最优子结构 Optimal substructure</strong></li>\n</ul>\n<blockquote>\n<p>如果问题的一个最优解中包含了子问题的最优解,则该问题具有最优子结构;而当一个问题具有最优子结构时,提示我们动态规划可能会适用.在矩阵链乘法问题中,$A_iA_{i+1} \\dots A_j$的最优加括号方案就包括了$A_iA_{i+1} \\dots A_k$和$A_kA_{k+1} \\dots A_j$这两个自问的最优解.<br>那么如何寻找最优子结构?有下面的模式可以遵循:</p>\n<ol>\n<li>问题的解一般是一种决策或选择.矩阵链乘法问题即选择在哪里分裂矩阵链</li>\n<li>对给定的问题,假设已知的是一个导致最优解的选择</li>\n<li>已知这个选择后,确定子问题,和如何描述子问题</li>\n<li>使用剪贴技术(cut and paste)用来证明在问题的一个最优解中,使用的子</li>\n</ol>\n<p>问题的解本身也必须是最优的.即用反证法,”剪除”非最优问题的解再”贴上”最优解,证明可以得到原问题的更好的解,与假设已经得到的最优解相矛盾.<br>最优子结构在问题域中以两种方式变化(在找出这两个问题的解之后,构造出原问题的最优子结构往往就不是难事了):</p>\n<ol>\n<li>有多少个子问题被用在原问题的一个最优解中</li>\n<li>在决定一个最优解中使用哪些子问题有多少个选择</li>\n</ol>\n<p>非正式地:一个动态规划算法的运行时间依赖于两个因素的乘积:子问题的总个数和每个子问题中有多少种选择.问题解的代价通常是子问题的代价加上选择本身带来的开销.例如,在矩阵链乘法问题中,选择矩阵$A_k$分裂为子链, 再加上选择的代价$p_{i-1}p_kp_j$.<br>动态规划能够消除重复计算子问题是因为它与普通递归相反,它是通过自下而上的方式来进行求解的.动态规划正是一个递归的反向展开的过程:<br>在满足1.最优子结构 2.重叠子问题这2个条件下,通过把递归从下至上的进行展开以避免重复计算子问题从而加速了最终问题的求解的过程.<br><strong>注</strong>: 在不能应用最优子结构的时间,就一定不能假设它能够应用.</p>\n</blockquote>\n<ul>\n<li><strong>重叠子问题 Overlapping subproblems</strong></li>\n</ul>\n<blockquote>\n<p>最优化问题要求解原问题的递归算法可反复解同样的子问题,而不是产生新的子问题.<br>一般的,不同的子问题的数目是输入规模的一个多项式.这样,动态规划算法才能充分利用重叠的子问题,减少计算量.即通过每个子问题只解一次,把解保存在一个需要时就可以查看的表中,而每次查表只需要常数时间.<br>如在矩阵链乘法中,<code>matrix-chain-order</code>解更大问题时,反复取出较小的子问题.比如m[3,4]计算被使用四次:在计算m[2,4],m[1,4],m[3,5]和m[3,6]被使用.相比较的,如果采用低效率的递归程序产生的递归树,反复计算m[i,j],导致复杂度骤升到$O(2^n)$<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">recursive-matirc-chain(p, i, j)</div><div class=\"line\">  if i = j</div><div class=\"line\">    then return 0</div><div class=\"line\">  m[i,j] &lt;- INT</div><div class=\"line\">  for k &lt;- i to j - 1</div><div class=\"line\">    do q &lt;- recursive-matirc-chain(p, i, k) + recursive-matirc-chain(p, k+1, j) + p(i-1)p(k)p(i)</div><div class=\"line\">    if q &lt; m[i, j]</div><div class=\"line\">      then m[i,j] &lt;- q</div><div class=\"line\">  return m[i,j]</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>4.<strong>备忘录方法 memorandum method</strong></p>\n<blockquote>\n<p>备忘录方法:这种方法是动态规划的一个变形,它本质上与动态规划相同,但是比动态规划更好理解.步骤如下:</p>\n<ol>\n<li>使用普通的递归结构,自上而下的解决问题.</li>\n<li>当在递归算法的执行中每一次遇到一个子问题时,就计算它的解并填入一个表中.以后每次遇到该子问题时,只要查看并返回表中先前填入的值即可.</li>\n</ol>\n<p>从这段描述可以看出:动态规划与递归时做备忘录的本质是完全相同的,所以说备忘录方法与普通的动态递归本质完全相同,没有孰优孰劣之分,哪个方便用哪个.</p>\n<p>从备忘录方法求解矩阵链问题如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">memoized-matirx-chain(p)</div><div class=\"line\">  n &lt;- length[p] - 1</div><div class=\"line\">  for i &lt;- i to n</div><div class=\"line\">    do for j &lt;- i to n</div><div class=\"line\">      do m[i,j] &lt;- INT</div><div class=\"line\">  return lookup-chain(p, 1, n)</div><div class=\"line\"></div><div class=\"line\">#查表</div><div class=\"line\">lookup-chain(p, i, j)</div><div class=\"line\">  if m[i,j] &lt; INT</div><div class=\"line\">    then return m[i,j]</div><div class=\"line\">  if i = j</div><div class=\"line\">    then m[i,j] &lt;- 0</div><div class=\"line\">    else for k &lt;- i to j - 1</div><div class=\"line\">      do q &lt;- lookup-chain(p,i,k) + lookup-chain(p,k+1,j)+p(i-1)p(k)p(j)</div><div class=\"line\">      if q &lt; m[i,j]</div><div class=\"line\">        then m[i,j] &lt;- q</div><div class=\"line\">  return m[i,j]</div></pre></td></tr></table></figure></p>\n<p>备忘录方法与动态递归方法的比较:</p>\n<ol>\n<li>如果所有的子问题都至少要被计算一次,则一个自底向上的动态规划算法通常比一个自顶向下的做备忘录算法好出一个常数因子.因为动态规划没有使用递归的代价,只用到了循环,所以常数因子肯定比递归要好一些.</li>\n<li>此外,在有些问题中,还可以用动态规划算法中的表存取模式来进一步的减少时间和空间上的需求;或者,如果子问题中<br>的某些子问题根本没有必须求解,做备忘录的方法有着只解那些肯定要求解的子问题的优点.(而且这点是自动获得的,那些不必要计算的子问题在备忘录方法中会被自动的抛弃)</li>\n</ol>\n<p>备忘录方法总结:由“是否所有的子问题都至少需要被计算一次”来决定使用动态规划还是备忘录.这两种方法没孰优孰劣之分,因为它们的本质思想是完全一样的;消除重复子问题.</p>\n</blockquote>\n<h4 id=\"Chapter16-局部最优能得到全局最优吗\"><a href=\"#Chapter16-局部最优能得到全局最优吗\" class=\"headerlink\" title=\"Chapter16 局部最优能得到全局最优吗?\"></a>Chapter16 局部最优能得到全局最优吗?</h4><p>最优化问题如果采用动态规划可能设计分析过于复杂,这时可以选择贪心算法.<br>贪心算法使所作的选择看起来都是当前最佳的,期望通所做的局部最优选择来产生一个全局最优解.对算法中的每一个决策点,做一个当时看起来是最佳的选择,这种启发式策略并不是总能产生最优解的.</p>\n<p>1.活动选择问题</p>\n<blockquote>\n<p>有一个需要使用每个资源的n个活动组成的集合$S= {a_1,a_2,\\dots,a_n}$,资源每次只能由一个活动使用.每个活动$a_i$都有一个开始时间$s_i$和结束时间$f_i$,且 $0 &lt; s_i &lt; f_i &lt; \\infty$.一旦被选择后,活动$a_i$就占据半开时间区间 $[s_i,f_i)$ .如果 $[s_i,f_i] [s_j,f_j)$ 互不重叠,则称 $a_i$和 $a_j$两个活动是兼容的.该问题就是要找出一个由互相兼容的活动组成的最大子集.<br>动态规划与贪心求解该问题<br>a. 最优子结构<br>子问题空间:<br>$$S_{ij} = \\{a_k \\in S: f_i \\leq s_k &lt; f_k \\leq s_j \\}$$<br>定义子问题解空间 $S_{ij}$ 是S的子集,其中的每个获得都是互相兼容的.即每个活动都是在 $a_i$ 结束之后开始,且在 $a_i$ 开始之前结束.为了方便计算,添加两个虚构活动 $a_0$ 和 $a_{n+1}$ ,其中$f_0=0,s_{n+1}= \\infty$.<br>按活动结束时间单调递增排序<br>$$f_0 \\leq f_1 \\leq \\dots \\leq f_n \\leq f_{n+1}$$<br>可以得到：当$i \\geq j$时,$S_{i,j}$ 为空集.如果活动按照结束时间单调递增排序,子问题空间被用来从 $S_{i,j}$ 中选择最大兼容活动子集,其中 $0≤i＜j≤n+1$,所以其他的 $S_{i,j}$ 都是空集.<br>最优子结构为:假设 $S_{ij}$ 的最优解 $A_{ij}$ 包含活动 $a_k$,则对 $S_{ik}$ 的解 $A_{ik}$ 和 $S_{kj}$ 的解 $A_{kj}$ 必定是最优的.通过一个活动 $a_k$ 将问题分成两个子问题,下面的公式可以计算出$S_{ij}$的解 $A_{ij}$:<br>$$A_{ij} = A_{ik} \\bigcup \\{a_k\\} \\bigcup A_{kj}$$</p>\n<p>b.一个递归解<br>设c[i, j]为 $S_{ij}$ 中最大兼容子集中的活动数目,当 $S_{ij}$ 为空集时,c[i, j]=0；当$S_{ij}$非空时,若 $a_k$ 在 $S_{ij}$ 的最大兼容子集中被使用,则则问题 $S_{ik}$ 和 $S_{kj}$ 的最大兼容子集也被使用,故可得到$c[i, j] = c[i, k] + c[k, j] + 1$<br>故有<br>$$<br>c[i, j] =<br>\\begin{cases}<br>0, if \\, S_{ij} = \\emptyset \\\\<br>max_{i&lt;k&lt;j}\\{c[i,k]+c[j,k]+1\\},else<br>\\end{cases}$$</p>\n<p>c.最优解计算过程<br>采用动态规划可以直接解决,但针对活动选择问题可以有效简化，认真分析可以得出以下定理：对于任意非空子问题 $S_{ij}$ ，设 $a_m$ 是 $S_{ij}$ 中具有最早结束时间的活动,<br>$$f_m = min \\{ f_k: a_k \\in  S_{ij} \\}$$<br>有:</p>\n<ol>\n<li>$a_m$ 在 $S_{ij}$ 中的某最大兼容活动子集中被使用.</li>\n<li>$S_{im}$ 为空，所以选择 $a_m$ 将使子问题 $S_{mj}$ 为唯一可能非空的子问题.</li>\n</ol>\n<p>有这个定理，就简化了问题，使得最优解中只使用一个子问题，在解决子问题 $S_{ij}$ 时，在 $S_{ij}$ 中选择最早结束时间的那个活动.这样的贪心决策,使得剩下的,未调度的时间最大化.<br>贪心算法自顶向下地解决每个问题，解决子问题 $S_{ij}$ ，先找到 $S_{ij}$ 中最早结束的活动 $a_m$ ，然后将 $a_m$ 添加到最优解活动集合中，再来解决子问题 $S_{mj}$ .<br>递归解法如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">recursive-activity-selector(s, f, i, j)</div><div class=\"line\">  m &lt;- i + 1</div><div class=\"line\">  while m &lt; j and s(m) &lt; f(i)</div><div class=\"line\">    do m &lt;- m + 1</div><div class=\"line\">  if m &lt; j</div><div class=\"line\">    then return &#123;a(m)&#125; and recursive-activity-selector(s, f, m, j)</div><div class=\"line\">    else return none</div></pre></td></tr></table></figure></p>\n<p>根据尾递归的形式转化为迭代算法:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">greedy-activity-selector(s, f)</div><div class=\"line\">  n &lt;- length[s]</div><div class=\"line\">  A &lt;- &#123;a(i)&#125;</div><div class=\"line\">  i &lt;- 1</div><div class=\"line\">  for m &lt;- 2 to n</div><div class=\"line\">    do if s(m) &gt; f(i)</div><div class=\"line\">      then A &lt;- A and &#123;a(m)&#125;</div><div class=\"line\">        i &lt;- m</div><div class=\"line\">  return A</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>2.动态规划与贪心的关系</p>\n<blockquote>\n<p>从活动选择问题可以看到, 我们先用动态规划的思想解决, 继而发现可以增强条件,使用在动态规划基础上的贪心算法, 更高效的解决问题.贪心算法基础上有一个动态规划算法来证明其正确性,所以说安全的(能够取得最优解的).所以动态规划其实是“安全的贪心算法”的基础.无论如何,在每一个贪心算法的下面,几乎总是会有一个更加复杂的动态规划解.贪心算法实现简单速度快,但是证明贪心的正确性往往是很困难的,要在本已经较为复杂的动态规划证明上确定贪心的正确性.</p>\n</blockquote>\n<p>3.贪心算法的一般步骤:</p>\n<blockquote>\n<ol>\n<li>将优化问题转化成这样的一个问题,即先做出选择(对应于动态规划的先解决子问题再选择),再解决剩下的一个子问题.</li>\n<li>证明原问题总是有一个最优解是做贪心选择得到的,从而说明贪心选择的安全.</li>\n<li>说明在做出贪心选择后,剩余的子问题具有这样的一个性质.即如果将子问题的最优解和我们所做的贪心选择联合起来,就可以得出原问题的一个最优解.</li>\n</ol>\n<p>正确使用贪心算法的2个关键要素:贪心选择性质 和最优子结构.</p>\n<ol>\n<li><strong>贪心选择性质</strong>:一个全局最优解可以通过局部最优(贪心)选择来达到;即当考虑做何选择时,我们只考虑对当前问题最佳的选择而不考虑子问题的结果.</li>\n<li><strong>最优子结构</strong>:一个问题的最优解包含了其子问题的最优解.</li>\n</ol>\n<p>对应的,要使用贪心算法就必须先证明以下两个性质:</p>\n<ol>\n<li>每一步所做的贪心选择最终能产生一个全局最优解.在证明中先考察一个全局最优解,然后证明对该解加以修改,使其采用贪心选择,这个选择将原问题变为一个相似的、但更小的问题.</li>\n<li>子问题的最优解与所做的贪心选择合并后,的确可以得到原问题的一个最优解.</li>\n</ol>\n</blockquote>\n<p>4.应用</p>\n<blockquote>\n<p>一般地,就算证明不出来贪心算法能给出最优解,但是它一般都至少能给出次优解.所以贪心算法在实际的应用中是非常的普及的.</p>\n</blockquote>\n<h4 id=\"Chapter17-较复杂的操作怎样平摊到所有操作上\"><a href=\"#Chapter17-较复杂的操作怎样平摊到所有操作上\" class=\"headerlink\" title=\"Chapter17 较复杂的操作怎样平摊到所有操作上?\"></a>Chapter17 较复杂的操作怎样平摊到所有操作上?</h4><p>1.<strong>平摊分析 amortized analysis</strong><br>在平摊分析中,执行一系列数据结构操作所需要的时间是通过对执行所有操作所花费的时间求平均而得到的.平摊分析表明不能总以最坏情况来衡量算法,因为最坏的情况并不经常会发生,甚至在绝大多数应用中最坏情况出现的次数是极少的.</p>\n<blockquote>\n<p>平摊分析与平均情况分析的不同之处在于它不牵涉到概率;平摊分析保证在最坏情况下,每个操作具有平均性能.通过平摊分析,可以获得对某种特定数据结构的认识,这种认识有助于优化设计.<br>一个例子是 <code>C++ STL</code> 中 <code>vector.push_back</code> 操作,一般情况下<code>push_back</code>追加到<code>vector</code>只需要复杂度$O(1)$, 但在<code>vector</code>达到容量限度时,<code>vector</code>先要动态扩展,然后<code>push_back</code>,复杂度升到$O(n)$,这种最坏情况出现次数相对于一般情况出现很少,对所有操作求平均后,每个<code>push_back</code>具有 $O(1)$的性能.</p>\n</blockquote>\n<p>2.平摊分析的三种方法:</p>\n<blockquote>\n<ul>\n<li>聚集分析:指分析一系列操作的总时间的上节$T(n)$, 平均代价即为$T(n)/n$</li>\n<li>记账法:对每次操作的对象进行预先记账,补偿实际代价高于帐的操作</li>\n<li>势能方法:与记账法类似,但将每次预留的势能视为是整个数据结构共享的,整体维护</li>\n</ul>\n</blockquote>\n<p>3.<strong>聚集分析: aggregate analysis</strong></p>\n<blockquote>\n<p>由N个操作所构成的序列的总时间在最坏的情况下为$T(n)$,则每个操作的平均代价(平摊代价)为$T(n)/n$.以前的时间复杂度分析都是以单次操作为对象的分析它的最坏时间复杂度,而聚集分析所分析的是N次操作的总时间的最坏情况.<br>聚集分析:由序列的总最坏时间 -&gt; 单次的平摊时间<br>以<code>stack</code>的操作为例(增加一个操作<code>multipop</code>, 连续出栈)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">push(S, x): O(1)</div><div class=\"line\">pop(S): O(1)</div><div class=\"line\">multipop(S, k): O(n)</div><div class=\"line\">  while not stack-empty(S) and k != 0</div><div class=\"line\">    do pop(s)</div><div class=\"line\">      k &lt;- k - 1</div></pre></td></tr></table></figure></p>\n<p>则n个包含<code>push</code>和<code>pop</code>的序列总代价为 $O(n)$ , 但加上复杂度为 $O(n)$ 的<code>multipop</code>操作后,应该如何计算?<br>任意stack操作的最坏时间复杂度为$O(n)$, 故N个操作的代价是 $O(2^n)$.但这个界明显过大, 因为不可能出现连续n次<code>multipop</code>的情况.<br>但从<code>pop</code>和<code>push</code>对应的角度考虑,<br>因为一个对象入栈后最多出栈一次, 将<code>multipop</code>视为<code>pop</code>的连续操作<br>所以<code>pop</code>的次数 $\\leq$ <code>push</code>的次数<br>n个序列的总时间代价为$O(n)$,平均代价为$O(n)/n=O(1)$</p>\n</blockquote>\n<p>4.<strong>记账法: bookkeeping method</strong></p>\n<blockquote>\n<p>对序列操作中的每一个操作收取一定的费用,当所收取的费用比它实际应支付的费用多时就把多余的部分当作存款(credit)存起来,一个操作的平摊代价可以看作两部分:实际代价和存款(或被储蓄或被用完).其要素为:</p>\n<ol>\n<li>存款可以用来在以后补偿那些其平摊代价低于其实际代价的操作.</li>\n<li>如果希望通过对平摊代价的分析来说明每次操作的最坏情况平均代价较小,则操作序列的总平摊代价就必须是该序列的总的实际代价的一个上界.因为平摊代价是最坏时的平均代价,即存款不能为负.</li>\n<li>存款不能为负,因为记账法是不允许欠账的,否则就不能满足平摊代价是操作总时间的最坏情况的平均这个定义.</li>\n</ol>\n<p>对于前面的stack操作,各操作的实际代价和平摊代价如下:</p>\n</blockquote>\n<table>\n<thead>\n<tr>\n<th>操作</th>\n<th>实际代价</th>\n<th>平摊代价</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>push</td>\n<td>1</td>\n<td>2</td>\n</tr>\n<tr>\n<td>pop</td>\n<td>1</td>\n<td>0</td>\n</tr>\n<tr>\n<td>multipop</td>\n<td>min(k, s)</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>平摊代价当每次入栈时记账支付2元,其中1元支付该<code>push</code>操作的实际代价,还有1元用于支付该元素被<code>pop</code>出来时的代价.则可以保证在任何时间内都不会有欠账,故<code>pop</code>操作可以不收取任何费用.</p>\n</blockquote>\n<p>5.<strong>势能方法: potential method</strong></p>\n<blockquote>\n<p>将已预付的工作作为一种“势能”保存,它在需要时可以释放出来,以支付后面的操作.势能是与整个数据结构而不是其中的个别对象发生联系的.相对比, 记账法中的账与个别对象发生联系,比如栈操作时支付的2元就记在入栈的那个元素上)<br>\\begin{align}<br>初始数据结构D_0, 记c_i为第i个操作的实际代价 \\\\<br>D_i为数据结构D_{i-1}作用第i操作的的结果 \\\\<br>势函数\\Phi: D_i \\mapsto \\Phi(D_i) \\\\<br>平摊代价 \\hat{c_i} = c_i + \\Phi(D_i) - \\Phi(D_{i-1}) \\\\<br>总平摊代价 \\sum_{i=1}^n\\hat{c_i} = \\sum_{i=1}^n(c_i + \\Phi(D_i) - \\Phi(D_{i-1})) = \\sum_{i=1}^n c_i + \\Phi(D_n) - \\Phi(D_0)<br>\\end{align}</p>\n<p>仍然以<code>stack</code>操作为例,<br>\\begin{align}<br>定义势函数\\Phi 为stack中对象个数 \\\\<br>初始空stack D_0, \\Phi(D_0) = 0 \\\\<br>push操作: \\\\<br>\\hat{c_i} = c_i + \\Phi(D_i) - \\Phi(D_{i-1}) = 1 + (s+1) - s = 2 \\\\<br>multipop操作: \\\\<br>\\hat{c_i} = c_i + \\Phi(D_i) - \\Phi(D_{i-1}) = k + (s -k) - s = 0 \\\\<br>\\therefore 每一操作平摊代价为O(1) \\\\<br>\\therefore n个操作最坏代价为O(n)<br>\\end{align}</p>\n</blockquote>"},{"title":"introduction to algorithms note4","date":"2017-05-01T16:00:00.000Z","_content":"\n# ＜Introduction to algorithms＞笔记\n## Part5 高级数据结构\n在[part3数据结构](https://chestnutme.github.io/2017/04/17/CLRS-notes2/)中,学习了基本的支持动态集合的数据结构,包括stack/queue/bst/rbt.接着在[part4高级设计和分析技术](https://chestnutme.github.io/2017/04/22/CLRS-notes3/)中学习了在分治法/递归等基本算法设计思想上的动态规划和贪心思想,以及如何对复杂的算法进行分析的平摊分析法.在以上学习的基础上,part5学习高级的数据结构如下：\n* B树:一种被设计成专门存储在磁盘上的平衡查找树.因为磁盘的速度远远慢于内存,所以 B 树被设计成尽量减少磁盘访问的次数,知道了这一点之后就会很清楚明白B树的变形 B+树了,B+树通过将数据存储在叶子结点从而增大了一个结点所包含的信息进而更加的减少了磁盘的访问次数.\n* 可合并堆:这种堆支持`Insert,Mininum,Extract-Min,union,delete,decrease-key`操作.\n> * 二项堆能够在 $O(\\log n)$ 的最坏情况时间内支持以上的各种操作.当必须支持 `union`操作时,二项堆优越于二叉堆,因为后者在最坏情况下,合并两个二叉堆要花 $O(n)$ 的时间.\n> * 斐波那契堆对于以上各种除了`extract-min,delete`的操作外都只需要 O(1)的实际时间,而`extract-min,delete`也只需要 $O(\\log n)$ 的平摊时间.它的重要优点在于`decrease-key`也只需要 O(1)的平摊时间.注意斐波那契堆的一些操作都只是平摊时间,并非最坏情况时间.现代的快速图算法(part6,下一部分)中,很多是使用斐波那契堆作为其核心数据结构的.\n* 不相交集合(并查集):由n个元素构成的全域集被划分为若干个动态集合.基本操作为`union, find-set`通过用一棵简单的有根树来表示每个集合,就可以得到惊人的快速操作:一个由m个操作构成的序列的运行时间为 $O(n\\alpha (n) )$,而对于宇宙中的原子数总和 n,α(n)也<=4,所以可以认为实际时间是 $O(n)$.\n\n<!-- more -->\n### Chapter18 如何对大量数据进行索引？\n1.B-tree 产生背景：\n> 大规模数据存储（如磁盘阵列,数据库）中,实现索引查询这样一个实际背景下,树节点存储的元素数量是有限的(如果元素数量非常多的话,查找就退化成节点内部的线性查找了),这样导致二叉查找树结构由于树的深度过大而造成磁盘 I/O读写过于频繁,进而导致查询效率低下(读取磁盘速度远慢于访问内存),那么如何减少树的深度(而不是能减少查询的数据量),一个基本的、很自然的想法就是:采用多叉树结构.由于树节点元素数量是有限的,自然该节点的子树数量也就是有限的.每个节点储存多个数据使得节点数减少,继而减少树的高度,从而减少对磁盘的访问次数,极大的提高数据操作效率.\n> 在大多数系统中,B 树算法的运行时间主要由它所执行的磁盘读取操作`disk-read`和`disk-write` 的次数所决定,因而应该有效地使用这两种操作,即让它们读取更多的信息更少的次数.由于这个原因,在 B 树中,一个结点的大小通常相当于一个完整的磁盘页.因此,一个B树结点可以拥有的子女数就由磁盘页的大小所决定.\n因此, 树的分支因子越大越好,因为这样运行时间的绝大部分都是由磁盘存取次数决定的.分支因子越大,需要进行的磁盘存取次数就越少.但是这个分支因子是有限制的,一个结点的总大小不能大于磁盘中一个页的大小,否则在一个结点内操作时还要来回访问内存,反而会拖慢效率.\n> 下图是一棵B树的典型例子.：\n\n！[b-tree](/images/b-tree.png)\n\n2.B-tree定义\n> B树是为了磁盘或其它存储设备而设计的一种多叉（相对于二叉,B树每个内结点有多个分支,即多叉）平衡查找树.与part3介绍的红黑树（red-black-tree)很相似,但在降低磁盘I/0操作方面要更好一些.许多数据库系统都一般使用B树或者B树的各种变形结构,如用B+树,B*树来存储信息.B树与红黑树最大的不同在于,B树的结点可以有许多子女,从几个到几千个.那为什么又说B树与红黑树很相似呢?因为与红黑树一样,一棵含n个结点的B树的高度也为 $O(\\log n)$,但可能比一棵红黑树的高度小许多,应为它的分支因子比较大.所以,B树可以在$O(\\log n)$时间内,实现各种如`insert,delete`等动态集合操作.\n\n> 有根树（根为root[T])B树性质如下：\n> 1. 节点x具有以下域：\n>> a. n[x], 节点x中的关键字数\n>> b. n[x]个关键字,非降序排列,即 $key\\_1[x] \\leq key\\_2[x] \\leq \\dots \\leq key\\_{n[x]}[x]$\n>> c. leaf[x], bool值,为true如果是叶子节点\n> 2. n[x] + 1个指向子女的指针 $c\\_1[x], c\\_2[x], \\dots, c\\_{n[x]+1}$\n> 3. $key\\_i[x]$ 对子树的关键字进行分隔,记 $k\\_i$为储存在以 $c\\_i[x]$ 为根的子树的关键字, 有：\n> $$ k\\_1 \\leq key\\_1[x] \\leq k\\_2 \\leq key\\_2[x] \\leq \\dots key\\_{n[x]}[x] \\leq k\\_{n[x]+1}$$\n> 4. 叶节点深度相同, 为树高h\n> 5. 节点包含关键字数最小值为度树t：\n>> a. 非根每个结点可包含至多2m-1个关键字.所以一个内结点至多可有2m个子女.如果一个结点恰好有2m-1个关键字,则这个结点是满的\n>> b. 每个结点可包含至多2m-1个关键字.所以一个内结点至多可有2m个子女.如果一个结点恰好有2m-1个关键字,我们就说这个结点是满的\n\n包含n个关键字,高度为h,最小度数 $t \\geq 2$的B树有：\n>若B树高度为h,其根节点至少包含一个关键字,其他节点至少包含t-1个关键字,\n第一层至少有2个节点, 第二层至少2t个节点,第三层至少 $2t^2$个节点,故有：\n$$ n \\geq 1 + (t-1)\\sum\\_{i=1}^h 2t^{i-1} = 1 + 2(t-1)(\\frac{t^h-1}{t-1}) =  2t^h - 1 $$\n$$ h \\leq \\log\\_t \\frac{n+1}{2} $$\n\n3.B树的操作:\n\n> 1. 查找 $O(t \\log_t n)$：bst上查找的推广\n```\nb-tree-search(x, k):\ni <- 1\nwhile i \u0002<= n[x] and k > keyi[x]\n  do i <- i + 1\nif i <= n[x] and k= keyi[x]\n  then return (x,i)\nif leaf[x]\n  then return NULL\n  else disk-read(ci[x])\n    return b-tree-search(ci[x], k)\n```\n\n> 2. 插入 $O(t \\log_t n)$：\n插入一个元素时,首先在B树中是否存在,如果不存在,即在叶子结点处结束,然后在叶子结点中插入该新的元素,注意：如果叶子结点空间足够,这里需要向右移动该叶子结点中大于新插入关键字的元素,如果空间满了以致没有足够的空间去添加新的元素,则将该结点进行“分裂”,将一半数量的关键字元素分裂到新的其相邻右结点中,中间关键字元素上移到父结点中（当然,如果父结点空间满了,也同样需要“分裂”操作）,而且当结点中关键元素向右移动了,相关的指针也需要向右移.如果在根结点插入新元素,空间满了,则进行分裂操作,这样原来的根结点中的中间关键字元素向上移动到新的根结点中,因此导致树的高度增加一层.\n```\nb-tree-split-child(x, i, y)\nz <- allocate-node()\nlead[z] <- leaf[y]\nn[z] <- t - 1\nfor j <- 1 ot t - 1\n  do keyi[z] <- key[j+i][y]\nif not leaf[y]\n  then for j <- 1 to t\n    do cj[z] <- c[j+i][y]\nn[y] <- t - 1\nfor j <- n[x] + 1 downto i + 1\n  do c[j+1][x] <- cj[x]\nc[i+1][x] <- z\nfor j <- n[x] downto i\n  do key[j+1][x] <- keyj[x]\nkeyi[x] <- keyi[y]\nn[x] <- n[x] + 1\ndisk-write(y)\ndisk-write(z)\ndisk-write(x)\n\nb-tree-insert(T, k)\nr <- root[T]\nif n[r] = 2t - 1\n  then s <- allocate-node()\n    root[T] <- s\n    leaf[s] <- False\n    n[s] <- 0\n    c1[s] <- r\n    b-tree-split-child(s, 1, r)\n    b-tree-insert-nonfull(s, k)\nelse b-tree-insert-nonfull(r, k)\n\nb-tree-insert-nonfull(x, k): #关键词k插入非满节点x\ni <- n[x]\nif leaf[x]\n  then while i >= 1 and k < keyi[x]\n      do key[i+1][x] <- keyi[x]\n        i<- i - 1\n    key[i+1][x] <- k\n    n[x] <- n[x] + 1\n    disk-write(x)\n  else while i >= 1 and k < keyi[x]\n      do i <- i + 1\n      i <- i + 1\n      disk-read(ci[x])\n      if n[ci[x]] = 2t - 1\n        then b-tree-split-child(x, i, ci[x])\n          if k > keyi[x]\n            then i <- i + 1\n        b-tree-insert-nonfull(ci[x], k)\n```\n\n> 3. 删除 $O(t \\log_t n)$：\n删除操作稍微复杂一些,因为删除操作不仅仅会发生在叶子结点,还可能会发生在内结点,这与插入操作不同.但是可以通过一个技巧消除这一点,找到要删除结点的前驱,然后与要删除的结点的关键值进行对调,再删除这个前驱结点就可以保证每次要删除的都是叶子结点\n具体如下:\n任一关键字 K 的中序前趋(后继)必是 K 的左子树(右子树)中最右(左)下的结点中最后(最前)一个关键字.根据 B 树的性质:B\n树上每一个结点的关键字的个数必须为[t-1, 2*t-1]之间,记Min = t - 1.若被删关键字K所在的结点非树叶,则用 K的中序前趋(或后继)K'取代 K,然后从叶子中删去 K'.从叶子*x 开始删去某关键字K的三种情形为:\n>> a. 若 x->keynum>Min,则只需删去K及其右指针(x是叶子,K的右指针为空)即可使删除操作结束.\n>> b. 若 x->keynum=Min,该叶子中的关键字个数已是最小值,删K及其右指针后会破坏B树的性质3.若x的左(或右)邻兄弟结点y 中的关键字数目大于Min,则将y中的最大(或最小)关键字上移至双亲结点parent 中,而将parent中相应的关键字下移至 x 中.显然这种移动使得双亲中关键字数目不变;y 被移出一个关键字,故其keynum减1,因它原大于Min,故减少1个关键字后keynum仍大于等于Min;而x中已移入一个关键字,故删 K 后x中仍 Min 个关键字.涉及移动关键字的三个结点均满足 B-树的性质3.移动完\n成后,删除过程亦结束.\n>> c.若x及其相邻的左右兄弟(也可能只有一个兄弟)中的关键字数目均为最小值 Min,则上述的移动操作就不奏效,此时节点x和左或右兄弟合并.不妨设x有右邻兄弟y(对左邻兄弟的讨论与此类似),在x中删去K及其右子树后,将双亲结点parent中介于x和y之间的关键字K,作为中间关键字,与并x和y中的关键字一起\"合并\"为一个新的结点取代x和y.因为x和y原各有Min个关键字,从双亲中移人的K'抵消了从x中删除的 K,故新结点中恰有 2Min(即2t-2 <= 2t-1)个关键字,没有破坏B树的性质3.但由于 K'从双亲中移到新结点后,相当于从parent中删去了K',若parent->keynum原大于 Min,则删除操作到此结束;否则,同样要通过移动*parent 的左右兄弟中的关键字或将parent与 左右兄弟合并的方法来维护B树性质.最坏情况下,合并操作会向上传播至根节点,当根节点中只有一个关键字时,合并操作将会使根结点及其两个孩子合并成一个新的根,从而使整棵树的高度减少一层.\n删除操作看似复杂,但是对一棵高度为h的B树,它只需要 $O(h)$ 次磁盘操作,因为在递归调用的过程之间,仅需要 $O(1)$ 次`disk-read,disk-write`操作,时间复杂度为 $O(th)=O(tlog_tn)$.\n\n### Chapter19 二项堆\n1.二项堆(Binomial Heaps)定义\n> 二项堆（Binomial Heap）是一种类似于二叉堆(Binary Heap)的堆结构.与二叉堆相比,其优势是可以快速合并两个堆,因此它属于可合并堆（Mergeable Heap）.x下一张的斐波那契堆也是可合并堆.一个二项堆由一组二项树所构成,这里的二项树(Binomial Tree)不同于二叉树(Binary Trees).二叉树是“左孩子,右孩子”的表示方法,而二项树是“左孩子,右兄弟”的表示方法.\n二项树定义：\n二项树是一种特殊的多分支有序树.二项树 $B_k$是一种递归定义的有序树.二项树 $B\\_0$只包含一个结点.二项树 $B\\_k$由两个子树 $B\\_{k-1}$连接而成：其中一棵树的根是另一棵树的根的最左孩子.性质如下：\n> 1.共有2k个结点.\n> 2.树的高度为k.\n> 3.在深度i处恰有 $C_i^k$个结点.\n> 4.根的度数（子女的个数）为k,它大于任何其他结点的度数；如果根的子女从左到右的编号设为k-1, k-2, …, 0,子女i是子树$B_i$的根.\n\n![b-heap1](/images/b-heap1.jpg)\n\n> 一个二项堆由一组二项树所构成,这里的二项树需要满足下列条件：\n> 1. 每棵二项树都满足最小堆性质.即,父节点的关键字 <= 它的孩子的关键字.\n> 2. 对于任意非负整数k,在堆中至多有一棵二项树的根具有度数k.\n第一个性质保证了二项树的根结点包含了最小的关键字.第二个性质则说明结点数为 n 的二项堆最多只有 $\\log n + 1$棵二项树\n\n2.二项堆表示\n如下图,二项堆(heap[H])每棵二项树按”左孩子,右兄弟方法储存“, 二项堆中的各二项树的根被组织成一个链表为根表.节点x的域如下：\n> 1. p[x],指向x的父节点\n> 2. child[x],指向x的最左孩子节点\n> 3. sibling[x], 指向x的最右兄弟节点\n![b-heap2](/images/b-heap2.jpg)\n\n3.二项堆操作\n> 1.创建堆: $O(1)$\n```\nmake\nhead[H] = NULL\n```\n\n> 2.最小关键字 $O(\\log n)$\n```\nbinomial-heap-minimum(H)\ny <- NULL\nx <- heap[H]\nmin <- INT\nwhile x != NULL\n  do if key[x] < min\n    then min <- key[y]\n      y <- x\n  x <- sibling[x]\nreturn y\n```\n\n> 3.合并\n二项堆最重要的一个操作就是`union`操作,其它的操作都可以在`union`操作的基础上轻松的实现.\n大概思路为:将两个二项堆的根表连接起来组成一个大的二项树的连接,按“度”的单调递增顺序进行排序之后,从左至右来消除具有重复度的二项树.因为原本的每个二项堆中任意度K至多只有一个相应的二项树,所以这个消除重复的操作会非常容易.从小到大找到两个相同度K的二项树,然后连接成一个K+1度的二项树,直到链尾时合并完毕.完成后二项堆就满足对任意度K至多只有一棵二项树.\n具体分解为三个过程：\n```\nbinomial-link(y, z)：#将两棵根节点度数相同的二项树Bk-1连接成一棵Bk\np[y] <- z\nsibling[y] <- child[z]\nchild[z] <- y\ndegree[z] <- degree[z] + 1\nbinomial-heap-merge #将H1和H2的根表合并成一个按度数的单调递增次序排列的链表\nbinomial-heap-union： #反复连接根节点的度数相同的各二项树\nH <- make-binomial-heap()\nhead[H] <- binomial-heap-merge(H1, H2)\nfree the objects H1 and H2 but not the lists they point to\nif head[H] = NULL\n  then return H\nprev-x <- NULL\nx <- head[H]\nnext-x <- sibling[x]\nwhile next-x ≠ NULL\n  do if (degree[x] ≠ degree[next-x]) or (sibling[next-x] ≠ NULL and degree[sibling[next-x]] = degree[x])\n    then prev-x <- x ▹ Cases 1 and 2                #case1 and 2\n      x <- next-x ▹ Cases 1 and 2\n    else if key[x] ≤ key[next-x]\n      then sibling[x] <- sibling[next-x] ▹ Case 3   #case3\n        binomial-link(next-x, x) ▹ Case 3\n    else if prev-x = NULL ▹ Case 4                  #case4\n      then head[H] <- next-x ▹ Case 4\n      else sibling[prev-x] <- next-x ▹ Case 4\n      binomial-link(x, next-x) ▹ Case 4\n      x <- next-x ▹ Case 4\n  next-x <- sibling[x]\nreturn H\n```\n>> `union`操作分为两个阶段：\n第一阶段：执行`binomial-heap-merge`,将两个堆H1和H2的根表合并成一个链表H,它按度数排序成单调递增次序.MERGE的时间复杂度 $O(\\log n)$.n为H1和H2的结点总数.（对于每一个度数值,可能有两个根与其对应,所以第二阶段要把这些相同的根连起来）.\n第二阶段：将相等度数的根连接起来,直到每个度数至多有一个根时为止.执行过程中,合并的堆H的根表中至多出现三个根具有相同的度数.合并的时候对于每一个节点,要么在主链上去掉连到其它二项树中,而插入别的二项树中的复杂度为 $O(1)$,要么只是遍历,总的节点是n个,根节点是lg(n)个,所以总的时间为 $O(\\log n)$,加上merge的时间为 $O(\\log n)$,总的时间为 $O(\\log n)$.（merge后H中至多出现两个根具有相同的度数,但是将两个相同度数的根的二项树连接后,可能与后面的至多两棵二项树出现相同的度数的根,因此至多出现三个根具有相同的度数）\n第二阶段根据当前遍历到的根表中的结点x,分四种情况考虑:\n>> Case1：degree[x] != degree[sibling[x]].此时,不需要做任何变化,将指针向根表后移动即可.\n>> Case2：degree[x] == degree[sibling[x]] == degree[sibling[sibling[x]]].此时,仍不做变化,将指针后移.\n>> Case3 & Case4：degree[x] = degree[sibling[x]] != degree[sibling[sibling[x]]]\nCase3：key[x] <= key[sibling[x]].此时,将sibling[x]连接到x上.\nCase4：key[x] > key[sibling[x]].此时,将x连接到sibling[x]上.\n\n> 4.插入节点: $O(\\log n)$\n```\nbinomial-heap-insert(H, x)\nH′ <- make-binomial-heap()\np[x] <- NULL\nchild[x] <- NULL\nsibling[x] <- NULL\ndegree[x] <- 0\nhead[H′] <- x\nH <- binomial-heap-union(H, H′)\n```\n\n> 5.删除最小关键字 $O(\\log n)$\n```\nbinomial-heap-extract-min(H):\nfind the root x with the minimum key in the root list of H,\nand remove x from the root list of H\nH′ <- make-binomial-heap()\nreverse the order of the linked list of x’s children,\nand set head[H′] to point to the head of the resulting list\nH <- binomial-heap-union(H, H′)\n```\n\n> 6.减小关键字值\n减小关键字的过程类似维护最小堆结构,key[y]与y的父结点z的关键字作比较.如果y为根或者key[y] >= key[z],则该二项树已是最小堆有序.否则结点研究违反了最小堆有序,故将其关键字与其父节点z的关键字相交换,同时还要交换其他数据并循环这个过程\n```\nbinomial-heap-decrease-key(H, x, k)\nif k > key[x]\n  then error \"new key is greater than current key\"\nkey[x] <- k\ny <- x\nz <- p[y]\nwhile z ≠ NULL and key[y] < key[z]\n  do exchange key[y] ↔ key[z]\n  y <- z\n  z <- p[y]\n```\n\n> 7.删除关键字\n```\nbinomial-heap-delete(H, x)\n1 binomial-heap-decrease-key(H, x, -INT)\n2 binomial-heap-extract-min(H)\n```\n\n4.总结\n> 可合并堆 = 普通的堆 + `decrease-key,union`操作\n但是其应该高效的实现, `union`操作是可合并堆最关键的部分.如果不需要高效的支持`union`操作,则普通的堆结构已经足够.\n对于所有的堆结构:二叉堆、二项堆、斐波那契堆.它们的`search`操作都是很慢的,不能像二叉搜索树高效的支持`search`操作!因而在`decrease-key`和`delete`等涉及结点的操作时都需要一个指向结点的指针.\n\n### Chapter20 斐波那契堆\n1.定义\n> 斐波那契堆(Fibonacci heap)是堆中一种,它和二项堆一样,也是一种可合并堆；可用于实现合并优先队列.斐波那契堆比二项堆具有更好的平摊分析性能,它的合并操作的时间复杂度是O(1).\n与二项堆一样,它也是由一组堆最小有序树组成,并且是一种可合并堆.\n与二项堆不同的是,斐波那契堆中的树不一定是二项树；而且二项堆中的树是有序排列的,但是斐波那契堆中的树都是有根而无序的.\n\n！[fib-heap](/images/fib.jpg)\n\n> 斐波那契堆中的所有树的树根被保存在一个链表即根表中.对于一个斐波那契堆,min[H]保存了具有最小节点值的根节点.\n堆中每个节点的数据结构包含如下域：\n>> 1. p[x],指向x的父节点\n>> 2. child[x], 指向x的任意一个孩子\n>> 3. 任意一个节点x的所有孩子被链接在一个双向链表环形链表中\n>> 4. degree,x的孩子的数目\n>> 5. mark,表示自从x上一次称为另一个节点的子女以来,它是否失掉了一个孩子,TRUE表示是失去了\n\n2.操作\n> 1. 创建堆\n```\nmake-fib-heap()\nH <- allocate-node()\nn[H] = 0\nmin[h] = NULL\nreturn H\n```\n\n> 2. 插入: $O(1)$\n```\nfib-heap-insert(H, x)\ndegree[x] <- 0\np[x] <- NUll\nchild[x] <- NULL\nleft[x] <- x\nright[x] <- x\nmark[x] = false\nconcatenate the root list containing x with root list H\nif min[H] = NULL or key[x] < key[min[H]]\n  then min[H] <- x\nn[H] <- n[H] + 1\n```\n\n> 3. 合并: $O(1)$\n合并两个斐波那契堆的操作非常简单,可以分为两步：\n>> 1.将两个根表通过指针合并为一个根表\n>> 2.更新min[H],比较两个堆的min[H],取较小的\n```\nfib-heap-union(H1, H2)\nH <- make-fib-heap()\nmin[H] <- min[H1]\nconcatenate the root list of H@ with the root list of H\nif (min[H1] = NULL) or (min[H2] != NULL) and min[H2] < min[H1])\n  then min[H1] <- min[H2]\nn[H] <- n[H1] + n[H2]\nfree the objects H1 and H2\nreturn H\n```\n\n> 4. 删除最小节点: $O(\\log n)$\n删除最小节点的操作比较复杂,其算法思想为：\n>> 1. 删除最小节点,并将被删除节点的每个孩子都看做新的堆中的一棵树的根,将它们加入到根表中\n>> 2. 遍历根表,合并度数相同的树\n这里的在根链上合并操作与二项树基本相同,就是按“度的递增”顺序排列所有的子树之后,合并具有相同度的子树,使得最后的根链上每一个度 K 都只有至多一棵子树.(这里又与二项堆神似了,所以说斐波那契堆是松散地基于二项堆.)调整根表的步骤\n1:在根表中找出两个具有相同度数的根 x 和 y,且 key[x]<key[y]\n2:将y与x连接.将 y 从根表里去掉,成为 x一个孩子,并增加degree[x].同时,如果y上有标记的话也被清除掉.”\n```\nfib-heap-extract-min(H)\nz <- min[H]\nif z != NULL\n  then for each child x of z\n    do add x to the root list of H\n      p[x] <- NULL\n    remove z from the root list of H\n    if z = right[z]\n      then min[H] <- NULL\n      else min[H] <- right[z]\n        consolidate(H)\n    n[H] <- n[H] - 1\n\nconsolidate(H): #合并H的根表,减少堆中树的数量\n```\n> 5. 减小一个关键字: $O(1)$\n减小一个关键字的字,会破坏最小堆的性质,所以要进行最小堆维护.因为斐波那契支持减小关键字和删除结点操作,所以斐波那契堆的子树就不一定是二项树了.步骤如下：\n>> 1.减此减小不影响堆序,不作调整;\n>> 2.若影响堆序,则从堆中删除该节点,将其加入根表,并检查其父亲的 mark 位;若为 false,则停止,并将其置为 true;若为 true,则删除其父亲,继续递归向上执行;直到一个节点 mark 域为 false 或该节点为根节点为止.\n```\nfib-heap-decrease-key(H, x, k)\nif k > key[x]\n  then return error \"new key is greater than current key\"\nkey[x] <- k\ny <- p[x]\nif y != NULL and key[x] < key[y]\n  then cut(H, x, y)\n    cascading-cut\nif key[x] < key[min[h]]\n  then min[h] <- x\n\ncut(H, x, y)\nremove x from the child list of y, decrementing degree[y]\nadd x to the root list of H\np[x] <- NULL\nmark[x] <- False\n\ncascading-cut(H, y)\nz <- p[y]\nif z != NULL\n   then if mark[y] = False\n      mark[y] <- true\n      else cut(H, y, z)\n        cascading-cut(H, z)\n```\n\n> 6. 删除节点\n```\nfib-heap-delete(H, x)\nfib-heap-decrease-key(H, x, -INT)\nfib-heap-extract-min(H)\n```\n\n3.总结\n斐波那契堆之所以高效,就是因为它放宽了条件了,将很多二项堆要维护的工作都推迟到了`extract-min` 和 `delete`操作之中去了.而它之所以能够放宽条件,就是因为它的限制非常的少,并没有像二项堆一样的要求子树全部必须是二项树,而且根表上的任意度数的子树至多只能有一个.没有了这些限制,斐波那契堆就可以实现的非常的松散以至少将日常工作的维护时间都平摊给 `extract-min` 和 `delete` 操作.\n但是,正如斐波那契堆现在更多的应用于理论中,实践中使用的并不多的现象所映射的,在大部分的应用中斐波那契堆并不能带来大幅度的效率的提升.因为它并不是减少了要做的工作,只是将很多要做的工作都进行了推迟.\n但一般对于规模足够大的输入,斐波那契堆是能够很大改善算法的性能的,尤其是对于一些 `extract-min`和 `delete` 操作少的情况.比如斐波那契堆的使用能加快Prime 和 Djikstra 算法的执行速度.\n\n### Chapter21 用于划分的数据结构-不相交集合\n1.定义：\n不相交集合数据结构（disjoing-set data structure)保持一组不相交的动态集合 $S = \\\\{S_1,S_2,S_3, \\dots, S_k\\\\}$.每个集合通过一个代表来识别,代表即集合中的某个成员.\n不相交集合数据结构支持如下操作：\n> 1. `make-set(x)`： 建立一个新的集合,其唯一成员就是x,所以其代表也就是自己.因为各集合是不相交的,故要求x没有在其他集合中出现过.\n> 2. `union(x,y)`： 将包含x和y的动态集合（比如说 $S_x和S_y$）合并为一个新的集合（即这两个集合的并集）.假定这个操作之前是不相交的.在经过此操作后,所得集合的代表可以是$Sx \\bigcup Sy$中的任何一个成员,但在`union`的很多实现细节中,都选择Sx或Sy的代表作为新的代表.由于要求各集合是不相交的,故我们“消除”集合Sx和Sy,把它们从S中删去.\n> 3. `find-set(x)`：返回一个指针,指向包含x的（唯一）集合的代表.\n\n2.表示\n不相交数据集合一般用链表或森林来实现,有根树的速度更快.\n> 1.链表表示\n>> a. 每个链表的第一个对象作为它所在集合的代表\n>> b. 链表上的第个结点都有指向它所在集合的代表的指针,从而使得找出所属集合的操作时间降为 $O(1)$\n>> c. 但是因为每个结点都有指向代表的指针,使得在进行合并操作时,需要更新所有结点的指向代表的指针,从而时间复杂度为 $O(n)$.\n>> d. 一种加权合并启发式策略:在进行合并操作时,总是把较短的表拼到较长的表上去.\n\n> 2.树表示\n> 用有根树来表示集合,树中的每个节点都包含集合的一个成员,每棵树都表示一个集合.不相交森林中,每个成员仅指向其父节点.每个树的根包含了代表,并且是它自己的父节点.尽管采用了这种表示的直观算法并不比采用链表表示的直观算法并不比采用链表表示的算法更快,但是,通过引入两种启发式策略（“按秩合并”和“路径压缩”）,就可以获得目前已知的,渐进意义上最快的不相交集合的数据结构\n```\nmake-set(x)\np[x] <- x\nrank[x] <- 0\n```\n>> 1.按秩合并,其思想是是包含较少节点的树的根指向包含较多节点的树的根.我们并不显示的记录以每个节点为根的子树大小,而是采用了一种能够简化分析的方法.对每个节点,用秩表示节点高度的一个上届.在按秩合并中具有较小秩的根在`union`操作中要指向具有较大秩的根.\n![tree-set](/images/union.jpg)\n```\nunion(x, y)\nlink(find-set(x), find-set(y))\n\nlink(x, y)\nif rank[x] > rank[y]\n  then p[y] <- x\n  else p[x] <- y\n    if rank[x] = rank[y]\n      then rank[y] <- rank[y] + 1\n```\n>> 2.路径压缩,它非常简单而有效.如下图所示,在`find-set`操作中,利用这种启发式策略,来使查找路径上的每个节点都直接指向根节点.路径压缩并不改变节点的秩\n！[find-set1](find-set1.gif)\n```\nfind-set(x)\nif x != p[x]\n  then p[x] <- find-set(p[x])\nreturn p[x]\n```\n\n3.应用\n不相交集合数据结构有多种应用,其中之一是用于确定一个无向图中连通子图的个数.在下面给出的过程`connected-components`中,利用了不相交集合操作来计算一个图的连通子图.一旦`connected-components`作为预处理步骤执行后,过程`same-component`回答两个顶点是否在同一连通子图的查询.\n```\nconnected-components(G) #图G,顶点集V[G],边集E[G]\nfor each vertex v in V[G]\n    do make-set(v)\nfor each edge(u, v) in E[G]\n    do if find-set(u) != find-set(v)\n        then union(u, v)\n\nsame-component(u, v)\nif find-set(u) = find-set(v)\n    then return true\n    else return false\n```\n![find-set2](find-set2.gif)\n","source":"_posts/CLRS-notes4.md","raw":"title: introduction to algorithms note4\ntags:\n  - algorithm\n  - data_structure\ndate: 2017/05/02\n\n----\n\n# ＜Introduction to algorithms＞笔记\n## Part5 高级数据结构\n在[part3数据结构](https://chestnutme.github.io/2017/04/17/CLRS-notes2/)中,学习了基本的支持动态集合的数据结构,包括stack/queue/bst/rbt.接着在[part4高级设计和分析技术](https://chestnutme.github.io/2017/04/22/CLRS-notes3/)中学习了在分治法/递归等基本算法设计思想上的动态规划和贪心思想,以及如何对复杂的算法进行分析的平摊分析法.在以上学习的基础上,part5学习高级的数据结构如下：\n* B树:一种被设计成专门存储在磁盘上的平衡查找树.因为磁盘的速度远远慢于内存,所以 B 树被设计成尽量减少磁盘访问的次数,知道了这一点之后就会很清楚明白B树的变形 B+树了,B+树通过将数据存储在叶子结点从而增大了一个结点所包含的信息进而更加的减少了磁盘的访问次数.\n* 可合并堆:这种堆支持`Insert,Mininum,Extract-Min,union,delete,decrease-key`操作.\n> * 二项堆能够在 $O(\\log n)$ 的最坏情况时间内支持以上的各种操作.当必须支持 `union`操作时,二项堆优越于二叉堆,因为后者在最坏情况下,合并两个二叉堆要花 $O(n)$ 的时间.\n> * 斐波那契堆对于以上各种除了`extract-min,delete`的操作外都只需要 O(1)的实际时间,而`extract-min,delete`也只需要 $O(\\log n)$ 的平摊时间.它的重要优点在于`decrease-key`也只需要 O(1)的平摊时间.注意斐波那契堆的一些操作都只是平摊时间,并非最坏情况时间.现代的快速图算法(part6,下一部分)中,很多是使用斐波那契堆作为其核心数据结构的.\n* 不相交集合(并查集):由n个元素构成的全域集被划分为若干个动态集合.基本操作为`union, find-set`通过用一棵简单的有根树来表示每个集合,就可以得到惊人的快速操作:一个由m个操作构成的序列的运行时间为 $O(n\\alpha (n) )$,而对于宇宙中的原子数总和 n,α(n)也<=4,所以可以认为实际时间是 $O(n)$.\n\n<!-- more -->\n### Chapter18 如何对大量数据进行索引？\n1.B-tree 产生背景：\n> 大规模数据存储（如磁盘阵列,数据库）中,实现索引查询这样一个实际背景下,树节点存储的元素数量是有限的(如果元素数量非常多的话,查找就退化成节点内部的线性查找了),这样导致二叉查找树结构由于树的深度过大而造成磁盘 I/O读写过于频繁,进而导致查询效率低下(读取磁盘速度远慢于访问内存),那么如何减少树的深度(而不是能减少查询的数据量),一个基本的、很自然的想法就是:采用多叉树结构.由于树节点元素数量是有限的,自然该节点的子树数量也就是有限的.每个节点储存多个数据使得节点数减少,继而减少树的高度,从而减少对磁盘的访问次数,极大的提高数据操作效率.\n> 在大多数系统中,B 树算法的运行时间主要由它所执行的磁盘读取操作`disk-read`和`disk-write` 的次数所决定,因而应该有效地使用这两种操作,即让它们读取更多的信息更少的次数.由于这个原因,在 B 树中,一个结点的大小通常相当于一个完整的磁盘页.因此,一个B树结点可以拥有的子女数就由磁盘页的大小所决定.\n因此, 树的分支因子越大越好,因为这样运行时间的绝大部分都是由磁盘存取次数决定的.分支因子越大,需要进行的磁盘存取次数就越少.但是这个分支因子是有限制的,一个结点的总大小不能大于磁盘中一个页的大小,否则在一个结点内操作时还要来回访问内存,反而会拖慢效率.\n> 下图是一棵B树的典型例子.：\n\n！[b-tree](/images/b-tree.png)\n\n2.B-tree定义\n> B树是为了磁盘或其它存储设备而设计的一种多叉（相对于二叉,B树每个内结点有多个分支,即多叉）平衡查找树.与part3介绍的红黑树（red-black-tree)很相似,但在降低磁盘I/0操作方面要更好一些.许多数据库系统都一般使用B树或者B树的各种变形结构,如用B+树,B*树来存储信息.B树与红黑树最大的不同在于,B树的结点可以有许多子女,从几个到几千个.那为什么又说B树与红黑树很相似呢?因为与红黑树一样,一棵含n个结点的B树的高度也为 $O(\\log n)$,但可能比一棵红黑树的高度小许多,应为它的分支因子比较大.所以,B树可以在$O(\\log n)$时间内,实现各种如`insert,delete`等动态集合操作.\n\n> 有根树（根为root[T])B树性质如下：\n> 1. 节点x具有以下域：\n>> a. n[x], 节点x中的关键字数\n>> b. n[x]个关键字,非降序排列,即 $key\\_1[x] \\leq key\\_2[x] \\leq \\dots \\leq key\\_{n[x]}[x]$\n>> c. leaf[x], bool值,为true如果是叶子节点\n> 2. n[x] + 1个指向子女的指针 $c\\_1[x], c\\_2[x], \\dots, c\\_{n[x]+1}$\n> 3. $key\\_i[x]$ 对子树的关键字进行分隔,记 $k\\_i$为储存在以 $c\\_i[x]$ 为根的子树的关键字, 有：\n> $$ k\\_1 \\leq key\\_1[x] \\leq k\\_2 \\leq key\\_2[x] \\leq \\dots key\\_{n[x]}[x] \\leq k\\_{n[x]+1}$$\n> 4. 叶节点深度相同, 为树高h\n> 5. 节点包含关键字数最小值为度树t：\n>> a. 非根每个结点可包含至多2m-1个关键字.所以一个内结点至多可有2m个子女.如果一个结点恰好有2m-1个关键字,则这个结点是满的\n>> b. 每个结点可包含至多2m-1个关键字.所以一个内结点至多可有2m个子女.如果一个结点恰好有2m-1个关键字,我们就说这个结点是满的\n\n包含n个关键字,高度为h,最小度数 $t \\geq 2$的B树有：\n>若B树高度为h,其根节点至少包含一个关键字,其他节点至少包含t-1个关键字,\n第一层至少有2个节点, 第二层至少2t个节点,第三层至少 $2t^2$个节点,故有：\n$$ n \\geq 1 + (t-1)\\sum\\_{i=1}^h 2t^{i-1} = 1 + 2(t-1)(\\frac{t^h-1}{t-1}) =  2t^h - 1 $$\n$$ h \\leq \\log\\_t \\frac{n+1}{2} $$\n\n3.B树的操作:\n\n> 1. 查找 $O(t \\log_t n)$：bst上查找的推广\n```\nb-tree-search(x, k):\ni <- 1\nwhile i \u0002<= n[x] and k > keyi[x]\n  do i <- i + 1\nif i <= n[x] and k= keyi[x]\n  then return (x,i)\nif leaf[x]\n  then return NULL\n  else disk-read(ci[x])\n    return b-tree-search(ci[x], k)\n```\n\n> 2. 插入 $O(t \\log_t n)$：\n插入一个元素时,首先在B树中是否存在,如果不存在,即在叶子结点处结束,然后在叶子结点中插入该新的元素,注意：如果叶子结点空间足够,这里需要向右移动该叶子结点中大于新插入关键字的元素,如果空间满了以致没有足够的空间去添加新的元素,则将该结点进行“分裂”,将一半数量的关键字元素分裂到新的其相邻右结点中,中间关键字元素上移到父结点中（当然,如果父结点空间满了,也同样需要“分裂”操作）,而且当结点中关键元素向右移动了,相关的指针也需要向右移.如果在根结点插入新元素,空间满了,则进行分裂操作,这样原来的根结点中的中间关键字元素向上移动到新的根结点中,因此导致树的高度增加一层.\n```\nb-tree-split-child(x, i, y)\nz <- allocate-node()\nlead[z] <- leaf[y]\nn[z] <- t - 1\nfor j <- 1 ot t - 1\n  do keyi[z] <- key[j+i][y]\nif not leaf[y]\n  then for j <- 1 to t\n    do cj[z] <- c[j+i][y]\nn[y] <- t - 1\nfor j <- n[x] + 1 downto i + 1\n  do c[j+1][x] <- cj[x]\nc[i+1][x] <- z\nfor j <- n[x] downto i\n  do key[j+1][x] <- keyj[x]\nkeyi[x] <- keyi[y]\nn[x] <- n[x] + 1\ndisk-write(y)\ndisk-write(z)\ndisk-write(x)\n\nb-tree-insert(T, k)\nr <- root[T]\nif n[r] = 2t - 1\n  then s <- allocate-node()\n    root[T] <- s\n    leaf[s] <- False\n    n[s] <- 0\n    c1[s] <- r\n    b-tree-split-child(s, 1, r)\n    b-tree-insert-nonfull(s, k)\nelse b-tree-insert-nonfull(r, k)\n\nb-tree-insert-nonfull(x, k): #关键词k插入非满节点x\ni <- n[x]\nif leaf[x]\n  then while i >= 1 and k < keyi[x]\n      do key[i+1][x] <- keyi[x]\n        i<- i - 1\n    key[i+1][x] <- k\n    n[x] <- n[x] + 1\n    disk-write(x)\n  else while i >= 1 and k < keyi[x]\n      do i <- i + 1\n      i <- i + 1\n      disk-read(ci[x])\n      if n[ci[x]] = 2t - 1\n        then b-tree-split-child(x, i, ci[x])\n          if k > keyi[x]\n            then i <- i + 1\n        b-tree-insert-nonfull(ci[x], k)\n```\n\n> 3. 删除 $O(t \\log_t n)$：\n删除操作稍微复杂一些,因为删除操作不仅仅会发生在叶子结点,还可能会发生在内结点,这与插入操作不同.但是可以通过一个技巧消除这一点,找到要删除结点的前驱,然后与要删除的结点的关键值进行对调,再删除这个前驱结点就可以保证每次要删除的都是叶子结点\n具体如下:\n任一关键字 K 的中序前趋(后继)必是 K 的左子树(右子树)中最右(左)下的结点中最后(最前)一个关键字.根据 B 树的性质:B\n树上每一个结点的关键字的个数必须为[t-1, 2*t-1]之间,记Min = t - 1.若被删关键字K所在的结点非树叶,则用 K的中序前趋(或后继)K'取代 K,然后从叶子中删去 K'.从叶子*x 开始删去某关键字K的三种情形为:\n>> a. 若 x->keynum>Min,则只需删去K及其右指针(x是叶子,K的右指针为空)即可使删除操作结束.\n>> b. 若 x->keynum=Min,该叶子中的关键字个数已是最小值,删K及其右指针后会破坏B树的性质3.若x的左(或右)邻兄弟结点y 中的关键字数目大于Min,则将y中的最大(或最小)关键字上移至双亲结点parent 中,而将parent中相应的关键字下移至 x 中.显然这种移动使得双亲中关键字数目不变;y 被移出一个关键字,故其keynum减1,因它原大于Min,故减少1个关键字后keynum仍大于等于Min;而x中已移入一个关键字,故删 K 后x中仍 Min 个关键字.涉及移动关键字的三个结点均满足 B-树的性质3.移动完\n成后,删除过程亦结束.\n>> c.若x及其相邻的左右兄弟(也可能只有一个兄弟)中的关键字数目均为最小值 Min,则上述的移动操作就不奏效,此时节点x和左或右兄弟合并.不妨设x有右邻兄弟y(对左邻兄弟的讨论与此类似),在x中删去K及其右子树后,将双亲结点parent中介于x和y之间的关键字K,作为中间关键字,与并x和y中的关键字一起\"合并\"为一个新的结点取代x和y.因为x和y原各有Min个关键字,从双亲中移人的K'抵消了从x中删除的 K,故新结点中恰有 2Min(即2t-2 <= 2t-1)个关键字,没有破坏B树的性质3.但由于 K'从双亲中移到新结点后,相当于从parent中删去了K',若parent->keynum原大于 Min,则删除操作到此结束;否则,同样要通过移动*parent 的左右兄弟中的关键字或将parent与 左右兄弟合并的方法来维护B树性质.最坏情况下,合并操作会向上传播至根节点,当根节点中只有一个关键字时,合并操作将会使根结点及其两个孩子合并成一个新的根,从而使整棵树的高度减少一层.\n删除操作看似复杂,但是对一棵高度为h的B树,它只需要 $O(h)$ 次磁盘操作,因为在递归调用的过程之间,仅需要 $O(1)$ 次`disk-read,disk-write`操作,时间复杂度为 $O(th)=O(tlog_tn)$.\n\n### Chapter19 二项堆\n1.二项堆(Binomial Heaps)定义\n> 二项堆（Binomial Heap）是一种类似于二叉堆(Binary Heap)的堆结构.与二叉堆相比,其优势是可以快速合并两个堆,因此它属于可合并堆（Mergeable Heap）.x下一张的斐波那契堆也是可合并堆.一个二项堆由一组二项树所构成,这里的二项树(Binomial Tree)不同于二叉树(Binary Trees).二叉树是“左孩子,右孩子”的表示方法,而二项树是“左孩子,右兄弟”的表示方法.\n二项树定义：\n二项树是一种特殊的多分支有序树.二项树 $B_k$是一种递归定义的有序树.二项树 $B\\_0$只包含一个结点.二项树 $B\\_k$由两个子树 $B\\_{k-1}$连接而成：其中一棵树的根是另一棵树的根的最左孩子.性质如下：\n> 1.共有2k个结点.\n> 2.树的高度为k.\n> 3.在深度i处恰有 $C_i^k$个结点.\n> 4.根的度数（子女的个数）为k,它大于任何其他结点的度数；如果根的子女从左到右的编号设为k-1, k-2, …, 0,子女i是子树$B_i$的根.\n\n![b-heap1](/images/b-heap1.jpg)\n\n> 一个二项堆由一组二项树所构成,这里的二项树需要满足下列条件：\n> 1. 每棵二项树都满足最小堆性质.即,父节点的关键字 <= 它的孩子的关键字.\n> 2. 对于任意非负整数k,在堆中至多有一棵二项树的根具有度数k.\n第一个性质保证了二项树的根结点包含了最小的关键字.第二个性质则说明结点数为 n 的二项堆最多只有 $\\log n + 1$棵二项树\n\n2.二项堆表示\n如下图,二项堆(heap[H])每棵二项树按”左孩子,右兄弟方法储存“, 二项堆中的各二项树的根被组织成一个链表为根表.节点x的域如下：\n> 1. p[x],指向x的父节点\n> 2. child[x],指向x的最左孩子节点\n> 3. sibling[x], 指向x的最右兄弟节点\n![b-heap2](/images/b-heap2.jpg)\n\n3.二项堆操作\n> 1.创建堆: $O(1)$\n```\nmake\nhead[H] = NULL\n```\n\n> 2.最小关键字 $O(\\log n)$\n```\nbinomial-heap-minimum(H)\ny <- NULL\nx <- heap[H]\nmin <- INT\nwhile x != NULL\n  do if key[x] < min\n    then min <- key[y]\n      y <- x\n  x <- sibling[x]\nreturn y\n```\n\n> 3.合并\n二项堆最重要的一个操作就是`union`操作,其它的操作都可以在`union`操作的基础上轻松的实现.\n大概思路为:将两个二项堆的根表连接起来组成一个大的二项树的连接,按“度”的单调递增顺序进行排序之后,从左至右来消除具有重复度的二项树.因为原本的每个二项堆中任意度K至多只有一个相应的二项树,所以这个消除重复的操作会非常容易.从小到大找到两个相同度K的二项树,然后连接成一个K+1度的二项树,直到链尾时合并完毕.完成后二项堆就满足对任意度K至多只有一棵二项树.\n具体分解为三个过程：\n```\nbinomial-link(y, z)：#将两棵根节点度数相同的二项树Bk-1连接成一棵Bk\np[y] <- z\nsibling[y] <- child[z]\nchild[z] <- y\ndegree[z] <- degree[z] + 1\nbinomial-heap-merge #将H1和H2的根表合并成一个按度数的单调递增次序排列的链表\nbinomial-heap-union： #反复连接根节点的度数相同的各二项树\nH <- make-binomial-heap()\nhead[H] <- binomial-heap-merge(H1, H2)\nfree the objects H1 and H2 but not the lists they point to\nif head[H] = NULL\n  then return H\nprev-x <- NULL\nx <- head[H]\nnext-x <- sibling[x]\nwhile next-x ≠ NULL\n  do if (degree[x] ≠ degree[next-x]) or (sibling[next-x] ≠ NULL and degree[sibling[next-x]] = degree[x])\n    then prev-x <- x ▹ Cases 1 and 2                #case1 and 2\n      x <- next-x ▹ Cases 1 and 2\n    else if key[x] ≤ key[next-x]\n      then sibling[x] <- sibling[next-x] ▹ Case 3   #case3\n        binomial-link(next-x, x) ▹ Case 3\n    else if prev-x = NULL ▹ Case 4                  #case4\n      then head[H] <- next-x ▹ Case 4\n      else sibling[prev-x] <- next-x ▹ Case 4\n      binomial-link(x, next-x) ▹ Case 4\n      x <- next-x ▹ Case 4\n  next-x <- sibling[x]\nreturn H\n```\n>> `union`操作分为两个阶段：\n第一阶段：执行`binomial-heap-merge`,将两个堆H1和H2的根表合并成一个链表H,它按度数排序成单调递增次序.MERGE的时间复杂度 $O(\\log n)$.n为H1和H2的结点总数.（对于每一个度数值,可能有两个根与其对应,所以第二阶段要把这些相同的根连起来）.\n第二阶段：将相等度数的根连接起来,直到每个度数至多有一个根时为止.执行过程中,合并的堆H的根表中至多出现三个根具有相同的度数.合并的时候对于每一个节点,要么在主链上去掉连到其它二项树中,而插入别的二项树中的复杂度为 $O(1)$,要么只是遍历,总的节点是n个,根节点是lg(n)个,所以总的时间为 $O(\\log n)$,加上merge的时间为 $O(\\log n)$,总的时间为 $O(\\log n)$.（merge后H中至多出现两个根具有相同的度数,但是将两个相同度数的根的二项树连接后,可能与后面的至多两棵二项树出现相同的度数的根,因此至多出现三个根具有相同的度数）\n第二阶段根据当前遍历到的根表中的结点x,分四种情况考虑:\n>> Case1：degree[x] != degree[sibling[x]].此时,不需要做任何变化,将指针向根表后移动即可.\n>> Case2：degree[x] == degree[sibling[x]] == degree[sibling[sibling[x]]].此时,仍不做变化,将指针后移.\n>> Case3 & Case4：degree[x] = degree[sibling[x]] != degree[sibling[sibling[x]]]\nCase3：key[x] <= key[sibling[x]].此时,将sibling[x]连接到x上.\nCase4：key[x] > key[sibling[x]].此时,将x连接到sibling[x]上.\n\n> 4.插入节点: $O(\\log n)$\n```\nbinomial-heap-insert(H, x)\nH′ <- make-binomial-heap()\np[x] <- NULL\nchild[x] <- NULL\nsibling[x] <- NULL\ndegree[x] <- 0\nhead[H′] <- x\nH <- binomial-heap-union(H, H′)\n```\n\n> 5.删除最小关键字 $O(\\log n)$\n```\nbinomial-heap-extract-min(H):\nfind the root x with the minimum key in the root list of H,\nand remove x from the root list of H\nH′ <- make-binomial-heap()\nreverse the order of the linked list of x’s children,\nand set head[H′] to point to the head of the resulting list\nH <- binomial-heap-union(H, H′)\n```\n\n> 6.减小关键字值\n减小关键字的过程类似维护最小堆结构,key[y]与y的父结点z的关键字作比较.如果y为根或者key[y] >= key[z],则该二项树已是最小堆有序.否则结点研究违反了最小堆有序,故将其关键字与其父节点z的关键字相交换,同时还要交换其他数据并循环这个过程\n```\nbinomial-heap-decrease-key(H, x, k)\nif k > key[x]\n  then error \"new key is greater than current key\"\nkey[x] <- k\ny <- x\nz <- p[y]\nwhile z ≠ NULL and key[y] < key[z]\n  do exchange key[y] ↔ key[z]\n  y <- z\n  z <- p[y]\n```\n\n> 7.删除关键字\n```\nbinomial-heap-delete(H, x)\n1 binomial-heap-decrease-key(H, x, -INT)\n2 binomial-heap-extract-min(H)\n```\n\n4.总结\n> 可合并堆 = 普通的堆 + `decrease-key,union`操作\n但是其应该高效的实现, `union`操作是可合并堆最关键的部分.如果不需要高效的支持`union`操作,则普通的堆结构已经足够.\n对于所有的堆结构:二叉堆、二项堆、斐波那契堆.它们的`search`操作都是很慢的,不能像二叉搜索树高效的支持`search`操作!因而在`decrease-key`和`delete`等涉及结点的操作时都需要一个指向结点的指针.\n\n### Chapter20 斐波那契堆\n1.定义\n> 斐波那契堆(Fibonacci heap)是堆中一种,它和二项堆一样,也是一种可合并堆；可用于实现合并优先队列.斐波那契堆比二项堆具有更好的平摊分析性能,它的合并操作的时间复杂度是O(1).\n与二项堆一样,它也是由一组堆最小有序树组成,并且是一种可合并堆.\n与二项堆不同的是,斐波那契堆中的树不一定是二项树；而且二项堆中的树是有序排列的,但是斐波那契堆中的树都是有根而无序的.\n\n！[fib-heap](/images/fib.jpg)\n\n> 斐波那契堆中的所有树的树根被保存在一个链表即根表中.对于一个斐波那契堆,min[H]保存了具有最小节点值的根节点.\n堆中每个节点的数据结构包含如下域：\n>> 1. p[x],指向x的父节点\n>> 2. child[x], 指向x的任意一个孩子\n>> 3. 任意一个节点x的所有孩子被链接在一个双向链表环形链表中\n>> 4. degree,x的孩子的数目\n>> 5. mark,表示自从x上一次称为另一个节点的子女以来,它是否失掉了一个孩子,TRUE表示是失去了\n\n2.操作\n> 1. 创建堆\n```\nmake-fib-heap()\nH <- allocate-node()\nn[H] = 0\nmin[h] = NULL\nreturn H\n```\n\n> 2. 插入: $O(1)$\n```\nfib-heap-insert(H, x)\ndegree[x] <- 0\np[x] <- NUll\nchild[x] <- NULL\nleft[x] <- x\nright[x] <- x\nmark[x] = false\nconcatenate the root list containing x with root list H\nif min[H] = NULL or key[x] < key[min[H]]\n  then min[H] <- x\nn[H] <- n[H] + 1\n```\n\n> 3. 合并: $O(1)$\n合并两个斐波那契堆的操作非常简单,可以分为两步：\n>> 1.将两个根表通过指针合并为一个根表\n>> 2.更新min[H],比较两个堆的min[H],取较小的\n```\nfib-heap-union(H1, H2)\nH <- make-fib-heap()\nmin[H] <- min[H1]\nconcatenate the root list of H@ with the root list of H\nif (min[H1] = NULL) or (min[H2] != NULL) and min[H2] < min[H1])\n  then min[H1] <- min[H2]\nn[H] <- n[H1] + n[H2]\nfree the objects H1 and H2\nreturn H\n```\n\n> 4. 删除最小节点: $O(\\log n)$\n删除最小节点的操作比较复杂,其算法思想为：\n>> 1. 删除最小节点,并将被删除节点的每个孩子都看做新的堆中的一棵树的根,将它们加入到根表中\n>> 2. 遍历根表,合并度数相同的树\n这里的在根链上合并操作与二项树基本相同,就是按“度的递增”顺序排列所有的子树之后,合并具有相同度的子树,使得最后的根链上每一个度 K 都只有至多一棵子树.(这里又与二项堆神似了,所以说斐波那契堆是松散地基于二项堆.)调整根表的步骤\n1:在根表中找出两个具有相同度数的根 x 和 y,且 key[x]<key[y]\n2:将y与x连接.将 y 从根表里去掉,成为 x一个孩子,并增加degree[x].同时,如果y上有标记的话也被清除掉.”\n```\nfib-heap-extract-min(H)\nz <- min[H]\nif z != NULL\n  then for each child x of z\n    do add x to the root list of H\n      p[x] <- NULL\n    remove z from the root list of H\n    if z = right[z]\n      then min[H] <- NULL\n      else min[H] <- right[z]\n        consolidate(H)\n    n[H] <- n[H] - 1\n\nconsolidate(H): #合并H的根表,减少堆中树的数量\n```\n> 5. 减小一个关键字: $O(1)$\n减小一个关键字的字,会破坏最小堆的性质,所以要进行最小堆维护.因为斐波那契支持减小关键字和删除结点操作,所以斐波那契堆的子树就不一定是二项树了.步骤如下：\n>> 1.减此减小不影响堆序,不作调整;\n>> 2.若影响堆序,则从堆中删除该节点,将其加入根表,并检查其父亲的 mark 位;若为 false,则停止,并将其置为 true;若为 true,则删除其父亲,继续递归向上执行;直到一个节点 mark 域为 false 或该节点为根节点为止.\n```\nfib-heap-decrease-key(H, x, k)\nif k > key[x]\n  then return error \"new key is greater than current key\"\nkey[x] <- k\ny <- p[x]\nif y != NULL and key[x] < key[y]\n  then cut(H, x, y)\n    cascading-cut\nif key[x] < key[min[h]]\n  then min[h] <- x\n\ncut(H, x, y)\nremove x from the child list of y, decrementing degree[y]\nadd x to the root list of H\np[x] <- NULL\nmark[x] <- False\n\ncascading-cut(H, y)\nz <- p[y]\nif z != NULL\n   then if mark[y] = False\n      mark[y] <- true\n      else cut(H, y, z)\n        cascading-cut(H, z)\n```\n\n> 6. 删除节点\n```\nfib-heap-delete(H, x)\nfib-heap-decrease-key(H, x, -INT)\nfib-heap-extract-min(H)\n```\n\n3.总结\n斐波那契堆之所以高效,就是因为它放宽了条件了,将很多二项堆要维护的工作都推迟到了`extract-min` 和 `delete`操作之中去了.而它之所以能够放宽条件,就是因为它的限制非常的少,并没有像二项堆一样的要求子树全部必须是二项树,而且根表上的任意度数的子树至多只能有一个.没有了这些限制,斐波那契堆就可以实现的非常的松散以至少将日常工作的维护时间都平摊给 `extract-min` 和 `delete` 操作.\n但是,正如斐波那契堆现在更多的应用于理论中,实践中使用的并不多的现象所映射的,在大部分的应用中斐波那契堆并不能带来大幅度的效率的提升.因为它并不是减少了要做的工作,只是将很多要做的工作都进行了推迟.\n但一般对于规模足够大的输入,斐波那契堆是能够很大改善算法的性能的,尤其是对于一些 `extract-min`和 `delete` 操作少的情况.比如斐波那契堆的使用能加快Prime 和 Djikstra 算法的执行速度.\n\n### Chapter21 用于划分的数据结构-不相交集合\n1.定义：\n不相交集合数据结构（disjoing-set data structure)保持一组不相交的动态集合 $S = \\\\{S_1,S_2,S_3, \\dots, S_k\\\\}$.每个集合通过一个代表来识别,代表即集合中的某个成员.\n不相交集合数据结构支持如下操作：\n> 1. `make-set(x)`： 建立一个新的集合,其唯一成员就是x,所以其代表也就是自己.因为各集合是不相交的,故要求x没有在其他集合中出现过.\n> 2. `union(x,y)`： 将包含x和y的动态集合（比如说 $S_x和S_y$）合并为一个新的集合（即这两个集合的并集）.假定这个操作之前是不相交的.在经过此操作后,所得集合的代表可以是$Sx \\bigcup Sy$中的任何一个成员,但在`union`的很多实现细节中,都选择Sx或Sy的代表作为新的代表.由于要求各集合是不相交的,故我们“消除”集合Sx和Sy,把它们从S中删去.\n> 3. `find-set(x)`：返回一个指针,指向包含x的（唯一）集合的代表.\n\n2.表示\n不相交数据集合一般用链表或森林来实现,有根树的速度更快.\n> 1.链表表示\n>> a. 每个链表的第一个对象作为它所在集合的代表\n>> b. 链表上的第个结点都有指向它所在集合的代表的指针,从而使得找出所属集合的操作时间降为 $O(1)$\n>> c. 但是因为每个结点都有指向代表的指针,使得在进行合并操作时,需要更新所有结点的指向代表的指针,从而时间复杂度为 $O(n)$.\n>> d. 一种加权合并启发式策略:在进行合并操作时,总是把较短的表拼到较长的表上去.\n\n> 2.树表示\n> 用有根树来表示集合,树中的每个节点都包含集合的一个成员,每棵树都表示一个集合.不相交森林中,每个成员仅指向其父节点.每个树的根包含了代表,并且是它自己的父节点.尽管采用了这种表示的直观算法并不比采用链表表示的直观算法并不比采用链表表示的算法更快,但是,通过引入两种启发式策略（“按秩合并”和“路径压缩”）,就可以获得目前已知的,渐进意义上最快的不相交集合的数据结构\n```\nmake-set(x)\np[x] <- x\nrank[x] <- 0\n```\n>> 1.按秩合并,其思想是是包含较少节点的树的根指向包含较多节点的树的根.我们并不显示的记录以每个节点为根的子树大小,而是采用了一种能够简化分析的方法.对每个节点,用秩表示节点高度的一个上届.在按秩合并中具有较小秩的根在`union`操作中要指向具有较大秩的根.\n![tree-set](/images/union.jpg)\n```\nunion(x, y)\nlink(find-set(x), find-set(y))\n\nlink(x, y)\nif rank[x] > rank[y]\n  then p[y] <- x\n  else p[x] <- y\n    if rank[x] = rank[y]\n      then rank[y] <- rank[y] + 1\n```\n>> 2.路径压缩,它非常简单而有效.如下图所示,在`find-set`操作中,利用这种启发式策略,来使查找路径上的每个节点都直接指向根节点.路径压缩并不改变节点的秩\n！[find-set1](find-set1.gif)\n```\nfind-set(x)\nif x != p[x]\n  then p[x] <- find-set(p[x])\nreturn p[x]\n```\n\n3.应用\n不相交集合数据结构有多种应用,其中之一是用于确定一个无向图中连通子图的个数.在下面给出的过程`connected-components`中,利用了不相交集合操作来计算一个图的连通子图.一旦`connected-components`作为预处理步骤执行后,过程`same-component`回答两个顶点是否在同一连通子图的查询.\n```\nconnected-components(G) #图G,顶点集V[G],边集E[G]\nfor each vertex v in V[G]\n    do make-set(v)\nfor each edge(u, v) in E[G]\n    do if find-set(u) != find-set(v)\n        then union(u, v)\n\nsame-component(u, v)\nif find-set(u) = find-set(v)\n    then return true\n    else return false\n```\n![find-set2](find-set2.gif)\n","slug":"CLRS-notes4","published":1,"updated":"2017-08-26T03:38:21.618Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6sslhav00083gamypcq3who","content":"<h1 id=\"＜Introduction-to-algorithms＞笔记\"><a href=\"#＜Introduction-to-algorithms＞笔记\" class=\"headerlink\" title=\"＜Introduction to algorithms＞笔记\"></a>＜Introduction to algorithms＞笔记</h1><h2 id=\"Part5-高级数据结构\"><a href=\"#Part5-高级数据结构\" class=\"headerlink\" title=\"Part5 高级数据结构\"></a>Part5 高级数据结构</h2><p>在<a href=\"https://chestnutme.github.io/2017/04/17/CLRS-notes2/\" target=\"_blank\" rel=\"external\">part3数据结构</a>中,学习了基本的支持动态集合的数据结构,包括stack/queue/bst/rbt.接着在<a href=\"https://chestnutme.github.io/2017/04/22/CLRS-notes3/\" target=\"_blank\" rel=\"external\">part4高级设计和分析技术</a>中学习了在分治法/递归等基本算法设计思想上的动态规划和贪心思想,以及如何对复杂的算法进行分析的平摊分析法.在以上学习的基础上,part5学习高级的数据结构如下：</p>\n<ul>\n<li>B树:一种被设计成专门存储在磁盘上的平衡查找树.因为磁盘的速度远远慢于内存,所以 B 树被设计成尽量减少磁盘访问的次数,知道了这一点之后就会很清楚明白B树的变形 B+树了,B+树通过将数据存储在叶子结点从而增大了一个结点所包含的信息进而更加的减少了磁盘的访问次数.</li>\n<li>可合并堆:这种堆支持<code>Insert,Mininum,Extract-Min,union,delete,decrease-key</code>操作.<blockquote>\n<ul>\n<li>二项堆能够在 $O(\\log n)$ 的最坏情况时间内支持以上的各种操作.当必须支持 <code>union</code>操作时,二项堆优越于二叉堆,因为后者在最坏情况下,合并两个二叉堆要花 $O(n)$ 的时间.</li>\n<li>斐波那契堆对于以上各种除了<code>extract-min,delete</code>的操作外都只需要 O(1)的实际时间,而<code>extract-min,delete</code>也只需要 $O(\\log n)$ 的平摊时间.它的重要优点在于<code>decrease-key</code>也只需要 O(1)的平摊时间.注意斐波那契堆的一些操作都只是平摊时间,并非最坏情况时间.现代的快速图算法(part6,下一部分)中,很多是使用斐波那契堆作为其核心数据结构的.</li>\n</ul>\n</blockquote>\n</li>\n<li>不相交集合(并查集):由n个元素构成的全域集被划分为若干个动态集合.基本操作为<code>union, find-set</code>通过用一棵简单的有根树来表示每个集合,就可以得到惊人的快速操作:一个由m个操作构成的序列的运行时间为 $O(n\\alpha (n) )$,而对于宇宙中的原子数总和 n,α(n)也&lt;=4,所以可以认为实际时间是 $O(n)$.</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"Chapter18-如何对大量数据进行索引？\"><a href=\"#Chapter18-如何对大量数据进行索引？\" class=\"headerlink\" title=\"Chapter18 如何对大量数据进行索引？\"></a>Chapter18 如何对大量数据进行索引？</h3><p>1.B-tree 产生背景：</p>\n<blockquote>\n<p>大规模数据存储（如磁盘阵列,数据库）中,实现索引查询这样一个实际背景下,树节点存储的元素数量是有限的(如果元素数量非常多的话,查找就退化成节点内部的线性查找了),这样导致二叉查找树结构由于树的深度过大而造成磁盘 I/O读写过于频繁,进而导致查询效率低下(读取磁盘速度远慢于访问内存),那么如何减少树的深度(而不是能减少查询的数据量),一个基本的、很自然的想法就是:采用多叉树结构.由于树节点元素数量是有限的,自然该节点的子树数量也就是有限的.每个节点储存多个数据使得节点数减少,继而减少树的高度,从而减少对磁盘的访问次数,极大的提高数据操作效率.<br>在大多数系统中,B 树算法的运行时间主要由它所执行的磁盘读取操作<code>disk-read</code>和<code>disk-write</code> 的次数所决定,因而应该有效地使用这两种操作,即让它们读取更多的信息更少的次数.由于这个原因,在 B 树中,一个结点的大小通常相当于一个完整的磁盘页.因此,一个B树结点可以拥有的子女数就由磁盘页的大小所决定.<br>因此, 树的分支因子越大越好,因为这样运行时间的绝大部分都是由磁盘存取次数决定的.分支因子越大,需要进行的磁盘存取次数就越少.但是这个分支因子是有限制的,一个结点的总大小不能大于磁盘中一个页的大小,否则在一个结点内操作时还要来回访问内存,反而会拖慢效率.<br>下图是一棵B树的典型例子.：</p>\n</blockquote>\n<p>！<a href=\"/images/b-tree.png\">b-tree</a></p>\n<p>2.B-tree定义</p>\n<blockquote>\n<p>B树是为了磁盘或其它存储设备而设计的一种多叉（相对于二叉,B树每个内结点有多个分支,即多叉）平衡查找树.与part3介绍的红黑树（red-black-tree)很相似,但在降低磁盘I/0操作方面要更好一些.许多数据库系统都一般使用B树或者B树的各种变形结构,如用B+树,B*树来存储信息.B树与红黑树最大的不同在于,B树的结点可以有许多子女,从几个到几千个.那为什么又说B树与红黑树很相似呢?因为与红黑树一样,一棵含n个结点的B树的高度也为 $O(\\log n)$,但可能比一棵红黑树的高度小许多,应为它的分支因子比较大.所以,B树可以在$O(\\log n)$时间内,实现各种如<code>insert,delete</code>等动态集合操作.</p>\n<p>有根树（根为root[T])B树性质如下：</p>\n<ol>\n<li>节点x具有以下域：<blockquote>\n<p>a. n[x], 节点x中的关键字数<br>b. n[x]个关键字,非降序排列,即 $key_1[x] \\leq key_2[x] \\leq \\dots \\leq key_{n[x]}[x]$<br>c. leaf[x], bool值,为true如果是叶子节点</p>\n</blockquote>\n</li>\n<li>n[x] + 1个指向子女的指针 $c_1[x], c_2[x], \\dots, c_{n[x]+1}$</li>\n<li>$key_i[x]$ 对子树的关键字进行分隔,记 $k_i$为储存在以 $c_i[x]$ 为根的子树的关键字, 有：<br>$$ k_1 \\leq key_1[x] \\leq k_2 \\leq key_2[x] \\leq \\dots key_{n[x]}[x] \\leq k_{n[x]+1}$$</li>\n<li>叶节点深度相同, 为树高h</li>\n<li>节点包含关键字数最小值为度树t：<blockquote>\n<p>a. 非根每个结点可包含至多2m-1个关键字.所以一个内结点至多可有2m个子女.如果一个结点恰好有2m-1个关键字,则这个结点是满的<br>b. 每个结点可包含至多2m-1个关键字.所以一个内结点至多可有2m个子女.如果一个结点恰好有2m-1个关键字,我们就说这个结点是满的</p>\n</blockquote>\n</li>\n</ol>\n</blockquote>\n<p>包含n个关键字,高度为h,最小度数 $t \\geq 2$的B树有：</p>\n<blockquote>\n<p>若B树高度为h,其根节点至少包含一个关键字,其他节点至少包含t-1个关键字,<br>第一层至少有2个节点, 第二层至少2t个节点,第三层至少 $2t^2$个节点,故有：<br>$$ n \\geq 1 + (t-1)\\sum_{i=1}^h 2t^{i-1} = 1 + 2(t-1)(\\frac{t^h-1}{t-1}) =  2t^h - 1 $$<br>$$ h \\leq \\log_t \\frac{n+1}{2} $$</p>\n</blockquote>\n<p>3.B树的操作:</p>\n<blockquote>\n<ol>\n<li><p>查找 $O(t \\log_t n)$：bst上查找的推广</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">b-tree-search(x, k):</div><div class=\"line\">i &lt;- 1</div><div class=\"line\">while i \u0002&lt;= n[x] and k &gt; keyi[x]</div><div class=\"line\">  do i &lt;- i + 1</div><div class=\"line\">if i &lt;= n[x] and k= keyi[x]</div><div class=\"line\">  then return (x,i)</div><div class=\"line\">if leaf[x]</div><div class=\"line\">  then return NULL</div><div class=\"line\">  else disk-read(ci[x])</div><div class=\"line\">    return b-tree-search(ci[x], k)</div></pre></td></tr></table></figure>\n</li>\n<li><p>插入 $O(t \\log_t n)$：<br>插入一个元素时,首先在B树中是否存在,如果不存在,即在叶子结点处结束,然后在叶子结点中插入该新的元素,注意：如果叶子结点空间足够,这里需要向右移动该叶子结点中大于新插入关键字的元素,如果空间满了以致没有足够的空间去添加新的元素,则将该结点进行“分裂”,将一半数量的关键字元素分裂到新的其相邻右结点中,中间关键字元素上移到父结点中（当然,如果父结点空间满了,也同样需要“分裂”操作）,而且当结点中关键元素向右移动了,相关的指针也需要向右移.如果在根结点插入新元素,空间满了,则进行分裂操作,这样原来的根结点中的中间关键字元素向上移动到新的根结点中,因此导致树的高度增加一层.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\">b-tree-split-child(x, i, y)</div><div class=\"line\">z &lt;- allocate-node()</div><div class=\"line\">lead[z] &lt;- leaf[y]</div><div class=\"line\">n[z] &lt;- t - 1</div><div class=\"line\">for j &lt;- 1 ot t - 1</div><div class=\"line\">  do keyi[z] &lt;- key[j+i][y]</div><div class=\"line\">if not leaf[y]</div><div class=\"line\">  then for j &lt;- 1 to t</div><div class=\"line\">    do cj[z] &lt;- c[j+i][y]</div><div class=\"line\">n[y] &lt;- t - 1</div><div class=\"line\">for j &lt;- n[x] + 1 downto i + 1</div><div class=\"line\">  do c[j+1][x] &lt;- cj[x]</div><div class=\"line\">c[i+1][x] &lt;- z</div><div class=\"line\">for j &lt;- n[x] downto i</div><div class=\"line\">  do key[j+1][x] &lt;- keyj[x]</div><div class=\"line\">keyi[x] &lt;- keyi[y]</div><div class=\"line\">n[x] &lt;- n[x] + 1</div><div class=\"line\">disk-write(y)</div><div class=\"line\">disk-write(z)</div><div class=\"line\">disk-write(x)</div><div class=\"line\"></div><div class=\"line\">b-tree-insert(T, k)</div><div class=\"line\">r &lt;- root[T]</div><div class=\"line\">if n[r] = 2t - 1</div><div class=\"line\">  then s &lt;- allocate-node()</div><div class=\"line\">    root[T] &lt;- s</div><div class=\"line\">    leaf[s] &lt;- False</div><div class=\"line\">    n[s] &lt;- 0</div><div class=\"line\">    c1[s] &lt;- r</div><div class=\"line\">    b-tree-split-child(s, 1, r)</div><div class=\"line\">    b-tree-insert-nonfull(s, k)</div><div class=\"line\">else b-tree-insert-nonfull(r, k)</div><div class=\"line\"></div><div class=\"line\">b-tree-insert-nonfull(x, k): #关键词k插入非满节点x</div><div class=\"line\">i &lt;- n[x]</div><div class=\"line\">if leaf[x]</div><div class=\"line\">  then while i &gt;= 1 and k &lt; keyi[x]</div><div class=\"line\">      do key[i+1][x] &lt;- keyi[x]</div><div class=\"line\">        i&lt;- i - 1</div><div class=\"line\">    key[i+1][x] &lt;- k</div><div class=\"line\">    n[x] &lt;- n[x] + 1</div><div class=\"line\">    disk-write(x)</div><div class=\"line\">  else while i &gt;= 1 and k &lt; keyi[x]</div><div class=\"line\">      do i &lt;- i + 1</div><div class=\"line\">      i &lt;- i + 1</div><div class=\"line\">      disk-read(ci[x])</div><div class=\"line\">      if n[ci[x]] = 2t - 1</div><div class=\"line\">        then b-tree-split-child(x, i, ci[x])</div><div class=\"line\">          if k &gt; keyi[x]</div><div class=\"line\">            then i &lt;- i + 1</div><div class=\"line\">        b-tree-insert-nonfull(ci[x], k)</div></pre></td></tr></table></figure>\n</li>\n<li><p>删除 $O(t \\log_t n)$：<br>删除操作稍微复杂一些,因为删除操作不仅仅会发生在叶子结点,还可能会发生在内结点,这与插入操作不同.但是可以通过一个技巧消除这一点,找到要删除结点的前驱,然后与要删除的结点的关键值进行对调,再删除这个前驱结点就可以保证每次要删除的都是叶子结点<br>具体如下:<br>任一关键字 K 的中序前趋(后继)必是 K 的左子树(右子树)中最右(左)下的结点中最后(最前)一个关键字.根据 B 树的性质:B<br>树上每一个结点的关键字的个数必须为[t-1, 2<em>t-1]之间,记Min = t - 1.若被删关键字K所在的结点非树叶,则用 K的中序前趋(或后继)K’取代 K,然后从叶子中删去 K’.从叶子</em>x 开始删去某关键字K的三种情形为:</p>\n<blockquote>\n<p>a. 若 x-&gt;keynum&gt;Min,则只需删去K及其右指针(x是叶子,K的右指针为空)即可使删除操作结束.<br>b. 若 x-&gt;keynum=Min,该叶子中的关键字个数已是最小值,删K及其右指针后会破坏B树的性质3.若x的左(或右)邻兄弟结点y 中的关键字数目大于Min,则将y中的最大(或最小)关键字上移至双亲结点parent 中,而将parent中相应的关键字下移至 x 中.显然这种移动使得双亲中关键字数目不变;y 被移出一个关键字,故其keynum减1,因它原大于Min,故减少1个关键字后keynum仍大于等于Min;而x中已移入一个关键字,故删 K 后x中仍 Min 个关键字.涉及移动关键字的三个结点均满足 B-树的性质3.移动完<br>成后,删除过程亦结束.<br>c.若x及其相邻的左右兄弟(也可能只有一个兄弟)中的关键字数目均为最小值 Min,则上述的移动操作就不奏效,此时节点x和左或右兄弟合并.不妨设x有右邻兄弟y(对左邻兄弟的讨论与此类似),在x中删去K及其右子树后,将双亲结点parent中介于x和y之间的关键字K,作为中间关键字,与并x和y中的关键字一起”合并”为一个新的结点取代x和y.因为x和y原各有Min个关键字,从双亲中移人的K’抵消了从x中删除的 K,故新结点中恰有 2Min(即2t-2 &lt;= 2t-1)个关键字,没有破坏B树的性质3.但由于 K’从双亲中移到新结点后,相当于从parent中删去了K’,若parent-&gt;keynum原大于 Min,则删除操作到此结束;否则,同样要通过移动*parent 的左右兄弟中的关键字或将parent与 左右兄弟合并的方法来维护B树性质.最坏情况下,合并操作会向上传播至根节点,当根节点中只有一个关键字时,合并操作将会使根结点及其两个孩子合并成一个新的根,从而使整棵树的高度减少一层.<br>删除操作看似复杂,但是对一棵高度为h的B树,它只需要 $O(h)$ 次磁盘操作,因为在递归调用的过程之间,仅需要 $O(1)$ 次<code>disk-read,disk-write</code>操作,时间复杂度为 $O(th)=O(tlog_tn)$.</p>\n</blockquote>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"Chapter19-二项堆\"><a href=\"#Chapter19-二项堆\" class=\"headerlink\" title=\"Chapter19 二项堆\"></a>Chapter19 二项堆</h3><p>1.二项堆(Binomial Heaps)定义</p>\n<blockquote>\n<p>二项堆（Binomial Heap）是一种类似于二叉堆(Binary Heap)的堆结构.与二叉堆相比,其优势是可以快速合并两个堆,因此它属于可合并堆（Mergeable Heap）.x下一张的斐波那契堆也是可合并堆.一个二项堆由一组二项树所构成,这里的二项树(Binomial Tree)不同于二叉树(Binary Trees).二叉树是“左孩子,右孩子”的表示方法,而二项树是“左孩子,右兄弟”的表示方法.<br>二项树定义：<br>二项树是一种特殊的多分支有序树.二项树 $B_k$是一种递归定义的有序树.二项树 $B_0$只包含一个结点.二项树 $B_k$由两个子树 $B_{k-1}$连接而成：其中一棵树的根是另一棵树的根的最左孩子.性质如下：<br>1.共有2k个结点.<br>2.树的高度为k.<br>3.在深度i处恰有 $C_i^k$个结点.<br>4.根的度数（子女的个数）为k,它大于任何其他结点的度数；如果根的子女从左到右的编号设为k-1, k-2, …, 0,子女i是子树$B_i$的根.</p>\n</blockquote>\n<p><img src=\"/images/b-heap1.jpg\" alt=\"b-heap1\"></p>\n<blockquote>\n<p>一个二项堆由一组二项树所构成,这里的二项树需要满足下列条件：</p>\n<ol>\n<li>每棵二项树都满足最小堆性质.即,父节点的关键字 &lt;= 它的孩子的关键字.</li>\n<li>对于任意非负整数k,在堆中至多有一棵二项树的根具有度数k.<br>第一个性质保证了二项树的根结点包含了最小的关键字.第二个性质则说明结点数为 n 的二项堆最多只有 $\\log n + 1$棵二项树</li>\n</ol>\n</blockquote>\n<p>2.二项堆表示<br>如下图,二项堆(heap[H])每棵二项树按”左孩子,右兄弟方法储存“, 二项堆中的各二项树的根被组织成一个链表为根表.节点x的域如下：</p>\n<blockquote>\n<ol>\n<li>p[x],指向x的父节点</li>\n<li>child[x],指向x的最左孩子节点</li>\n<li>sibling[x], 指向x的最右兄弟节点<br><img src=\"/images/b-heap2.jpg\" alt=\"b-heap2\"></li>\n</ol>\n</blockquote>\n<p>3.二项堆操作</p>\n<blockquote>\n<p>1.创建堆: $O(1)$<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">make</div><div class=\"line\">head[H] = NULL</div></pre></td></tr></table></figure></p>\n<p>2.最小关键字 $O(\\log n)$<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">binomial-heap-minimum(H)</div><div class=\"line\">y &lt;- NULL</div><div class=\"line\">x &lt;- heap[H]</div><div class=\"line\">min &lt;- INT</div><div class=\"line\">while x != NULL</div><div class=\"line\">  do if key[x] &lt; min</div><div class=\"line\">    then min &lt;- key[y]</div><div class=\"line\">      y &lt;- x</div><div class=\"line\">  x &lt;- sibling[x]</div><div class=\"line\">return y</div></pre></td></tr></table></figure></p>\n<p>3.合并<br>二项堆最重要的一个操作就是<code>union</code>操作,其它的操作都可以在<code>union</code>操作的基础上轻松的实现.<br>大概思路为:将两个二项堆的根表连接起来组成一个大的二项树的连接,按“度”的单调递增顺序进行排序之后,从左至右来消除具有重复度的二项树.因为原本的每个二项堆中任意度K至多只有一个相应的二项树,所以这个消除重复的操作会非常容易.从小到大找到两个相同度K的二项树,然后连接成一个K+1度的二项树,直到链尾时合并完毕.完成后二项堆就满足对任意度K至多只有一棵二项树.<br>具体分解为三个过程：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">binomial-link(y, z)：#将两棵根节点度数相同的二项树Bk-1连接成一棵Bk</div><div class=\"line\">p[y] &lt;- z</div><div class=\"line\">sibling[y] &lt;- child[z]</div><div class=\"line\">child[z] &lt;- y</div><div class=\"line\">degree[z] &lt;- degree[z] + 1</div><div class=\"line\">binomial-heap-merge #将H1和H2的根表合并成一个按度数的单调递增次序排列的链表</div><div class=\"line\">binomial-heap-union： #反复连接根节点的度数相同的各二项树</div><div class=\"line\">H &lt;- make-binomial-heap()</div><div class=\"line\">head[H] &lt;- binomial-heap-merge(H1, H2)</div><div class=\"line\">free the objects H1 and H2 but not the lists they point to</div><div class=\"line\">if head[H] = NULL</div><div class=\"line\">  then return H</div><div class=\"line\">prev-x &lt;- NULL</div><div class=\"line\">x &lt;- head[H]</div><div class=\"line\">next-x &lt;- sibling[x]</div><div class=\"line\">while next-x ≠ NULL</div><div class=\"line\">  do if (degree[x] ≠ degree[next-x]) or (sibling[next-x] ≠ NULL and degree[sibling[next-x]] = degree[x])</div><div class=\"line\">    then prev-x &lt;- x ▹ Cases 1 and 2                #case1 and 2</div><div class=\"line\">      x &lt;- next-x ▹ Cases 1 and 2</div><div class=\"line\">    else if key[x] ≤ key[next-x]</div><div class=\"line\">      then sibling[x] &lt;- sibling[next-x] ▹ Case 3   #case3</div><div class=\"line\">        binomial-link(next-x, x) ▹ Case 3</div><div class=\"line\">    else if prev-x = NULL ▹ Case 4                  #case4</div><div class=\"line\">      then head[H] &lt;- next-x ▹ Case 4</div><div class=\"line\">      else sibling[prev-x] &lt;- next-x ▹ Case 4</div><div class=\"line\">      binomial-link(x, next-x) ▹ Case 4</div><div class=\"line\">      x &lt;- next-x ▹ Case 4</div><div class=\"line\">  next-x &lt;- sibling[x]</div><div class=\"line\">return H</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p><code>union</code>操作分为两个阶段：<br>第一阶段：执行<code>binomial-heap-merge</code>,将两个堆H1和H2的根表合并成一个链表H,它按度数排序成单调递增次序.MERGE的时间复杂度 $O(\\log n)$.n为H1和H2的结点总数.（对于每一个度数值,可能有两个根与其对应,所以第二阶段要把这些相同的根连起来）.<br>第二阶段：将相等度数的根连接起来,直到每个度数至多有一个根时为止.执行过程中,合并的堆H的根表中至多出现三个根具有相同的度数.合并的时候对于每一个节点,要么在主链上去掉连到其它二项树中,而插入别的二项树中的复杂度为 $O(1)$,要么只是遍历,总的节点是n个,根节点是lg(n)个,所以总的时间为 $O(\\log n)$,加上merge的时间为 $O(\\log n)$,总的时间为 $O(\\log n)$.（merge后H中至多出现两个根具有相同的度数,但是将两个相同度数的根的二项树连接后,可能与后面的至多两棵二项树出现相同的度数的根,因此至多出现三个根具有相同的度数）<br>第二阶段根据当前遍历到的根表中的结点x,分四种情况考虑:<br>Case1：degree[x] != degree[sibling[x]].此时,不需要做任何变化,将指针向根表后移动即可.<br>Case2：degree[x] == degree[sibling[x]] == degree[sibling[sibling[x]]].此时,仍不做变化,将指针后移.<br>Case3 &amp; Case4：degree[x] = degree[sibling[x]] != degree[sibling[sibling[x]]]<br>Case3：key[x] &lt;= key[sibling[x]].此时,将sibling[x]连接到x上.<br>Case4：key[x] &gt; key[sibling[x]].此时,将x连接到sibling[x]上.</p>\n</blockquote>\n<p>4.插入节点: $O(\\log n)$<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">binomial-heap-insert(H, x)</div><div class=\"line\">H′ &lt;- make-binomial-heap()</div><div class=\"line\">p[x] &lt;- NULL</div><div class=\"line\">child[x] &lt;- NULL</div><div class=\"line\">sibling[x] &lt;- NULL</div><div class=\"line\">degree[x] &lt;- 0</div><div class=\"line\">head[H′] &lt;- x</div><div class=\"line\">H &lt;- binomial-heap-union(H, H′)</div></pre></td></tr></table></figure></p>\n<p>5.删除最小关键字 $O(\\log n)$<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">binomial-heap-extract-min(H):</div><div class=\"line\">find the root x with the minimum key in the root list of H,</div><div class=\"line\">and remove x from the root list of H</div><div class=\"line\">H′ &lt;- make-binomial-heap()</div><div class=\"line\">reverse the order of the linked list of x’s children,</div><div class=\"line\">and set head[H′] to point to the head of the resulting list</div><div class=\"line\">H &lt;- binomial-heap-union(H, H′)</div></pre></td></tr></table></figure></p>\n<p>6.减小关键字值<br>减小关键字的过程类似维护最小堆结构,key[y]与y的父结点z的关键字作比较.如果y为根或者key[y] &gt;= key[z],则该二项树已是最小堆有序.否则结点研究违反了最小堆有序,故将其关键字与其父节点z的关键字相交换,同时还要交换其他数据并循环这个过程<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">binomial-heap-decrease-key(H, x, k)</div><div class=\"line\">if k &gt; key[x]</div><div class=\"line\">  then error &quot;new key is greater than current key&quot;</div><div class=\"line\">key[x] &lt;- k</div><div class=\"line\">y &lt;- x</div><div class=\"line\">z &lt;- p[y]</div><div class=\"line\">while z ≠ NULL and key[y] &lt; key[z]</div><div class=\"line\">  do exchange key[y] ↔ key[z]</div><div class=\"line\">  y &lt;- z</div><div class=\"line\">  z &lt;- p[y]</div></pre></td></tr></table></figure></p>\n<p>7.删除关键字<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">binomial-heap-delete(H, x)</div><div class=\"line\">1 binomial-heap-decrease-key(H, x, -INT)</div><div class=\"line\">2 binomial-heap-extract-min(H)</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>4.总结</p>\n<blockquote>\n<p>可合并堆 = 普通的堆 + <code>decrease-key,union</code>操作<br>但是其应该高效的实现, <code>union</code>操作是可合并堆最关键的部分.如果不需要高效的支持<code>union</code>操作,则普通的堆结构已经足够.<br>对于所有的堆结构:二叉堆、二项堆、斐波那契堆.它们的<code>search</code>操作都是很慢的,不能像二叉搜索树高效的支持<code>search</code>操作!因而在<code>decrease-key</code>和<code>delete</code>等涉及结点的操作时都需要一个指向结点的指针.</p>\n</blockquote>\n<h3 id=\"Chapter20-斐波那契堆\"><a href=\"#Chapter20-斐波那契堆\" class=\"headerlink\" title=\"Chapter20 斐波那契堆\"></a>Chapter20 斐波那契堆</h3><p>1.定义</p>\n<blockquote>\n<p>斐波那契堆(Fibonacci heap)是堆中一种,它和二项堆一样,也是一种可合并堆；可用于实现合并优先队列.斐波那契堆比二项堆具有更好的平摊分析性能,它的合并操作的时间复杂度是O(1).<br>与二项堆一样,它也是由一组堆最小有序树组成,并且是一种可合并堆.<br>与二项堆不同的是,斐波那契堆中的树不一定是二项树；而且二项堆中的树是有序排列的,但是斐波那契堆中的树都是有根而无序的.</p>\n</blockquote>\n<p>！<a href=\"/images/fib.jpg\">fib-heap</a></p>\n<blockquote>\n<p>斐波那契堆中的所有树的树根被保存在一个链表即根表中.对于一个斐波那契堆,min[H]保存了具有最小节点值的根节点.<br>堆中每个节点的数据结构包含如下域：</p>\n<blockquote>\n<ol>\n<li>p[x],指向x的父节点</li>\n<li>child[x], 指向x的任意一个孩子</li>\n<li>任意一个节点x的所有孩子被链接在一个双向链表环形链表中</li>\n<li>degree,x的孩子的数目</li>\n<li>mark,表示自从x上一次称为另一个节点的子女以来,它是否失掉了一个孩子,TRUE表示是失去了</li>\n</ol>\n</blockquote>\n</blockquote>\n<p>2.操作</p>\n<blockquote>\n<ol>\n<li><p>创建堆</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">make-fib-heap()</div><div class=\"line\">H &lt;- allocate-node()</div><div class=\"line\">n[H] = 0</div><div class=\"line\">min[h] = NULL</div><div class=\"line\">return H</div></pre></td></tr></table></figure>\n</li>\n<li><p>插入: $O(1)$</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">fib-heap-insert(H, x)</div><div class=\"line\">degree[x] &lt;- 0</div><div class=\"line\">p[x] &lt;- NUll</div><div class=\"line\">child[x] &lt;- NULL</div><div class=\"line\">left[x] &lt;- x</div><div class=\"line\">right[x] &lt;- x</div><div class=\"line\">mark[x] = false</div><div class=\"line\">concatenate the root list containing x with root list H</div><div class=\"line\">if min[H] = NULL or key[x] &lt; key[min[H]]</div><div class=\"line\">  then min[H] &lt;- x</div><div class=\"line\">n[H] &lt;- n[H] + 1</div></pre></td></tr></table></figure>\n</li>\n<li><p>合并: $O(1)$<br>合并两个斐波那契堆的操作非常简单,可以分为两步：</p>\n<blockquote>\n<p>1.将两个根表通过指针合并为一个根表<br>2.更新min[H],比较两个堆的min[H],取较小的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">fib-heap-union(H1, H2)</div><div class=\"line\">H &lt;- make-fib-heap()</div><div class=\"line\">min[H] &lt;- min[H1]</div><div class=\"line\">concatenate the root list of H@ with the root list of H</div><div class=\"line\">if (min[H1] = NULL) or (min[H2] != NULL) and min[H2] &lt; min[H1])</div><div class=\"line\">  then min[H1] &lt;- min[H2]</div><div class=\"line\">n[H] &lt;- n[H1] + n[H2]</div><div class=\"line\">free the objects H1 and H2</div><div class=\"line\">return H</div></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li><p>删除最小节点: $O(\\log n)$<br>删除最小节点的操作比较复杂,其算法思想为：</p>\n<blockquote>\n<ol>\n<li>删除最小节点,并将被删除节点的每个孩子都看做新的堆中的一棵树的根,将它们加入到根表中</li>\n<li>遍历根表,合并度数相同的树<br>这里的在根链上合并操作与二项树基本相同,就是按“度的递增”顺序排列所有的子树之后,合并具有相同度的子树,使得最后的根链上每一个度 K 都只有至多一棵子树.(这里又与二项堆神似了,所以说斐波那契堆是松散地基于二项堆.)调整根表的步骤<br>1:在根表中找出两个具有相同度数的根 x 和 y,且 key[x]&lt;key[y]<br>2:将y与x连接.将 y 从根表里去掉,成为 x一个孩子,并增加degree[x].同时,如果y上有标记的话也被清除掉.”<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">fib-heap-extract-min(H)</div><div class=\"line\">z &lt;- min[H]</div><div class=\"line\">if z != NULL</div><div class=\"line\">  then for each child x of z</div><div class=\"line\">    do add x to the root list of H</div><div class=\"line\">      p[x] &lt;- NULL</div><div class=\"line\">    remove z from the root list of H</div><div class=\"line\">    if z = right[z]</div><div class=\"line\">      then min[H] &lt;- NULL</div><div class=\"line\">      else min[H] &lt;- right[z]</div><div class=\"line\">        consolidate(H)</div><div class=\"line\">    n[H] &lt;- n[H] - 1</div><div class=\"line\"></div><div class=\"line\">consolidate(H): #合并H的根表,减少堆中树的数量</div></pre></td></tr></table></figure>\n</li>\n</ol>\n</blockquote>\n</li>\n<li><p>减小一个关键字: $O(1)$<br>减小一个关键字的字,会破坏最小堆的性质,所以要进行最小堆维护.因为斐波那契支持减小关键字和删除结点操作,所以斐波那契堆的子树就不一定是二项树了.步骤如下：</p>\n<blockquote>\n<p>1.减此减小不影响堆序,不作调整;<br>2.若影响堆序,则从堆中删除该节点,将其加入根表,并检查其父亲的 mark 位;若为 false,则停止,并将其置为 true;若为 true,则删除其父亲,继续递归向上执行;直到一个节点 mark 域为 false 或该节点为根节点为止.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">fib-heap-decrease-key(H, x, k)</div><div class=\"line\">if k &gt; key[x]</div><div class=\"line\">  then return error &quot;new key is greater than current key&quot;</div><div class=\"line\">key[x] &lt;- k</div><div class=\"line\">y &lt;- p[x]</div><div class=\"line\">if y != NULL and key[x] &lt; key[y]</div><div class=\"line\">  then cut(H, x, y)</div><div class=\"line\">    cascading-cut</div><div class=\"line\">if key[x] &lt; key[min[h]]</div><div class=\"line\">  then min[h] &lt;- x</div><div class=\"line\"></div><div class=\"line\">cut(H, x, y)</div><div class=\"line\">remove x from the child list of y, decrementing degree[y]</div><div class=\"line\">add x to the root list of H</div><div class=\"line\">p[x] &lt;- NULL</div><div class=\"line\">mark[x] &lt;- False</div><div class=\"line\"></div><div class=\"line\">cascading-cut(H, y)</div><div class=\"line\">z &lt;- p[y]</div><div class=\"line\">if z != NULL</div><div class=\"line\">   then if mark[y] = False</div><div class=\"line\">      mark[y] &lt;- true</div><div class=\"line\">      else cut(H, y, z)</div><div class=\"line\">        cascading-cut(H, z)</div></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li><p>删除节点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">fib-heap-delete(H, x)</div><div class=\"line\">fib-heap-decrease-key(H, x, -INT)</div><div class=\"line\">fib-heap-extract-min(H)</div></pre></td></tr></table></figure>\n</li>\n</ol>\n</blockquote>\n<p>3.总结<br>斐波那契堆之所以高效,就是因为它放宽了条件了,将很多二项堆要维护的工作都推迟到了<code>extract-min</code> 和 <code>delete</code>操作之中去了.而它之所以能够放宽条件,就是因为它的限制非常的少,并没有像二项堆一样的要求子树全部必须是二项树,而且根表上的任意度数的子树至多只能有一个.没有了这些限制,斐波那契堆就可以实现的非常的松散以至少将日常工作的维护时间都平摊给 <code>extract-min</code> 和 <code>delete</code> 操作.<br>但是,正如斐波那契堆现在更多的应用于理论中,实践中使用的并不多的现象所映射的,在大部分的应用中斐波那契堆并不能带来大幅度的效率的提升.因为它并不是减少了要做的工作,只是将很多要做的工作都进行了推迟.<br>但一般对于规模足够大的输入,斐波那契堆是能够很大改善算法的性能的,尤其是对于一些 <code>extract-min</code>和 <code>delete</code> 操作少的情况.比如斐波那契堆的使用能加快Prime 和 Djikstra 算法的执行速度.</p>\n<h3 id=\"Chapter21-用于划分的数据结构-不相交集合\"><a href=\"#Chapter21-用于划分的数据结构-不相交集合\" class=\"headerlink\" title=\"Chapter21 用于划分的数据结构-不相交集合\"></a>Chapter21 用于划分的数据结构-不相交集合</h3><p>1.定义：<br>不相交集合数据结构（disjoing-set data structure)保持一组不相交的动态集合 $S = \\{S_1,S_2,S_3, \\dots, S_k\\}$.每个集合通过一个代表来识别,代表即集合中的某个成员.<br>不相交集合数据结构支持如下操作：</p>\n<blockquote>\n<ol>\n<li><code>make-set(x)</code>： 建立一个新的集合,其唯一成员就是x,所以其代表也就是自己.因为各集合是不相交的,故要求x没有在其他集合中出现过.</li>\n<li><code>union(x,y)</code>： 将包含x和y的动态集合（比如说 $S_x和S_y$）合并为一个新的集合（即这两个集合的并集）.假定这个操作之前是不相交的.在经过此操作后,所得集合的代表可以是$Sx \\bigcup Sy$中的任何一个成员,但在<code>union</code>的很多实现细节中,都选择Sx或Sy的代表作为新的代表.由于要求各集合是不相交的,故我们“消除”集合Sx和Sy,把它们从S中删去.</li>\n<li><code>find-set(x)</code>：返回一个指针,指向包含x的（唯一）集合的代表.</li>\n</ol>\n</blockquote>\n<p>2.表示<br>不相交数据集合一般用链表或森林来实现,有根树的速度更快.</p>\n<blockquote>\n<p>1.链表表示</p>\n<blockquote>\n<p>a. 每个链表的第一个对象作为它所在集合的代表<br>b. 链表上的第个结点都有指向它所在集合的代表的指针,从而使得找出所属集合的操作时间降为 $O(1)$<br>c. 但是因为每个结点都有指向代表的指针,使得在进行合并操作时,需要更新所有结点的指向代表的指针,从而时间复杂度为 $O(n)$.<br>d. 一种加权合并启发式策略:在进行合并操作时,总是把较短的表拼到较长的表上去.</p>\n</blockquote>\n<p>2.树表示<br>用有根树来表示集合,树中的每个节点都包含集合的一个成员,每棵树都表示一个集合.不相交森林中,每个成员仅指向其父节点.每个树的根包含了代表,并且是它自己的父节点.尽管采用了这种表示的直观算法并不比采用链表表示的直观算法并不比采用链表表示的算法更快,但是,通过引入两种启发式策略（“按秩合并”和“路径压缩”）,就可以获得目前已知的,渐进意义上最快的不相交集合的数据结构<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">make-set(x)</div><div class=\"line\">p[x] &lt;- x</div><div class=\"line\">rank[x] &lt;- 0</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>1.按秩合并,其思想是是包含较少节点的树的根指向包含较多节点的树的根.我们并不显示的记录以每个节点为根的子树大小,而是采用了一种能够简化分析的方法.对每个节点,用秩表示节点高度的一个上届.在按秩合并中具有较小秩的根在<code>union</code>操作中要指向具有较大秩的根.<br><img src=\"/images/union.jpg\" alt=\"tree-set\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">union(x, y)</div><div class=\"line\">link(find-set(x), find-set(y))</div><div class=\"line\"></div><div class=\"line\">link(x, y)</div><div class=\"line\">if rank[x] &gt; rank[y]</div><div class=\"line\">  then p[y] &lt;- x</div><div class=\"line\">  else p[x] &lt;- y</div><div class=\"line\">    if rank[x] = rank[y]</div><div class=\"line\">      then rank[y] &lt;- rank[y] + 1</div></pre></td></tr></table></figure></p>\n<p>2.路径压缩,它非常简单而有效.如下图所示,在<code>find-set</code>操作中,利用这种启发式策略,来使查找路径上的每个节点都直接指向根节点.路径压缩并不改变节点的秩<br>！<a href=\"find-set1.gif\">find-set1</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">find-set(x)</div><div class=\"line\">if x != p[x]</div><div class=\"line\">  then p[x] &lt;- find-set(p[x])</div><div class=\"line\">return p[x]</div></pre></td></tr></table></figure></p>\n</blockquote>\n</blockquote>\n<p>3.应用<br>不相交集合数据结构有多种应用,其中之一是用于确定一个无向图中连通子图的个数.在下面给出的过程<code>connected-components</code>中,利用了不相交集合操作来计算一个图的连通子图.一旦<code>connected-components</code>作为预处理步骤执行后,过程<code>same-component</code>回答两个顶点是否在同一连通子图的查询.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">connected-components(G) #图G,顶点集V[G],边集E[G]</div><div class=\"line\">for each vertex v in V[G]</div><div class=\"line\">    do make-set(v)</div><div class=\"line\">for each edge(u, v) in E[G]</div><div class=\"line\">    do if find-set(u) != find-set(v)</div><div class=\"line\">        then union(u, v)</div><div class=\"line\"></div><div class=\"line\">same-component(u, v)</div><div class=\"line\">if find-set(u) = find-set(v)</div><div class=\"line\">    then return true</div><div class=\"line\">    else return false</div></pre></td></tr></table></figure></p>\n<p><img src=\"find-set2.gif\" alt=\"find-set2\"></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"＜Introduction-to-algorithms＞笔记\"><a href=\"#＜Introduction-to-algorithms＞笔记\" class=\"headerlink\" title=\"＜Introduction to algorithms＞笔记\"></a>＜Introduction to algorithms＞笔记</h1><h2 id=\"Part5-高级数据结构\"><a href=\"#Part5-高级数据结构\" class=\"headerlink\" title=\"Part5 高级数据结构\"></a>Part5 高级数据结构</h2><p>在<a href=\"https://chestnutme.github.io/2017/04/17/CLRS-notes2/\" target=\"_blank\" rel=\"external\">part3数据结构</a>中,学习了基本的支持动态集合的数据结构,包括stack/queue/bst/rbt.接着在<a href=\"https://chestnutme.github.io/2017/04/22/CLRS-notes3/\" target=\"_blank\" rel=\"external\">part4高级设计和分析技术</a>中学习了在分治法/递归等基本算法设计思想上的动态规划和贪心思想,以及如何对复杂的算法进行分析的平摊分析法.在以上学习的基础上,part5学习高级的数据结构如下：</p>\n<ul>\n<li>B树:一种被设计成专门存储在磁盘上的平衡查找树.因为磁盘的速度远远慢于内存,所以 B 树被设计成尽量减少磁盘访问的次数,知道了这一点之后就会很清楚明白B树的变形 B+树了,B+树通过将数据存储在叶子结点从而增大了一个结点所包含的信息进而更加的减少了磁盘的访问次数.</li>\n<li>可合并堆:这种堆支持<code>Insert,Mininum,Extract-Min,union,delete,decrease-key</code>操作.<blockquote>\n<ul>\n<li>二项堆能够在 $O(\\log n)$ 的最坏情况时间内支持以上的各种操作.当必须支持 <code>union</code>操作时,二项堆优越于二叉堆,因为后者在最坏情况下,合并两个二叉堆要花 $O(n)$ 的时间.</li>\n<li>斐波那契堆对于以上各种除了<code>extract-min,delete</code>的操作外都只需要 O(1)的实际时间,而<code>extract-min,delete</code>也只需要 $O(\\log n)$ 的平摊时间.它的重要优点在于<code>decrease-key</code>也只需要 O(1)的平摊时间.注意斐波那契堆的一些操作都只是平摊时间,并非最坏情况时间.现代的快速图算法(part6,下一部分)中,很多是使用斐波那契堆作为其核心数据结构的.</li>\n</ul>\n</blockquote>\n</li>\n<li>不相交集合(并查集):由n个元素构成的全域集被划分为若干个动态集合.基本操作为<code>union, find-set</code>通过用一棵简单的有根树来表示每个集合,就可以得到惊人的快速操作:一个由m个操作构成的序列的运行时间为 $O(n\\alpha (n) )$,而对于宇宙中的原子数总和 n,α(n)也&lt;=4,所以可以认为实际时间是 $O(n)$.</li>\n</ul>","more":"<h3 id=\"Chapter18-如何对大量数据进行索引？\"><a href=\"#Chapter18-如何对大量数据进行索引？\" class=\"headerlink\" title=\"Chapter18 如何对大量数据进行索引？\"></a>Chapter18 如何对大量数据进行索引？</h3><p>1.B-tree 产生背景：</p>\n<blockquote>\n<p>大规模数据存储（如磁盘阵列,数据库）中,实现索引查询这样一个实际背景下,树节点存储的元素数量是有限的(如果元素数量非常多的话,查找就退化成节点内部的线性查找了),这样导致二叉查找树结构由于树的深度过大而造成磁盘 I/O读写过于频繁,进而导致查询效率低下(读取磁盘速度远慢于访问内存),那么如何减少树的深度(而不是能减少查询的数据量),一个基本的、很自然的想法就是:采用多叉树结构.由于树节点元素数量是有限的,自然该节点的子树数量也就是有限的.每个节点储存多个数据使得节点数减少,继而减少树的高度,从而减少对磁盘的访问次数,极大的提高数据操作效率.<br>在大多数系统中,B 树算法的运行时间主要由它所执行的磁盘读取操作<code>disk-read</code>和<code>disk-write</code> 的次数所决定,因而应该有效地使用这两种操作,即让它们读取更多的信息更少的次数.由于这个原因,在 B 树中,一个结点的大小通常相当于一个完整的磁盘页.因此,一个B树结点可以拥有的子女数就由磁盘页的大小所决定.<br>因此, 树的分支因子越大越好,因为这样运行时间的绝大部分都是由磁盘存取次数决定的.分支因子越大,需要进行的磁盘存取次数就越少.但是这个分支因子是有限制的,一个结点的总大小不能大于磁盘中一个页的大小,否则在一个结点内操作时还要来回访问内存,反而会拖慢效率.<br>下图是一棵B树的典型例子.：</p>\n</blockquote>\n<p>！<a href=\"/images/b-tree.png\">b-tree</a></p>\n<p>2.B-tree定义</p>\n<blockquote>\n<p>B树是为了磁盘或其它存储设备而设计的一种多叉（相对于二叉,B树每个内结点有多个分支,即多叉）平衡查找树.与part3介绍的红黑树（red-black-tree)很相似,但在降低磁盘I/0操作方面要更好一些.许多数据库系统都一般使用B树或者B树的各种变形结构,如用B+树,B*树来存储信息.B树与红黑树最大的不同在于,B树的结点可以有许多子女,从几个到几千个.那为什么又说B树与红黑树很相似呢?因为与红黑树一样,一棵含n个结点的B树的高度也为 $O(\\log n)$,但可能比一棵红黑树的高度小许多,应为它的分支因子比较大.所以,B树可以在$O(\\log n)$时间内,实现各种如<code>insert,delete</code>等动态集合操作.</p>\n<p>有根树（根为root[T])B树性质如下：</p>\n<ol>\n<li>节点x具有以下域：<blockquote>\n<p>a. n[x], 节点x中的关键字数<br>b. n[x]个关键字,非降序排列,即 $key_1[x] \\leq key_2[x] \\leq \\dots \\leq key_{n[x]}[x]$<br>c. leaf[x], bool值,为true如果是叶子节点</p>\n</blockquote>\n</li>\n<li>n[x] + 1个指向子女的指针 $c_1[x], c_2[x], \\dots, c_{n[x]+1}$</li>\n<li>$key_i[x]$ 对子树的关键字进行分隔,记 $k_i$为储存在以 $c_i[x]$ 为根的子树的关键字, 有：<br>$$ k_1 \\leq key_1[x] \\leq k_2 \\leq key_2[x] \\leq \\dots key_{n[x]}[x] \\leq k_{n[x]+1}$$</li>\n<li>叶节点深度相同, 为树高h</li>\n<li>节点包含关键字数最小值为度树t：<blockquote>\n<p>a. 非根每个结点可包含至多2m-1个关键字.所以一个内结点至多可有2m个子女.如果一个结点恰好有2m-1个关键字,则这个结点是满的<br>b. 每个结点可包含至多2m-1个关键字.所以一个内结点至多可有2m个子女.如果一个结点恰好有2m-1个关键字,我们就说这个结点是满的</p>\n</blockquote>\n</li>\n</ol>\n</blockquote>\n<p>包含n个关键字,高度为h,最小度数 $t \\geq 2$的B树有：</p>\n<blockquote>\n<p>若B树高度为h,其根节点至少包含一个关键字,其他节点至少包含t-1个关键字,<br>第一层至少有2个节点, 第二层至少2t个节点,第三层至少 $2t^2$个节点,故有：<br>$$ n \\geq 1 + (t-1)\\sum_{i=1}^h 2t^{i-1} = 1 + 2(t-1)(\\frac{t^h-1}{t-1}) =  2t^h - 1 $$<br>$$ h \\leq \\log_t \\frac{n+1}{2} $$</p>\n</blockquote>\n<p>3.B树的操作:</p>\n<blockquote>\n<ol>\n<li><p>查找 $O(t \\log_t n)$：bst上查找的推广</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">b-tree-search(x, k):</div><div class=\"line\">i &lt;- 1</div><div class=\"line\">while i \u0002&lt;= n[x] and k &gt; keyi[x]</div><div class=\"line\">  do i &lt;- i + 1</div><div class=\"line\">if i &lt;= n[x] and k= keyi[x]</div><div class=\"line\">  then return (x,i)</div><div class=\"line\">if leaf[x]</div><div class=\"line\">  then return NULL</div><div class=\"line\">  else disk-read(ci[x])</div><div class=\"line\">    return b-tree-search(ci[x], k)</div></pre></td></tr></table></figure>\n</li>\n<li><p>插入 $O(t \\log_t n)$：<br>插入一个元素时,首先在B树中是否存在,如果不存在,即在叶子结点处结束,然后在叶子结点中插入该新的元素,注意：如果叶子结点空间足够,这里需要向右移动该叶子结点中大于新插入关键字的元素,如果空间满了以致没有足够的空间去添加新的元素,则将该结点进行“分裂”,将一半数量的关键字元素分裂到新的其相邻右结点中,中间关键字元素上移到父结点中（当然,如果父结点空间满了,也同样需要“分裂”操作）,而且当结点中关键元素向右移动了,相关的指针也需要向右移.如果在根结点插入新元素,空间满了,则进行分裂操作,这样原来的根结点中的中间关键字元素向上移动到新的根结点中,因此导致树的高度增加一层.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\">b-tree-split-child(x, i, y)</div><div class=\"line\">z &lt;- allocate-node()</div><div class=\"line\">lead[z] &lt;- leaf[y]</div><div class=\"line\">n[z] &lt;- t - 1</div><div class=\"line\">for j &lt;- 1 ot t - 1</div><div class=\"line\">  do keyi[z] &lt;- key[j+i][y]</div><div class=\"line\">if not leaf[y]</div><div class=\"line\">  then for j &lt;- 1 to t</div><div class=\"line\">    do cj[z] &lt;- c[j+i][y]</div><div class=\"line\">n[y] &lt;- t - 1</div><div class=\"line\">for j &lt;- n[x] + 1 downto i + 1</div><div class=\"line\">  do c[j+1][x] &lt;- cj[x]</div><div class=\"line\">c[i+1][x] &lt;- z</div><div class=\"line\">for j &lt;- n[x] downto i</div><div class=\"line\">  do key[j+1][x] &lt;- keyj[x]</div><div class=\"line\">keyi[x] &lt;- keyi[y]</div><div class=\"line\">n[x] &lt;- n[x] + 1</div><div class=\"line\">disk-write(y)</div><div class=\"line\">disk-write(z)</div><div class=\"line\">disk-write(x)</div><div class=\"line\"></div><div class=\"line\">b-tree-insert(T, k)</div><div class=\"line\">r &lt;- root[T]</div><div class=\"line\">if n[r] = 2t - 1</div><div class=\"line\">  then s &lt;- allocate-node()</div><div class=\"line\">    root[T] &lt;- s</div><div class=\"line\">    leaf[s] &lt;- False</div><div class=\"line\">    n[s] &lt;- 0</div><div class=\"line\">    c1[s] &lt;- r</div><div class=\"line\">    b-tree-split-child(s, 1, r)</div><div class=\"line\">    b-tree-insert-nonfull(s, k)</div><div class=\"line\">else b-tree-insert-nonfull(r, k)</div><div class=\"line\"></div><div class=\"line\">b-tree-insert-nonfull(x, k): #关键词k插入非满节点x</div><div class=\"line\">i &lt;- n[x]</div><div class=\"line\">if leaf[x]</div><div class=\"line\">  then while i &gt;= 1 and k &lt; keyi[x]</div><div class=\"line\">      do key[i+1][x] &lt;- keyi[x]</div><div class=\"line\">        i&lt;- i - 1</div><div class=\"line\">    key[i+1][x] &lt;- k</div><div class=\"line\">    n[x] &lt;- n[x] + 1</div><div class=\"line\">    disk-write(x)</div><div class=\"line\">  else while i &gt;= 1 and k &lt; keyi[x]</div><div class=\"line\">      do i &lt;- i + 1</div><div class=\"line\">      i &lt;- i + 1</div><div class=\"line\">      disk-read(ci[x])</div><div class=\"line\">      if n[ci[x]] = 2t - 1</div><div class=\"line\">        then b-tree-split-child(x, i, ci[x])</div><div class=\"line\">          if k &gt; keyi[x]</div><div class=\"line\">            then i &lt;- i + 1</div><div class=\"line\">        b-tree-insert-nonfull(ci[x], k)</div></pre></td></tr></table></figure>\n</li>\n<li><p>删除 $O(t \\log_t n)$：<br>删除操作稍微复杂一些,因为删除操作不仅仅会发生在叶子结点,还可能会发生在内结点,这与插入操作不同.但是可以通过一个技巧消除这一点,找到要删除结点的前驱,然后与要删除的结点的关键值进行对调,再删除这个前驱结点就可以保证每次要删除的都是叶子结点<br>具体如下:<br>任一关键字 K 的中序前趋(后继)必是 K 的左子树(右子树)中最右(左)下的结点中最后(最前)一个关键字.根据 B 树的性质:B<br>树上每一个结点的关键字的个数必须为[t-1, 2<em>t-1]之间,记Min = t - 1.若被删关键字K所在的结点非树叶,则用 K的中序前趋(或后继)K’取代 K,然后从叶子中删去 K’.从叶子</em>x 开始删去某关键字K的三种情形为:</p>\n<blockquote>\n<p>a. 若 x-&gt;keynum&gt;Min,则只需删去K及其右指针(x是叶子,K的右指针为空)即可使删除操作结束.<br>b. 若 x-&gt;keynum=Min,该叶子中的关键字个数已是最小值,删K及其右指针后会破坏B树的性质3.若x的左(或右)邻兄弟结点y 中的关键字数目大于Min,则将y中的最大(或最小)关键字上移至双亲结点parent 中,而将parent中相应的关键字下移至 x 中.显然这种移动使得双亲中关键字数目不变;y 被移出一个关键字,故其keynum减1,因它原大于Min,故减少1个关键字后keynum仍大于等于Min;而x中已移入一个关键字,故删 K 后x中仍 Min 个关键字.涉及移动关键字的三个结点均满足 B-树的性质3.移动完<br>成后,删除过程亦结束.<br>c.若x及其相邻的左右兄弟(也可能只有一个兄弟)中的关键字数目均为最小值 Min,则上述的移动操作就不奏效,此时节点x和左或右兄弟合并.不妨设x有右邻兄弟y(对左邻兄弟的讨论与此类似),在x中删去K及其右子树后,将双亲结点parent中介于x和y之间的关键字K,作为中间关键字,与并x和y中的关键字一起”合并”为一个新的结点取代x和y.因为x和y原各有Min个关键字,从双亲中移人的K’抵消了从x中删除的 K,故新结点中恰有 2Min(即2t-2 &lt;= 2t-1)个关键字,没有破坏B树的性质3.但由于 K’从双亲中移到新结点后,相当于从parent中删去了K’,若parent-&gt;keynum原大于 Min,则删除操作到此结束;否则,同样要通过移动*parent 的左右兄弟中的关键字或将parent与 左右兄弟合并的方法来维护B树性质.最坏情况下,合并操作会向上传播至根节点,当根节点中只有一个关键字时,合并操作将会使根结点及其两个孩子合并成一个新的根,从而使整棵树的高度减少一层.<br>删除操作看似复杂,但是对一棵高度为h的B树,它只需要 $O(h)$ 次磁盘操作,因为在递归调用的过程之间,仅需要 $O(1)$ 次<code>disk-read,disk-write</code>操作,时间复杂度为 $O(th)=O(tlog_tn)$.</p>\n</blockquote>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"Chapter19-二项堆\"><a href=\"#Chapter19-二项堆\" class=\"headerlink\" title=\"Chapter19 二项堆\"></a>Chapter19 二项堆</h3><p>1.二项堆(Binomial Heaps)定义</p>\n<blockquote>\n<p>二项堆（Binomial Heap）是一种类似于二叉堆(Binary Heap)的堆结构.与二叉堆相比,其优势是可以快速合并两个堆,因此它属于可合并堆（Mergeable Heap）.x下一张的斐波那契堆也是可合并堆.一个二项堆由一组二项树所构成,这里的二项树(Binomial Tree)不同于二叉树(Binary Trees).二叉树是“左孩子,右孩子”的表示方法,而二项树是“左孩子,右兄弟”的表示方法.<br>二项树定义：<br>二项树是一种特殊的多分支有序树.二项树 $B_k$是一种递归定义的有序树.二项树 $B_0$只包含一个结点.二项树 $B_k$由两个子树 $B_{k-1}$连接而成：其中一棵树的根是另一棵树的根的最左孩子.性质如下：<br>1.共有2k个结点.<br>2.树的高度为k.<br>3.在深度i处恰有 $C_i^k$个结点.<br>4.根的度数（子女的个数）为k,它大于任何其他结点的度数；如果根的子女从左到右的编号设为k-1, k-2, …, 0,子女i是子树$B_i$的根.</p>\n</blockquote>\n<p><img src=\"/images/b-heap1.jpg\" alt=\"b-heap1\"></p>\n<blockquote>\n<p>一个二项堆由一组二项树所构成,这里的二项树需要满足下列条件：</p>\n<ol>\n<li>每棵二项树都满足最小堆性质.即,父节点的关键字 &lt;= 它的孩子的关键字.</li>\n<li>对于任意非负整数k,在堆中至多有一棵二项树的根具有度数k.<br>第一个性质保证了二项树的根结点包含了最小的关键字.第二个性质则说明结点数为 n 的二项堆最多只有 $\\log n + 1$棵二项树</li>\n</ol>\n</blockquote>\n<p>2.二项堆表示<br>如下图,二项堆(heap[H])每棵二项树按”左孩子,右兄弟方法储存“, 二项堆中的各二项树的根被组织成一个链表为根表.节点x的域如下：</p>\n<blockquote>\n<ol>\n<li>p[x],指向x的父节点</li>\n<li>child[x],指向x的最左孩子节点</li>\n<li>sibling[x], 指向x的最右兄弟节点<br><img src=\"/images/b-heap2.jpg\" alt=\"b-heap2\"></li>\n</ol>\n</blockquote>\n<p>3.二项堆操作</p>\n<blockquote>\n<p>1.创建堆: $O(1)$<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">make</div><div class=\"line\">head[H] = NULL</div></pre></td></tr></table></figure></p>\n<p>2.最小关键字 $O(\\log n)$<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">binomial-heap-minimum(H)</div><div class=\"line\">y &lt;- NULL</div><div class=\"line\">x &lt;- heap[H]</div><div class=\"line\">min &lt;- INT</div><div class=\"line\">while x != NULL</div><div class=\"line\">  do if key[x] &lt; min</div><div class=\"line\">    then min &lt;- key[y]</div><div class=\"line\">      y &lt;- x</div><div class=\"line\">  x &lt;- sibling[x]</div><div class=\"line\">return y</div></pre></td></tr></table></figure></p>\n<p>3.合并<br>二项堆最重要的一个操作就是<code>union</code>操作,其它的操作都可以在<code>union</code>操作的基础上轻松的实现.<br>大概思路为:将两个二项堆的根表连接起来组成一个大的二项树的连接,按“度”的单调递增顺序进行排序之后,从左至右来消除具有重复度的二项树.因为原本的每个二项堆中任意度K至多只有一个相应的二项树,所以这个消除重复的操作会非常容易.从小到大找到两个相同度K的二项树,然后连接成一个K+1度的二项树,直到链尾时合并完毕.完成后二项堆就满足对任意度K至多只有一棵二项树.<br>具体分解为三个过程：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">binomial-link(y, z)：#将两棵根节点度数相同的二项树Bk-1连接成一棵Bk</div><div class=\"line\">p[y] &lt;- z</div><div class=\"line\">sibling[y] &lt;- child[z]</div><div class=\"line\">child[z] &lt;- y</div><div class=\"line\">degree[z] &lt;- degree[z] + 1</div><div class=\"line\">binomial-heap-merge #将H1和H2的根表合并成一个按度数的单调递增次序排列的链表</div><div class=\"line\">binomial-heap-union： #反复连接根节点的度数相同的各二项树</div><div class=\"line\">H &lt;- make-binomial-heap()</div><div class=\"line\">head[H] &lt;- binomial-heap-merge(H1, H2)</div><div class=\"line\">free the objects H1 and H2 but not the lists they point to</div><div class=\"line\">if head[H] = NULL</div><div class=\"line\">  then return H</div><div class=\"line\">prev-x &lt;- NULL</div><div class=\"line\">x &lt;- head[H]</div><div class=\"line\">next-x &lt;- sibling[x]</div><div class=\"line\">while next-x ≠ NULL</div><div class=\"line\">  do if (degree[x] ≠ degree[next-x]) or (sibling[next-x] ≠ NULL and degree[sibling[next-x]] = degree[x])</div><div class=\"line\">    then prev-x &lt;- x ▹ Cases 1 and 2                #case1 and 2</div><div class=\"line\">      x &lt;- next-x ▹ Cases 1 and 2</div><div class=\"line\">    else if key[x] ≤ key[next-x]</div><div class=\"line\">      then sibling[x] &lt;- sibling[next-x] ▹ Case 3   #case3</div><div class=\"line\">        binomial-link(next-x, x) ▹ Case 3</div><div class=\"line\">    else if prev-x = NULL ▹ Case 4                  #case4</div><div class=\"line\">      then head[H] &lt;- next-x ▹ Case 4</div><div class=\"line\">      else sibling[prev-x] &lt;- next-x ▹ Case 4</div><div class=\"line\">      binomial-link(x, next-x) ▹ Case 4</div><div class=\"line\">      x &lt;- next-x ▹ Case 4</div><div class=\"line\">  next-x &lt;- sibling[x]</div><div class=\"line\">return H</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p><code>union</code>操作分为两个阶段：<br>第一阶段：执行<code>binomial-heap-merge</code>,将两个堆H1和H2的根表合并成一个链表H,它按度数排序成单调递增次序.MERGE的时间复杂度 $O(\\log n)$.n为H1和H2的结点总数.（对于每一个度数值,可能有两个根与其对应,所以第二阶段要把这些相同的根连起来）.<br>第二阶段：将相等度数的根连接起来,直到每个度数至多有一个根时为止.执行过程中,合并的堆H的根表中至多出现三个根具有相同的度数.合并的时候对于每一个节点,要么在主链上去掉连到其它二项树中,而插入别的二项树中的复杂度为 $O(1)$,要么只是遍历,总的节点是n个,根节点是lg(n)个,所以总的时间为 $O(\\log n)$,加上merge的时间为 $O(\\log n)$,总的时间为 $O(\\log n)$.（merge后H中至多出现两个根具有相同的度数,但是将两个相同度数的根的二项树连接后,可能与后面的至多两棵二项树出现相同的度数的根,因此至多出现三个根具有相同的度数）<br>第二阶段根据当前遍历到的根表中的结点x,分四种情况考虑:<br>Case1：degree[x] != degree[sibling[x]].此时,不需要做任何变化,将指针向根表后移动即可.<br>Case2：degree[x] == degree[sibling[x]] == degree[sibling[sibling[x]]].此时,仍不做变化,将指针后移.<br>Case3 &amp; Case4：degree[x] = degree[sibling[x]] != degree[sibling[sibling[x]]]<br>Case3：key[x] &lt;= key[sibling[x]].此时,将sibling[x]连接到x上.<br>Case4：key[x] &gt; key[sibling[x]].此时,将x连接到sibling[x]上.</p>\n</blockquote>\n<p>4.插入节点: $O(\\log n)$<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">binomial-heap-insert(H, x)</div><div class=\"line\">H′ &lt;- make-binomial-heap()</div><div class=\"line\">p[x] &lt;- NULL</div><div class=\"line\">child[x] &lt;- NULL</div><div class=\"line\">sibling[x] &lt;- NULL</div><div class=\"line\">degree[x] &lt;- 0</div><div class=\"line\">head[H′] &lt;- x</div><div class=\"line\">H &lt;- binomial-heap-union(H, H′)</div></pre></td></tr></table></figure></p>\n<p>5.删除最小关键字 $O(\\log n)$<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">binomial-heap-extract-min(H):</div><div class=\"line\">find the root x with the minimum key in the root list of H,</div><div class=\"line\">and remove x from the root list of H</div><div class=\"line\">H′ &lt;- make-binomial-heap()</div><div class=\"line\">reverse the order of the linked list of x’s children,</div><div class=\"line\">and set head[H′] to point to the head of the resulting list</div><div class=\"line\">H &lt;- binomial-heap-union(H, H′)</div></pre></td></tr></table></figure></p>\n<p>6.减小关键字值<br>减小关键字的过程类似维护最小堆结构,key[y]与y的父结点z的关键字作比较.如果y为根或者key[y] &gt;= key[z],则该二项树已是最小堆有序.否则结点研究违反了最小堆有序,故将其关键字与其父节点z的关键字相交换,同时还要交换其他数据并循环这个过程<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">binomial-heap-decrease-key(H, x, k)</div><div class=\"line\">if k &gt; key[x]</div><div class=\"line\">  then error &quot;new key is greater than current key&quot;</div><div class=\"line\">key[x] &lt;- k</div><div class=\"line\">y &lt;- x</div><div class=\"line\">z &lt;- p[y]</div><div class=\"line\">while z ≠ NULL and key[y] &lt; key[z]</div><div class=\"line\">  do exchange key[y] ↔ key[z]</div><div class=\"line\">  y &lt;- z</div><div class=\"line\">  z &lt;- p[y]</div></pre></td></tr></table></figure></p>\n<p>7.删除关键字<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">binomial-heap-delete(H, x)</div><div class=\"line\">1 binomial-heap-decrease-key(H, x, -INT)</div><div class=\"line\">2 binomial-heap-extract-min(H)</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>4.总结</p>\n<blockquote>\n<p>可合并堆 = 普通的堆 + <code>decrease-key,union</code>操作<br>但是其应该高效的实现, <code>union</code>操作是可合并堆最关键的部分.如果不需要高效的支持<code>union</code>操作,则普通的堆结构已经足够.<br>对于所有的堆结构:二叉堆、二项堆、斐波那契堆.它们的<code>search</code>操作都是很慢的,不能像二叉搜索树高效的支持<code>search</code>操作!因而在<code>decrease-key</code>和<code>delete</code>等涉及结点的操作时都需要一个指向结点的指针.</p>\n</blockquote>\n<h3 id=\"Chapter20-斐波那契堆\"><a href=\"#Chapter20-斐波那契堆\" class=\"headerlink\" title=\"Chapter20 斐波那契堆\"></a>Chapter20 斐波那契堆</h3><p>1.定义</p>\n<blockquote>\n<p>斐波那契堆(Fibonacci heap)是堆中一种,它和二项堆一样,也是一种可合并堆；可用于实现合并优先队列.斐波那契堆比二项堆具有更好的平摊分析性能,它的合并操作的时间复杂度是O(1).<br>与二项堆一样,它也是由一组堆最小有序树组成,并且是一种可合并堆.<br>与二项堆不同的是,斐波那契堆中的树不一定是二项树；而且二项堆中的树是有序排列的,但是斐波那契堆中的树都是有根而无序的.</p>\n</blockquote>\n<p>！<a href=\"/images/fib.jpg\">fib-heap</a></p>\n<blockquote>\n<p>斐波那契堆中的所有树的树根被保存在一个链表即根表中.对于一个斐波那契堆,min[H]保存了具有最小节点值的根节点.<br>堆中每个节点的数据结构包含如下域：</p>\n<blockquote>\n<ol>\n<li>p[x],指向x的父节点</li>\n<li>child[x], 指向x的任意一个孩子</li>\n<li>任意一个节点x的所有孩子被链接在一个双向链表环形链表中</li>\n<li>degree,x的孩子的数目</li>\n<li>mark,表示自从x上一次称为另一个节点的子女以来,它是否失掉了一个孩子,TRUE表示是失去了</li>\n</ol>\n</blockquote>\n</blockquote>\n<p>2.操作</p>\n<blockquote>\n<ol>\n<li><p>创建堆</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">make-fib-heap()</div><div class=\"line\">H &lt;- allocate-node()</div><div class=\"line\">n[H] = 0</div><div class=\"line\">min[h] = NULL</div><div class=\"line\">return H</div></pre></td></tr></table></figure>\n</li>\n<li><p>插入: $O(1)$</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">fib-heap-insert(H, x)</div><div class=\"line\">degree[x] &lt;- 0</div><div class=\"line\">p[x] &lt;- NUll</div><div class=\"line\">child[x] &lt;- NULL</div><div class=\"line\">left[x] &lt;- x</div><div class=\"line\">right[x] &lt;- x</div><div class=\"line\">mark[x] = false</div><div class=\"line\">concatenate the root list containing x with root list H</div><div class=\"line\">if min[H] = NULL or key[x] &lt; key[min[H]]</div><div class=\"line\">  then min[H] &lt;- x</div><div class=\"line\">n[H] &lt;- n[H] + 1</div></pre></td></tr></table></figure>\n</li>\n<li><p>合并: $O(1)$<br>合并两个斐波那契堆的操作非常简单,可以分为两步：</p>\n<blockquote>\n<p>1.将两个根表通过指针合并为一个根表<br>2.更新min[H],比较两个堆的min[H],取较小的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">fib-heap-union(H1, H2)</div><div class=\"line\">H &lt;- make-fib-heap()</div><div class=\"line\">min[H] &lt;- min[H1]</div><div class=\"line\">concatenate the root list of H@ with the root list of H</div><div class=\"line\">if (min[H1] = NULL) or (min[H2] != NULL) and min[H2] &lt; min[H1])</div><div class=\"line\">  then min[H1] &lt;- min[H2]</div><div class=\"line\">n[H] &lt;- n[H1] + n[H2]</div><div class=\"line\">free the objects H1 and H2</div><div class=\"line\">return H</div></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li><p>删除最小节点: $O(\\log n)$<br>删除最小节点的操作比较复杂,其算法思想为：</p>\n<blockquote>\n<ol>\n<li>删除最小节点,并将被删除节点的每个孩子都看做新的堆中的一棵树的根,将它们加入到根表中</li>\n<li>遍历根表,合并度数相同的树<br>这里的在根链上合并操作与二项树基本相同,就是按“度的递增”顺序排列所有的子树之后,合并具有相同度的子树,使得最后的根链上每一个度 K 都只有至多一棵子树.(这里又与二项堆神似了,所以说斐波那契堆是松散地基于二项堆.)调整根表的步骤<br>1:在根表中找出两个具有相同度数的根 x 和 y,且 key[x]&lt;key[y]<br>2:将y与x连接.将 y 从根表里去掉,成为 x一个孩子,并增加degree[x].同时,如果y上有标记的话也被清除掉.”<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">fib-heap-extract-min(H)</div><div class=\"line\">z &lt;- min[H]</div><div class=\"line\">if z != NULL</div><div class=\"line\">  then for each child x of z</div><div class=\"line\">    do add x to the root list of H</div><div class=\"line\">      p[x] &lt;- NULL</div><div class=\"line\">    remove z from the root list of H</div><div class=\"line\">    if z = right[z]</div><div class=\"line\">      then min[H] &lt;- NULL</div><div class=\"line\">      else min[H] &lt;- right[z]</div><div class=\"line\">        consolidate(H)</div><div class=\"line\">    n[H] &lt;- n[H] - 1</div><div class=\"line\"></div><div class=\"line\">consolidate(H): #合并H的根表,减少堆中树的数量</div></pre></td></tr></table></figure>\n</li>\n</ol>\n</blockquote>\n</li>\n<li><p>减小一个关键字: $O(1)$<br>减小一个关键字的字,会破坏最小堆的性质,所以要进行最小堆维护.因为斐波那契支持减小关键字和删除结点操作,所以斐波那契堆的子树就不一定是二项树了.步骤如下：</p>\n<blockquote>\n<p>1.减此减小不影响堆序,不作调整;<br>2.若影响堆序,则从堆中删除该节点,将其加入根表,并检查其父亲的 mark 位;若为 false,则停止,并将其置为 true;若为 true,则删除其父亲,继续递归向上执行;直到一个节点 mark 域为 false 或该节点为根节点为止.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\">fib-heap-decrease-key(H, x, k)</div><div class=\"line\">if k &gt; key[x]</div><div class=\"line\">  then return error &quot;new key is greater than current key&quot;</div><div class=\"line\">key[x] &lt;- k</div><div class=\"line\">y &lt;- p[x]</div><div class=\"line\">if y != NULL and key[x] &lt; key[y]</div><div class=\"line\">  then cut(H, x, y)</div><div class=\"line\">    cascading-cut</div><div class=\"line\">if key[x] &lt; key[min[h]]</div><div class=\"line\">  then min[h] &lt;- x</div><div class=\"line\"></div><div class=\"line\">cut(H, x, y)</div><div class=\"line\">remove x from the child list of y, decrementing degree[y]</div><div class=\"line\">add x to the root list of H</div><div class=\"line\">p[x] &lt;- NULL</div><div class=\"line\">mark[x] &lt;- False</div><div class=\"line\"></div><div class=\"line\">cascading-cut(H, y)</div><div class=\"line\">z &lt;- p[y]</div><div class=\"line\">if z != NULL</div><div class=\"line\">   then if mark[y] = False</div><div class=\"line\">      mark[y] &lt;- true</div><div class=\"line\">      else cut(H, y, z)</div><div class=\"line\">        cascading-cut(H, z)</div></pre></td></tr></table></figure>\n</blockquote>\n</li>\n<li><p>删除节点</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">fib-heap-delete(H, x)</div><div class=\"line\">fib-heap-decrease-key(H, x, -INT)</div><div class=\"line\">fib-heap-extract-min(H)</div></pre></td></tr></table></figure>\n</li>\n</ol>\n</blockquote>\n<p>3.总结<br>斐波那契堆之所以高效,就是因为它放宽了条件了,将很多二项堆要维护的工作都推迟到了<code>extract-min</code> 和 <code>delete</code>操作之中去了.而它之所以能够放宽条件,就是因为它的限制非常的少,并没有像二项堆一样的要求子树全部必须是二项树,而且根表上的任意度数的子树至多只能有一个.没有了这些限制,斐波那契堆就可以实现的非常的松散以至少将日常工作的维护时间都平摊给 <code>extract-min</code> 和 <code>delete</code> 操作.<br>但是,正如斐波那契堆现在更多的应用于理论中,实践中使用的并不多的现象所映射的,在大部分的应用中斐波那契堆并不能带来大幅度的效率的提升.因为它并不是减少了要做的工作,只是将很多要做的工作都进行了推迟.<br>但一般对于规模足够大的输入,斐波那契堆是能够很大改善算法的性能的,尤其是对于一些 <code>extract-min</code>和 <code>delete</code> 操作少的情况.比如斐波那契堆的使用能加快Prime 和 Djikstra 算法的执行速度.</p>\n<h3 id=\"Chapter21-用于划分的数据结构-不相交集合\"><a href=\"#Chapter21-用于划分的数据结构-不相交集合\" class=\"headerlink\" title=\"Chapter21 用于划分的数据结构-不相交集合\"></a>Chapter21 用于划分的数据结构-不相交集合</h3><p>1.定义：<br>不相交集合数据结构（disjoing-set data structure)保持一组不相交的动态集合 $S = \\{S_1,S_2,S_3, \\dots, S_k\\}$.每个集合通过一个代表来识别,代表即集合中的某个成员.<br>不相交集合数据结构支持如下操作：</p>\n<blockquote>\n<ol>\n<li><code>make-set(x)</code>： 建立一个新的集合,其唯一成员就是x,所以其代表也就是自己.因为各集合是不相交的,故要求x没有在其他集合中出现过.</li>\n<li><code>union(x,y)</code>： 将包含x和y的动态集合（比如说 $S_x和S_y$）合并为一个新的集合（即这两个集合的并集）.假定这个操作之前是不相交的.在经过此操作后,所得集合的代表可以是$Sx \\bigcup Sy$中的任何一个成员,但在<code>union</code>的很多实现细节中,都选择Sx或Sy的代表作为新的代表.由于要求各集合是不相交的,故我们“消除”集合Sx和Sy,把它们从S中删去.</li>\n<li><code>find-set(x)</code>：返回一个指针,指向包含x的（唯一）集合的代表.</li>\n</ol>\n</blockquote>\n<p>2.表示<br>不相交数据集合一般用链表或森林来实现,有根树的速度更快.</p>\n<blockquote>\n<p>1.链表表示</p>\n<blockquote>\n<p>a. 每个链表的第一个对象作为它所在集合的代表<br>b. 链表上的第个结点都有指向它所在集合的代表的指针,从而使得找出所属集合的操作时间降为 $O(1)$<br>c. 但是因为每个结点都有指向代表的指针,使得在进行合并操作时,需要更新所有结点的指向代表的指针,从而时间复杂度为 $O(n)$.<br>d. 一种加权合并启发式策略:在进行合并操作时,总是把较短的表拼到较长的表上去.</p>\n</blockquote>\n<p>2.树表示<br>用有根树来表示集合,树中的每个节点都包含集合的一个成员,每棵树都表示一个集合.不相交森林中,每个成员仅指向其父节点.每个树的根包含了代表,并且是它自己的父节点.尽管采用了这种表示的直观算法并不比采用链表表示的直观算法并不比采用链表表示的算法更快,但是,通过引入两种启发式策略（“按秩合并”和“路径压缩”）,就可以获得目前已知的,渐进意义上最快的不相交集合的数据结构<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">make-set(x)</div><div class=\"line\">p[x] &lt;- x</div><div class=\"line\">rank[x] &lt;- 0</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>1.按秩合并,其思想是是包含较少节点的树的根指向包含较多节点的树的根.我们并不显示的记录以每个节点为根的子树大小,而是采用了一种能够简化分析的方法.对每个节点,用秩表示节点高度的一个上届.在按秩合并中具有较小秩的根在<code>union</code>操作中要指向具有较大秩的根.<br><img src=\"/images/union.jpg\" alt=\"tree-set\"><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">union(x, y)</div><div class=\"line\">link(find-set(x), find-set(y))</div><div class=\"line\"></div><div class=\"line\">link(x, y)</div><div class=\"line\">if rank[x] &gt; rank[y]</div><div class=\"line\">  then p[y] &lt;- x</div><div class=\"line\">  else p[x] &lt;- y</div><div class=\"line\">    if rank[x] = rank[y]</div><div class=\"line\">      then rank[y] &lt;- rank[y] + 1</div></pre></td></tr></table></figure></p>\n<p>2.路径压缩,它非常简单而有效.如下图所示,在<code>find-set</code>操作中,利用这种启发式策略,来使查找路径上的每个节点都直接指向根节点.路径压缩并不改变节点的秩<br>！<a href=\"find-set1.gif\">find-set1</a><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">find-set(x)</div><div class=\"line\">if x != p[x]</div><div class=\"line\">  then p[x] &lt;- find-set(p[x])</div><div class=\"line\">return p[x]</div></pre></td></tr></table></figure></p>\n</blockquote>\n</blockquote>\n<p>3.应用<br>不相交集合数据结构有多种应用,其中之一是用于确定一个无向图中连通子图的个数.在下面给出的过程<code>connected-components</code>中,利用了不相交集合操作来计算一个图的连通子图.一旦<code>connected-components</code>作为预处理步骤执行后,过程<code>same-component</code>回答两个顶点是否在同一连通子图的查询.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">connected-components(G) #图G,顶点集V[G],边集E[G]</div><div class=\"line\">for each vertex v in V[G]</div><div class=\"line\">    do make-set(v)</div><div class=\"line\">for each edge(u, v) in E[G]</div><div class=\"line\">    do if find-set(u) != find-set(v)</div><div class=\"line\">        then union(u, v)</div><div class=\"line\"></div><div class=\"line\">same-component(u, v)</div><div class=\"line\">if find-set(u) = find-set(v)</div><div class=\"line\">    then return true</div><div class=\"line\">    else return false</div></pre></td></tr></table></figure></p>\n<p><img src=\"find-set2.gif\" alt=\"find-set2\"></p>"},{"title":"introduction to algorithms note5","date":"2017-05-08T16:00:00.000Z","_content":"\n# ＜Introduction to algorithms＞笔记\n\n## Part6 图算法\n在前面的部分学习了表示一对一关系的线性数据结构(数组, 链表, stack, queue), 表示一对多关系的树型数据结构(二叉树, 森林, 堆)后, 将其拓展到多对多关系-图.在part6主要是学习用图定义的计算问题和对应的算法,主要包括三个部分:\n* 图的表示,及广度/深度优先的图搜索算法\n* 求解最小生成树问题\n* 最短路径问题\n\n约定:以 $G = (V, E)$ 描述一个图G, 其顶点集为V[G], 顶点数为|V|;边集为E[G], 边数为|E|;故图问题的输入规模的参数有两个, |V|和|G|.例如,算法的复杂度为 $O(VE)$ 表示该算法的运行时间的 $O(|V||E|)$\n\n### Chapter22 如何表示和遍历图?\n本章的图搜索技术是图算法领域的核心.分为五个部分:\n* 图的表示\n* 广度优先搜索\n* 深度优先搜索\n* 有向无环图的拓扑排序\n* 有向图的强连通子图\n\n<!-- more -->\n\n#### 图的表示\n两种基本的表示方法:\n* 邻接表(adjacency lists)\n包含|V|个链表的数组*Adj*表示, 对 $u \\in V$, 有Adj[u] 包含图G中和顶点u相邻的所有顶点.其适用于稀疏图($|E|远小于|V|^2$).\n不论是有向图还是无向图,邻接表法都有一个很好的特性,即它所需要的存储空间为 $O(V+E)$ ;邻接表表示法稍作修改就能支持其它多种图的变体,因而有着很强的适应性.\n\n* 邻接矩阵(adjacency matrix)\nG的邻接矩阵为|V| * |V|的矩阵 $A = {a\\_{ij}}$, 其满足:\n$$ a\\_{ij} =\n\\begin{cases}\n1, \\text {if (i, j)} \\in E \\\\\\\\\n0, else \\\\\\\\\n\\end{cases}\n$$\n适用于稠密图, 空间复杂度 $O(v^2)$\n无向图的邻接矩阵A就是它的转置矩阵,即$A=A^T$ .在某些应用中采用矩阵严肃哦存储,可以只存储邻接矩阵的对角线及对角线以上的部分,这样一来,图所占用的存储空间可以减少一半.\n\n图1 无向图的邻接表和邻接矩阵表示\n![directed graph](/images/graph1.png)\n\n图2 有向图的邻接表和邻接矩阵表示\n![undirected graph](/images/graph2.png)\n\n邻接表表示和邻接矩阵表示在渐近意义上至少是一样有效的,但由于邻接矩阵简单明了,因而当图较小时,更多多地采用邻接矩阵来表示.另外,如果一个图不是加权的,采用邻接矩阵的存储形式还有一个优越性:在存储邻接矩阵的每个元素时,可以只用一个二进位,而不必有一个字的空间.这样,当采用了二进位以及表示无向图的技巧时,邻接矩阵法的占用空间大的缺点就可以得到一定程度上的改善.\n\n#### 广度优先搜索(bread-first search)\nBFS思路: 给定图G=(V, E)和特定原顶点s, 遍历G中的边, 发现可从s到达的所有顶点, 并计算s到所有可达顶点间的距离(最少的边数).因为始终是将已发现顶点和未发现顶点之间的边界沿广度方向扩展,即首先遍历和s距离k的顶点, 然后发现和s距离k+1的顶点.\nBFS实现如下:\n```\nBFS(G, s)\nfor each vertex u in V[G]-{s}\n    do color[u] <- white      #color数组:标记是否访问并可视化算法\n        d[u] <- INT           #d[u]: u到源点s的距离\n        f[u] <- Null          #f[u]: u的父顶点\ncolor[s] <- gray\nd[s] <- i\nf[s] <- Null\nQ <- Empty                     #Q:先进先出队列\nEnqueue(Q, s)\nwhile Q != Empty\n    do u <- Dequeu(Q)\n    for each v in Adj[u]\n        do if color[u] = white\n            then color[u] <- gray\n            d[v] <- d[u] + 1\n            f[v] <- u\n            Enqueue(Q, v)\n    color[u] <- black\n```\n算法过程如图3\n![BFS](/images/bfs.png)\n\nBFS分析:\n采用part4学习的聚集分析(aggregate analysis), 通过color数组的染色标记,确保每个顶点v只Enqueue一次,故亦只Dequeue一次.Enqueue和Dequeue要求 $O(1)$ 的时间,故队列操作时间为 $O(V)$.又有每个顶点v出队时扫描其邻接表Adj[v], 所以每个顶点邻接表只遍历一次, 花费时间为 $O(E)$. 故总运行时间为 $O(V + E)$.\n\n**将BFS理解为同心圆扩展算法, 想象图G为一片水面, 源点s就是我们扔进石子的点, 激出的波纹沿半径方向延伸,圆圈向外扩展的过程即是遍历水面的过程**.在这个过程中,BFS构造了一棵广度优先搜索树,包括s的所有**可达**顶点.对从s可达的任意顶点v,广度优先树中s到v的路径对应于图G中s到v的一条最短路径(边数最少).从BFS的算法中的数组f[u]可以用前驱图子图 $G\\_f = (V\\_f, E\\_f)$ 表示图G = (V, E)的广度优先树:\n\\begin{align}\nV\\_f = \\{v \\in V: f[v] \\neq Null \\} \\bigcup \\{s\\} \\\\\\\\\nE\\_f = \\{(f[v], v): v \\in V\\_f - \\{s\\} \\}\n\\end{align}\n\n根据BFS算法用递归输出s到v的最短路径如下:\n```\nprint-path(G, s, v)\nif v == s\n    then print s\n    else if f[v] = Null\n        then print \"no path from\" s \"to\" v \"exists\"\n        else print-path(G, s, f[v])\n            print v\n```\n\n### 深度优先搜索(depth-first search)\nDFS思路:对新遍历的顶点u, 如果还有以u为起点而未遍历的边,沿此边继续遍历.如果u的所有边都已遍历,则回溯到发现顶点u有起始点的顶点边.制止发现所有顶点为止.可以发现DFS按深度为策略进行遍历.\nDFS实现如下:\n```\nDFS(G)\nfor each vertex u in V[G]\n    do color[u] <- white\n        f[u] <- Null\ntime <- 0                       #全局计时器, 确定完成时间f[v]\nfor each vertex u in V[G]\n    do if colo[u] = white\n    then DFS-visit[u]\n\nDFS-visit(u)\ncolo[u] <- gray\nd[u] <- time + 1\nd[u] <- time\nfor each v in Adj[u]\n    do if color[v]  = white\n        then f[v] <- u\n        DFS-visit(v)\ncolor[u] <- black\nf[u] <- time <- time + 1\n```\nDFS可视化如图4\n![dfs](/images/dfs.png)\n\nDFS分析: 仍然采用聚集分析, 每个顶点的邻接表被遍历一次, 要求 $O(V)$.对每个顶点u, 过程DFS-visit仅被调用一次,即只对未遍历的顶点调用该过程.在DFS-visit(v)的一次执行中,遍历的标记过程被执行|Adj[v]|次,且有:\n$$  \\sum\\_{v \\in V}|Adj[v]| = O(E) $$\n故DFS的总运行时间为 $O(V + E)$.\n\nDFS创建一个深度优先森林外,深度优先搜索同时为每个顶点加盖时间戳.每个顶点 v 有两个时间戳:当顶点 v 第一次被发现时,记录下第一个时间戳 d[v],当结束检查 v 的邻接表时,记录下第二个时间戳 f[v].许多基于深度优先搜索的图算法都用到了时间戳,它们对推算深度优先搜索的时行情况有很大的帮助.\n\n#### 拓扑排序 Topological sort\n对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序,是将G中所有顶点排成一个线性序列,使得图中任意一对顶点u和v,若边 $(u,v) \\in E[G]$,则u在线性序列中出现在v之前.通常,这样的线性序列称为满足拓扑次序(Topological Order)的序列,简称拓扑序列.拓扑排序运用在在顶点活动网(Activity On Vertex network,简称AOV网)中,确定活动先后的发生顺序.\n\n一个dag的拓扑排序可以理解为图中所有顶点沿水平线排列而成的一个序列.下面是一个典型的活动安排例子:\n![dag](/images/dag.png)\n\n一般由AOV网构造拓扑序列的拓扑排序算法主要是循环执行以下两步,直到不存在入度为0的顶点为止.\n* 选择一个入度为0的顶点并输出之；\n* 从网中删除此顶点及所有出边.\n循环结束后,若输出的顶点数小于网中的顶点数,则输出“有回路”信息,否则输出的顶点序列就是一种拓扑序列.\n\n而在算法导论中运用全局的计时器time,巧妙的实现拓扑排序.通过深度遍历来确定时间完成的时间,按时间顺序自然构造拓扑序列,而无需根据BFS遍历来删除边.\n```\ntopoligical-sort(G)\ncall DFS(G) to compute finishing times f[v] for each vertex v\nas each vete is finished, insert it onto the front of a linked list\nreturn the linked list of vertices\n```\n\n#### 强连通分支\n强连通分支(strongly connected component):有向图G=(V,E)的一个最大顶点集合 $C \\subseteq V$, 对C中任意一堆对顶点u, v, 它们是互相可达的.\n\n寻找SCC的思路: 定义图G的转置:\n$$ G^T = (V, E^T), E^T = \\{(u, v):(v, u) \\in E\\} $$\n对分支图 $G^{SCC} = (V^{SCC}, E^{SCC})$,假设G的强连通分支为 $[C\\_1, C\\_2, \\dots, C\\_k]$.顶点集 $V^{SCC} = \\{v\\_1, v\\_2, \\dots, v\\_k \\}$,对于G的每一个强连通分支 $C\\_i$,它都包含一个顶点 $v\\_i$.如果对某个 $x \\in C\\_i$ 以及 $y \\in C\\_i$, G中包含有向边(x, y), 则有一条边 $(v\\_i,v\\_j) \\in E^{SCC}$. 因此收缩其关联的顶点都处于G的同一强连通分支内的边,即可得到图 $G^{SCC}$. 对应的 $G^{SCC}$是一个有向无环图(dag);\n![scc](/images/scc.png)\n\n> 1. 对G进行深度优先遍历得到每个顶点的时间戳 f[x];\n> 2. 求得G的返回图 $G^T$;\n> 3. 按照f[x]的逆向顺序为顶点顺序对$G^T$进行深度优先遍历,即按照G的拓扑排序的顺序对 $G^T$再进行深度优先遍历;\n步骤3得到的各棵子树就是原图 G的各强连通分支.\n```\nstrongly-connnected-component(G)\ncall DFS(G) to compute finishing times f[u] for each vertex u\ncompute GT\ncall DFS(GT). but in the main loop of DFS, consider the vertices in order of decreasing f[u](as computed in line 1)\noutput the vertices of each tree in the depth-first forest formed in line 3 as a separate strongly connected component\n```\n\n### Chapter23 最小生成树 Minimum Spanning Trees\n在生成树(spanning tree)T是指: T连接了G的所有顶点且无回路, 因此T必然是一棵树.其中特殊的一类T得到的树的权值最小, 为最小生成树.\n采用贪心的思路,可以通过Kruskal算法和Prim算法有效的解决生成树问题.\n\n#### 最小生成树的策略\n最小(权值)生成树:由 n-1 条边,连接了所有的 n 个顶点,并且所有边上的权值和最小.一个典型实例如下:\n![mst](/images/mst.png)\n\n一个通用的贪心策略是,在每个步骤中都形成最小生成树的一条边,算法维护这个集合A, 并保持了以下循环不变式:\n每次循环之前, A是最小生成树的一个子集.\n在算法的每一步,确定一条边(u, v), 使得它加入集合A后, 循环不变式得以保持, 即 $A \\bigcup \\{(u, v) \\}$仍然是最小生成树的子集.这样的边(u, v)称为安全边(safe edge).描述如下:\n```\ngeneric-mst(G, w)\nA <- Empty\nwhile A does not form a spanning tree\n    do find an edge(u, v) that is safe for A\n        A <- A union (u, v)\nreturn A\n```\n\n#### Kruskal算法\nKruskal算法直接基于通用贪心策略:找出森林中连接任意两棵树的所有边中,具有最小权值的边作为安全边,添加其到正在生长的森林中.即,集合A是一个森林,加入集合A中的安全边总是图中连接两个不同连通分支的最小权边.\n通过part5高级数据结构中不相交集合可以很好的实现Kruskal算法.比较`find-set(u)`和`find-set(v)`是否等同,确定u和v是否属于同一棵树,通过`Union`实现树的合并.\n```\nmst-kruskal(G, w)\nA <- Empty\nfor each vertex v in V[G]\n    do make-set(v)\nsort the edges of E into nondecreasing order by weight w\nfor each edge(u, v) in E, taken in nondecreasing order by weight\n    do if find-set(u) != find-set(v)\n        then A <- A union (u, v)\n            Union(u, v)\nreturn A\n```\n\n算法可视化如下:\n![kruskal](/images/kruskal.png)\n\nKruskal算法分析:\n如果采用不相交数据集合中的按秩结合和路径压缩的策略,可以最高效的实现.初始化要求 $O(1)$, 对各条边排序需要 $O(E\\log E)$.对每一条边, 执行 $O(E)$ 次`find-set`和`union`操作, 加上|V|次`make-set`操作,要求的总时间为$O((V + E)\\alpha(V)$.假定G是连通的,则有 |E| > |v| - 1, 因而不相交集合操作时间为 $O(E\\alpha(v))$. 又有 $\\alpha(|V|) = O(\\log V) = O(\\log E)$,故有总运行时间为 $O(E\\log E)$. 由于 $|E| < |V| ^ 2$, 因而 $\\log |E| = O(\\log V)$, 即Kruskal总运行时间为 $O(E\\log V)$\n\n#### Prim算法\nPrim算法的贪心策略:集合A仅形成单棵树,添入集合A中的安全边总是连接树与一个不在树中的顶点的最小权边.树从任意根顶点r开始形成, 每一步里连接了树A与 $G\\_A=(V, A)$ 中某孤立顶点的轻边(最小权值边)加入到树A中, 直至包含了所有的顶点.如下图:\n![prim](/images/prim.png)\n\nPrim算法维护一个基于key域的最小优先级队列Q,其包含所有不在树A中的顶点.key[u]表示所有与u相连的树中顶点的边的最小权值.f[u]指向u的父节点.\n```\nmst-prim(G, w, r)\nfor each u in V[G]\n    do key[u] <- INT\n        f[u] <- Null\nkey[r] <- 0\nQ <- V[G]\nwhile Q != Empty\n    do u <- extract-min(Q)\n        for each v in Adj[u]\n            do if v in Q and w(u, v) < key[v]\n                then f[u] <- u\n                    key[v] <- w(u, v)\n```\n\nPrim算法分析:\nPrim算法性能取决于优先队列Q的实现方案, 如果采用Part5学习的二叉堆实现:通过`build-min-heao`实现初始化, 需要 $O(V)$. `while`循环体执行|V|次, 每次调用`extract-min`需要 $O(\\log V)$, 故该循环占用时间 $O(V\\log V)$.`for`循环执行 $O(E)$ 次, 每次调用`decrease-key`实现对key的赋值要求 $O(\\log V)$.因此, Prim算法总的运行时间为 $O(V\\log V + E\\log V) = O(E\\log V)$.从渐进意义上来说, Prim算法和Kruskal算法运行时间相同.\n如果改进为斐波那契堆, 在Chapter20得到,|V|个元素组成的斐波那契堆,可以在 $O(\\log Ｖ)$ 的平摊时间内完成`extract-min`操作．则Prim算法运行时间可以改进为 $O(E + V\\log Ｖ)$.\n\n#### 对比\nPrim算法有着更好的实际效率:\n> 1. Prim算法在执行的过程中,将不在树中的所有顶点都放在一个基于key域的最小优先队列Q中;\n> 2. 每次在选取安全边时,只需要从Q中弹出最小key值的顶点即可,而不需要像 Kruskal 一样为对所有的边的权值进行一次排序;\n> 3. Prim 算法使用了用于快速或者最小权值边的技巧(二叉堆、二项堆、斐波那契堆)来加速算法的运行.在最朴素的选取安全边的算法中,需要遍历剩下的所有的边,所需要的时间复杂度为 $O(EV)$,而采用堆来优化后只需要 $O(E\\log V)$ ,大大地改善了算法的执行时间(堆的好处).\n\n不过Kruskal算法实现相对简单,所以对于一般的应用Kruskal算法也是可以的．\n\n\n### Chapter24 如何在地图中选择最短的路径?\n考虑一个实际问题:在地图上选出从北京到上海的最短距离.直接的想法是北京和上海两点之间的直线, 但实际不可能存在这条路, 北京和上海是通过之间一个个城市中转的.城市抽象为顶点, 城市之间的道路抽象为边,道路里程为权值,则北京到上海的最短路径问题转化为图中的单源最短路径问题.本章即是学习在图中解决最短路径问题的算法\n\n#### 最短路径\n定义\n给定带权有向图G = (V, E),加权函数 $w: E \\to R$从边到实数的映射.\n路径 $p = \\{v\\_0, v\\_1, \\dots, v\\_k\\}$的权为组成边的所有权值之和:\n$$ w(p) = \\sum\\_{i=1}^k w(v\\_{i-1}, v\\_i) $$\nu到v的最短路径的权为:\n$$\n\\delta(u, v) =\n\\begin{cases}\nmin\\{w(p): u \\to v \\}, \\text {if path(u, v) exists} \\\\\\\\\n\\infty, else \\\\\\\\\n\\end{cases}\n$$\n对应的最短路径为权 $w(p) = \\delta(u, v)$的任何路径.\n\n注:权值是一种度量标准, 不限于距离, 还可以是时间/费用/损失.\n\n问题变体\n* 单终点最短路: 每个顶点v到终点t的最短路, 即将单源最短路问题反向即可\n* 单对顶点最短路: 给定顶点u和v的最短路,u单源最短路的问题选择终点v即可\n* 全源最短路: 找出所有顶点之间的最短路径.\n\n问题分析\n1.最优子结构\n**最短路径的子路径是最短路径.**\n$$\\begin{align}\n设路径p = < v\\_0, v\\_1, \\dots, v\\_k >是v\\_0到v\\_k的最短路径,\\\\\n则对 \\forall i, j, 1 \\leq i \\leq j \\leq k \\\\\n路径p\\_{ij} = < v\\_i, v\\_{i+1}, \\dots, v\\_j>是 v\\_i到v\\_j的最短路径 \\\\\n\\end{align}\n$$\n\n2.负权值边\n如果问题中存在负权值边, 但不包含**负权值回路**,则最短路径的定义仍然是正确的.但一旦存在负权值回路, 则不存在最短路径,因为通过不断穿过负权值回路可以得到更小权值的边.\n![negative path](/images/n-path.png)\n\n3.回路\n除去负权值回路, 最短路径亦不能包含正权值回路.因为从路径上一出回路后,可以得到源点/终点相同,权值更小的路径.\n\n4.求解路径\n最短路径问题中我们不仅想得到最短路径的权,也想得到最短路径是什么.通过类似广度优先搜索树的表示方法,设置顶点v的前驱f[v], 形成最短路径树.然后调用`print-path(G, s, v)`来递归的输出最短路径即可.\n![mst-path](/images/mst-path.png)\n\n5.**松弛技术 relaxation**\n对顶点 $ v \\in V$, 设置d[v]描述源点s到v的最短路径权值的上界,初始化如下:\n```\ninitialize-single-source(G, s)\nfor each vertex v in V[G]\n    do d[v] <- INT\n        f[v] <- Null\nd[s] <- 0\n```\n松弛操作指, 通过顶点u, 对迄今找到的v的最短路径改进的过程:\n```\nrelax(u, v, w)\nif d[v] > d[u] + w(u, v)\n    then d[v] <- d[u] + w(u, v)\n        f[v] <- u\n```\n松弛是最短路径的核心操作, 其是改变最短路径和前驱的唯一方式.本章的算法的区别主要就在对每条边的松弛操作的次数和顺序有所不同.Dijkstra算法对每条边执行一次松弛, 而在Bellman-Ford中执行多次.\n\n#### Bellman-Ford算法\nBellman-Ford算法运用松弛技术, 对每个顶点, 逐步减小源s到v的最短路径的估计值d[v]直到达到实际最短路径的权.算法返回布尔值,表明图中是否存在从源点可达的负权值回路.实现如下:\n```\nbellman-ford(G, w, s)\ninitialize-single-source(G, s)\nfor i <- 1 to |V[G]| - 1\n    do for each edge (u, v) in E[G]\n        do relax(u, v, w)\nfor each edge(u, v) in E[G]\n    do if d[v] > d[u] + w(u, v)\n        then return false\nreturn true\n```\n可视化如下:\n![bellman-ford](/images/bellman-ford.png)\n\n算法分析:\n初始化需要 $O(V)$, 松弛操作的循环共|V| - 1轮, 每轮运行时间为 $O(E)$.检验是否存在负权值回路需要 $O(E)$.故bellman-ford算法的总运行时间为 $O(EV)$.\n\n#### 有向无环图dag中的单源最短路径\n按顶点的拓扑顺序对某加权有向无回路图的边进行松弛后, 因为如果存在path(u,v),则拓扑序列中u在v之前.所以在遍历每个顶点时, 只需松弛从该点出发的所有边即可.因此,可以在 $O(V+E)$ 时间内计算出单源最短路径.在一个有向无回路图中最短路径总是存在的,因为即使图中有权值为负的边,也不可能存在负权回路(因为它根本没有任何回路).\n实现如下:\n```\ndag-shortest-path(G, w, s)\ntopoligically sort the vertices of G\ninitialize-single-source(G, s)\nfor each vertex u, taken in topoligically sorted order\n    do for each vertex v in Adj[u]\n        do relax(u, v, w)\n```\n\n可视化如下:\n![dag-path](/images/dag-path.png)\n\n\n#### Dijkstra算法\nDijkstra算法中设置顶点集合S, 从源点s到集合中顶点的最终最短路径的权值都已确定.其反复选择具有最短路径估计的顶点 $u \\in V-S$, 并将u将入S中, 对u的所有出边进行松弛.其中使用了优先级队列Q,来优化顶点d值的选取过程.\n实现如下:\n```\ndijkstra(G, w, s)\ninitialize-single-source(G, s)\ns <- Empty\nQ <- V[G]\nwhile Q != Empty\n    do u <- extract-min(Q)\n        s <- s union {u}\n        for each vertex v in Adj[u]\n            do relax(u, v, w)\n```\n\n可视化如下:\n![dijkstra](/images/dijkstra.png)\n\n算法分析\ndijkstra算法同样依赖优先队列Q的具体实现. 初始化Q调用`insert`方法 $O(1)$, 每个顶点调用一次, 需要 $O(V)$;for循环共有|E|迭代, 即至多|E|次调用`decrease-key` $O(1)$,共 $O(E)$.又有每个顶点只加入集合S一次, 故调用`extract-min` $O(v)$ 共|V|次, 于是dijkstra的总的运行时间为 $O(V^2 + E) = O(V^2)$.\n如果采用斐波那契堆实现优先级队列, 因为|V|个`extract-min`的平摊代价为 $O(\\log V)$, 至多|E|个`decrease-key`操作的每个的平摊代价为 $O(1)$.使得dijkstra算法可以优化到 $O(V\\log V + E)$.\n","source":"_posts/CLRS-notes5.md","raw":"title: introduction to algorithms note5\ntags:\n  - algorithm\n  - data_structure\ndate: 2017/05/09\n\n---\n\n# ＜Introduction to algorithms＞笔记\n\n## Part6 图算法\n在前面的部分学习了表示一对一关系的线性数据结构(数组, 链表, stack, queue), 表示一对多关系的树型数据结构(二叉树, 森林, 堆)后, 将其拓展到多对多关系-图.在part6主要是学习用图定义的计算问题和对应的算法,主要包括三个部分:\n* 图的表示,及广度/深度优先的图搜索算法\n* 求解最小生成树问题\n* 最短路径问题\n\n约定:以 $G = (V, E)$ 描述一个图G, 其顶点集为V[G], 顶点数为|V|;边集为E[G], 边数为|E|;故图问题的输入规模的参数有两个, |V|和|G|.例如,算法的复杂度为 $O(VE)$ 表示该算法的运行时间的 $O(|V||E|)$\n\n### Chapter22 如何表示和遍历图?\n本章的图搜索技术是图算法领域的核心.分为五个部分:\n* 图的表示\n* 广度优先搜索\n* 深度优先搜索\n* 有向无环图的拓扑排序\n* 有向图的强连通子图\n\n<!-- more -->\n\n#### 图的表示\n两种基本的表示方法:\n* 邻接表(adjacency lists)\n包含|V|个链表的数组*Adj*表示, 对 $u \\in V$, 有Adj[u] 包含图G中和顶点u相邻的所有顶点.其适用于稀疏图($|E|远小于|V|^2$).\n不论是有向图还是无向图,邻接表法都有一个很好的特性,即它所需要的存储空间为 $O(V+E)$ ;邻接表表示法稍作修改就能支持其它多种图的变体,因而有着很强的适应性.\n\n* 邻接矩阵(adjacency matrix)\nG的邻接矩阵为|V| * |V|的矩阵 $A = {a\\_{ij}}$, 其满足:\n$$ a\\_{ij} =\n\\begin{cases}\n1, \\text {if (i, j)} \\in E \\\\\\\\\n0, else \\\\\\\\\n\\end{cases}\n$$\n适用于稠密图, 空间复杂度 $O(v^2)$\n无向图的邻接矩阵A就是它的转置矩阵,即$A=A^T$ .在某些应用中采用矩阵严肃哦存储,可以只存储邻接矩阵的对角线及对角线以上的部分,这样一来,图所占用的存储空间可以减少一半.\n\n图1 无向图的邻接表和邻接矩阵表示\n![directed graph](/images/graph1.png)\n\n图2 有向图的邻接表和邻接矩阵表示\n![undirected graph](/images/graph2.png)\n\n邻接表表示和邻接矩阵表示在渐近意义上至少是一样有效的,但由于邻接矩阵简单明了,因而当图较小时,更多多地采用邻接矩阵来表示.另外,如果一个图不是加权的,采用邻接矩阵的存储形式还有一个优越性:在存储邻接矩阵的每个元素时,可以只用一个二进位,而不必有一个字的空间.这样,当采用了二进位以及表示无向图的技巧时,邻接矩阵法的占用空间大的缺点就可以得到一定程度上的改善.\n\n#### 广度优先搜索(bread-first search)\nBFS思路: 给定图G=(V, E)和特定原顶点s, 遍历G中的边, 发现可从s到达的所有顶点, 并计算s到所有可达顶点间的距离(最少的边数).因为始终是将已发现顶点和未发现顶点之间的边界沿广度方向扩展,即首先遍历和s距离k的顶点, 然后发现和s距离k+1的顶点.\nBFS实现如下:\n```\nBFS(G, s)\nfor each vertex u in V[G]-{s}\n    do color[u] <- white      #color数组:标记是否访问并可视化算法\n        d[u] <- INT           #d[u]: u到源点s的距离\n        f[u] <- Null          #f[u]: u的父顶点\ncolor[s] <- gray\nd[s] <- i\nf[s] <- Null\nQ <- Empty                     #Q:先进先出队列\nEnqueue(Q, s)\nwhile Q != Empty\n    do u <- Dequeu(Q)\n    for each v in Adj[u]\n        do if color[u] = white\n            then color[u] <- gray\n            d[v] <- d[u] + 1\n            f[v] <- u\n            Enqueue(Q, v)\n    color[u] <- black\n```\n算法过程如图3\n![BFS](/images/bfs.png)\n\nBFS分析:\n采用part4学习的聚集分析(aggregate analysis), 通过color数组的染色标记,确保每个顶点v只Enqueue一次,故亦只Dequeue一次.Enqueue和Dequeue要求 $O(1)$ 的时间,故队列操作时间为 $O(V)$.又有每个顶点v出队时扫描其邻接表Adj[v], 所以每个顶点邻接表只遍历一次, 花费时间为 $O(E)$. 故总运行时间为 $O(V + E)$.\n\n**将BFS理解为同心圆扩展算法, 想象图G为一片水面, 源点s就是我们扔进石子的点, 激出的波纹沿半径方向延伸,圆圈向外扩展的过程即是遍历水面的过程**.在这个过程中,BFS构造了一棵广度优先搜索树,包括s的所有**可达**顶点.对从s可达的任意顶点v,广度优先树中s到v的路径对应于图G中s到v的一条最短路径(边数最少).从BFS的算法中的数组f[u]可以用前驱图子图 $G\\_f = (V\\_f, E\\_f)$ 表示图G = (V, E)的广度优先树:\n\\begin{align}\nV\\_f = \\{v \\in V: f[v] \\neq Null \\} \\bigcup \\{s\\} \\\\\\\\\nE\\_f = \\{(f[v], v): v \\in V\\_f - \\{s\\} \\}\n\\end{align}\n\n根据BFS算法用递归输出s到v的最短路径如下:\n```\nprint-path(G, s, v)\nif v == s\n    then print s\n    else if f[v] = Null\n        then print \"no path from\" s \"to\" v \"exists\"\n        else print-path(G, s, f[v])\n            print v\n```\n\n### 深度优先搜索(depth-first search)\nDFS思路:对新遍历的顶点u, 如果还有以u为起点而未遍历的边,沿此边继续遍历.如果u的所有边都已遍历,则回溯到发现顶点u有起始点的顶点边.制止发现所有顶点为止.可以发现DFS按深度为策略进行遍历.\nDFS实现如下:\n```\nDFS(G)\nfor each vertex u in V[G]\n    do color[u] <- white\n        f[u] <- Null\ntime <- 0                       #全局计时器, 确定完成时间f[v]\nfor each vertex u in V[G]\n    do if colo[u] = white\n    then DFS-visit[u]\n\nDFS-visit(u)\ncolo[u] <- gray\nd[u] <- time + 1\nd[u] <- time\nfor each v in Adj[u]\n    do if color[v]  = white\n        then f[v] <- u\n        DFS-visit(v)\ncolor[u] <- black\nf[u] <- time <- time + 1\n```\nDFS可视化如图4\n![dfs](/images/dfs.png)\n\nDFS分析: 仍然采用聚集分析, 每个顶点的邻接表被遍历一次, 要求 $O(V)$.对每个顶点u, 过程DFS-visit仅被调用一次,即只对未遍历的顶点调用该过程.在DFS-visit(v)的一次执行中,遍历的标记过程被执行|Adj[v]|次,且有:\n$$  \\sum\\_{v \\in V}|Adj[v]| = O(E) $$\n故DFS的总运行时间为 $O(V + E)$.\n\nDFS创建一个深度优先森林外,深度优先搜索同时为每个顶点加盖时间戳.每个顶点 v 有两个时间戳:当顶点 v 第一次被发现时,记录下第一个时间戳 d[v],当结束检查 v 的邻接表时,记录下第二个时间戳 f[v].许多基于深度优先搜索的图算法都用到了时间戳,它们对推算深度优先搜索的时行情况有很大的帮助.\n\n#### 拓扑排序 Topological sort\n对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序,是将G中所有顶点排成一个线性序列,使得图中任意一对顶点u和v,若边 $(u,v) \\in E[G]$,则u在线性序列中出现在v之前.通常,这样的线性序列称为满足拓扑次序(Topological Order)的序列,简称拓扑序列.拓扑排序运用在在顶点活动网(Activity On Vertex network,简称AOV网)中,确定活动先后的发生顺序.\n\n一个dag的拓扑排序可以理解为图中所有顶点沿水平线排列而成的一个序列.下面是一个典型的活动安排例子:\n![dag](/images/dag.png)\n\n一般由AOV网构造拓扑序列的拓扑排序算法主要是循环执行以下两步,直到不存在入度为0的顶点为止.\n* 选择一个入度为0的顶点并输出之；\n* 从网中删除此顶点及所有出边.\n循环结束后,若输出的顶点数小于网中的顶点数,则输出“有回路”信息,否则输出的顶点序列就是一种拓扑序列.\n\n而在算法导论中运用全局的计时器time,巧妙的实现拓扑排序.通过深度遍历来确定时间完成的时间,按时间顺序自然构造拓扑序列,而无需根据BFS遍历来删除边.\n```\ntopoligical-sort(G)\ncall DFS(G) to compute finishing times f[v] for each vertex v\nas each vete is finished, insert it onto the front of a linked list\nreturn the linked list of vertices\n```\n\n#### 强连通分支\n强连通分支(strongly connected component):有向图G=(V,E)的一个最大顶点集合 $C \\subseteq V$, 对C中任意一堆对顶点u, v, 它们是互相可达的.\n\n寻找SCC的思路: 定义图G的转置:\n$$ G^T = (V, E^T), E^T = \\{(u, v):(v, u) \\in E\\} $$\n对分支图 $G^{SCC} = (V^{SCC}, E^{SCC})$,假设G的强连通分支为 $[C\\_1, C\\_2, \\dots, C\\_k]$.顶点集 $V^{SCC} = \\{v\\_1, v\\_2, \\dots, v\\_k \\}$,对于G的每一个强连通分支 $C\\_i$,它都包含一个顶点 $v\\_i$.如果对某个 $x \\in C\\_i$ 以及 $y \\in C\\_i$, G中包含有向边(x, y), 则有一条边 $(v\\_i,v\\_j) \\in E^{SCC}$. 因此收缩其关联的顶点都处于G的同一强连通分支内的边,即可得到图 $G^{SCC}$. 对应的 $G^{SCC}$是一个有向无环图(dag);\n![scc](/images/scc.png)\n\n> 1. 对G进行深度优先遍历得到每个顶点的时间戳 f[x];\n> 2. 求得G的返回图 $G^T$;\n> 3. 按照f[x]的逆向顺序为顶点顺序对$G^T$进行深度优先遍历,即按照G的拓扑排序的顺序对 $G^T$再进行深度优先遍历;\n步骤3得到的各棵子树就是原图 G的各强连通分支.\n```\nstrongly-connnected-component(G)\ncall DFS(G) to compute finishing times f[u] for each vertex u\ncompute GT\ncall DFS(GT). but in the main loop of DFS, consider the vertices in order of decreasing f[u](as computed in line 1)\noutput the vertices of each tree in the depth-first forest formed in line 3 as a separate strongly connected component\n```\n\n### Chapter23 最小生成树 Minimum Spanning Trees\n在生成树(spanning tree)T是指: T连接了G的所有顶点且无回路, 因此T必然是一棵树.其中特殊的一类T得到的树的权值最小, 为最小生成树.\n采用贪心的思路,可以通过Kruskal算法和Prim算法有效的解决生成树问题.\n\n#### 最小生成树的策略\n最小(权值)生成树:由 n-1 条边,连接了所有的 n 个顶点,并且所有边上的权值和最小.一个典型实例如下:\n![mst](/images/mst.png)\n\n一个通用的贪心策略是,在每个步骤中都形成最小生成树的一条边,算法维护这个集合A, 并保持了以下循环不变式:\n每次循环之前, A是最小生成树的一个子集.\n在算法的每一步,确定一条边(u, v), 使得它加入集合A后, 循环不变式得以保持, 即 $A \\bigcup \\{(u, v) \\}$仍然是最小生成树的子集.这样的边(u, v)称为安全边(safe edge).描述如下:\n```\ngeneric-mst(G, w)\nA <- Empty\nwhile A does not form a spanning tree\n    do find an edge(u, v) that is safe for A\n        A <- A union (u, v)\nreturn A\n```\n\n#### Kruskal算法\nKruskal算法直接基于通用贪心策略:找出森林中连接任意两棵树的所有边中,具有最小权值的边作为安全边,添加其到正在生长的森林中.即,集合A是一个森林,加入集合A中的安全边总是图中连接两个不同连通分支的最小权边.\n通过part5高级数据结构中不相交集合可以很好的实现Kruskal算法.比较`find-set(u)`和`find-set(v)`是否等同,确定u和v是否属于同一棵树,通过`Union`实现树的合并.\n```\nmst-kruskal(G, w)\nA <- Empty\nfor each vertex v in V[G]\n    do make-set(v)\nsort the edges of E into nondecreasing order by weight w\nfor each edge(u, v) in E, taken in nondecreasing order by weight\n    do if find-set(u) != find-set(v)\n        then A <- A union (u, v)\n            Union(u, v)\nreturn A\n```\n\n算法可视化如下:\n![kruskal](/images/kruskal.png)\n\nKruskal算法分析:\n如果采用不相交数据集合中的按秩结合和路径压缩的策略,可以最高效的实现.初始化要求 $O(1)$, 对各条边排序需要 $O(E\\log E)$.对每一条边, 执行 $O(E)$ 次`find-set`和`union`操作, 加上|V|次`make-set`操作,要求的总时间为$O((V + E)\\alpha(V)$.假定G是连通的,则有 |E| > |v| - 1, 因而不相交集合操作时间为 $O(E\\alpha(v))$. 又有 $\\alpha(|V|) = O(\\log V) = O(\\log E)$,故有总运行时间为 $O(E\\log E)$. 由于 $|E| < |V| ^ 2$, 因而 $\\log |E| = O(\\log V)$, 即Kruskal总运行时间为 $O(E\\log V)$\n\n#### Prim算法\nPrim算法的贪心策略:集合A仅形成单棵树,添入集合A中的安全边总是连接树与一个不在树中的顶点的最小权边.树从任意根顶点r开始形成, 每一步里连接了树A与 $G\\_A=(V, A)$ 中某孤立顶点的轻边(最小权值边)加入到树A中, 直至包含了所有的顶点.如下图:\n![prim](/images/prim.png)\n\nPrim算法维护一个基于key域的最小优先级队列Q,其包含所有不在树A中的顶点.key[u]表示所有与u相连的树中顶点的边的最小权值.f[u]指向u的父节点.\n```\nmst-prim(G, w, r)\nfor each u in V[G]\n    do key[u] <- INT\n        f[u] <- Null\nkey[r] <- 0\nQ <- V[G]\nwhile Q != Empty\n    do u <- extract-min(Q)\n        for each v in Adj[u]\n            do if v in Q and w(u, v) < key[v]\n                then f[u] <- u\n                    key[v] <- w(u, v)\n```\n\nPrim算法分析:\nPrim算法性能取决于优先队列Q的实现方案, 如果采用Part5学习的二叉堆实现:通过`build-min-heao`实现初始化, 需要 $O(V)$. `while`循环体执行|V|次, 每次调用`extract-min`需要 $O(\\log V)$, 故该循环占用时间 $O(V\\log V)$.`for`循环执行 $O(E)$ 次, 每次调用`decrease-key`实现对key的赋值要求 $O(\\log V)$.因此, Prim算法总的运行时间为 $O(V\\log V + E\\log V) = O(E\\log V)$.从渐进意义上来说, Prim算法和Kruskal算法运行时间相同.\n如果改进为斐波那契堆, 在Chapter20得到,|V|个元素组成的斐波那契堆,可以在 $O(\\log Ｖ)$ 的平摊时间内完成`extract-min`操作．则Prim算法运行时间可以改进为 $O(E + V\\log Ｖ)$.\n\n#### 对比\nPrim算法有着更好的实际效率:\n> 1. Prim算法在执行的过程中,将不在树中的所有顶点都放在一个基于key域的最小优先队列Q中;\n> 2. 每次在选取安全边时,只需要从Q中弹出最小key值的顶点即可,而不需要像 Kruskal 一样为对所有的边的权值进行一次排序;\n> 3. Prim 算法使用了用于快速或者最小权值边的技巧(二叉堆、二项堆、斐波那契堆)来加速算法的运行.在最朴素的选取安全边的算法中,需要遍历剩下的所有的边,所需要的时间复杂度为 $O(EV)$,而采用堆来优化后只需要 $O(E\\log V)$ ,大大地改善了算法的执行时间(堆的好处).\n\n不过Kruskal算法实现相对简单,所以对于一般的应用Kruskal算法也是可以的．\n\n\n### Chapter24 如何在地图中选择最短的路径?\n考虑一个实际问题:在地图上选出从北京到上海的最短距离.直接的想法是北京和上海两点之间的直线, 但实际不可能存在这条路, 北京和上海是通过之间一个个城市中转的.城市抽象为顶点, 城市之间的道路抽象为边,道路里程为权值,则北京到上海的最短路径问题转化为图中的单源最短路径问题.本章即是学习在图中解决最短路径问题的算法\n\n#### 最短路径\n定义\n给定带权有向图G = (V, E),加权函数 $w: E \\to R$从边到实数的映射.\n路径 $p = \\{v\\_0, v\\_1, \\dots, v\\_k\\}$的权为组成边的所有权值之和:\n$$ w(p) = \\sum\\_{i=1}^k w(v\\_{i-1}, v\\_i) $$\nu到v的最短路径的权为:\n$$\n\\delta(u, v) =\n\\begin{cases}\nmin\\{w(p): u \\to v \\}, \\text {if path(u, v) exists} \\\\\\\\\n\\infty, else \\\\\\\\\n\\end{cases}\n$$\n对应的最短路径为权 $w(p) = \\delta(u, v)$的任何路径.\n\n注:权值是一种度量标准, 不限于距离, 还可以是时间/费用/损失.\n\n问题变体\n* 单终点最短路: 每个顶点v到终点t的最短路, 即将单源最短路问题反向即可\n* 单对顶点最短路: 给定顶点u和v的最短路,u单源最短路的问题选择终点v即可\n* 全源最短路: 找出所有顶点之间的最短路径.\n\n问题分析\n1.最优子结构\n**最短路径的子路径是最短路径.**\n$$\\begin{align}\n设路径p = < v\\_0, v\\_1, \\dots, v\\_k >是v\\_0到v\\_k的最短路径,\\\\\n则对 \\forall i, j, 1 \\leq i \\leq j \\leq k \\\\\n路径p\\_{ij} = < v\\_i, v\\_{i+1}, \\dots, v\\_j>是 v\\_i到v\\_j的最短路径 \\\\\n\\end{align}\n$$\n\n2.负权值边\n如果问题中存在负权值边, 但不包含**负权值回路**,则最短路径的定义仍然是正确的.但一旦存在负权值回路, 则不存在最短路径,因为通过不断穿过负权值回路可以得到更小权值的边.\n![negative path](/images/n-path.png)\n\n3.回路\n除去负权值回路, 最短路径亦不能包含正权值回路.因为从路径上一出回路后,可以得到源点/终点相同,权值更小的路径.\n\n4.求解路径\n最短路径问题中我们不仅想得到最短路径的权,也想得到最短路径是什么.通过类似广度优先搜索树的表示方法,设置顶点v的前驱f[v], 形成最短路径树.然后调用`print-path(G, s, v)`来递归的输出最短路径即可.\n![mst-path](/images/mst-path.png)\n\n5.**松弛技术 relaxation**\n对顶点 $ v \\in V$, 设置d[v]描述源点s到v的最短路径权值的上界,初始化如下:\n```\ninitialize-single-source(G, s)\nfor each vertex v in V[G]\n    do d[v] <- INT\n        f[v] <- Null\nd[s] <- 0\n```\n松弛操作指, 通过顶点u, 对迄今找到的v的最短路径改进的过程:\n```\nrelax(u, v, w)\nif d[v] > d[u] + w(u, v)\n    then d[v] <- d[u] + w(u, v)\n        f[v] <- u\n```\n松弛是最短路径的核心操作, 其是改变最短路径和前驱的唯一方式.本章的算法的区别主要就在对每条边的松弛操作的次数和顺序有所不同.Dijkstra算法对每条边执行一次松弛, 而在Bellman-Ford中执行多次.\n\n#### Bellman-Ford算法\nBellman-Ford算法运用松弛技术, 对每个顶点, 逐步减小源s到v的最短路径的估计值d[v]直到达到实际最短路径的权.算法返回布尔值,表明图中是否存在从源点可达的负权值回路.实现如下:\n```\nbellman-ford(G, w, s)\ninitialize-single-source(G, s)\nfor i <- 1 to |V[G]| - 1\n    do for each edge (u, v) in E[G]\n        do relax(u, v, w)\nfor each edge(u, v) in E[G]\n    do if d[v] > d[u] + w(u, v)\n        then return false\nreturn true\n```\n可视化如下:\n![bellman-ford](/images/bellman-ford.png)\n\n算法分析:\n初始化需要 $O(V)$, 松弛操作的循环共|V| - 1轮, 每轮运行时间为 $O(E)$.检验是否存在负权值回路需要 $O(E)$.故bellman-ford算法的总运行时间为 $O(EV)$.\n\n#### 有向无环图dag中的单源最短路径\n按顶点的拓扑顺序对某加权有向无回路图的边进行松弛后, 因为如果存在path(u,v),则拓扑序列中u在v之前.所以在遍历每个顶点时, 只需松弛从该点出发的所有边即可.因此,可以在 $O(V+E)$ 时间内计算出单源最短路径.在一个有向无回路图中最短路径总是存在的,因为即使图中有权值为负的边,也不可能存在负权回路(因为它根本没有任何回路).\n实现如下:\n```\ndag-shortest-path(G, w, s)\ntopoligically sort the vertices of G\ninitialize-single-source(G, s)\nfor each vertex u, taken in topoligically sorted order\n    do for each vertex v in Adj[u]\n        do relax(u, v, w)\n```\n\n可视化如下:\n![dag-path](/images/dag-path.png)\n\n\n#### Dijkstra算法\nDijkstra算法中设置顶点集合S, 从源点s到集合中顶点的最终最短路径的权值都已确定.其反复选择具有最短路径估计的顶点 $u \\in V-S$, 并将u将入S中, 对u的所有出边进行松弛.其中使用了优先级队列Q,来优化顶点d值的选取过程.\n实现如下:\n```\ndijkstra(G, w, s)\ninitialize-single-source(G, s)\ns <- Empty\nQ <- V[G]\nwhile Q != Empty\n    do u <- extract-min(Q)\n        s <- s union {u}\n        for each vertex v in Adj[u]\n            do relax(u, v, w)\n```\n\n可视化如下:\n![dijkstra](/images/dijkstra.png)\n\n算法分析\ndijkstra算法同样依赖优先队列Q的具体实现. 初始化Q调用`insert`方法 $O(1)$, 每个顶点调用一次, 需要 $O(V)$;for循环共有|E|迭代, 即至多|E|次调用`decrease-key` $O(1)$,共 $O(E)$.又有每个顶点只加入集合S一次, 故调用`extract-min` $O(v)$ 共|V|次, 于是dijkstra的总的运行时间为 $O(V^2 + E) = O(V^2)$.\n如果采用斐波那契堆实现优先级队列, 因为|V|个`extract-min`的平摊代价为 $O(\\log V)$, 至多|E|个`decrease-key`操作的每个的平摊代价为 $O(1)$.使得dijkstra算法可以优化到 $O(V\\log V + E)$.\n","slug":"CLRS-notes5","published":1,"updated":"2017-08-26T03:38:21.610Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6sslhaw000a3gamryu1r0la","content":"<h1 id=\"＜Introduction-to-algorithms＞笔记\"><a href=\"#＜Introduction-to-algorithms＞笔记\" class=\"headerlink\" title=\"＜Introduction to algorithms＞笔记\"></a>＜Introduction to algorithms＞笔记</h1><h2 id=\"Part6-图算法\"><a href=\"#Part6-图算法\" class=\"headerlink\" title=\"Part6 图算法\"></a>Part6 图算法</h2><p>在前面的部分学习了表示一对一关系的线性数据结构(数组, 链表, stack, queue), 表示一对多关系的树型数据结构(二叉树, 森林, 堆)后, 将其拓展到多对多关系-图.在part6主要是学习用图定义的计算问题和对应的算法,主要包括三个部分:</p>\n<ul>\n<li>图的表示,及广度/深度优先的图搜索算法</li>\n<li>求解最小生成树问题</li>\n<li>最短路径问题</li>\n</ul>\n<p>约定:以 $G = (V, E)$ 描述一个图G, 其顶点集为V[G], 顶点数为|V|;边集为E[G], 边数为|E|;故图问题的输入规模的参数有两个, |V|和|G|.例如,算法的复杂度为 $O(VE)$ 表示该算法的运行时间的 $O(|V||E|)$</p>\n<h3 id=\"Chapter22-如何表示和遍历图\"><a href=\"#Chapter22-如何表示和遍历图\" class=\"headerlink\" title=\"Chapter22 如何表示和遍历图?\"></a>Chapter22 如何表示和遍历图?</h3><p>本章的图搜索技术是图算法领域的核心.分为五个部分:</p>\n<ul>\n<li>图的表示</li>\n<li>广度优先搜索</li>\n<li>深度优先搜索</li>\n<li>有向无环图的拓扑排序</li>\n<li>有向图的强连通子图</li>\n</ul>\n<a id=\"more\"></a>\n<h4 id=\"图的表示\"><a href=\"#图的表示\" class=\"headerlink\" title=\"图的表示\"></a>图的表示</h4><p>两种基本的表示方法:</p>\n<ul>\n<li><p>邻接表(adjacency lists)<br>包含|V|个链表的数组<em>Adj</em>表示, 对 $u \\in V$, 有Adj[u] 包含图G中和顶点u相邻的所有顶点.其适用于稀疏图($|E|远小于|V|^2$).<br>不论是有向图还是无向图,邻接表法都有一个很好的特性,即它所需要的存储空间为 $O(V+E)$ ;邻接表表示法稍作修改就能支持其它多种图的变体,因而有着很强的适应性.</p>\n</li>\n<li><p>邻接矩阵(adjacency matrix)<br>G的邻接矩阵为|V| * |V|的矩阵 $A = {a_{ij}}$, 其满足:<br>$$ a_{ij} =<br>\\begin{cases}<br>1, \\text {if (i, j)} \\in E \\\\<br>0, else \\\\<br>\\end{cases}<br>$$<br>适用于稠密图, 空间复杂度 $O(v^2)$<br>无向图的邻接矩阵A就是它的转置矩阵,即$A=A^T$ .在某些应用中采用矩阵严肃哦存储,可以只存储邻接矩阵的对角线及对角线以上的部分,这样一来,图所占用的存储空间可以减少一半.</p>\n</li>\n</ul>\n<p>图1 无向图的邻接表和邻接矩阵表示<br><img src=\"/images/graph1.png\" alt=\"directed graph\"></p>\n<p>图2 有向图的邻接表和邻接矩阵表示<br><img src=\"/images/graph2.png\" alt=\"undirected graph\"></p>\n<p>邻接表表示和邻接矩阵表示在渐近意义上至少是一样有效的,但由于邻接矩阵简单明了,因而当图较小时,更多多地采用邻接矩阵来表示.另外,如果一个图不是加权的,采用邻接矩阵的存储形式还有一个优越性:在存储邻接矩阵的每个元素时,可以只用一个二进位,而不必有一个字的空间.这样,当采用了二进位以及表示无向图的技巧时,邻接矩阵法的占用空间大的缺点就可以得到一定程度上的改善.</p>\n<h4 id=\"广度优先搜索-bread-first-search\"><a href=\"#广度优先搜索-bread-first-search\" class=\"headerlink\" title=\"广度优先搜索(bread-first search)\"></a>广度优先搜索(bread-first search)</h4><p>BFS思路: 给定图G=(V, E)和特定原顶点s, 遍历G中的边, 发现可从s到达的所有顶点, 并计算s到所有可达顶点间的距离(最少的边数).因为始终是将已发现顶点和未发现顶点之间的边界沿广度方向扩展,即首先遍历和s距离k的顶点, 然后发现和s距离k+1的顶点.<br>BFS实现如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">BFS(G, s)</div><div class=\"line\">for each vertex u in V[G]-&#123;s&#125;</div><div class=\"line\">    do color[u] &lt;- white      #color数组:标记是否访问并可视化算法</div><div class=\"line\">        d[u] &lt;- INT           #d[u]: u到源点s的距离</div><div class=\"line\">        f[u] &lt;- Null          #f[u]: u的父顶点</div><div class=\"line\">color[s] &lt;- gray</div><div class=\"line\">d[s] &lt;- i</div><div class=\"line\">f[s] &lt;- Null</div><div class=\"line\">Q &lt;- Empty                     #Q:先进先出队列</div><div class=\"line\">Enqueue(Q, s)</div><div class=\"line\">while Q != Empty</div><div class=\"line\">    do u &lt;- Dequeu(Q)</div><div class=\"line\">    for each v in Adj[u]</div><div class=\"line\">        do if color[u] = white</div><div class=\"line\">            then color[u] &lt;- gray</div><div class=\"line\">            d[v] &lt;- d[u] + 1</div><div class=\"line\">            f[v] &lt;- u</div><div class=\"line\">            Enqueue(Q, v)</div><div class=\"line\">    color[u] &lt;- black</div></pre></td></tr></table></figure></p>\n<p>算法过程如图3<br><img src=\"/images/bfs.png\" alt=\"BFS\"></p>\n<p>BFS分析:<br>采用part4学习的聚集分析(aggregate analysis), 通过color数组的染色标记,确保每个顶点v只Enqueue一次,故亦只Dequeue一次.Enqueue和Dequeue要求 $O(1)$ 的时间,故队列操作时间为 $O(V)$.又有每个顶点v出队时扫描其邻接表Adj[v], 所以每个顶点邻接表只遍历一次, 花费时间为 $O(E)$. 故总运行时间为 $O(V + E)$.</p>\n<p><strong>将BFS理解为同心圆扩展算法, 想象图G为一片水面, 源点s就是我们扔进石子的点, 激出的波纹沿半径方向延伸,圆圈向外扩展的过程即是遍历水面的过程</strong>.在这个过程中,BFS构造了一棵广度优先搜索树,包括s的所有<strong>可达</strong>顶点.对从s可达的任意顶点v,广度优先树中s到v的路径对应于图G中s到v的一条最短路径(边数最少).从BFS的算法中的数组f[u]可以用前驱图子图 $G_f = (V_f, E_f)$ 表示图G = (V, E)的广度优先树:<br>\\begin{align}<br>V_f = {v \\in V: f[v] \\neq Null } \\bigcup {s} \\\\<br>E_f = {(f[v], v): v \\in V_f - {s} }<br>\\end{align}</p>\n<p>根据BFS算法用递归输出s到v的最短路径如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">print-path(G, s, v)</div><div class=\"line\">if v == s</div><div class=\"line\">    then print s</div><div class=\"line\">    else if f[v] = Null</div><div class=\"line\">        then print &quot;no path from&quot; s &quot;to&quot; v &quot;exists&quot;</div><div class=\"line\">        else print-path(G, s, f[v])</div><div class=\"line\">            print v</div></pre></td></tr></table></figure></p>\n<h3 id=\"深度优先搜索-depth-first-search\"><a href=\"#深度优先搜索-depth-first-search\" class=\"headerlink\" title=\"深度优先搜索(depth-first search)\"></a>深度优先搜索(depth-first search)</h3><p>DFS思路:对新遍历的顶点u, 如果还有以u为起点而未遍历的边,沿此边继续遍历.如果u的所有边都已遍历,则回溯到发现顶点u有起始点的顶点边.制止发现所有顶点为止.可以发现DFS按深度为策略进行遍历.<br>DFS实现如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">DFS(G)</div><div class=\"line\">for each vertex u in V[G]</div><div class=\"line\">    do color[u] &lt;- white</div><div class=\"line\">        f[u] &lt;- Null</div><div class=\"line\">time &lt;- 0                       #全局计时器, 确定完成时间f[v]</div><div class=\"line\">for each vertex u in V[G]</div><div class=\"line\">    do if colo[u] = white</div><div class=\"line\">    then DFS-visit[u]</div><div class=\"line\"></div><div class=\"line\">DFS-visit(u)</div><div class=\"line\">colo[u] &lt;- gray</div><div class=\"line\">d[u] &lt;- time + 1</div><div class=\"line\">d[u] &lt;- time</div><div class=\"line\">for each v in Adj[u]</div><div class=\"line\">    do if color[v]  = white</div><div class=\"line\">        then f[v] &lt;- u</div><div class=\"line\">        DFS-visit(v)</div><div class=\"line\">color[u] &lt;- black</div><div class=\"line\">f[u] &lt;- time &lt;- time + 1</div></pre></td></tr></table></figure></p>\n<p>DFS可视化如图4<br><img src=\"/images/dfs.png\" alt=\"dfs\"></p>\n<p>DFS分析: 仍然采用聚集分析, 每个顶点的邻接表被遍历一次, 要求 $O(V)$.对每个顶点u, 过程DFS-visit仅被调用一次,即只对未遍历的顶点调用该过程.在DFS-visit(v)的一次执行中,遍历的标记过程被执行|Adj[v]|次,且有:<br>$$  \\sum_{v \\in V}|Adj[v]| = O(E) $$<br>故DFS的总运行时间为 $O(V + E)$.</p>\n<p>DFS创建一个深度优先森林外,深度优先搜索同时为每个顶点加盖时间戳.每个顶点 v 有两个时间戳:当顶点 v 第一次被发现时,记录下第一个时间戳 d[v],当结束检查 v 的邻接表时,记录下第二个时间戳 f[v].许多基于深度优先搜索的图算法都用到了时间戳,它们对推算深度优先搜索的时行情况有很大的帮助.</p>\n<h4 id=\"拓扑排序-Topological-sort\"><a href=\"#拓扑排序-Topological-sort\" class=\"headerlink\" title=\"拓扑排序 Topological sort\"></a>拓扑排序 Topological sort</h4><p>对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序,是将G中所有顶点排成一个线性序列,使得图中任意一对顶点u和v,若边 $(u,v) \\in E[G]$,则u在线性序列中出现在v之前.通常,这样的线性序列称为满足拓扑次序(Topological Order)的序列,简称拓扑序列.拓扑排序运用在在顶点活动网(Activity On Vertex network,简称AOV网)中,确定活动先后的发生顺序.</p>\n<p>一个dag的拓扑排序可以理解为图中所有顶点沿水平线排列而成的一个序列.下面是一个典型的活动安排例子:<br><img src=\"/images/dag.png\" alt=\"dag\"></p>\n<p>一般由AOV网构造拓扑序列的拓扑排序算法主要是循环执行以下两步,直到不存在入度为0的顶点为止.</p>\n<ul>\n<li>选择一个入度为0的顶点并输出之；</li>\n<li>从网中删除此顶点及所有出边.<br>循环结束后,若输出的顶点数小于网中的顶点数,则输出“有回路”信息,否则输出的顶点序列就是一种拓扑序列.</li>\n</ul>\n<p>而在算法导论中运用全局的计时器time,巧妙的实现拓扑排序.通过深度遍历来确定时间完成的时间,按时间顺序自然构造拓扑序列,而无需根据BFS遍历来删除边.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">topoligical-sort(G)</div><div class=\"line\">call DFS(G) to compute finishing times f[v] for each vertex v</div><div class=\"line\">as each vete is finished, insert it onto the front of a linked list</div><div class=\"line\">return the linked list of vertices</div></pre></td></tr></table></figure></p>\n<h4 id=\"强连通分支\"><a href=\"#强连通分支\" class=\"headerlink\" title=\"强连通分支\"></a>强连通分支</h4><p>强连通分支(strongly connected component):有向图G=(V,E)的一个最大顶点集合 $C \\subseteq V$, 对C中任意一堆对顶点u, v, 它们是互相可达的.</p>\n<p>寻找SCC的思路: 定义图G的转置:<br>$$ G^T = (V, E^T), E^T = {(u, v):(v, u) \\in E} $$<br>对分支图 $G^{SCC} = (V^{SCC}, E^{SCC})$,假设G的强连通分支为 $[C_1, C_2, \\dots, C_k]$.顶点集 $V^{SCC} = {v_1, v_2, \\dots, v_k }$,对于G的每一个强连通分支 $C_i$,它都包含一个顶点 $v_i$.如果对某个 $x \\in C_i$ 以及 $y \\in C_i$, G中包含有向边(x, y), 则有一条边 $(v_i,v_j) \\in E^{SCC}$. 因此收缩其关联的顶点都处于G的同一强连通分支内的边,即可得到图 $G^{SCC}$. 对应的 $G^{SCC}$是一个有向无环图(dag);<br><img src=\"/images/scc.png\" alt=\"scc\"></p>\n<blockquote>\n<ol>\n<li>对G进行深度优先遍历得到每个顶点的时间戳 f[x];</li>\n<li>求得G的返回图 $G^T$;</li>\n<li>按照f[x]的逆向顺序为顶点顺序对$G^T$进行深度优先遍历,即按照G的拓扑排序的顺序对 $G^T$再进行深度优先遍历;<br>步骤3得到的各棵子树就是原图 G的各强连通分支.<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">strongly-connnected-component(G)</div><div class=\"line\">call DFS(G) to compute finishing times f[u] for each vertex u</div><div class=\"line\">compute GT</div><div class=\"line\">call DFS(GT). but in the main loop of DFS, consider the vertices in order of decreasing f[u](as computed in line 1)</div><div class=\"line\">output the vertices of each tree in the depth-first forest formed in line 3 as a separate strongly connected component</div></pre></td></tr></table></figure>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"Chapter23-最小生成树-Minimum-Spanning-Trees\"><a href=\"#Chapter23-最小生成树-Minimum-Spanning-Trees\" class=\"headerlink\" title=\"Chapter23 最小生成树 Minimum Spanning Trees\"></a>Chapter23 最小生成树 Minimum Spanning Trees</h3><p>在生成树(spanning tree)T是指: T连接了G的所有顶点且无回路, 因此T必然是一棵树.其中特殊的一类T得到的树的权值最小, 为最小生成树.<br>采用贪心的思路,可以通过Kruskal算法和Prim算法有效的解决生成树问题.</p>\n<h4 id=\"最小生成树的策略\"><a href=\"#最小生成树的策略\" class=\"headerlink\" title=\"最小生成树的策略\"></a>最小生成树的策略</h4><p>最小(权值)生成树:由 n-1 条边,连接了所有的 n 个顶点,并且所有边上的权值和最小.一个典型实例如下:<br><img src=\"/images/mst.png\" alt=\"mst\"></p>\n<p>一个通用的贪心策略是,在每个步骤中都形成最小生成树的一条边,算法维护这个集合A, 并保持了以下循环不变式:<br>每次循环之前, A是最小生成树的一个子集.<br>在算法的每一步,确定一条边(u, v), 使得它加入集合A后, 循环不变式得以保持, 即 $A \\bigcup {(u, v) }$仍然是最小生成树的子集.这样的边(u, v)称为安全边(safe edge).描述如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">generic-mst(G, w)</div><div class=\"line\">A &lt;- Empty</div><div class=\"line\">while A does not form a spanning tree</div><div class=\"line\">    do find an edge(u, v) that is safe for A</div><div class=\"line\">        A &lt;- A union (u, v)</div><div class=\"line\">return A</div></pre></td></tr></table></figure></p>\n<h4 id=\"Kruskal算法\"><a href=\"#Kruskal算法\" class=\"headerlink\" title=\"Kruskal算法\"></a>Kruskal算法</h4><p>Kruskal算法直接基于通用贪心策略:找出森林中连接任意两棵树的所有边中,具有最小权值的边作为安全边,添加其到正在生长的森林中.即,集合A是一个森林,加入集合A中的安全边总是图中连接两个不同连通分支的最小权边.<br>通过part5高级数据结构中不相交集合可以很好的实现Kruskal算法.比较<code>find-set(u)</code>和<code>find-set(v)</code>是否等同,确定u和v是否属于同一棵树,通过<code>Union</code>实现树的合并.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">mst-kruskal(G, w)</div><div class=\"line\">A &lt;- Empty</div><div class=\"line\">for each vertex v in V[G]</div><div class=\"line\">    do make-set(v)</div><div class=\"line\">sort the edges of E into nondecreasing order by weight w</div><div class=\"line\">for each edge(u, v) in E, taken in nondecreasing order by weight</div><div class=\"line\">    do if find-set(u) != find-set(v)</div><div class=\"line\">        then A &lt;- A union (u, v)</div><div class=\"line\">            Union(u, v)</div><div class=\"line\">return A</div></pre></td></tr></table></figure></p>\n<p>算法可视化如下:<br><img src=\"/images/kruskal.png\" alt=\"kruskal\"></p>\n<p>Kruskal算法分析:<br>如果采用不相交数据集合中的按秩结合和路径压缩的策略,可以最高效的实现.初始化要求 $O(1)$, 对各条边排序需要 $O(E\\log E)$.对每一条边, 执行 $O(E)$ 次<code>find-set</code>和<code>union</code>操作, 加上|V|次<code>make-set</code>操作,要求的总时间为$O((V + E)\\alpha(V)$.假定G是连通的,则有 |E| &gt; |v| - 1, 因而不相交集合操作时间为 $O(E\\alpha(v))$. 又有 $\\alpha(|V|) = O(\\log V) = O(\\log E)$,故有总运行时间为 $O(E\\log E)$. 由于 $|E| &lt; |V| ^ 2$, 因而 $\\log |E| = O(\\log V)$, 即Kruskal总运行时间为 $O(E\\log V)$</p>\n<h4 id=\"Prim算法\"><a href=\"#Prim算法\" class=\"headerlink\" title=\"Prim算法\"></a>Prim算法</h4><p>Prim算法的贪心策略:集合A仅形成单棵树,添入集合A中的安全边总是连接树与一个不在树中的顶点的最小权边.树从任意根顶点r开始形成, 每一步里连接了树A与 $G_A=(V, A)$ 中某孤立顶点的轻边(最小权值边)加入到树A中, 直至包含了所有的顶点.如下图:<br><img src=\"/images/prim.png\" alt=\"prim\"></p>\n<p>Prim算法维护一个基于key域的最小优先级队列Q,其包含所有不在树A中的顶点.key[u]表示所有与u相连的树中顶点的边的最小权值.f[u]指向u的父节点.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">mst-prim(G, w, r)</div><div class=\"line\">for each u in V[G]</div><div class=\"line\">    do key[u] &lt;- INT</div><div class=\"line\">        f[u] &lt;- Null</div><div class=\"line\">key[r] &lt;- 0</div><div class=\"line\">Q &lt;- V[G]</div><div class=\"line\">while Q != Empty</div><div class=\"line\">    do u &lt;- extract-min(Q)</div><div class=\"line\">        for each v in Adj[u]</div><div class=\"line\">            do if v in Q and w(u, v) &lt; key[v]</div><div class=\"line\">                then f[u] &lt;- u</div><div class=\"line\">                    key[v] &lt;- w(u, v)</div></pre></td></tr></table></figure></p>\n<p>Prim算法分析:<br>Prim算法性能取决于优先队列Q的实现方案, 如果采用Part5学习的二叉堆实现:通过<code>build-min-heao</code>实现初始化, 需要 $O(V)$. <code>while</code>循环体执行|V|次, 每次调用<code>extract-min</code>需要 $O(\\log V)$, 故该循环占用时间 $O(V\\log V)$.<code>for</code>循环执行 $O(E)$ 次, 每次调用<code>decrease-key</code>实现对key的赋值要求 $O(\\log V)$.因此, Prim算法总的运行时间为 $O(V\\log V + E\\log V) = O(E\\log V)$.从渐进意义上来说, Prim算法和Kruskal算法运行时间相同.<br>如果改进为斐波那契堆, 在Chapter20得到,|V|个元素组成的斐波那契堆,可以在 $O(\\log Ｖ)$ 的平摊时间内完成<code>extract-min</code>操作．则Prim算法运行时间可以改进为 $O(E + V\\log Ｖ)$.</p>\n<h4 id=\"对比\"><a href=\"#对比\" class=\"headerlink\" title=\"对比\"></a>对比</h4><p>Prim算法有着更好的实际效率:</p>\n<blockquote>\n<ol>\n<li>Prim算法在执行的过程中,将不在树中的所有顶点都放在一个基于key域的最小优先队列Q中;</li>\n<li>每次在选取安全边时,只需要从Q中弹出最小key值的顶点即可,而不需要像 Kruskal 一样为对所有的边的权值进行一次排序;</li>\n<li>Prim 算法使用了用于快速或者最小权值边的技巧(二叉堆、二项堆、斐波那契堆)来加速算法的运行.在最朴素的选取安全边的算法中,需要遍历剩下的所有的边,所需要的时间复杂度为 $O(EV)$,而采用堆来优化后只需要 $O(E\\log V)$ ,大大地改善了算法的执行时间(堆的好处).</li>\n</ol>\n</blockquote>\n<p>不过Kruskal算法实现相对简单,所以对于一般的应用Kruskal算法也是可以的．</p>\n<h3 id=\"Chapter24-如何在地图中选择最短的路径\"><a href=\"#Chapter24-如何在地图中选择最短的路径\" class=\"headerlink\" title=\"Chapter24 如何在地图中选择最短的路径?\"></a>Chapter24 如何在地图中选择最短的路径?</h3><p>考虑一个实际问题:在地图上选出从北京到上海的最短距离.直接的想法是北京和上海两点之间的直线, 但实际不可能存在这条路, 北京和上海是通过之间一个个城市中转的.城市抽象为顶点, 城市之间的道路抽象为边,道路里程为权值,则北京到上海的最短路径问题转化为图中的单源最短路径问题.本章即是学习在图中解决最短路径问题的算法</p>\n<h4 id=\"最短路径\"><a href=\"#最短路径\" class=\"headerlink\" title=\"最短路径\"></a>最短路径</h4><p>定义<br>给定带权有向图G = (V, E),加权函数 $w: E \\to R$从边到实数的映射.<br>路径 $p = {v_0, v_1, \\dots, v_k}$的权为组成边的所有权值之和:<br>$$ w(p) = \\sum_{i=1}^k w(v_{i-1}, v_i) $$<br>u到v的最短路径的权为:<br>$$<br>\\delta(u, v) =<br>\\begin{cases}<br>min{w(p): u \\to v }, \\text {if path(u, v) exists} \\\\<br>\\infty, else \\\\<br>\\end{cases}<br>$$<br>对应的最短路径为权 $w(p) = \\delta(u, v)$的任何路径.</p>\n<p>注:权值是一种度量标准, 不限于距离, 还可以是时间/费用/损失.</p>\n<p>问题变体</p>\n<ul>\n<li>单终点最短路: 每个顶点v到终点t的最短路, 即将单源最短路问题反向即可</li>\n<li>单对顶点最短路: 给定顶点u和v的最短路,u单源最短路的问题选择终点v即可</li>\n<li>全源最短路: 找出所有顶点之间的最短路径.</li>\n</ul>\n<p>问题分析<br>1.最优子结构<br><strong>最短路径的子路径是最短路径.</strong><br>$$\\begin{align}<br>设路径p = &lt; v_0, v_1, \\dots, v_k &gt;是v_0到v_k的最短路径,\\<br>则对 \\forall i, j, 1 \\leq i \\leq j \\leq k \\<br>路径p_{ij} = &lt; v_i, v_{i+1}, \\dots, v_j&gt;是 v_i到v_j的最短路径 \\<br>\\end{align}<br>$$</p>\n<p>2.负权值边<br>如果问题中存在负权值边, 但不包含<strong>负权值回路</strong>,则最短路径的定义仍然是正确的.但一旦存在负权值回路, 则不存在最短路径,因为通过不断穿过负权值回路可以得到更小权值的边.<br><img src=\"/images/n-path.png\" alt=\"negative path\"></p>\n<p>3.回路<br>除去负权值回路, 最短路径亦不能包含正权值回路.因为从路径上一出回路后,可以得到源点/终点相同,权值更小的路径.</p>\n<p>4.求解路径<br>最短路径问题中我们不仅想得到最短路径的权,也想得到最短路径是什么.通过类似广度优先搜索树的表示方法,设置顶点v的前驱f[v], 形成最短路径树.然后调用<code>print-path(G, s, v)</code>来递归的输出最短路径即可.<br><img src=\"/images/mst-path.png\" alt=\"mst-path\"></p>\n<p>5.<strong>松弛技术 relaxation</strong><br>对顶点 $ v \\in V$, 设置d[v]描述源点s到v的最短路径权值的上界,初始化如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">initialize-single-source(G, s)</div><div class=\"line\">for each vertex v in V[G]</div><div class=\"line\">    do d[v] &lt;- INT</div><div class=\"line\">        f[v] &lt;- Null</div><div class=\"line\">d[s] &lt;- 0</div></pre></td></tr></table></figure></p>\n<p>松弛操作指, 通过顶点u, 对迄今找到的v的最短路径改进的过程:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">relax(u, v, w)</div><div class=\"line\">if d[v] &gt; d[u] + w(u, v)</div><div class=\"line\">    then d[v] &lt;- d[u] + w(u, v)</div><div class=\"line\">        f[v] &lt;- u</div></pre></td></tr></table></figure></p>\n<p>松弛是最短路径的核心操作, 其是改变最短路径和前驱的唯一方式.本章的算法的区别主要就在对每条边的松弛操作的次数和顺序有所不同.Dijkstra算法对每条边执行一次松弛, 而在Bellman-Ford中执行多次.</p>\n<h4 id=\"Bellman-Ford算法\"><a href=\"#Bellman-Ford算法\" class=\"headerlink\" title=\"Bellman-Ford算法\"></a>Bellman-Ford算法</h4><p>Bellman-Ford算法运用松弛技术, 对每个顶点, 逐步减小源s到v的最短路径的估计值d[v]直到达到实际最短路径的权.算法返回布尔值,表明图中是否存在从源点可达的负权值回路.实现如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">bellman-ford(G, w, s)</div><div class=\"line\">initialize-single-source(G, s)</div><div class=\"line\">for i &lt;- 1 to |V[G]| - 1</div><div class=\"line\">    do for each edge (u, v) in E[G]</div><div class=\"line\">        do relax(u, v, w)</div><div class=\"line\">for each edge(u, v) in E[G]</div><div class=\"line\">    do if d[v] &gt; d[u] + w(u, v)</div><div class=\"line\">        then return false</div><div class=\"line\">return true</div></pre></td></tr></table></figure></p>\n<p>可视化如下:<br><img src=\"/images/bellman-ford.png\" alt=\"bellman-ford\"></p>\n<p>算法分析:<br>初始化需要 $O(V)$, 松弛操作的循环共|V| - 1轮, 每轮运行时间为 $O(E)$.检验是否存在负权值回路需要 $O(E)$.故bellman-ford算法的总运行时间为 $O(EV)$.</p>\n<h4 id=\"有向无环图dag中的单源最短路径\"><a href=\"#有向无环图dag中的单源最短路径\" class=\"headerlink\" title=\"有向无环图dag中的单源最短路径\"></a>有向无环图dag中的单源最短路径</h4><p>按顶点的拓扑顺序对某加权有向无回路图的边进行松弛后, 因为如果存在path(u,v),则拓扑序列中u在v之前.所以在遍历每个顶点时, 只需松弛从该点出发的所有边即可.因此,可以在 $O(V+E)$ 时间内计算出单源最短路径.在一个有向无回路图中最短路径总是存在的,因为即使图中有权值为负的边,也不可能存在负权回路(因为它根本没有任何回路).<br>实现如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">dag-shortest-path(G, w, s)</div><div class=\"line\">topoligically sort the vertices of G</div><div class=\"line\">initialize-single-source(G, s)</div><div class=\"line\">for each vertex u, taken in topoligically sorted order</div><div class=\"line\">    do for each vertex v in Adj[u]</div><div class=\"line\">        do relax(u, v, w)</div></pre></td></tr></table></figure></p>\n<p>可视化如下:<br><img src=\"/images/dag-path.png\" alt=\"dag-path\"></p>\n<h4 id=\"Dijkstra算法\"><a href=\"#Dijkstra算法\" class=\"headerlink\" title=\"Dijkstra算法\"></a>Dijkstra算法</h4><p>Dijkstra算法中设置顶点集合S, 从源点s到集合中顶点的最终最短路径的权值都已确定.其反复选择具有最短路径估计的顶点 $u \\in V-S$, 并将u将入S中, 对u的所有出边进行松弛.其中使用了优先级队列Q,来优化顶点d值的选取过程.<br>实现如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">dijkstra(G, w, s)</div><div class=\"line\">initialize-single-source(G, s)</div><div class=\"line\">s &lt;- Empty</div><div class=\"line\">Q &lt;- V[G]</div><div class=\"line\">while Q != Empty</div><div class=\"line\">    do u &lt;- extract-min(Q)</div><div class=\"line\">        s &lt;- s union &#123;u&#125;</div><div class=\"line\">        for each vertex v in Adj[u]</div><div class=\"line\">            do relax(u, v, w)</div></pre></td></tr></table></figure></p>\n<p>可视化如下:<br><img src=\"/images/dijkstra.png\" alt=\"dijkstra\"></p>\n<p>算法分析<br>dijkstra算法同样依赖优先队列Q的具体实现. 初始化Q调用<code>insert</code>方法 $O(1)$, 每个顶点调用一次, 需要 $O(V)$;for循环共有|E|迭代, 即至多|E|次调用<code>decrease-key</code> $O(1)$,共 $O(E)$.又有每个顶点只加入集合S一次, 故调用<code>extract-min</code> $O(v)$ 共|V|次, 于是dijkstra的总的运行时间为 $O(V^2 + E) = O(V^2)$.<br>如果采用斐波那契堆实现优先级队列, 因为|V|个<code>extract-min</code>的平摊代价为 $O(\\log V)$, 至多|E|个<code>decrease-key</code>操作的每个的平摊代价为 $O(1)$.使得dijkstra算法可以优化到 $O(V\\log V + E)$.</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"＜Introduction-to-algorithms＞笔记\"><a href=\"#＜Introduction-to-algorithms＞笔记\" class=\"headerlink\" title=\"＜Introduction to algorithms＞笔记\"></a>＜Introduction to algorithms＞笔记</h1><h2 id=\"Part6-图算法\"><a href=\"#Part6-图算法\" class=\"headerlink\" title=\"Part6 图算法\"></a>Part6 图算法</h2><p>在前面的部分学习了表示一对一关系的线性数据结构(数组, 链表, stack, queue), 表示一对多关系的树型数据结构(二叉树, 森林, 堆)后, 将其拓展到多对多关系-图.在part6主要是学习用图定义的计算问题和对应的算法,主要包括三个部分:</p>\n<ul>\n<li>图的表示,及广度/深度优先的图搜索算法</li>\n<li>求解最小生成树问题</li>\n<li>最短路径问题</li>\n</ul>\n<p>约定:以 $G = (V, E)$ 描述一个图G, 其顶点集为V[G], 顶点数为|V|;边集为E[G], 边数为|E|;故图问题的输入规模的参数有两个, |V|和|G|.例如,算法的复杂度为 $O(VE)$ 表示该算法的运行时间的 $O(|V||E|)$</p>\n<h3 id=\"Chapter22-如何表示和遍历图\"><a href=\"#Chapter22-如何表示和遍历图\" class=\"headerlink\" title=\"Chapter22 如何表示和遍历图?\"></a>Chapter22 如何表示和遍历图?</h3><p>本章的图搜索技术是图算法领域的核心.分为五个部分:</p>\n<ul>\n<li>图的表示</li>\n<li>广度优先搜索</li>\n<li>深度优先搜索</li>\n<li>有向无环图的拓扑排序</li>\n<li>有向图的强连通子图</li>\n</ul>","more":"<h4 id=\"图的表示\"><a href=\"#图的表示\" class=\"headerlink\" title=\"图的表示\"></a>图的表示</h4><p>两种基本的表示方法:</p>\n<ul>\n<li><p>邻接表(adjacency lists)<br>包含|V|个链表的数组<em>Adj</em>表示, 对 $u \\in V$, 有Adj[u] 包含图G中和顶点u相邻的所有顶点.其适用于稀疏图($|E|远小于|V|^2$).<br>不论是有向图还是无向图,邻接表法都有一个很好的特性,即它所需要的存储空间为 $O(V+E)$ ;邻接表表示法稍作修改就能支持其它多种图的变体,因而有着很强的适应性.</p>\n</li>\n<li><p>邻接矩阵(adjacency matrix)<br>G的邻接矩阵为|V| * |V|的矩阵 $A = {a_{ij}}$, 其满足:<br>$$ a_{ij} =<br>\\begin{cases}<br>1, \\text {if (i, j)} \\in E \\\\<br>0, else \\\\<br>\\end{cases}<br>$$<br>适用于稠密图, 空间复杂度 $O(v^2)$<br>无向图的邻接矩阵A就是它的转置矩阵,即$A=A^T$ .在某些应用中采用矩阵严肃哦存储,可以只存储邻接矩阵的对角线及对角线以上的部分,这样一来,图所占用的存储空间可以减少一半.</p>\n</li>\n</ul>\n<p>图1 无向图的邻接表和邻接矩阵表示<br><img src=\"/images/graph1.png\" alt=\"directed graph\"></p>\n<p>图2 有向图的邻接表和邻接矩阵表示<br><img src=\"/images/graph2.png\" alt=\"undirected graph\"></p>\n<p>邻接表表示和邻接矩阵表示在渐近意义上至少是一样有效的,但由于邻接矩阵简单明了,因而当图较小时,更多多地采用邻接矩阵来表示.另外,如果一个图不是加权的,采用邻接矩阵的存储形式还有一个优越性:在存储邻接矩阵的每个元素时,可以只用一个二进位,而不必有一个字的空间.这样,当采用了二进位以及表示无向图的技巧时,邻接矩阵法的占用空间大的缺点就可以得到一定程度上的改善.</p>\n<h4 id=\"广度优先搜索-bread-first-search\"><a href=\"#广度优先搜索-bread-first-search\" class=\"headerlink\" title=\"广度优先搜索(bread-first search)\"></a>广度优先搜索(bread-first search)</h4><p>BFS思路: 给定图G=(V, E)和特定原顶点s, 遍历G中的边, 发现可从s到达的所有顶点, 并计算s到所有可达顶点间的距离(最少的边数).因为始终是将已发现顶点和未发现顶点之间的边界沿广度方向扩展,即首先遍历和s距离k的顶点, 然后发现和s距离k+1的顶点.<br>BFS实现如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">BFS(G, s)</div><div class=\"line\">for each vertex u in V[G]-&#123;s&#125;</div><div class=\"line\">    do color[u] &lt;- white      #color数组:标记是否访问并可视化算法</div><div class=\"line\">        d[u] &lt;- INT           #d[u]: u到源点s的距离</div><div class=\"line\">        f[u] &lt;- Null          #f[u]: u的父顶点</div><div class=\"line\">color[s] &lt;- gray</div><div class=\"line\">d[s] &lt;- i</div><div class=\"line\">f[s] &lt;- Null</div><div class=\"line\">Q &lt;- Empty                     #Q:先进先出队列</div><div class=\"line\">Enqueue(Q, s)</div><div class=\"line\">while Q != Empty</div><div class=\"line\">    do u &lt;- Dequeu(Q)</div><div class=\"line\">    for each v in Adj[u]</div><div class=\"line\">        do if color[u] = white</div><div class=\"line\">            then color[u] &lt;- gray</div><div class=\"line\">            d[v] &lt;- d[u] + 1</div><div class=\"line\">            f[v] &lt;- u</div><div class=\"line\">            Enqueue(Q, v)</div><div class=\"line\">    color[u] &lt;- black</div></pre></td></tr></table></figure></p>\n<p>算法过程如图3<br><img src=\"/images/bfs.png\" alt=\"BFS\"></p>\n<p>BFS分析:<br>采用part4学习的聚集分析(aggregate analysis), 通过color数组的染色标记,确保每个顶点v只Enqueue一次,故亦只Dequeue一次.Enqueue和Dequeue要求 $O(1)$ 的时间,故队列操作时间为 $O(V)$.又有每个顶点v出队时扫描其邻接表Adj[v], 所以每个顶点邻接表只遍历一次, 花费时间为 $O(E)$. 故总运行时间为 $O(V + E)$.</p>\n<p><strong>将BFS理解为同心圆扩展算法, 想象图G为一片水面, 源点s就是我们扔进石子的点, 激出的波纹沿半径方向延伸,圆圈向外扩展的过程即是遍历水面的过程</strong>.在这个过程中,BFS构造了一棵广度优先搜索树,包括s的所有<strong>可达</strong>顶点.对从s可达的任意顶点v,广度优先树中s到v的路径对应于图G中s到v的一条最短路径(边数最少).从BFS的算法中的数组f[u]可以用前驱图子图 $G_f = (V_f, E_f)$ 表示图G = (V, E)的广度优先树:<br>\\begin{align}<br>V_f = {v \\in V: f[v] \\neq Null } \\bigcup {s} \\\\<br>E_f = {(f[v], v): v \\in V_f - {s} }<br>\\end{align}</p>\n<p>根据BFS算法用递归输出s到v的最短路径如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">print-path(G, s, v)</div><div class=\"line\">if v == s</div><div class=\"line\">    then print s</div><div class=\"line\">    else if f[v] = Null</div><div class=\"line\">        then print &quot;no path from&quot; s &quot;to&quot; v &quot;exists&quot;</div><div class=\"line\">        else print-path(G, s, f[v])</div><div class=\"line\">            print v</div></pre></td></tr></table></figure></p>\n<h3 id=\"深度优先搜索-depth-first-search\"><a href=\"#深度优先搜索-depth-first-search\" class=\"headerlink\" title=\"深度优先搜索(depth-first search)\"></a>深度优先搜索(depth-first search)</h3><p>DFS思路:对新遍历的顶点u, 如果还有以u为起点而未遍历的边,沿此边继续遍历.如果u的所有边都已遍历,则回溯到发现顶点u有起始点的顶点边.制止发现所有顶点为止.可以发现DFS按深度为策略进行遍历.<br>DFS实现如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">DFS(G)</div><div class=\"line\">for each vertex u in V[G]</div><div class=\"line\">    do color[u] &lt;- white</div><div class=\"line\">        f[u] &lt;- Null</div><div class=\"line\">time &lt;- 0                       #全局计时器, 确定完成时间f[v]</div><div class=\"line\">for each vertex u in V[G]</div><div class=\"line\">    do if colo[u] = white</div><div class=\"line\">    then DFS-visit[u]</div><div class=\"line\"></div><div class=\"line\">DFS-visit(u)</div><div class=\"line\">colo[u] &lt;- gray</div><div class=\"line\">d[u] &lt;- time + 1</div><div class=\"line\">d[u] &lt;- time</div><div class=\"line\">for each v in Adj[u]</div><div class=\"line\">    do if color[v]  = white</div><div class=\"line\">        then f[v] &lt;- u</div><div class=\"line\">        DFS-visit(v)</div><div class=\"line\">color[u] &lt;- black</div><div class=\"line\">f[u] &lt;- time &lt;- time + 1</div></pre></td></tr></table></figure></p>\n<p>DFS可视化如图4<br><img src=\"/images/dfs.png\" alt=\"dfs\"></p>\n<p>DFS分析: 仍然采用聚集分析, 每个顶点的邻接表被遍历一次, 要求 $O(V)$.对每个顶点u, 过程DFS-visit仅被调用一次,即只对未遍历的顶点调用该过程.在DFS-visit(v)的一次执行中,遍历的标记过程被执行|Adj[v]|次,且有:<br>$$  \\sum_{v \\in V}|Adj[v]| = O(E) $$<br>故DFS的总运行时间为 $O(V + E)$.</p>\n<p>DFS创建一个深度优先森林外,深度优先搜索同时为每个顶点加盖时间戳.每个顶点 v 有两个时间戳:当顶点 v 第一次被发现时,记录下第一个时间戳 d[v],当结束检查 v 的邻接表时,记录下第二个时间戳 f[v].许多基于深度优先搜索的图算法都用到了时间戳,它们对推算深度优先搜索的时行情况有很大的帮助.</p>\n<h4 id=\"拓扑排序-Topological-sort\"><a href=\"#拓扑排序-Topological-sort\" class=\"headerlink\" title=\"拓扑排序 Topological sort\"></a>拓扑排序 Topological sort</h4><p>对一个有向无环图(Directed Acyclic Graph简称DAG)G进行拓扑排序,是将G中所有顶点排成一个线性序列,使得图中任意一对顶点u和v,若边 $(u,v) \\in E[G]$,则u在线性序列中出现在v之前.通常,这样的线性序列称为满足拓扑次序(Topological Order)的序列,简称拓扑序列.拓扑排序运用在在顶点活动网(Activity On Vertex network,简称AOV网)中,确定活动先后的发生顺序.</p>\n<p>一个dag的拓扑排序可以理解为图中所有顶点沿水平线排列而成的一个序列.下面是一个典型的活动安排例子:<br><img src=\"/images/dag.png\" alt=\"dag\"></p>\n<p>一般由AOV网构造拓扑序列的拓扑排序算法主要是循环执行以下两步,直到不存在入度为0的顶点为止.</p>\n<ul>\n<li>选择一个入度为0的顶点并输出之；</li>\n<li>从网中删除此顶点及所有出边.<br>循环结束后,若输出的顶点数小于网中的顶点数,则输出“有回路”信息,否则输出的顶点序列就是一种拓扑序列.</li>\n</ul>\n<p>而在算法导论中运用全局的计时器time,巧妙的实现拓扑排序.通过深度遍历来确定时间完成的时间,按时间顺序自然构造拓扑序列,而无需根据BFS遍历来删除边.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">topoligical-sort(G)</div><div class=\"line\">call DFS(G) to compute finishing times f[v] for each vertex v</div><div class=\"line\">as each vete is finished, insert it onto the front of a linked list</div><div class=\"line\">return the linked list of vertices</div></pre></td></tr></table></figure></p>\n<h4 id=\"强连通分支\"><a href=\"#强连通分支\" class=\"headerlink\" title=\"强连通分支\"></a>强连通分支</h4><p>强连通分支(strongly connected component):有向图G=(V,E)的一个最大顶点集合 $C \\subseteq V$, 对C中任意一堆对顶点u, v, 它们是互相可达的.</p>\n<p>寻找SCC的思路: 定义图G的转置:<br>$$ G^T = (V, E^T), E^T = {(u, v):(v, u) \\in E} $$<br>对分支图 $G^{SCC} = (V^{SCC}, E^{SCC})$,假设G的强连通分支为 $[C_1, C_2, \\dots, C_k]$.顶点集 $V^{SCC} = {v_1, v_2, \\dots, v_k }$,对于G的每一个强连通分支 $C_i$,它都包含一个顶点 $v_i$.如果对某个 $x \\in C_i$ 以及 $y \\in C_i$, G中包含有向边(x, y), 则有一条边 $(v_i,v_j) \\in E^{SCC}$. 因此收缩其关联的顶点都处于G的同一强连通分支内的边,即可得到图 $G^{SCC}$. 对应的 $G^{SCC}$是一个有向无环图(dag);<br><img src=\"/images/scc.png\" alt=\"scc\"></p>\n<blockquote>\n<ol>\n<li>对G进行深度优先遍历得到每个顶点的时间戳 f[x];</li>\n<li>求得G的返回图 $G^T$;</li>\n<li>按照f[x]的逆向顺序为顶点顺序对$G^T$进行深度优先遍历,即按照G的拓扑排序的顺序对 $G^T$再进行深度优先遍历;<br>步骤3得到的各棵子树就是原图 G的各强连通分支.<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">strongly-connnected-component(G)</div><div class=\"line\">call DFS(G) to compute finishing times f[u] for each vertex u</div><div class=\"line\">compute GT</div><div class=\"line\">call DFS(GT). but in the main loop of DFS, consider the vertices in order of decreasing f[u](as computed in line 1)</div><div class=\"line\">output the vertices of each tree in the depth-first forest formed in line 3 as a separate strongly connected component</div></pre></td></tr></table></figure>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"Chapter23-最小生成树-Minimum-Spanning-Trees\"><a href=\"#Chapter23-最小生成树-Minimum-Spanning-Trees\" class=\"headerlink\" title=\"Chapter23 最小生成树 Minimum Spanning Trees\"></a>Chapter23 最小生成树 Minimum Spanning Trees</h3><p>在生成树(spanning tree)T是指: T连接了G的所有顶点且无回路, 因此T必然是一棵树.其中特殊的一类T得到的树的权值最小, 为最小生成树.<br>采用贪心的思路,可以通过Kruskal算法和Prim算法有效的解决生成树问题.</p>\n<h4 id=\"最小生成树的策略\"><a href=\"#最小生成树的策略\" class=\"headerlink\" title=\"最小生成树的策略\"></a>最小生成树的策略</h4><p>最小(权值)生成树:由 n-1 条边,连接了所有的 n 个顶点,并且所有边上的权值和最小.一个典型实例如下:<br><img src=\"/images/mst.png\" alt=\"mst\"></p>\n<p>一个通用的贪心策略是,在每个步骤中都形成最小生成树的一条边,算法维护这个集合A, 并保持了以下循环不变式:<br>每次循环之前, A是最小生成树的一个子集.<br>在算法的每一步,确定一条边(u, v), 使得它加入集合A后, 循环不变式得以保持, 即 $A \\bigcup {(u, v) }$仍然是最小生成树的子集.这样的边(u, v)称为安全边(safe edge).描述如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">generic-mst(G, w)</div><div class=\"line\">A &lt;- Empty</div><div class=\"line\">while A does not form a spanning tree</div><div class=\"line\">    do find an edge(u, v) that is safe for A</div><div class=\"line\">        A &lt;- A union (u, v)</div><div class=\"line\">return A</div></pre></td></tr></table></figure></p>\n<h4 id=\"Kruskal算法\"><a href=\"#Kruskal算法\" class=\"headerlink\" title=\"Kruskal算法\"></a>Kruskal算法</h4><p>Kruskal算法直接基于通用贪心策略:找出森林中连接任意两棵树的所有边中,具有最小权值的边作为安全边,添加其到正在生长的森林中.即,集合A是一个森林,加入集合A中的安全边总是图中连接两个不同连通分支的最小权边.<br>通过part5高级数据结构中不相交集合可以很好的实现Kruskal算法.比较<code>find-set(u)</code>和<code>find-set(v)</code>是否等同,确定u和v是否属于同一棵树,通过<code>Union</code>实现树的合并.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">mst-kruskal(G, w)</div><div class=\"line\">A &lt;- Empty</div><div class=\"line\">for each vertex v in V[G]</div><div class=\"line\">    do make-set(v)</div><div class=\"line\">sort the edges of E into nondecreasing order by weight w</div><div class=\"line\">for each edge(u, v) in E, taken in nondecreasing order by weight</div><div class=\"line\">    do if find-set(u) != find-set(v)</div><div class=\"line\">        then A &lt;- A union (u, v)</div><div class=\"line\">            Union(u, v)</div><div class=\"line\">return A</div></pre></td></tr></table></figure></p>\n<p>算法可视化如下:<br><img src=\"/images/kruskal.png\" alt=\"kruskal\"></p>\n<p>Kruskal算法分析:<br>如果采用不相交数据集合中的按秩结合和路径压缩的策略,可以最高效的实现.初始化要求 $O(1)$, 对各条边排序需要 $O(E\\log E)$.对每一条边, 执行 $O(E)$ 次<code>find-set</code>和<code>union</code>操作, 加上|V|次<code>make-set</code>操作,要求的总时间为$O((V + E)\\alpha(V)$.假定G是连通的,则有 |E| &gt; |v| - 1, 因而不相交集合操作时间为 $O(E\\alpha(v))$. 又有 $\\alpha(|V|) = O(\\log V) = O(\\log E)$,故有总运行时间为 $O(E\\log E)$. 由于 $|E| &lt; |V| ^ 2$, 因而 $\\log |E| = O(\\log V)$, 即Kruskal总运行时间为 $O(E\\log V)$</p>\n<h4 id=\"Prim算法\"><a href=\"#Prim算法\" class=\"headerlink\" title=\"Prim算法\"></a>Prim算法</h4><p>Prim算法的贪心策略:集合A仅形成单棵树,添入集合A中的安全边总是连接树与一个不在树中的顶点的最小权边.树从任意根顶点r开始形成, 每一步里连接了树A与 $G_A=(V, A)$ 中某孤立顶点的轻边(最小权值边)加入到树A中, 直至包含了所有的顶点.如下图:<br><img src=\"/images/prim.png\" alt=\"prim\"></p>\n<p>Prim算法维护一个基于key域的最小优先级队列Q,其包含所有不在树A中的顶点.key[u]表示所有与u相连的树中顶点的边的最小权值.f[u]指向u的父节点.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">mst-prim(G, w, r)</div><div class=\"line\">for each u in V[G]</div><div class=\"line\">    do key[u] &lt;- INT</div><div class=\"line\">        f[u] &lt;- Null</div><div class=\"line\">key[r] &lt;- 0</div><div class=\"line\">Q &lt;- V[G]</div><div class=\"line\">while Q != Empty</div><div class=\"line\">    do u &lt;- extract-min(Q)</div><div class=\"line\">        for each v in Adj[u]</div><div class=\"line\">            do if v in Q and w(u, v) &lt; key[v]</div><div class=\"line\">                then f[u] &lt;- u</div><div class=\"line\">                    key[v] &lt;- w(u, v)</div></pre></td></tr></table></figure></p>\n<p>Prim算法分析:<br>Prim算法性能取决于优先队列Q的实现方案, 如果采用Part5学习的二叉堆实现:通过<code>build-min-heao</code>实现初始化, 需要 $O(V)$. <code>while</code>循环体执行|V|次, 每次调用<code>extract-min</code>需要 $O(\\log V)$, 故该循环占用时间 $O(V\\log V)$.<code>for</code>循环执行 $O(E)$ 次, 每次调用<code>decrease-key</code>实现对key的赋值要求 $O(\\log V)$.因此, Prim算法总的运行时间为 $O(V\\log V + E\\log V) = O(E\\log V)$.从渐进意义上来说, Prim算法和Kruskal算法运行时间相同.<br>如果改进为斐波那契堆, 在Chapter20得到,|V|个元素组成的斐波那契堆,可以在 $O(\\log Ｖ)$ 的平摊时间内完成<code>extract-min</code>操作．则Prim算法运行时间可以改进为 $O(E + V\\log Ｖ)$.</p>\n<h4 id=\"对比\"><a href=\"#对比\" class=\"headerlink\" title=\"对比\"></a>对比</h4><p>Prim算法有着更好的实际效率:</p>\n<blockquote>\n<ol>\n<li>Prim算法在执行的过程中,将不在树中的所有顶点都放在一个基于key域的最小优先队列Q中;</li>\n<li>每次在选取安全边时,只需要从Q中弹出最小key值的顶点即可,而不需要像 Kruskal 一样为对所有的边的权值进行一次排序;</li>\n<li>Prim 算法使用了用于快速或者最小权值边的技巧(二叉堆、二项堆、斐波那契堆)来加速算法的运行.在最朴素的选取安全边的算法中,需要遍历剩下的所有的边,所需要的时间复杂度为 $O(EV)$,而采用堆来优化后只需要 $O(E\\log V)$ ,大大地改善了算法的执行时间(堆的好处).</li>\n</ol>\n</blockquote>\n<p>不过Kruskal算法实现相对简单,所以对于一般的应用Kruskal算法也是可以的．</p>\n<h3 id=\"Chapter24-如何在地图中选择最短的路径\"><a href=\"#Chapter24-如何在地图中选择最短的路径\" class=\"headerlink\" title=\"Chapter24 如何在地图中选择最短的路径?\"></a>Chapter24 如何在地图中选择最短的路径?</h3><p>考虑一个实际问题:在地图上选出从北京到上海的最短距离.直接的想法是北京和上海两点之间的直线, 但实际不可能存在这条路, 北京和上海是通过之间一个个城市中转的.城市抽象为顶点, 城市之间的道路抽象为边,道路里程为权值,则北京到上海的最短路径问题转化为图中的单源最短路径问题.本章即是学习在图中解决最短路径问题的算法</p>\n<h4 id=\"最短路径\"><a href=\"#最短路径\" class=\"headerlink\" title=\"最短路径\"></a>最短路径</h4><p>定义<br>给定带权有向图G = (V, E),加权函数 $w: E \\to R$从边到实数的映射.<br>路径 $p = {v_0, v_1, \\dots, v_k}$的权为组成边的所有权值之和:<br>$$ w(p) = \\sum_{i=1}^k w(v_{i-1}, v_i) $$<br>u到v的最短路径的权为:<br>$$<br>\\delta(u, v) =<br>\\begin{cases}<br>min{w(p): u \\to v }, \\text {if path(u, v) exists} \\\\<br>\\infty, else \\\\<br>\\end{cases}<br>$$<br>对应的最短路径为权 $w(p) = \\delta(u, v)$的任何路径.</p>\n<p>注:权值是一种度量标准, 不限于距离, 还可以是时间/费用/损失.</p>\n<p>问题变体</p>\n<ul>\n<li>单终点最短路: 每个顶点v到终点t的最短路, 即将单源最短路问题反向即可</li>\n<li>单对顶点最短路: 给定顶点u和v的最短路,u单源最短路的问题选择终点v即可</li>\n<li>全源最短路: 找出所有顶点之间的最短路径.</li>\n</ul>\n<p>问题分析<br>1.最优子结构<br><strong>最短路径的子路径是最短路径.</strong><br>$$\\begin{align}<br>设路径p = &lt; v_0, v_1, \\dots, v_k &gt;是v_0到v_k的最短路径,\\<br>则对 \\forall i, j, 1 \\leq i \\leq j \\leq k \\<br>路径p_{ij} = &lt; v_i, v_{i+1}, \\dots, v_j&gt;是 v_i到v_j的最短路径 \\<br>\\end{align}<br>$$</p>\n<p>2.负权值边<br>如果问题中存在负权值边, 但不包含<strong>负权值回路</strong>,则最短路径的定义仍然是正确的.但一旦存在负权值回路, 则不存在最短路径,因为通过不断穿过负权值回路可以得到更小权值的边.<br><img src=\"/images/n-path.png\" alt=\"negative path\"></p>\n<p>3.回路<br>除去负权值回路, 最短路径亦不能包含正权值回路.因为从路径上一出回路后,可以得到源点/终点相同,权值更小的路径.</p>\n<p>4.求解路径<br>最短路径问题中我们不仅想得到最短路径的权,也想得到最短路径是什么.通过类似广度优先搜索树的表示方法,设置顶点v的前驱f[v], 形成最短路径树.然后调用<code>print-path(G, s, v)</code>来递归的输出最短路径即可.<br><img src=\"/images/mst-path.png\" alt=\"mst-path\"></p>\n<p>5.<strong>松弛技术 relaxation</strong><br>对顶点 $ v \\in V$, 设置d[v]描述源点s到v的最短路径权值的上界,初始化如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">initialize-single-source(G, s)</div><div class=\"line\">for each vertex v in V[G]</div><div class=\"line\">    do d[v] &lt;- INT</div><div class=\"line\">        f[v] &lt;- Null</div><div class=\"line\">d[s] &lt;- 0</div></pre></td></tr></table></figure></p>\n<p>松弛操作指, 通过顶点u, 对迄今找到的v的最短路径改进的过程:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">relax(u, v, w)</div><div class=\"line\">if d[v] &gt; d[u] + w(u, v)</div><div class=\"line\">    then d[v] &lt;- d[u] + w(u, v)</div><div class=\"line\">        f[v] &lt;- u</div></pre></td></tr></table></figure></p>\n<p>松弛是最短路径的核心操作, 其是改变最短路径和前驱的唯一方式.本章的算法的区别主要就在对每条边的松弛操作的次数和顺序有所不同.Dijkstra算法对每条边执行一次松弛, 而在Bellman-Ford中执行多次.</p>\n<h4 id=\"Bellman-Ford算法\"><a href=\"#Bellman-Ford算法\" class=\"headerlink\" title=\"Bellman-Ford算法\"></a>Bellman-Ford算法</h4><p>Bellman-Ford算法运用松弛技术, 对每个顶点, 逐步减小源s到v的最短路径的估计值d[v]直到达到实际最短路径的权.算法返回布尔值,表明图中是否存在从源点可达的负权值回路.实现如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">bellman-ford(G, w, s)</div><div class=\"line\">initialize-single-source(G, s)</div><div class=\"line\">for i &lt;- 1 to |V[G]| - 1</div><div class=\"line\">    do for each edge (u, v) in E[G]</div><div class=\"line\">        do relax(u, v, w)</div><div class=\"line\">for each edge(u, v) in E[G]</div><div class=\"line\">    do if d[v] &gt; d[u] + w(u, v)</div><div class=\"line\">        then return false</div><div class=\"line\">return true</div></pre></td></tr></table></figure></p>\n<p>可视化如下:<br><img src=\"/images/bellman-ford.png\" alt=\"bellman-ford\"></p>\n<p>算法分析:<br>初始化需要 $O(V)$, 松弛操作的循环共|V| - 1轮, 每轮运行时间为 $O(E)$.检验是否存在负权值回路需要 $O(E)$.故bellman-ford算法的总运行时间为 $O(EV)$.</p>\n<h4 id=\"有向无环图dag中的单源最短路径\"><a href=\"#有向无环图dag中的单源最短路径\" class=\"headerlink\" title=\"有向无环图dag中的单源最短路径\"></a>有向无环图dag中的单源最短路径</h4><p>按顶点的拓扑顺序对某加权有向无回路图的边进行松弛后, 因为如果存在path(u,v),则拓扑序列中u在v之前.所以在遍历每个顶点时, 只需松弛从该点出发的所有边即可.因此,可以在 $O(V+E)$ 时间内计算出单源最短路径.在一个有向无回路图中最短路径总是存在的,因为即使图中有权值为负的边,也不可能存在负权回路(因为它根本没有任何回路).<br>实现如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">dag-shortest-path(G, w, s)</div><div class=\"line\">topoligically sort the vertices of G</div><div class=\"line\">initialize-single-source(G, s)</div><div class=\"line\">for each vertex u, taken in topoligically sorted order</div><div class=\"line\">    do for each vertex v in Adj[u]</div><div class=\"line\">        do relax(u, v, w)</div></pre></td></tr></table></figure></p>\n<p>可视化如下:<br><img src=\"/images/dag-path.png\" alt=\"dag-path\"></p>\n<h4 id=\"Dijkstra算法\"><a href=\"#Dijkstra算法\" class=\"headerlink\" title=\"Dijkstra算法\"></a>Dijkstra算法</h4><p>Dijkstra算法中设置顶点集合S, 从源点s到集合中顶点的最终最短路径的权值都已确定.其反复选择具有最短路径估计的顶点 $u \\in V-S$, 并将u将入S中, 对u的所有出边进行松弛.其中使用了优先级队列Q,来优化顶点d值的选取过程.<br>实现如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">dijkstra(G, w, s)</div><div class=\"line\">initialize-single-source(G, s)</div><div class=\"line\">s &lt;- Empty</div><div class=\"line\">Q &lt;- V[G]</div><div class=\"line\">while Q != Empty</div><div class=\"line\">    do u &lt;- extract-min(Q)</div><div class=\"line\">        s &lt;- s union &#123;u&#125;</div><div class=\"line\">        for each vertex v in Adj[u]</div><div class=\"line\">            do relax(u, v, w)</div></pre></td></tr></table></figure></p>\n<p>可视化如下:<br><img src=\"/images/dijkstra.png\" alt=\"dijkstra\"></p>\n<p>算法分析<br>dijkstra算法同样依赖优先队列Q的具体实现. 初始化Q调用<code>insert</code>方法 $O(1)$, 每个顶点调用一次, 需要 $O(V)$;for循环共有|E|迭代, 即至多|E|次调用<code>decrease-key</code> $O(1)$,共 $O(E)$.又有每个顶点只加入集合S一次, 故调用<code>extract-min</code> $O(v)$ 共|V|次, 于是dijkstra的总的运行时间为 $O(V^2 + E) = O(V^2)$.<br>如果采用斐波那契堆实现优先级队列, 因为|V|个<code>extract-min</code>的平摊代价为 $O(\\log V)$, 至多|E|个<code>decrease-key</code>操作的每个的平摊代价为 $O(1)$.使得dijkstra算法可以优化到 $O(V\\log V + E)$.</p>"},{"title":"introduction to algorithms notes6","date":"2017-05-17T16:00:00.000Z","_content":"\n# ＜Introduction to algorithms＞笔记\n\n## Part7 高级算法问题\n在part1-6学习基本的数据结构和算法问题后, part7不再集中于对一个算法问题专题进行学习, 而是就不同的高级算法问题进行基本的介绍,其其覆盖的内容十分全面,涉及一下几个领域:\n* 排序网络\n* 矩阵运算\n* 线性规划\n* 字符串匹配\n\n### Chapter26 如何利用多核来并行排序?\n在part2中学习了基本的排序算法,包括插入,快排,归并,堆排序等,它们都是在串行计算机上线性执行的算法.随着硬件的发展,多处理器的进步,如何利用多核来进行并行排序?如何推而广之到多核并行算法?这一章就套路基于计算的一种比较网络模型,同时进行多个比较操作.\n\n比较网络与串行排序算法的区别:\n* 比较网络只能执行比较操作, 即只能执行基于比较操作的算法.因此part2中学习的计数排序就无法再比较网络中实现\n* 比较网络中比较操作可以并行的执行, 而串行排序算法各操作是依次执行的.故前者拥有更好的算法效率- 更小的算法复杂度\n\n1.比较网络定义\n* 组成：\n基本构件:线路和比较器\n![comparsion](/images/comparsion.png)\n\n<!-- more -->\n\n* 比较网络含义：\n* 一个由线路互相联接着的比较器的集合,我们把具有n个输入的比较网络画成一个由n条水平线组成的图,比较器则垂直地与两条水平线相连接.每个比较器的输入端要么与网络的n条输入线路 $a\\_1,a\\_2, \\dots, a\\_n$ 中的一条相连,要么与另一个比较器的输出端相连接.类似地,每个比较器的输出端要么与网络的n条输出线路 $b\\_1,b\\_2, \\dots, b\\_n$中的一条相连,要么与另一个比较器的输入端相连接.互相连接的比较器主要应满足如下要求：\n> 1. 其互相连接所成的图中必须没有回路.\n> 2. 只有当同时有两个输入时,比较器才能产生输出值.\n\n在每个比较器均运行单位时间的假设下,我们可以对比较网络的“运行时间”作出定义,这就是从输入线路接收到其值的时刻到所有输出线路收到其值所花费的时间.\n\n* 比较网络示意图:\n![sortnet](/images/sortnet.png)\n\n* 排序网络定义:\n对每个输入序列其输出序列均为单调递增(即 $b\\_1 \\leq\n b\\_2, \\dots, b\\_n$ )的一种比较网络\n\n* 0-1原理：\n如果一个具有n个输入的比较网络,能够对所有可能存在的2^n个0和1组成的序列进行正确的排序,则对所有任意数组成的序列,该比较网络也可能对其正确排序.\n0-1原理推定认为：如果对于属于集合{0,1}的每个输入值,排序网络都能正确运行,则对任意输入值,它也能争取而运行(输入值可以是整数、实数或者任意线性排序的值的集合).这样在构造排序网络时,可以专注在0和1组成的输入序列上设计比较器.这个原理目的是简化输入值,而通过0和1来设计比较网络的线路和比较器,只要0和1可运行,那么其他任意值的序列也都可以运行.\n0-1原理的证明依赖单调递增函数.如果比较网络把输入序列 $a=<a\\_1,a\\_2, \\dots, a\\_n>$ 转化为输出序列 $b=<b\\_1,b\\_2, \\dots, b\\_n>$,则对任意单调递增函数f,该网络把输入序列f(a)=<f(a1),f(a2),…,f(an)>转化为输出序列f(b)=<f(b1),f(b2),…,f(bn)>.\n这个可以这样理解,对输入序列a施以f(a)单调递增函数,比较网络(线路和比较器)能够使序列a输出序列b,那么该比较网络同样可以使输入序列f(a)输出序列f(b).\n这就为0-1原理奠定了基础,只要证明比较网络可以运行于0和1的输入,那么设计一个单调递增函数,0和1是因变量,其自变量自然也可以通过同样比较网络来排序.\n如果一个具有n个输入的比较网络能够对所有可能存在的2n个0和1组成的序列进行正确的排序,则对所有任意数组成的序列,该比较网络也可能对其正确排序.\n0-1原理证明用到了单调递增函数概念,同时采用数学归纳法和反证法来证明.这也给出了一个很重要的思想,那就是对现实问题的解决,在构建数学模型时,可以简单到0-1,然后再推广到复杂数.\n\n* 双调序列：\n序列要么先单调递增然后再单调递减,要么先单调递减然后又单调递增.例如序列<1,4,6,8,3,2>和<9,8,3,2,4,6>都是双调的\n\n\n2.双调排序网络\n* 双调排序程序由 $log\\_2n$个阶段组成,其中每一个阶段称为一个半清洁器.每个半清洁器是一个深度为1的比较网络,其中输入线I与输入线I+n/2进行比较,I=1,2,…,n/2(这里假设n为偶数).下图即为一个具有8个输入和8个输出的半清洁器(half-cleaner)\n![half-cleaner](/images/half-cleaner.png)\n\n* 当由0和1组成的双调序列用作半清洁器的输入时,半清洁器产生的输出序列满足如下条件：\n> 1. 较小的值位于输出的上半部,较大的值位于输出的下半部.\n> 2. 两部分序列仍是双调的.\n> 3. 两部分序列中至少有一个是清洁的——全由0或1组成.\n\n* 双调排序器(bitonic-sorter)\n通过递归地连接半清洁器,我们可以建立一个双调排序网络.双调排序网络[n]的第一阶段由半清洁器[n]组成,可知半清洁器[n]产生两个规模缩小一半的双调序列且满足上半部分的每个元素不比下半部分的任一个元素大.因此,我们可以运用两个双调排序网络[n/2]分别对两部分递归地进行排序,以此完成整个排序工作\n![bitonic-sorter](/images/bitonic-sorter.png)\n\n我们只要把含n个元素的双调排序网络的第一个半清洁器修改一下就可以得到合并网络MERGER[n].由于输入的上半部和下半部都是单调递增的,所以我们把比较网络的下半部分颠倒一下,输入就成了一个双调序列.添上半清洁器,再颠倒回去,半清洁器就变成了把输入 $a\\_i$和$a\\_{n-i+1}比较.这时,输出也被颠倒了.但是,一个双调序列颠倒了以后还是一个双调序列.\n因此就可以用*bitonic-sorter*对深度为 $\\log n$ 的0-1双调序列进行排序.\n![bitonic-sorter2](/images/bitonic-sorter2.png)\n\n3.合并网络(mergin network)\n合并网络,能够把两个已排序的输入序列合并为一个有序的输出序列的网络.基于双调排序网络思想,对已知的两个有序序列进行连接(第二个序列顺序颠倒),所得的序列是双调序列,再利用双调排序器就能完成两个有序序列的合并.其原理如下:\n![merger1](/images/merger1.png)\n![merger2](/images/merger2.png)\n\n4.基于0-1原理、双调排序网络、合并网络,我们可以构造一个输入任意序列进行排序的比较排序网络.思想很简单：第一步开展最基础的2个元素的两两比较,这个用普通的比较器就可以实现,输出长度为2的有序序列;第二步对长度为2的有序序列进行两两合并,这个用合并网络排序(基于双调排序器,先连接序列构造双调序列)实现,输出长度为4的有序序列;第三步对长度为4的有序序列进行合并网络,直到 $\\log n$次.算法上,可以在 $O(\\log n)$内并行地对n个数进行排序.\n![sorter](/images/sorter.png)\n\n总结:排序网络可以并行地进行排序,然后再组合各并行排序结果,适合分布式场景的排序需求.\n\n### Chapter27 矩阵运算\n在part4高级设计技术中在动态规划中研究了矩阵链乘法问题后, 这一章深入学习矩阵运算, 特别学习矩阵相乘的Strasssen算法,该算法能在 $O(n^{\\log 7})$ 的时间内计算两个 $n*n$ 的矩阵的乘积.\n\n1.首先重温下矩阵的相关概念和性质,为后续矩阵运算奠定数据理论基础.\n\n矩阵A：\n数字的一个矩形阵列,形式化为 $A=(a\\_{ij})$,第i行j列元素为 $a\\_ij$,如元素为实数的所有元素mXn矩阵组合的元素用 $R\\_{mXn}$表示.\n![matrix](/images/matrix.png)\n\n矩阵转置AT：是矩阵A的行和列互相交换而产生的矩阵.\n\n向量(Vector)：是数字的一维向量,列向量看成是nX1的矩阵,转置成行向量就是1Xn的矩阵.\n\n单位向量$e\\_i$：矩阵第一个元素为1而其他元素均为0的常量.\n\n零矩阵：所有元素都是0的矩阵.\n\n对角矩阵：当i≠j时,$a\\_ij$,所有非对角线上的元素均为0.\n\nnXn单位矩阵 $I\\_n$：是对角线元素都是1的对角矩阵.\n\n三对角矩阵T：满足 $|i-j|>1$ 的元素 $t\\_ij$=0的矩阵,非零元素仅出现在主对角线上、靠主对角线上面和对角线下面.\n\n上三角矩阵U：满足i>j的元素 $U\\_ij=0$的矩阵,对角线下面的所有元素均为0,若对角线元素为1,则是单位上三角矩阵.\n\n下三角矩阵L：满足i<j的元素 $L\\_ij=0$的矩阵,对角线上面的所有元素均为0,若对角线元素为1,则是单位下三角矩阵.\n\n置换矩阵P：每一行或列中仅包含一个1,其他元素都为0,可以把一个向量x和一个置换矩阵相乘,结果是向量x中的元素的一种置换.\n\n对称矩阵A：满足条件 $A= A^T$.\n\n矩阵加法：$C(c\\_ij)=A(a\\_ij)+B(b\\_ij),c\\_ij=a\\_ij+b\\_ij$,都是mXn矩阵.\n\n矩阵乘法：相容(A的列数等于B的行数)的两个矩阵才可以相乘,$C(c\\_ij)= \\sum\\_{k=1}^{m} A(a\\_ik)*B(b\\_kj)$,矩阵和单位矩阵等于自己、和零矩阵相乘等于零、和向量相乘得到向量,满足结合律和分配律,但不满足交换律.\n\n逆矩阵A-1：满足 $A A^{-1} = I\\_n= A^{-1}A$,不可逆的矩阵称为奇异矩阵.\n\n线性相关：设 $x\\_1,x\\_2, \\dots, x\\_n$是n个向量,若存在不全为零的常系数 $c\\_1,c\\_2, \\dots, c\\_n$,使 $c\\_1x\\_1+c\\_2x\\_2+ \\dots +c\\_nx\\_n=0$成立,就称 $x\\_1,x\\_2, \\dots, x\\_n$线性相关.\n\n非零mXn矩阵A的秩：A的极大线性无关列向量组中向量的个数为列秩,A的极大线性无关行向量组中向量的个数为列秩.任意一个矩阵的行秩和列秩都是相等.mXn的秩是0和min(m,n)之间的一个整数.\n\n非零mXn矩阵A的秩满足下列条件的最小的数r：存在mXr矩阵B和rXn矩阵C且有A=BC.如果一个nXn的矩阵秩为n,则是满秩,如果一个mXn矩阵的秩为n,则是列满秩.\n一个方阵满秩当且仅当它为非奇异矩阵.当前仅当A无空向量时,矩阵A为列满秩.\n当且仅当A具有空向量时,方阵A是奇异的.\n\n余子式：对于n>1,nXn矩阵A的第ij个余子式是把A的第i行和第j列元素去掉后所形成的一个(n-1)X(n-1)矩阵A[ij],表示为det(A[ij]).\n\n方阵A的行列式具有如下性质：如果A的任何行或列的元素为0,则det(A)=0;用常如a乘A的行列式任意一行(或任意一列)的诸元素,等于用a乘A的行列式;A的行列式中的一行(或一列)元素加上另一行(或另一列)中的相应元素,行列式的值不变;A的行列式值与其转置矩阵AT的行列式的值相等;行列式的任意两行(或两列)互换,则其值异号.\n\n正定矩阵：nXn矩阵A,如果对所有n维向量x≠0都有$x^TAx>0$,则矩阵A为正定矩阵.\n\n对任意列满秩矩阵A,矩阵$A^TA$是正定的.\n\n2.矩阵乘法的Strassen算法\n矩阵乘法是种极其耗时的运算.以C = AB为例,其中A和B都是 n x n 的矩阵.根据矩阵乘法的定义,计算过程如下：\n```\nSQUARE-MATRIX-MULTIPLY(A, B)\nn = A.rows\nlet C be a new nxn matrix\nfor i = 1 to n\n    for j = 1 to n\n        c[i][j] = 0\n        for k = 1 to n\n            c[i][j] += a[i][k] * b[k][j]\nreturn C\n```\n由于存在三层循环,它的时间复杂度将达到 $O(n^3)$.\nStrassen算法运用分治法将两个nXn的矩阵乘积运行时间,从简易矩阵乘法算法 $O(n^3)$提升到 $O(n^{\\log 7}) = O(n^{2.81})$.下面是算法的主要思想和步骤.\n\n> 一般情况下,矩阵乘积C=AB,其中A、B和C都是nXn方阵,假定n是2的幂,把A、B和C划分成四个n/2Xn/2矩阵：\n![matrix2](/images/matrix.png)\n则矩阵乘法对应四个等式：\n```\nr=ae+bg\ns=af+bh\nt=ce+dg\nu=cf+dh\n```\n> 每个等式运行包含两次 $n/2 * n/2$矩阵乘法和两次乘积所得的 $n/2 * n/2$矩阵的加法运算,推出 $n * n$ 矩阵相乘所需时间T(n)的递归式：\n$$T(n)=8T(n/2)+  O(n^2)$$\n\nStrassen算法在这个一般性的递归式上,发现只需要进行7次 $n/2 * n/2$矩阵乘法即可解决,即\n$$T(n)=7T(n/2)+O(n^2)= O(n^{\\log 7}) = O(n^{2.81})$$\n具体算法步骤如下：\n\n* 1.输入矩阵A和B划分为 $n/2 * n/2$的子矩阵;\n* 2.运行 $O(n^2)$标量加法和减法运算,计算出14个 $n/2 * n/2$的矩阵 $A\\_1,B\\_1,A\\_2,B\\_2, \\dots, A\\_7,B\\_7$;\n* 3.递归计算出7个矩阵的乘积 $P\\_i=A\\_i * B\\_i,i=1,2, \\dots, 7$;\n* 4.使用 $O(n^2)$ 次标量加法与减法运算,对 $P\\_i$ 矩阵的各种组合进行求和或求差运算,从而获得结果矩阵C的四个子矩阵r\\s\\t\\u.\n\nStrassen算法的核心思想是什么呢？何以产生如此一个步骤的算法呢？依据是什么？\n设想每个矩阵的积 $P\\_i$可以写成如下形式：\n $$P\\_i=A\\_iB\\_i=(α\\_{i1}a+α\\_{i2}b+α\\_{i3}c+α\\_{i4}d)( β\\_{i1}e+β\\_{i2}f+β\\_{i3}g+β\\_{i4}h)$$\n 其中系数α和β都属于集合{-1,0,1},就是说,对矩阵A和B的子矩阵进行加减运算,并对所得的结果进行相乘法来计算出每个子矩阵的乘积.简单说,将子矩阵的乘法运算变成加减运算,从而将8次乘法减少到7次.这是Strassen算法的核心思想和依据.\n\n上面给出的描述很好理解算法的思路和步骤.正如算法导论中对该算法的讨论中所指出的问题,对于矩阵乘法的困难(多项式时间内完成的算法)是合理的.Strassen算法并不是最佳,但目前并没有更多的突破.\n\n2.求解线性方程组(LUP分解思想)\n求解一组同时成立的线性方程式在很多应用中都会出现,也是线性代数的基本问题.可以将一个线性系统表示为一个矩阵方程,其中每个矩阵或向量元素都属于一个域,如实数域R.\nn个未知量的n个方程用矩阵表示如下：\n![matrix3](/images/matrix.png)\n设 $A=(a\\_{ij}),x=(x\\_i),b=(b\\_i)$,有Ax=b.\n\n如果A是非奇异矩阵(秩为n),存在逆矩阵 $A^{-1}$,则 $x= A^{-1}b$,且x是唯一解.方程数目少于未知量数目(或A的秩小于n)为不定方程组,具有无穷多解,如果方程组不相容则可能无解;方程数目多于未知量数目为超定方程组,可能无解.\nLUP分解在求解线性方程组具有数值稳定和速度快的优点.**LUP分解的思想就是找出三个n*n矩阵L、U和P,满足PA=LU,其中L是一个单位下三角矩阵、U是一个上三角矩阵、P是一个置换矩阵.**\n\n定义y=Ux,其中x是要求解的未知向量.用正向替换($O(n^2)$)方法求解Ly=Pb,在用逆向替换($O(n^2)$)方法求解Ux=y,可得：\n\n$$Ax = P^{-1}LUx = P^{-1}Ly = P^{-1}Pb=b$$\n\n问题是如何有效找出LUP呢？只要找出LUP就可以通过正向替换和逆向替换求解x.\n\nLU分解是采用高斯消元法.首先考虑A是nXn的非奇异矩阵,且P等价于$I\\_n$,找出A=LU,矩阵L和U称为A的LU分解.基于LU分解基础上开展LUP分解,数学基础一致,不失一般性而已,增加对置换矩阵P中值为1的元素的刻画.最重要还是要对矩阵运算和高斯消元法的数据基础有初步掌握.LUP分解如下\n```\nlu-decomposition(A)\nn <- rows[A]\nfor k <- 1 to n\n    do u{kk} <- a{kk}\n        for i <- k + 1 to n\n            do l{ik} <- a{ik}/u{kk}\n                u{ki} <- a{ki}\n        for i <- k + 1 to n\n            do for j <- k + 1 to n\n                do a{ij} <- a{ij} - l{ik}u{kj}\nreturn L and U\n```\nLU分解执行过程如下:\n![lu](/images/lu.png)\n\n总结:基于LUP分解矩阵求解线性方程组的方法,同样适用于非奇异矩阵的求逆.矩阵乘法和计算逆矩阵问题具有相同难度的两个问题,在一定技术条件限制下可以使用一个算法在相同渐进时间内解决另外一个问题,即可用Strassen矩阵乘法算法来求一个矩阵的逆.\n\n### Chapter28 线性规划\n怎么样问题可以建模为线性规划来解决呢？在给定的有限的资源和竞争约束情况下,取得最大化或最小化目标的问题.导论中给出政治竞选问题、航空航线调度问题、钻井采油问题.最大化或最小化目标是函数的因变量,自变量就是资源的约束因素,其函数就是由这些制约因素构成的等式或不等式.\n1.线性规划定义.\n> 在一般线性规划问题中,最优化一个满足一组线性不等式约束的线性函数.已知一组实数 $a\\_1,a\\_2, \\dots,a\\_n$和一组变量 $x\\_1,x\\_2, \\dots,x\\_n$,基于这些变量的一个线性函数f定义为\n$$ f(x\\_1,x\\_2, \\dots,x\\_n) = a\\_1x\\_1 + a\\_2x\\_2 + \\dots + a\\_nx\\_n = \\sum\\_{j=1}^n a\\_jx\\_j$$\n> 如果b是一个实数而f是一个线性函数,则等式：\n> $f(x\\_1,x\\_2, \\dots,x\\_n) = b$ 是一个线性等式.\n> $f(x\\_1,x\\_2, \\dots,x\\_n) \\leq b$ 和 $f(x\\_1,x\\_2, \\dots,x\\_n) \\geq b$ 是线性不等式.\n> 线性约束就是函数f和b的关系,就是求解n个变量m个线性不等式的最大化,约束为线性不等式的线性函数最大化称为标准型;而约束为线性等式的线性函数的最大化称为松弛型.\n\n基于上面描述可知,线性规划问题是要最小化或最大化一个受限于一组有限的线性约束的线性函数.最小化线性规划和最大化线性规划的分类,是基于目标的需求,同样是m个线性不等式约束,去求解n个变量的值,达到目标(最大化或最小化).\n\n2.凸形区域定义：\n区域内的任何两点之间连线上的点都属于这个区域.\n线性规划中,二维空间(两个变量)所构成的凸形区域为可行区域,要最大化的函数为目标函数.可行区域内的每个点都会去评估目标函数$x\\_1+x\\_2$,将目标函数的一个特点点上的值称为目标值,识别出一个有最大目标值的点就是最优解.当然有二维线性规划不等式所构成的可行区域上是有无数个点,不可能都去求值,因此需要找出一个有效的方式来寻找最大目标值的点.线性规划的最优解必定是在可行区域的边界上,所以只要沿着边界寻找顶点就可以很快找到最大目标值的点.\n推而广之,如果有三个变量,则每个约束以三位空间的一个半空间来描述,三个半空间的交集构成了可行区域,目标函数取目标值的点集合是一个平面.因为可行区域也是凸的,取得最优目标值的点集合必然包含可行区域的一个顶点.延伸到n个变量的超平面,每个约束定义了n维空间中的一个半空间,这些半空间的交集形成的可行区域称作单纯形,目标函数是一个超平面,且是凸性,一个最优解也是在单纯形的一个顶点上取得.理解下,无论多少维,找出凸形区域,目标函数的最优解就是在凸形区域的顶点集合之一或多个.\n\n3.单纯型算法\n单纯形算法输入一个线性规划(n个变量m个线性不等式),输出一个最优解.算法从单纯形的某个顶点开始,执行一系列迭代,每次迭代中,沿着单纯形的一条边从当前顶点移动到一个目标值不小于当前顶点的相邻顶点.当达到一个局部最大值,即一个顶点的目标值大于其所有相邻顶点的目标值时,算法终止.因为可行区域是凸的且目标函数是线性的,所以具备最优事实就是全局最优的.\n\n单纯形算法需要指数时间.线性规划的第一类多项式时间算法是椭圆算法,运行缓慢;第二类指数时间的算法是内点法,在大型输入上,性能优于单纯形算法.如果在线性规划中,所有的变量都取整数值,即整数线性规划,对于该问题,找出一个可行解是NP难度的.目前还没有已知的多项式时间算法能NP难度问题,所以没有有效的整数线性规划多项式时间算法.当然,一般的线性规划可以在多项式时间内解决.\n\n线性规划的关键步骤:\n1.标准型/松弛型转化\n标准型的线性规划所有的约束条件都是不等式,而松弛型中的约束是等式.要用单纯形算法求解线性规划,需要将所有线性规划转化为标准型,再将标准型转化为松弛型,线性方程组等式求解.\n标准型定义：\n已知n个实数 $c\\_1,c\\_2, \\dots,c\\_n$;m个实数 $b\\_1,b\\_2, \\dots, b\\_m$;以及m * n个实数 $a\\_ij,其中i=1,2,\\dots, m,而j=1,2, \\dots, n$ 希望找出n个实数$x\\_1,x\\_2, \\dots, x\\_n$来最大化目标函数：\n$$ \\sum\\_{j=1}^n c\\_jx\\_j$$\n满足n + m个不等式, 其中n个约束为非负性约束:\n$$ \\sum\\_{j=1}^n a\\_{ij}x\\_j \\leq b\\_i, i = 1,2, \\dots, m\nx\\_j \\geq 0, j= 1, 2, \\dots, n$$\n用矩阵表示更紧凑：\n$$最大化c^Tx,满足约束：Ax \\leq b,x \\geq 0$$\n\n满足所有约束的变量 $x\\_s$设定为可行解,而不满足至少一个约束的变量 $x\\_s$ 设定为不可解.称一个解xs拥有目标值 $c^Tx\\_s$,在所有可行解中其目标值最大的一个可行解 $x\\_s$是一个最优解,称其为目标值 $c^Tx\\_s$的最优目标值.如果一个线性规划没有可行解,则称此线性规划不可行,否则是可行的.如果一个线性规划有一些可行解但没有有限的最优目标值,则称此线性规划是无界的.\n已知一个最小化或最大化的线性函数受若干线性约束,总可以将这个线性规划转换为标准型.换句话说,要将非标准型的线性规划转化为标准型的.为什么会有非标准型的线性规划呢？可能目标函数是一个最小化而不是最大化;可能拥有的变量不具有非负性约束;可能有等式约束;可能有大于等于的不等式约束,而不是小于等于.\n将非标准的线性规划转化线性规划,最重要是确保转换后的线性规划最优解也是转换前的线性规划最优解,转化前后的两个线性规划是等价的.转化思路就是对目标函数系数取负,并将不具有非负约束性的变量转换成具有非负性约束的变量.\n\n为了利用单纯形算法高效地求解线性规划,需要将标准型转换成松弛型,就是非负约束是不等式,其他约束都是等式.转换思路就是利用松弛变量,就是将不等式的余量用s来接收,从而使不等式变成等式,形式如下：\n$$目标函数: z = v + \\sum\\_{j=1}^n c\\_jx\\_j \\\\\\\\\n约束条件(不含变量的非负性约束: b\\_i - \\sum\\_{j=1}^n a\\_{ij}x\\_j = x\\_i$$\n基于松弛型线性规划,就可以用单纯形算法求解.\n\n2.将问题表达为线性规划：建模\n既然定义了线性规划,也知道线性规划可以在多项式时间内求解,那么对于现实的问题,那些事如果形式化为线性规划的问题来求解呢？这就涉及到建模了,现实中的问题如何建模为线性规划来求解.建模：将问题转化成数学形式来求解.\n\n算法导论中对单源最短路径变形的单对最短路径、最大流以及最大流变形的最小费用流和多商品流形式化为线性规划.这里描述下单源最短路径的线性规划形式化\n\n> 在单对最短路径问题中,已知一个带权有向图G=(V,E),加权函数w:E->R将边映射到实数值的权值、一个源顶点s、一个目的顶点t,要计算从s到t的一条最短路径的权值d[t].将该问题用线性规划表示,要确定变量和约束的集合.在Belleman-Ford算法终止时,对每个顶点v,都一个值d[v],使得每条边 $(u,v) \\in E$,有 $d[v] \\leq d[u]+w(u,v)$.源顶点初始得到一个值d[s]=0,如此有计算从s到t的最短路径权值的线性规划：\n最大化：d[t]\n满足约束：$d[v] \\leq d[u]+w(u,v)$,对每条边 $(u,v) \\in E$成立d[s]=0\n共有|V|个变量d[v],每个顶点v∈V各有一个,有|E|+1个约束,每条边各有一个再加上源顶点d[s]=0的额外约束.\n\n3.单纯形算法实现\n单纯形算法是求解线性规划的古典方法.单纯形算法和高斯消元法迭代原理类似,高斯消元法是从解未知的一个线性等式系统开始.可以将单纯形算法看成是线性不等式系统上的高斯消元法.单纯形算法的迭代主要思想是：从线性规划的松弛型中得到每次迭代关联的基本解,将每个非基本变量设为0,并从等式约束中计算基本变量的值;一个基本解对应于单纯形的一个顶点;代数上,一次迭代将一个松弛型转换成一个等价的松弛型;相应的基本解的目标值不小于前一次迭代中的目标值,要实现迭代过程中目标值的递增,要选择一个非基本变量作为指示变量,从0开始增加这个变量的值,和目标值一起增加,增加到某个基本变量变为0为止再重写松弛型,将这个基本变量和所选的非基本变量进行角色互换,就是重写线性规划直到最优解很明显.\n\n单纯形算法主要关键是主元选择,并且有三个关键点:\n* 1.确定线性规划是可行的;\n* 2.确定线性规划是具有可行解而不是无界;\n* 3.主元如何选择换入变量和换出变量.\n\n主元选择算法如下:\n```\npivot(N, B, A, b.c. v, l, e)\n#compute the conefficients of the equation ofr new basic variable x\nb{e} <- b{l}/a{le}\nfor each j in N - {e}\n    do a{ej} <- a{lj}/a{le}\na{el} <- 1/a{le}\n#compute the conefficients of the remaining constraints\nfor each i in B - {l}\n    do b{i} <- b{i} - a{ie}b{e}\n    for eahc j in N - {e}\n        do a{ij} <- a{ij} - a{ie}a{ej}\n    a{il} <- a{ie}a{el}\n#compute the objective function\nv <- v + c{e}b{e}\nfor each j in N - {e}\n    do c{j} <- c{j} - c{e}a{ej}\ncl{e} <- -c{e}a{el}\n#compute new ses of basic and nonbasic variables\nN = N - {e} union {l}\nB = B - {l} union {e}\nreturn (N, B, A, b, c, v)\n\n```\n对标准型的输入来求解最优解的算法描述如下:\n```\nsimple(A, b ,c)\n(N, B, A, b, c, v) <0 initialize-simple(A, b, c)\nwhile some index j in N has c{j} > 0\n    do choose an index e in N for which c{e} > 0\n        for each index i in B\n            do if a{ie} > 0\n                then delta{i} <- b{i}/a{ie}\n                else delta{i} <- INT\n            choose an index l in B that minimizes delta{i}\n            if delta{i} = INT\n                then return \"unbounded\"\n                else (N, B, A, b, c, v) <- pivot(N, B, A, b, c, v, l, e)\nfor i <- 1 to n\n    do if i in B\n        then x{i} <- b{i}\n        else x{i} <- 0\nreturn (x{1}, x{2}, ..., x{n})\n```\n这里一般性地理解下,要通过单纯形算法来求解,在算法之前要肯定线性是可行(单纯性算法最初有一个初始化过程,会判断线性规划是否可行,返回一个初始基本解可行的松弛型),在算法之中要确保不陷入退化或说循环(目标值越迭代越小),能够终止返回最优解.单纯形算法输入一个标准型线性规划,返回线性规划一个最优解,能够顺利找到最优解并终止算法,后续对偶型可以说明.\n\n一个典型的单纯形算法例子：\n> 首先初始化标准型线性规划,返回一个初始基本解可行的松弛型,或者返回这个线性规划不可行,推出算法;其次对松弛型线性规划开始主元操作,选择非负系数最紧约束的换出变量,和换入变量交换,得到新的线性规划(和原来的线性规划是等价的);不断迭代这个过程,直到最优解确定,并终止返回一个最优解.\n对于松弛型线性规划通过主元操作生成的新线性规划,二者是等价的.现在很重要的就是主元操作迭代,是如何选择换出变量的.选择一个在目标函数中系数为正值的非基本变量,尽可能增加其值而不违反任何约束.现在通过一个例子来理解单纯形算法的过程.\n\n1.标准型线性规划转化为松弛型线性规划\n标准型：\n最大化：\n3x1+x2+2x3\n满足约束：\nx1+x2+3x3≤30\n2x1+2x2+5x3≤24\n4x1+x2+2x3≤36\nx1,x2,x3≥0\n\n松弛型：\n最大化：\nz=3x1+x2+2x3\n满足约束：\nx4=30-x1-x2-3x3\nx5=24-2x1-2x2-5x3\nx6=36-4x1-x2-2x3\n\n确定基本解：把等式右边的所有变量设为0,可得基本解(x1,x2,x3,x4, x5, x6)=(0,0,0,30,24,36),目标值z=0;\n\n2.主元操作迭代第一次,选择增加x1的值.当增加x1值时,x4, x5, x6的值随之减小,但每个变量都有非负约束,所以不能减小到负值,这个时候就要在约束函数上选择最紧约束(就是选择最小增加值).\n如果x1值增加到30,那么x4是负值;增加到12,则x5是负值;增加到9,则x6是负值;这个就知道了,9是x1值所能增加的最大值,就是最紧约束,对约束函数x6=36-4x1-x2-2x3互换变量x1和x6的角色,得到：x1=9- x2/4- x3/2- x6/4,代入原线性规划据此可得新的松弛型线性规划,如下：\n最大化：\nz=27+x2/4+ x3/2- 3x6/4\n满足约束：\nx1=9- x2/4- x3/2-x6/4\nx4=21-3x2/4-5x3/2+x6/4\nx5=6-3x2/2-4x3+x6/2\n确定基本解,同样把等式右边的所有变量设为0,可得基本解(x1,x2,x3,x4, x5, x6)=(9,0,0,21,6,0),目标值z=27;\n\n3.主元操作迭代第二次,选择增加x3的值,最紧约束是x5=6-3x2/2-4x3+x6/2,最大增加到3/2,否则x5的值为负,和第一次迭代一样,互换x3和x5并代入线性等式获得新的线性规划,可得基本解(x1,x2,x3, x4, x5,x6)=(33/4,0,3/2,69/4,0,0),目标值z=111/4;\n第四：主元操作迭代第三次,互换x2和x4并代入线性等式获得新的线性规划,可得基本解(x1,x2,x3, x4, x5,x6)=(8,4,0,18,0,0),目标值z=28,为最优解,(x1,x2,x3)=(8,4,0).\n最关心的问题还是具有可行解的线性规划经过这样的迭代,在算法终止时是否确实能找到最优解,这个就留给线性规划对偶性来说明.\n\n4. 单纯形算法分析\n现在我们知道单纯形算法可以在多项式时间内求解线性规划最优解,那么关心两点：\n* 是算法终止时,获得的是最优解,这个就是对偶性要回答;\n* 二是输入一个线性规划要判断出是可行可解的,这个就是辅助线性规划要回答的.\n任何线性规划都可能是不可行的,或是无界的,或有一个优先目标值得最优解,针对这些个情况,单纯形算法要能正确识别.\n\n**线性规划的基本定理**：\n以标准型给出任意的线性规划L可能是以下三者之一：\n第一：有一个有限目标值的最优解;\n第二：不可行;\n第三：无界;\n\n如果L是不可行的,单纯形算法在初始化中就会返回不可行;如果L是无界的,单纯形算法返回无界,无界就是找不到最优解或者有无限个目标值;当然,满足第一情况的,就会返回有限目标值的最优解.\n单纯形算法在初始化过程中,会确定线性规划是否有可行解,如果有,则给出一个基本解可行的松弛型线性规划.这个初始化过程其实就是对线性规划测试可行解.那么是如何来确认存在可行解呢？通过构造辅助线性规划,这个辅助线性规划,比较容易找到一个基本解可行的松弛型.只要辅助线性规划有可行解,则要输入的线性规划也就有可行解.如果线性规划L没有可行解,则初始化返回不可行,否则返回一个基本解可行的合法松弛型.怎么构造辅助线性规划呢？\n\n辅助线性规划：令L是一个标准型的线性规划,令 $L\\_{aux}$是带有n+1个变量的线性规划：\n最小化：-x0\n满足约束：\n$$ \\sum\\_{j-1}^{n} a\\_{ij}x\\_j - x\\_0 \\leq b\\_i, i = 1, 2, \\dots, m \\\\\\\\\nx\\_j \\geq 0, j = 0, 1, \\dots, n\n$$\n则当且仅当 $L\\_{aux}$的最优目标值为0时,L是可行的.\n辅助线性规划,增加一个x0变量,并且令目标值为0.对辅助线性规划求解可行解,也是按照主元操作,将标准型转换成松弛型后不断交换变量迭代.辅助线性规划较容易找到可行解.算法导论中证明了辅助线性规划存在可行解就是要求解的线性规划存在可行解.\n\n现在我们要引进线性规划**对偶性**的概念.对偶性有一个很重要的性质：在一个最优化问题中,一个对偶问题的识别总是可以在一个多项式时间内发现.对偶性是用来证明某个解确实是最优解.还是动态规划思想：已知一个最大化问题,定义个相关的最小化问题,来让着两个问题有相同的最优目标值.如最大流问题的最大流最小割原理.对偶的字面意义,就是我的解也是你的解,大问题的解是小问题的解.\n\n已知一个目标是最大化的线性规划,制定一个对偶线性规划,其目标是最小化,而且最优值与原始线性规划相同.给定一个标准的原线性规划,定义对偶线性规划为：\n$$\n最小化: \\sum\\_{i=1}^{m} b\\_iy\\_i \\\\\\\\\n满足约束: \\sum\\_{i=1}^{m} a\\_{ij}y\\_i \\geq c\\_j, j = 1,2, \\dots, n \\\\\\\\\ny\\_i \\geq 0, i = 1, 2, \\dots, m\n$$\n构造对偶,将最大化改成最小化,将约束右边的与目标函数的稀疏角色互换,并且小于等于号变成大于等于号.在原问题的m个约束中,每一个在对偶问题中都一个对应的变量yi,在对偶问题的n个约束中,每一个在原问题中都一个对应的变量xj.\n\n对偶性能证明最优解主要是两点：\n* 原线性规划中的目标函数的系数变成对偶线性规划中约束函数的右边值,原线性规划中的约束函数的右边值变成对偶线性规划中目标函数的系数;\n* 原线性规划中每一个约束函数的左边等于对偶线性规划中的一个变量,就是原线性规划中的m个约束函数等于m个对偶线性规划中的变量,反之也是.最后证明了对偶线性规划的最优值总是等于原线性规划的最优值.\n\n### Chapter28 寻找子串\n字符串匹配是一个很常见的问题,可以扩展为模式的识别,解决字符串问题的思想被广泛地应用.字符串匹配问题可以描述如下:\n![string-match1](/images/string-match1.png)\n介绍3种解决该问题的办法,包括：最朴素的遍历法,Rabin-Karp算法,自Knuth-Morris-Pratt算法即KMP.\n首先对时间复杂度做出一个概括(从大到小)：\n* 朴素法：$O((n-m+1)m)$;\n* Rabin-Karp：预处理：$O(m)$,匹配：最坏 $O((n-m+1)m)$,但是平均和实际中比这个好得多;\n* KMP：预处理O(m),匹配O(n).\n其中,m代表模式P的长度,n代表被匹配的数组S的长度,Σ代表P和S的字符表.\n\n接下来分开学习对应的算法和思想.\n\n1.朴素法(native)\n```\nnavite-string-matcher(T, P)\nn <- length[T]\nm <- length[P]\nfor s <- 0 to n - m\n    do if p[1...m] = T[s+1...s+m]\n        then print \"Pattern occurs with shift\"\n```\n朴素法简单直接,就是从T的每一个字符开始,看它之后(包括它)的m个字符与P是否一样.P从S中第几个字符开始,可以看作,P在S中位移了几步.\n朴素法的效率低的问题在于,它几乎忽视了所有的信息,每一次匹配都是“全新地”.如果P=abc,S=abdabc,从位置0开始,当我们匹配到 位置2,即c != d,朴素的做法是下一步从位置1开始匹配, 然而,在之前的匹配过程中,我们可以知道位置1的值b必然不匹配位置0的a.这是我们光通过P就能知道的,因为既然前一步已经开始去匹配位置2了,证明说明0和1已经成功匹配,而通过P自己,我们知道P的位置1不匹配0,则前一步的S位置1必然也不匹配P的位置1,这样就可以跳过这一步.问题在于,告诉程序跳过多少步,这就是我们接下来的算法要做的.显然,跳过得越多匹配越快,同时我们为了尽可能得到跳步的信息,可能需要进行预处理,预处理会产生另外的时间.\n\n2.Rabin-Karp\n```\nrabin-karp-matcher(T, P, d, q)\nn <- length[T]\nm <- length[P]\nj <- d^{m-1} mod q\np <- 0\nt{0} <- 0\nfor i <- 1 to m   #预处理\n    do p <- (dp + p[i]) mod q\n        t{0} <- (dt{0} + T[i]) mod q\nfor s <- 0 to n - m  #匹配\n    do if p = t{s}\n        then if P[1..m] = T[s+1...s+m]\n            then print \"Pattern occurs with shift\"s\n        if s <- n - m\n            then t{s+1} <- (d(t{s} - T[s+1]h) + T[s+m+1]) mod q\n```\n执行过程如下:\n![robin-karp](/images/robin-karp.png)\n\n算法将字符串转化为数,进制就是字符表的字符数目.那么,P是一个m位数,这个转化很容易用 $O(m)$ 算出来,通过遍历可以解决.再将S变为n-m+1个数：第一个数同P一样,$O(m)$ 完成预处理;当有了第k个数,算第k+1个数的时候,只需要去掉高位,补上低位,$O(1)$ 完成这个递推过程;总的预处理还是 $O(m)$.匹配的时候就是比较n-m+1次,所以复杂度是 $O(n-m+1)$.那么,为什么说它匹配最坏是 $O((n-m+1)m)$ 呢？\n原因在于这个转化得来的数可能很大,算术运算不是常数,怎么处理大数呢？这个时候可以用模除来做一个简单的hash,匹配的数hash一定匹配,hash匹配原数不一定匹配,需要再回去做检查.最差的情况下,所有的hash都一样,每个hash都匹配了,全部需要回去检查一遍,那么这个时候匹配过程和朴素法一样.工程上来说,通常选取一个较大的素数来做模除.算法的最差运行时间是 $O((n-m+1)m)$, 当素数比模式P长度大很多时,期望运行时间是 $O(n+ m)$.\n\n\n3.KMP\nKMP实际上是利用自动机的思想,但是我们并不是预先算好变迁函数.KMP遇到新字符,如果匹配当然是下一个状态,不匹配的话并不像自动机一步到位地接收新字符后到另一个状态,而是先到另一个状态,再递归地看是否接收这个字符,最终接收后在看下一个字符.关键在于,不匹配时,改变状态时是带着新字符还是不带.那么辅助的数组(数组也好,函数也好,总归还是查表),就从多维降到一维,多维是因为自动机遇到不同新字符跳到不同的状态,一维是KMP遇到新字符不匹配时直接跳到另一个状态,跳的时候不考虑新字符.直观上看,构建这样的数组也不再需要遍历Σ,预处理过程复杂度应该会降低.事实,确实省去了O(|Σ|)的复杂度,降到O(m)复杂度.同时,匹配时的复杂度还保持在了O(n).分析复杂度用到平摊分析法.\n匹配过程是简单直观的,如前所述,遇到新字符,借助辅助数组π不断地改变状态.伪代码乳如下：\n```\nkmp-matcher(T,P)\nn <- length[T]\nm <- length[P]\nπ <- kmp-computer-prefix(P)\nq <- 0               // state , number of char matched\nfor i <- 1 to n\n    while q > 0 && P[q+1] != T[i]  // P and T range from 1 to n, not 0 to n-1\n        do q <- π[q]\n        if P[q+1] = T[i]\n            then q <- q+1\n        if q = m\n            then print \"Pattern occurs with shift\" i-m\n                q <- π[q]\n```\n那么,问题的关键还是在于计算辅助数组π,即状态如何转移.这里KMP计算的时候,从P的低位(左边)开始计算π,显然只会用到前面低位的信息,不会用到后面高位的信息.那么利用动态规划中利用记录减少迭代的思想,再把计算π的过程看做与匹配过程类似,比如计算q+1那么就是用Pq去匹配Pq+1嘛,而Pq的数组π已经建立好了.\n```\nkmp-computer-prefix(P)\n\nm <- length[P]\nπ[1] <- 0\nk <- 0               // just like q above, number of char matched\nfor q <-  2 to m     // like i above, and actually it is state, so its name is q\n    while k>0 && P[k+1] != P[q]  // P range from 1 to n, not 0 to n-1\n        do k <- π[k]\n        if P[k+1] = P[q]\n            then k <- k+1\n        π[q] <- k\nreturn π\n```\nkmp算法执行如下:\n![kmp1](/images/kmp1.png)\n![kmp2](/images/kmp2.png)\n","source":"_posts/CLRS-notes6.md","raw":"title: introduction to algorithms notes6\ntags:\n  - algorithm\n  - data_structure\ndate: 2017/05/18\n\n------\n\n# ＜Introduction to algorithms＞笔记\n\n## Part7 高级算法问题\n在part1-6学习基本的数据结构和算法问题后, part7不再集中于对一个算法问题专题进行学习, 而是就不同的高级算法问题进行基本的介绍,其其覆盖的内容十分全面,涉及一下几个领域:\n* 排序网络\n* 矩阵运算\n* 线性规划\n* 字符串匹配\n\n### Chapter26 如何利用多核来并行排序?\n在part2中学习了基本的排序算法,包括插入,快排,归并,堆排序等,它们都是在串行计算机上线性执行的算法.随着硬件的发展,多处理器的进步,如何利用多核来进行并行排序?如何推而广之到多核并行算法?这一章就套路基于计算的一种比较网络模型,同时进行多个比较操作.\n\n比较网络与串行排序算法的区别:\n* 比较网络只能执行比较操作, 即只能执行基于比较操作的算法.因此part2中学习的计数排序就无法再比较网络中实现\n* 比较网络中比较操作可以并行的执行, 而串行排序算法各操作是依次执行的.故前者拥有更好的算法效率- 更小的算法复杂度\n\n1.比较网络定义\n* 组成：\n基本构件:线路和比较器\n![comparsion](/images/comparsion.png)\n\n<!-- more -->\n\n* 比较网络含义：\n* 一个由线路互相联接着的比较器的集合,我们把具有n个输入的比较网络画成一个由n条水平线组成的图,比较器则垂直地与两条水平线相连接.每个比较器的输入端要么与网络的n条输入线路 $a\\_1,a\\_2, \\dots, a\\_n$ 中的一条相连,要么与另一个比较器的输出端相连接.类似地,每个比较器的输出端要么与网络的n条输出线路 $b\\_1,b\\_2, \\dots, b\\_n$中的一条相连,要么与另一个比较器的输入端相连接.互相连接的比较器主要应满足如下要求：\n> 1. 其互相连接所成的图中必须没有回路.\n> 2. 只有当同时有两个输入时,比较器才能产生输出值.\n\n在每个比较器均运行单位时间的假设下,我们可以对比较网络的“运行时间”作出定义,这就是从输入线路接收到其值的时刻到所有输出线路收到其值所花费的时间.\n\n* 比较网络示意图:\n![sortnet](/images/sortnet.png)\n\n* 排序网络定义:\n对每个输入序列其输出序列均为单调递增(即 $b\\_1 \\leq\n b\\_2, \\dots, b\\_n$ )的一种比较网络\n\n* 0-1原理：\n如果一个具有n个输入的比较网络,能够对所有可能存在的2^n个0和1组成的序列进行正确的排序,则对所有任意数组成的序列,该比较网络也可能对其正确排序.\n0-1原理推定认为：如果对于属于集合{0,1}的每个输入值,排序网络都能正确运行,则对任意输入值,它也能争取而运行(输入值可以是整数、实数或者任意线性排序的值的集合).这样在构造排序网络时,可以专注在0和1组成的输入序列上设计比较器.这个原理目的是简化输入值,而通过0和1来设计比较网络的线路和比较器,只要0和1可运行,那么其他任意值的序列也都可以运行.\n0-1原理的证明依赖单调递增函数.如果比较网络把输入序列 $a=<a\\_1,a\\_2, \\dots, a\\_n>$ 转化为输出序列 $b=<b\\_1,b\\_2, \\dots, b\\_n>$,则对任意单调递增函数f,该网络把输入序列f(a)=<f(a1),f(a2),…,f(an)>转化为输出序列f(b)=<f(b1),f(b2),…,f(bn)>.\n这个可以这样理解,对输入序列a施以f(a)单调递增函数,比较网络(线路和比较器)能够使序列a输出序列b,那么该比较网络同样可以使输入序列f(a)输出序列f(b).\n这就为0-1原理奠定了基础,只要证明比较网络可以运行于0和1的输入,那么设计一个单调递增函数,0和1是因变量,其自变量自然也可以通过同样比较网络来排序.\n如果一个具有n个输入的比较网络能够对所有可能存在的2n个0和1组成的序列进行正确的排序,则对所有任意数组成的序列,该比较网络也可能对其正确排序.\n0-1原理证明用到了单调递增函数概念,同时采用数学归纳法和反证法来证明.这也给出了一个很重要的思想,那就是对现实问题的解决,在构建数学模型时,可以简单到0-1,然后再推广到复杂数.\n\n* 双调序列：\n序列要么先单调递增然后再单调递减,要么先单调递减然后又单调递增.例如序列<1,4,6,8,3,2>和<9,8,3,2,4,6>都是双调的\n\n\n2.双调排序网络\n* 双调排序程序由 $log\\_2n$个阶段组成,其中每一个阶段称为一个半清洁器.每个半清洁器是一个深度为1的比较网络,其中输入线I与输入线I+n/2进行比较,I=1,2,…,n/2(这里假设n为偶数).下图即为一个具有8个输入和8个输出的半清洁器(half-cleaner)\n![half-cleaner](/images/half-cleaner.png)\n\n* 当由0和1组成的双调序列用作半清洁器的输入时,半清洁器产生的输出序列满足如下条件：\n> 1. 较小的值位于输出的上半部,较大的值位于输出的下半部.\n> 2. 两部分序列仍是双调的.\n> 3. 两部分序列中至少有一个是清洁的——全由0或1组成.\n\n* 双调排序器(bitonic-sorter)\n通过递归地连接半清洁器,我们可以建立一个双调排序网络.双调排序网络[n]的第一阶段由半清洁器[n]组成,可知半清洁器[n]产生两个规模缩小一半的双调序列且满足上半部分的每个元素不比下半部分的任一个元素大.因此,我们可以运用两个双调排序网络[n/2]分别对两部分递归地进行排序,以此完成整个排序工作\n![bitonic-sorter](/images/bitonic-sorter.png)\n\n我们只要把含n个元素的双调排序网络的第一个半清洁器修改一下就可以得到合并网络MERGER[n].由于输入的上半部和下半部都是单调递增的,所以我们把比较网络的下半部分颠倒一下,输入就成了一个双调序列.添上半清洁器,再颠倒回去,半清洁器就变成了把输入 $a\\_i$和$a\\_{n-i+1}比较.这时,输出也被颠倒了.但是,一个双调序列颠倒了以后还是一个双调序列.\n因此就可以用*bitonic-sorter*对深度为 $\\log n$ 的0-1双调序列进行排序.\n![bitonic-sorter2](/images/bitonic-sorter2.png)\n\n3.合并网络(mergin network)\n合并网络,能够把两个已排序的输入序列合并为一个有序的输出序列的网络.基于双调排序网络思想,对已知的两个有序序列进行连接(第二个序列顺序颠倒),所得的序列是双调序列,再利用双调排序器就能完成两个有序序列的合并.其原理如下:\n![merger1](/images/merger1.png)\n![merger2](/images/merger2.png)\n\n4.基于0-1原理、双调排序网络、合并网络,我们可以构造一个输入任意序列进行排序的比较排序网络.思想很简单：第一步开展最基础的2个元素的两两比较,这个用普通的比较器就可以实现,输出长度为2的有序序列;第二步对长度为2的有序序列进行两两合并,这个用合并网络排序(基于双调排序器,先连接序列构造双调序列)实现,输出长度为4的有序序列;第三步对长度为4的有序序列进行合并网络,直到 $\\log n$次.算法上,可以在 $O(\\log n)$内并行地对n个数进行排序.\n![sorter](/images/sorter.png)\n\n总结:排序网络可以并行地进行排序,然后再组合各并行排序结果,适合分布式场景的排序需求.\n\n### Chapter27 矩阵运算\n在part4高级设计技术中在动态规划中研究了矩阵链乘法问题后, 这一章深入学习矩阵运算, 特别学习矩阵相乘的Strasssen算法,该算法能在 $O(n^{\\log 7})$ 的时间内计算两个 $n*n$ 的矩阵的乘积.\n\n1.首先重温下矩阵的相关概念和性质,为后续矩阵运算奠定数据理论基础.\n\n矩阵A：\n数字的一个矩形阵列,形式化为 $A=(a\\_{ij})$,第i行j列元素为 $a\\_ij$,如元素为实数的所有元素mXn矩阵组合的元素用 $R\\_{mXn}$表示.\n![matrix](/images/matrix.png)\n\n矩阵转置AT：是矩阵A的行和列互相交换而产生的矩阵.\n\n向量(Vector)：是数字的一维向量,列向量看成是nX1的矩阵,转置成行向量就是1Xn的矩阵.\n\n单位向量$e\\_i$：矩阵第一个元素为1而其他元素均为0的常量.\n\n零矩阵：所有元素都是0的矩阵.\n\n对角矩阵：当i≠j时,$a\\_ij$,所有非对角线上的元素均为0.\n\nnXn单位矩阵 $I\\_n$：是对角线元素都是1的对角矩阵.\n\n三对角矩阵T：满足 $|i-j|>1$ 的元素 $t\\_ij$=0的矩阵,非零元素仅出现在主对角线上、靠主对角线上面和对角线下面.\n\n上三角矩阵U：满足i>j的元素 $U\\_ij=0$的矩阵,对角线下面的所有元素均为0,若对角线元素为1,则是单位上三角矩阵.\n\n下三角矩阵L：满足i<j的元素 $L\\_ij=0$的矩阵,对角线上面的所有元素均为0,若对角线元素为1,则是单位下三角矩阵.\n\n置换矩阵P：每一行或列中仅包含一个1,其他元素都为0,可以把一个向量x和一个置换矩阵相乘,结果是向量x中的元素的一种置换.\n\n对称矩阵A：满足条件 $A= A^T$.\n\n矩阵加法：$C(c\\_ij)=A(a\\_ij)+B(b\\_ij),c\\_ij=a\\_ij+b\\_ij$,都是mXn矩阵.\n\n矩阵乘法：相容(A的列数等于B的行数)的两个矩阵才可以相乘,$C(c\\_ij)= \\sum\\_{k=1}^{m} A(a\\_ik)*B(b\\_kj)$,矩阵和单位矩阵等于自己、和零矩阵相乘等于零、和向量相乘得到向量,满足结合律和分配律,但不满足交换律.\n\n逆矩阵A-1：满足 $A A^{-1} = I\\_n= A^{-1}A$,不可逆的矩阵称为奇异矩阵.\n\n线性相关：设 $x\\_1,x\\_2, \\dots, x\\_n$是n个向量,若存在不全为零的常系数 $c\\_1,c\\_2, \\dots, c\\_n$,使 $c\\_1x\\_1+c\\_2x\\_2+ \\dots +c\\_nx\\_n=0$成立,就称 $x\\_1,x\\_2, \\dots, x\\_n$线性相关.\n\n非零mXn矩阵A的秩：A的极大线性无关列向量组中向量的个数为列秩,A的极大线性无关行向量组中向量的个数为列秩.任意一个矩阵的行秩和列秩都是相等.mXn的秩是0和min(m,n)之间的一个整数.\n\n非零mXn矩阵A的秩满足下列条件的最小的数r：存在mXr矩阵B和rXn矩阵C且有A=BC.如果一个nXn的矩阵秩为n,则是满秩,如果一个mXn矩阵的秩为n,则是列满秩.\n一个方阵满秩当且仅当它为非奇异矩阵.当前仅当A无空向量时,矩阵A为列满秩.\n当且仅当A具有空向量时,方阵A是奇异的.\n\n余子式：对于n>1,nXn矩阵A的第ij个余子式是把A的第i行和第j列元素去掉后所形成的一个(n-1)X(n-1)矩阵A[ij],表示为det(A[ij]).\n\n方阵A的行列式具有如下性质：如果A的任何行或列的元素为0,则det(A)=0;用常如a乘A的行列式任意一行(或任意一列)的诸元素,等于用a乘A的行列式;A的行列式中的一行(或一列)元素加上另一行(或另一列)中的相应元素,行列式的值不变;A的行列式值与其转置矩阵AT的行列式的值相等;行列式的任意两行(或两列)互换,则其值异号.\n\n正定矩阵：nXn矩阵A,如果对所有n维向量x≠0都有$x^TAx>0$,则矩阵A为正定矩阵.\n\n对任意列满秩矩阵A,矩阵$A^TA$是正定的.\n\n2.矩阵乘法的Strassen算法\n矩阵乘法是种极其耗时的运算.以C = AB为例,其中A和B都是 n x n 的矩阵.根据矩阵乘法的定义,计算过程如下：\n```\nSQUARE-MATRIX-MULTIPLY(A, B)\nn = A.rows\nlet C be a new nxn matrix\nfor i = 1 to n\n    for j = 1 to n\n        c[i][j] = 0\n        for k = 1 to n\n            c[i][j] += a[i][k] * b[k][j]\nreturn C\n```\n由于存在三层循环,它的时间复杂度将达到 $O(n^3)$.\nStrassen算法运用分治法将两个nXn的矩阵乘积运行时间,从简易矩阵乘法算法 $O(n^3)$提升到 $O(n^{\\log 7}) = O(n^{2.81})$.下面是算法的主要思想和步骤.\n\n> 一般情况下,矩阵乘积C=AB,其中A、B和C都是nXn方阵,假定n是2的幂,把A、B和C划分成四个n/2Xn/2矩阵：\n![matrix2](/images/matrix.png)\n则矩阵乘法对应四个等式：\n```\nr=ae+bg\ns=af+bh\nt=ce+dg\nu=cf+dh\n```\n> 每个等式运行包含两次 $n/2 * n/2$矩阵乘法和两次乘积所得的 $n/2 * n/2$矩阵的加法运算,推出 $n * n$ 矩阵相乘所需时间T(n)的递归式：\n$$T(n)=8T(n/2)+  O(n^2)$$\n\nStrassen算法在这个一般性的递归式上,发现只需要进行7次 $n/2 * n/2$矩阵乘法即可解决,即\n$$T(n)=7T(n/2)+O(n^2)= O(n^{\\log 7}) = O(n^{2.81})$$\n具体算法步骤如下：\n\n* 1.输入矩阵A和B划分为 $n/2 * n/2$的子矩阵;\n* 2.运行 $O(n^2)$标量加法和减法运算,计算出14个 $n/2 * n/2$的矩阵 $A\\_1,B\\_1,A\\_2,B\\_2, \\dots, A\\_7,B\\_7$;\n* 3.递归计算出7个矩阵的乘积 $P\\_i=A\\_i * B\\_i,i=1,2, \\dots, 7$;\n* 4.使用 $O(n^2)$ 次标量加法与减法运算,对 $P\\_i$ 矩阵的各种组合进行求和或求差运算,从而获得结果矩阵C的四个子矩阵r\\s\\t\\u.\n\nStrassen算法的核心思想是什么呢？何以产生如此一个步骤的算法呢？依据是什么？\n设想每个矩阵的积 $P\\_i$可以写成如下形式：\n $$P\\_i=A\\_iB\\_i=(α\\_{i1}a+α\\_{i2}b+α\\_{i3}c+α\\_{i4}d)( β\\_{i1}e+β\\_{i2}f+β\\_{i3}g+β\\_{i4}h)$$\n 其中系数α和β都属于集合{-1,0,1},就是说,对矩阵A和B的子矩阵进行加减运算,并对所得的结果进行相乘法来计算出每个子矩阵的乘积.简单说,将子矩阵的乘法运算变成加减运算,从而将8次乘法减少到7次.这是Strassen算法的核心思想和依据.\n\n上面给出的描述很好理解算法的思路和步骤.正如算法导论中对该算法的讨论中所指出的问题,对于矩阵乘法的困难(多项式时间内完成的算法)是合理的.Strassen算法并不是最佳,但目前并没有更多的突破.\n\n2.求解线性方程组(LUP分解思想)\n求解一组同时成立的线性方程式在很多应用中都会出现,也是线性代数的基本问题.可以将一个线性系统表示为一个矩阵方程,其中每个矩阵或向量元素都属于一个域,如实数域R.\nn个未知量的n个方程用矩阵表示如下：\n![matrix3](/images/matrix.png)\n设 $A=(a\\_{ij}),x=(x\\_i),b=(b\\_i)$,有Ax=b.\n\n如果A是非奇异矩阵(秩为n),存在逆矩阵 $A^{-1}$,则 $x= A^{-1}b$,且x是唯一解.方程数目少于未知量数目(或A的秩小于n)为不定方程组,具有无穷多解,如果方程组不相容则可能无解;方程数目多于未知量数目为超定方程组,可能无解.\nLUP分解在求解线性方程组具有数值稳定和速度快的优点.**LUP分解的思想就是找出三个n*n矩阵L、U和P,满足PA=LU,其中L是一个单位下三角矩阵、U是一个上三角矩阵、P是一个置换矩阵.**\n\n定义y=Ux,其中x是要求解的未知向量.用正向替换($O(n^2)$)方法求解Ly=Pb,在用逆向替换($O(n^2)$)方法求解Ux=y,可得：\n\n$$Ax = P^{-1}LUx = P^{-1}Ly = P^{-1}Pb=b$$\n\n问题是如何有效找出LUP呢？只要找出LUP就可以通过正向替换和逆向替换求解x.\n\nLU分解是采用高斯消元法.首先考虑A是nXn的非奇异矩阵,且P等价于$I\\_n$,找出A=LU,矩阵L和U称为A的LU分解.基于LU分解基础上开展LUP分解,数学基础一致,不失一般性而已,增加对置换矩阵P中值为1的元素的刻画.最重要还是要对矩阵运算和高斯消元法的数据基础有初步掌握.LUP分解如下\n```\nlu-decomposition(A)\nn <- rows[A]\nfor k <- 1 to n\n    do u{kk} <- a{kk}\n        for i <- k + 1 to n\n            do l{ik} <- a{ik}/u{kk}\n                u{ki} <- a{ki}\n        for i <- k + 1 to n\n            do for j <- k + 1 to n\n                do a{ij} <- a{ij} - l{ik}u{kj}\nreturn L and U\n```\nLU分解执行过程如下:\n![lu](/images/lu.png)\n\n总结:基于LUP分解矩阵求解线性方程组的方法,同样适用于非奇异矩阵的求逆.矩阵乘法和计算逆矩阵问题具有相同难度的两个问题,在一定技术条件限制下可以使用一个算法在相同渐进时间内解决另外一个问题,即可用Strassen矩阵乘法算法来求一个矩阵的逆.\n\n### Chapter28 线性规划\n怎么样问题可以建模为线性规划来解决呢？在给定的有限的资源和竞争约束情况下,取得最大化或最小化目标的问题.导论中给出政治竞选问题、航空航线调度问题、钻井采油问题.最大化或最小化目标是函数的因变量,自变量就是资源的约束因素,其函数就是由这些制约因素构成的等式或不等式.\n1.线性规划定义.\n> 在一般线性规划问题中,最优化一个满足一组线性不等式约束的线性函数.已知一组实数 $a\\_1,a\\_2, \\dots,a\\_n$和一组变量 $x\\_1,x\\_2, \\dots,x\\_n$,基于这些变量的一个线性函数f定义为\n$$ f(x\\_1,x\\_2, \\dots,x\\_n) = a\\_1x\\_1 + a\\_2x\\_2 + \\dots + a\\_nx\\_n = \\sum\\_{j=1}^n a\\_jx\\_j$$\n> 如果b是一个实数而f是一个线性函数,则等式：\n> $f(x\\_1,x\\_2, \\dots,x\\_n) = b$ 是一个线性等式.\n> $f(x\\_1,x\\_2, \\dots,x\\_n) \\leq b$ 和 $f(x\\_1,x\\_2, \\dots,x\\_n) \\geq b$ 是线性不等式.\n> 线性约束就是函数f和b的关系,就是求解n个变量m个线性不等式的最大化,约束为线性不等式的线性函数最大化称为标准型;而约束为线性等式的线性函数的最大化称为松弛型.\n\n基于上面描述可知,线性规划问题是要最小化或最大化一个受限于一组有限的线性约束的线性函数.最小化线性规划和最大化线性规划的分类,是基于目标的需求,同样是m个线性不等式约束,去求解n个变量的值,达到目标(最大化或最小化).\n\n2.凸形区域定义：\n区域内的任何两点之间连线上的点都属于这个区域.\n线性规划中,二维空间(两个变量)所构成的凸形区域为可行区域,要最大化的函数为目标函数.可行区域内的每个点都会去评估目标函数$x\\_1+x\\_2$,将目标函数的一个特点点上的值称为目标值,识别出一个有最大目标值的点就是最优解.当然有二维线性规划不等式所构成的可行区域上是有无数个点,不可能都去求值,因此需要找出一个有效的方式来寻找最大目标值的点.线性规划的最优解必定是在可行区域的边界上,所以只要沿着边界寻找顶点就可以很快找到最大目标值的点.\n推而广之,如果有三个变量,则每个约束以三位空间的一个半空间来描述,三个半空间的交集构成了可行区域,目标函数取目标值的点集合是一个平面.因为可行区域也是凸的,取得最优目标值的点集合必然包含可行区域的一个顶点.延伸到n个变量的超平面,每个约束定义了n维空间中的一个半空间,这些半空间的交集形成的可行区域称作单纯形,目标函数是一个超平面,且是凸性,一个最优解也是在单纯形的一个顶点上取得.理解下,无论多少维,找出凸形区域,目标函数的最优解就是在凸形区域的顶点集合之一或多个.\n\n3.单纯型算法\n单纯形算法输入一个线性规划(n个变量m个线性不等式),输出一个最优解.算法从单纯形的某个顶点开始,执行一系列迭代,每次迭代中,沿着单纯形的一条边从当前顶点移动到一个目标值不小于当前顶点的相邻顶点.当达到一个局部最大值,即一个顶点的目标值大于其所有相邻顶点的目标值时,算法终止.因为可行区域是凸的且目标函数是线性的,所以具备最优事实就是全局最优的.\n\n单纯形算法需要指数时间.线性规划的第一类多项式时间算法是椭圆算法,运行缓慢;第二类指数时间的算法是内点法,在大型输入上,性能优于单纯形算法.如果在线性规划中,所有的变量都取整数值,即整数线性规划,对于该问题,找出一个可行解是NP难度的.目前还没有已知的多项式时间算法能NP难度问题,所以没有有效的整数线性规划多项式时间算法.当然,一般的线性规划可以在多项式时间内解决.\n\n线性规划的关键步骤:\n1.标准型/松弛型转化\n标准型的线性规划所有的约束条件都是不等式,而松弛型中的约束是等式.要用单纯形算法求解线性规划,需要将所有线性规划转化为标准型,再将标准型转化为松弛型,线性方程组等式求解.\n标准型定义：\n已知n个实数 $c\\_1,c\\_2, \\dots,c\\_n$;m个实数 $b\\_1,b\\_2, \\dots, b\\_m$;以及m * n个实数 $a\\_ij,其中i=1,2,\\dots, m,而j=1,2, \\dots, n$ 希望找出n个实数$x\\_1,x\\_2, \\dots, x\\_n$来最大化目标函数：\n$$ \\sum\\_{j=1}^n c\\_jx\\_j$$\n满足n + m个不等式, 其中n个约束为非负性约束:\n$$ \\sum\\_{j=1}^n a\\_{ij}x\\_j \\leq b\\_i, i = 1,2, \\dots, m\nx\\_j \\geq 0, j= 1, 2, \\dots, n$$\n用矩阵表示更紧凑：\n$$最大化c^Tx,满足约束：Ax \\leq b,x \\geq 0$$\n\n满足所有约束的变量 $x\\_s$设定为可行解,而不满足至少一个约束的变量 $x\\_s$ 设定为不可解.称一个解xs拥有目标值 $c^Tx\\_s$,在所有可行解中其目标值最大的一个可行解 $x\\_s$是一个最优解,称其为目标值 $c^Tx\\_s$的最优目标值.如果一个线性规划没有可行解,则称此线性规划不可行,否则是可行的.如果一个线性规划有一些可行解但没有有限的最优目标值,则称此线性规划是无界的.\n已知一个最小化或最大化的线性函数受若干线性约束,总可以将这个线性规划转换为标准型.换句话说,要将非标准型的线性规划转化为标准型的.为什么会有非标准型的线性规划呢？可能目标函数是一个最小化而不是最大化;可能拥有的变量不具有非负性约束;可能有等式约束;可能有大于等于的不等式约束,而不是小于等于.\n将非标准的线性规划转化线性规划,最重要是确保转换后的线性规划最优解也是转换前的线性规划最优解,转化前后的两个线性规划是等价的.转化思路就是对目标函数系数取负,并将不具有非负约束性的变量转换成具有非负性约束的变量.\n\n为了利用单纯形算法高效地求解线性规划,需要将标准型转换成松弛型,就是非负约束是不等式,其他约束都是等式.转换思路就是利用松弛变量,就是将不等式的余量用s来接收,从而使不等式变成等式,形式如下：\n$$目标函数: z = v + \\sum\\_{j=1}^n c\\_jx\\_j \\\\\\\\\n约束条件(不含变量的非负性约束: b\\_i - \\sum\\_{j=1}^n a\\_{ij}x\\_j = x\\_i$$\n基于松弛型线性规划,就可以用单纯形算法求解.\n\n2.将问题表达为线性规划：建模\n既然定义了线性规划,也知道线性规划可以在多项式时间内求解,那么对于现实的问题,那些事如果形式化为线性规划的问题来求解呢？这就涉及到建模了,现实中的问题如何建模为线性规划来求解.建模：将问题转化成数学形式来求解.\n\n算法导论中对单源最短路径变形的单对最短路径、最大流以及最大流变形的最小费用流和多商品流形式化为线性规划.这里描述下单源最短路径的线性规划形式化\n\n> 在单对最短路径问题中,已知一个带权有向图G=(V,E),加权函数w:E->R将边映射到实数值的权值、一个源顶点s、一个目的顶点t,要计算从s到t的一条最短路径的权值d[t].将该问题用线性规划表示,要确定变量和约束的集合.在Belleman-Ford算法终止时,对每个顶点v,都一个值d[v],使得每条边 $(u,v) \\in E$,有 $d[v] \\leq d[u]+w(u,v)$.源顶点初始得到一个值d[s]=0,如此有计算从s到t的最短路径权值的线性规划：\n最大化：d[t]\n满足约束：$d[v] \\leq d[u]+w(u,v)$,对每条边 $(u,v) \\in E$成立d[s]=0\n共有|V|个变量d[v],每个顶点v∈V各有一个,有|E|+1个约束,每条边各有一个再加上源顶点d[s]=0的额外约束.\n\n3.单纯形算法实现\n单纯形算法是求解线性规划的古典方法.单纯形算法和高斯消元法迭代原理类似,高斯消元法是从解未知的一个线性等式系统开始.可以将单纯形算法看成是线性不等式系统上的高斯消元法.单纯形算法的迭代主要思想是：从线性规划的松弛型中得到每次迭代关联的基本解,将每个非基本变量设为0,并从等式约束中计算基本变量的值;一个基本解对应于单纯形的一个顶点;代数上,一次迭代将一个松弛型转换成一个等价的松弛型;相应的基本解的目标值不小于前一次迭代中的目标值,要实现迭代过程中目标值的递增,要选择一个非基本变量作为指示变量,从0开始增加这个变量的值,和目标值一起增加,增加到某个基本变量变为0为止再重写松弛型,将这个基本变量和所选的非基本变量进行角色互换,就是重写线性规划直到最优解很明显.\n\n单纯形算法主要关键是主元选择,并且有三个关键点:\n* 1.确定线性规划是可行的;\n* 2.确定线性规划是具有可行解而不是无界;\n* 3.主元如何选择换入变量和换出变量.\n\n主元选择算法如下:\n```\npivot(N, B, A, b.c. v, l, e)\n#compute the conefficients of the equation ofr new basic variable x\nb{e} <- b{l}/a{le}\nfor each j in N - {e}\n    do a{ej} <- a{lj}/a{le}\na{el} <- 1/a{le}\n#compute the conefficients of the remaining constraints\nfor each i in B - {l}\n    do b{i} <- b{i} - a{ie}b{e}\n    for eahc j in N - {e}\n        do a{ij} <- a{ij} - a{ie}a{ej}\n    a{il} <- a{ie}a{el}\n#compute the objective function\nv <- v + c{e}b{e}\nfor each j in N - {e}\n    do c{j} <- c{j} - c{e}a{ej}\ncl{e} <- -c{e}a{el}\n#compute new ses of basic and nonbasic variables\nN = N - {e} union {l}\nB = B - {l} union {e}\nreturn (N, B, A, b, c, v)\n\n```\n对标准型的输入来求解最优解的算法描述如下:\n```\nsimple(A, b ,c)\n(N, B, A, b, c, v) <0 initialize-simple(A, b, c)\nwhile some index j in N has c{j} > 0\n    do choose an index e in N for which c{e} > 0\n        for each index i in B\n            do if a{ie} > 0\n                then delta{i} <- b{i}/a{ie}\n                else delta{i} <- INT\n            choose an index l in B that minimizes delta{i}\n            if delta{i} = INT\n                then return \"unbounded\"\n                else (N, B, A, b, c, v) <- pivot(N, B, A, b, c, v, l, e)\nfor i <- 1 to n\n    do if i in B\n        then x{i} <- b{i}\n        else x{i} <- 0\nreturn (x{1}, x{2}, ..., x{n})\n```\n这里一般性地理解下,要通过单纯形算法来求解,在算法之前要肯定线性是可行(单纯性算法最初有一个初始化过程,会判断线性规划是否可行,返回一个初始基本解可行的松弛型),在算法之中要确保不陷入退化或说循环(目标值越迭代越小),能够终止返回最优解.单纯形算法输入一个标准型线性规划,返回线性规划一个最优解,能够顺利找到最优解并终止算法,后续对偶型可以说明.\n\n一个典型的单纯形算法例子：\n> 首先初始化标准型线性规划,返回一个初始基本解可行的松弛型,或者返回这个线性规划不可行,推出算法;其次对松弛型线性规划开始主元操作,选择非负系数最紧约束的换出变量,和换入变量交换,得到新的线性规划(和原来的线性规划是等价的);不断迭代这个过程,直到最优解确定,并终止返回一个最优解.\n对于松弛型线性规划通过主元操作生成的新线性规划,二者是等价的.现在很重要的就是主元操作迭代,是如何选择换出变量的.选择一个在目标函数中系数为正值的非基本变量,尽可能增加其值而不违反任何约束.现在通过一个例子来理解单纯形算法的过程.\n\n1.标准型线性规划转化为松弛型线性规划\n标准型：\n最大化：\n3x1+x2+2x3\n满足约束：\nx1+x2+3x3≤30\n2x1+2x2+5x3≤24\n4x1+x2+2x3≤36\nx1,x2,x3≥0\n\n松弛型：\n最大化：\nz=3x1+x2+2x3\n满足约束：\nx4=30-x1-x2-3x3\nx5=24-2x1-2x2-5x3\nx6=36-4x1-x2-2x3\n\n确定基本解：把等式右边的所有变量设为0,可得基本解(x1,x2,x3,x4, x5, x6)=(0,0,0,30,24,36),目标值z=0;\n\n2.主元操作迭代第一次,选择增加x1的值.当增加x1值时,x4, x5, x6的值随之减小,但每个变量都有非负约束,所以不能减小到负值,这个时候就要在约束函数上选择最紧约束(就是选择最小增加值).\n如果x1值增加到30,那么x4是负值;增加到12,则x5是负值;增加到9,则x6是负值;这个就知道了,9是x1值所能增加的最大值,就是最紧约束,对约束函数x6=36-4x1-x2-2x3互换变量x1和x6的角色,得到：x1=9- x2/4- x3/2- x6/4,代入原线性规划据此可得新的松弛型线性规划,如下：\n最大化：\nz=27+x2/4+ x3/2- 3x6/4\n满足约束：\nx1=9- x2/4- x3/2-x6/4\nx4=21-3x2/4-5x3/2+x6/4\nx5=6-3x2/2-4x3+x6/2\n确定基本解,同样把等式右边的所有变量设为0,可得基本解(x1,x2,x3,x4, x5, x6)=(9,0,0,21,6,0),目标值z=27;\n\n3.主元操作迭代第二次,选择增加x3的值,最紧约束是x5=6-3x2/2-4x3+x6/2,最大增加到3/2,否则x5的值为负,和第一次迭代一样,互换x3和x5并代入线性等式获得新的线性规划,可得基本解(x1,x2,x3, x4, x5,x6)=(33/4,0,3/2,69/4,0,0),目标值z=111/4;\n第四：主元操作迭代第三次,互换x2和x4并代入线性等式获得新的线性规划,可得基本解(x1,x2,x3, x4, x5,x6)=(8,4,0,18,0,0),目标值z=28,为最优解,(x1,x2,x3)=(8,4,0).\n最关心的问题还是具有可行解的线性规划经过这样的迭代,在算法终止时是否确实能找到最优解,这个就留给线性规划对偶性来说明.\n\n4. 单纯形算法分析\n现在我们知道单纯形算法可以在多项式时间内求解线性规划最优解,那么关心两点：\n* 是算法终止时,获得的是最优解,这个就是对偶性要回答;\n* 二是输入一个线性规划要判断出是可行可解的,这个就是辅助线性规划要回答的.\n任何线性规划都可能是不可行的,或是无界的,或有一个优先目标值得最优解,针对这些个情况,单纯形算法要能正确识别.\n\n**线性规划的基本定理**：\n以标准型给出任意的线性规划L可能是以下三者之一：\n第一：有一个有限目标值的最优解;\n第二：不可行;\n第三：无界;\n\n如果L是不可行的,单纯形算法在初始化中就会返回不可行;如果L是无界的,单纯形算法返回无界,无界就是找不到最优解或者有无限个目标值;当然,满足第一情况的,就会返回有限目标值的最优解.\n单纯形算法在初始化过程中,会确定线性规划是否有可行解,如果有,则给出一个基本解可行的松弛型线性规划.这个初始化过程其实就是对线性规划测试可行解.那么是如何来确认存在可行解呢？通过构造辅助线性规划,这个辅助线性规划,比较容易找到一个基本解可行的松弛型.只要辅助线性规划有可行解,则要输入的线性规划也就有可行解.如果线性规划L没有可行解,则初始化返回不可行,否则返回一个基本解可行的合法松弛型.怎么构造辅助线性规划呢？\n\n辅助线性规划：令L是一个标准型的线性规划,令 $L\\_{aux}$是带有n+1个变量的线性规划：\n最小化：-x0\n满足约束：\n$$ \\sum\\_{j-1}^{n} a\\_{ij}x\\_j - x\\_0 \\leq b\\_i, i = 1, 2, \\dots, m \\\\\\\\\nx\\_j \\geq 0, j = 0, 1, \\dots, n\n$$\n则当且仅当 $L\\_{aux}$的最优目标值为0时,L是可行的.\n辅助线性规划,增加一个x0变量,并且令目标值为0.对辅助线性规划求解可行解,也是按照主元操作,将标准型转换成松弛型后不断交换变量迭代.辅助线性规划较容易找到可行解.算法导论中证明了辅助线性规划存在可行解就是要求解的线性规划存在可行解.\n\n现在我们要引进线性规划**对偶性**的概念.对偶性有一个很重要的性质：在一个最优化问题中,一个对偶问题的识别总是可以在一个多项式时间内发现.对偶性是用来证明某个解确实是最优解.还是动态规划思想：已知一个最大化问题,定义个相关的最小化问题,来让着两个问题有相同的最优目标值.如最大流问题的最大流最小割原理.对偶的字面意义,就是我的解也是你的解,大问题的解是小问题的解.\n\n已知一个目标是最大化的线性规划,制定一个对偶线性规划,其目标是最小化,而且最优值与原始线性规划相同.给定一个标准的原线性规划,定义对偶线性规划为：\n$$\n最小化: \\sum\\_{i=1}^{m} b\\_iy\\_i \\\\\\\\\n满足约束: \\sum\\_{i=1}^{m} a\\_{ij}y\\_i \\geq c\\_j, j = 1,2, \\dots, n \\\\\\\\\ny\\_i \\geq 0, i = 1, 2, \\dots, m\n$$\n构造对偶,将最大化改成最小化,将约束右边的与目标函数的稀疏角色互换,并且小于等于号变成大于等于号.在原问题的m个约束中,每一个在对偶问题中都一个对应的变量yi,在对偶问题的n个约束中,每一个在原问题中都一个对应的变量xj.\n\n对偶性能证明最优解主要是两点：\n* 原线性规划中的目标函数的系数变成对偶线性规划中约束函数的右边值,原线性规划中的约束函数的右边值变成对偶线性规划中目标函数的系数;\n* 原线性规划中每一个约束函数的左边等于对偶线性规划中的一个变量,就是原线性规划中的m个约束函数等于m个对偶线性规划中的变量,反之也是.最后证明了对偶线性规划的最优值总是等于原线性规划的最优值.\n\n### Chapter28 寻找子串\n字符串匹配是一个很常见的问题,可以扩展为模式的识别,解决字符串问题的思想被广泛地应用.字符串匹配问题可以描述如下:\n![string-match1](/images/string-match1.png)\n介绍3种解决该问题的办法,包括：最朴素的遍历法,Rabin-Karp算法,自Knuth-Morris-Pratt算法即KMP.\n首先对时间复杂度做出一个概括(从大到小)：\n* 朴素法：$O((n-m+1)m)$;\n* Rabin-Karp：预处理：$O(m)$,匹配：最坏 $O((n-m+1)m)$,但是平均和实际中比这个好得多;\n* KMP：预处理O(m),匹配O(n).\n其中,m代表模式P的长度,n代表被匹配的数组S的长度,Σ代表P和S的字符表.\n\n接下来分开学习对应的算法和思想.\n\n1.朴素法(native)\n```\nnavite-string-matcher(T, P)\nn <- length[T]\nm <- length[P]\nfor s <- 0 to n - m\n    do if p[1...m] = T[s+1...s+m]\n        then print \"Pattern occurs with shift\"\n```\n朴素法简单直接,就是从T的每一个字符开始,看它之后(包括它)的m个字符与P是否一样.P从S中第几个字符开始,可以看作,P在S中位移了几步.\n朴素法的效率低的问题在于,它几乎忽视了所有的信息,每一次匹配都是“全新地”.如果P=abc,S=abdabc,从位置0开始,当我们匹配到 位置2,即c != d,朴素的做法是下一步从位置1开始匹配, 然而,在之前的匹配过程中,我们可以知道位置1的值b必然不匹配位置0的a.这是我们光通过P就能知道的,因为既然前一步已经开始去匹配位置2了,证明说明0和1已经成功匹配,而通过P自己,我们知道P的位置1不匹配0,则前一步的S位置1必然也不匹配P的位置1,这样就可以跳过这一步.问题在于,告诉程序跳过多少步,这就是我们接下来的算法要做的.显然,跳过得越多匹配越快,同时我们为了尽可能得到跳步的信息,可能需要进行预处理,预处理会产生另外的时间.\n\n2.Rabin-Karp\n```\nrabin-karp-matcher(T, P, d, q)\nn <- length[T]\nm <- length[P]\nj <- d^{m-1} mod q\np <- 0\nt{0} <- 0\nfor i <- 1 to m   #预处理\n    do p <- (dp + p[i]) mod q\n        t{0} <- (dt{0} + T[i]) mod q\nfor s <- 0 to n - m  #匹配\n    do if p = t{s}\n        then if P[1..m] = T[s+1...s+m]\n            then print \"Pattern occurs with shift\"s\n        if s <- n - m\n            then t{s+1} <- (d(t{s} - T[s+1]h) + T[s+m+1]) mod q\n```\n执行过程如下:\n![robin-karp](/images/robin-karp.png)\n\n算法将字符串转化为数,进制就是字符表的字符数目.那么,P是一个m位数,这个转化很容易用 $O(m)$ 算出来,通过遍历可以解决.再将S变为n-m+1个数：第一个数同P一样,$O(m)$ 完成预处理;当有了第k个数,算第k+1个数的时候,只需要去掉高位,补上低位,$O(1)$ 完成这个递推过程;总的预处理还是 $O(m)$.匹配的时候就是比较n-m+1次,所以复杂度是 $O(n-m+1)$.那么,为什么说它匹配最坏是 $O((n-m+1)m)$ 呢？\n原因在于这个转化得来的数可能很大,算术运算不是常数,怎么处理大数呢？这个时候可以用模除来做一个简单的hash,匹配的数hash一定匹配,hash匹配原数不一定匹配,需要再回去做检查.最差的情况下,所有的hash都一样,每个hash都匹配了,全部需要回去检查一遍,那么这个时候匹配过程和朴素法一样.工程上来说,通常选取一个较大的素数来做模除.算法的最差运行时间是 $O((n-m+1)m)$, 当素数比模式P长度大很多时,期望运行时间是 $O(n+ m)$.\n\n\n3.KMP\nKMP实际上是利用自动机的思想,但是我们并不是预先算好变迁函数.KMP遇到新字符,如果匹配当然是下一个状态,不匹配的话并不像自动机一步到位地接收新字符后到另一个状态,而是先到另一个状态,再递归地看是否接收这个字符,最终接收后在看下一个字符.关键在于,不匹配时,改变状态时是带着新字符还是不带.那么辅助的数组(数组也好,函数也好,总归还是查表),就从多维降到一维,多维是因为自动机遇到不同新字符跳到不同的状态,一维是KMP遇到新字符不匹配时直接跳到另一个状态,跳的时候不考虑新字符.直观上看,构建这样的数组也不再需要遍历Σ,预处理过程复杂度应该会降低.事实,确实省去了O(|Σ|)的复杂度,降到O(m)复杂度.同时,匹配时的复杂度还保持在了O(n).分析复杂度用到平摊分析法.\n匹配过程是简单直观的,如前所述,遇到新字符,借助辅助数组π不断地改变状态.伪代码乳如下：\n```\nkmp-matcher(T,P)\nn <- length[T]\nm <- length[P]\nπ <- kmp-computer-prefix(P)\nq <- 0               // state , number of char matched\nfor i <- 1 to n\n    while q > 0 && P[q+1] != T[i]  // P and T range from 1 to n, not 0 to n-1\n        do q <- π[q]\n        if P[q+1] = T[i]\n            then q <- q+1\n        if q = m\n            then print \"Pattern occurs with shift\" i-m\n                q <- π[q]\n```\n那么,问题的关键还是在于计算辅助数组π,即状态如何转移.这里KMP计算的时候,从P的低位(左边)开始计算π,显然只会用到前面低位的信息,不会用到后面高位的信息.那么利用动态规划中利用记录减少迭代的思想,再把计算π的过程看做与匹配过程类似,比如计算q+1那么就是用Pq去匹配Pq+1嘛,而Pq的数组π已经建立好了.\n```\nkmp-computer-prefix(P)\n\nm <- length[P]\nπ[1] <- 0\nk <- 0               // just like q above, number of char matched\nfor q <-  2 to m     // like i above, and actually it is state, so its name is q\n    while k>0 && P[k+1] != P[q]  // P range from 1 to n, not 0 to n-1\n        do k <- π[k]\n        if P[k+1] = P[q]\n            then k <- k+1\n        π[q] <- k\nreturn π\n```\nkmp算法执行如下:\n![kmp1](/images/kmp1.png)\n![kmp2](/images/kmp2.png)\n","slug":"CLRS-notes6","published":1,"updated":"2017-08-26T03:38:21.614Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6sslhax000b3gamd5om0wu8","content":"<h1 id=\"＜Introduction-to-algorithms＞笔记\"><a href=\"#＜Introduction-to-algorithms＞笔记\" class=\"headerlink\" title=\"＜Introduction to algorithms＞笔记\"></a>＜Introduction to algorithms＞笔记</h1><h2 id=\"Part7-高级算法问题\"><a href=\"#Part7-高级算法问题\" class=\"headerlink\" title=\"Part7 高级算法问题\"></a>Part7 高级算法问题</h2><p>在part1-6学习基本的数据结构和算法问题后, part7不再集中于对一个算法问题专题进行学习, 而是就不同的高级算法问题进行基本的介绍,其其覆盖的内容十分全面,涉及一下几个领域:</p>\n<ul>\n<li>排序网络</li>\n<li>矩阵运算</li>\n<li>线性规划</li>\n<li>字符串匹配</li>\n</ul>\n<h3 id=\"Chapter26-如何利用多核来并行排序\"><a href=\"#Chapter26-如何利用多核来并行排序\" class=\"headerlink\" title=\"Chapter26 如何利用多核来并行排序?\"></a>Chapter26 如何利用多核来并行排序?</h3><p>在part2中学习了基本的排序算法,包括插入,快排,归并,堆排序等,它们都是在串行计算机上线性执行的算法.随着硬件的发展,多处理器的进步,如何利用多核来进行并行排序?如何推而广之到多核并行算法?这一章就套路基于计算的一种比较网络模型,同时进行多个比较操作.</p>\n<p>比较网络与串行排序算法的区别:</p>\n<ul>\n<li>比较网络只能执行比较操作, 即只能执行基于比较操作的算法.因此part2中学习的计数排序就无法再比较网络中实现</li>\n<li>比较网络中比较操作可以并行的执行, 而串行排序算法各操作是依次执行的.故前者拥有更好的算法效率- 更小的算法复杂度</li>\n</ul>\n<p>1.比较网络定义</p>\n<ul>\n<li>组成：<br>基本构件:线路和比较器<br><img src=\"/images/comparsion.png\" alt=\"comparsion\"></li>\n</ul>\n<a id=\"more\"></a>\n<ul>\n<li>比较网络含义：</li>\n<li>一个由线路互相联接着的比较器的集合,我们把具有n个输入的比较网络画成一个由n条水平线组成的图,比较器则垂直地与两条水平线相连接.每个比较器的输入端要么与网络的n条输入线路 $a_1,a_2, \\dots, a_n$ 中的一条相连,要么与另一个比较器的输出端相连接.类似地,每个比较器的输出端要么与网络的n条输出线路 $b_1,b_2, \\dots, b_n$中的一条相连,要么与另一个比较器的输入端相连接.互相连接的比较器主要应满足如下要求：<blockquote>\n<ol>\n<li>其互相连接所成的图中必须没有回路.</li>\n<li>只有当同时有两个输入时,比较器才能产生输出值.</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<p>在每个比较器均运行单位时间的假设下,我们可以对比较网络的“运行时间”作出定义,这就是从输入线路接收到其值的时刻到所有输出线路收到其值所花费的时间.</p>\n<ul>\n<li><p>比较网络示意图:<br><img src=\"/images/sortnet.png\" alt=\"sortnet\"></p>\n</li>\n<li><p>排序网络定义:<br>对每个输入序列其输出序列均为单调递增(即 $b_1 \\leq<br>b_2, \\dots, b_n$ )的一种比较网络</p>\n</li>\n<li><p>0-1原理：<br>如果一个具有n个输入的比较网络,能够对所有可能存在的2^n个0和1组成的序列进行正确的排序,则对所有任意数组成的序列,该比较网络也可能对其正确排序.<br>0-1原理推定认为：如果对于属于集合{0,1}的每个输入值,排序网络都能正确运行,则对任意输入值,它也能争取而运行(输入值可以是整数、实数或者任意线性排序的值的集合).这样在构造排序网络时,可以专注在0和1组成的输入序列上设计比较器.这个原理目的是简化输入值,而通过0和1来设计比较网络的线路和比较器,只要0和1可运行,那么其他任意值的序列也都可以运行.<br>0-1原理的证明依赖单调递增函数.如果比较网络把输入序列 $a=<a\\_1,a\\_2, \\dots,=\"\" a\\_n=\"\">$ 转化为输出序列 $b=<b\\_1,b\\_2, \\dots,=\"\" b\\_n=\"\">$,则对任意单调递增函数f,该网络把输入序列f(a)=<f(a1),f(a2),…,f(an)>转化为输出序列f(b)=<f(b1),f(b2),…,f(bn)>.<br>这个可以这样理解,对输入序列a施以f(a)单调递增函数,比较网络(线路和比较器)能够使序列a输出序列b,那么该比较网络同样可以使输入序列f(a)输出序列f(b).<br>这就为0-1原理奠定了基础,只要证明比较网络可以运行于0和1的输入,那么设计一个单调递增函数,0和1是因变量,其自变量自然也可以通过同样比较网络来排序.<br>如果一个具有n个输入的比较网络能够对所有可能存在的2n个0和1组成的序列进行正确的排序,则对所有任意数组成的序列,该比较网络也可能对其正确排序.<br>0-1原理证明用到了单调递增函数概念,同时采用数学归纳法和反证法来证明.这也给出了一个很重要的思想,那就是对现实问题的解决,在构建数学模型时,可以简单到0-1,然后再推广到复杂数.</f(b1),f(b2),…,f(bn)></f(a1),f(a2),…,f(an)></b\\_1,b\\_2,></a\\_1,a\\_2,></p>\n</li>\n<li><p>双调序列：<br>序列要么先单调递增然后再单调递减,要么先单调递减然后又单调递增.例如序列<1,4,6,8,3,2>和<9,8,3,2,4,6>都是双调的</9,8,3,2,4,6></1,4,6,8,3,2></p>\n</li>\n</ul>\n<p>2.双调排序网络</p>\n<ul>\n<li><p>双调排序程序由 $log_2n$个阶段组成,其中每一个阶段称为一个半清洁器.每个半清洁器是一个深度为1的比较网络,其中输入线I与输入线I+n/2进行比较,I=1,2,…,n/2(这里假设n为偶数).下图即为一个具有8个输入和8个输出的半清洁器(half-cleaner)<br><img src=\"/images/half-cleaner.png\" alt=\"half-cleaner\"></p>\n</li>\n<li><p>当由0和1组成的双调序列用作半清洁器的输入时,半清洁器产生的输出序列满足如下条件：</p>\n<blockquote>\n<ol>\n<li>较小的值位于输出的上半部,较大的值位于输出的下半部.</li>\n<li>两部分序列仍是双调的.</li>\n<li>两部分序列中至少有一个是清洁的——全由0或1组成.</li>\n</ol>\n</blockquote>\n</li>\n<li><p>双调排序器(bitonic-sorter)<br>通过递归地连接半清洁器,我们可以建立一个双调排序网络.双调排序网络[n]的第一阶段由半清洁器[n]组成,可知半清洁器[n]产生两个规模缩小一半的双调序列且满足上半部分的每个元素不比下半部分的任一个元素大.因此,我们可以运用两个双调排序网络[n/2]分别对两部分递归地进行排序,以此完成整个排序工作<br><img src=\"/images/bitonic-sorter.png\" alt=\"bitonic-sorter\"></p>\n</li>\n</ul>\n<p>我们只要把含n个元素的双调排序网络的第一个半清洁器修改一下就可以得到合并网络MERGER[n].由于输入的上半部和下半部都是单调递增的,所以我们把比较网络的下半部分颠倒一下,输入就成了一个双调序列.添上半清洁器,再颠倒回去,半清洁器就变成了把输入 $a_i$和$a_{n-i+1}比较.这时,输出也被颠倒了.但是,一个双调序列颠倒了以后还是一个双调序列.<br>因此就可以用<em>bitonic-sorter</em>对深度为 $\\log n$ 的0-1双调序列进行排序.<br><img src=\"/images/bitonic-sorter2.png\" alt=\"bitonic-sorter2\"></p>\n<p>3.合并网络(mergin network)<br>合并网络,能够把两个已排序的输入序列合并为一个有序的输出序列的网络.基于双调排序网络思想,对已知的两个有序序列进行连接(第二个序列顺序颠倒),所得的序列是双调序列,再利用双调排序器就能完成两个有序序列的合并.其原理如下:<br><img src=\"/images/merger1.png\" alt=\"merger1\"><br><img src=\"/images/merger2.png\" alt=\"merger2\"></p>\n<p>4.基于0-1原理、双调排序网络、合并网络,我们可以构造一个输入任意序列进行排序的比较排序网络.思想很简单：第一步开展最基础的2个元素的两两比较,这个用普通的比较器就可以实现,输出长度为2的有序序列;第二步对长度为2的有序序列进行两两合并,这个用合并网络排序(基于双调排序器,先连接序列构造双调序列)实现,输出长度为4的有序序列;第三步对长度为4的有序序列进行合并网络,直到 $\\log n$次.算法上,可以在 $O(\\log n)$内并行地对n个数进行排序.<br><img src=\"/images/sorter.png\" alt=\"sorter\"></p>\n<p>总结:排序网络可以并行地进行排序,然后再组合各并行排序结果,适合分布式场景的排序需求.</p>\n<h3 id=\"Chapter27-矩阵运算\"><a href=\"#Chapter27-矩阵运算\" class=\"headerlink\" title=\"Chapter27 矩阵运算\"></a>Chapter27 矩阵运算</h3><p>在part4高级设计技术中在动态规划中研究了矩阵链乘法问题后, 这一章深入学习矩阵运算, 特别学习矩阵相乘的Strasssen算法,该算法能在 $O(n^{\\log 7})$ 的时间内计算两个 $n*n$ 的矩阵的乘积.</p>\n<p>1.首先重温下矩阵的相关概念和性质,为后续矩阵运算奠定数据理论基础.</p>\n<p>矩阵A：<br>数字的一个矩形阵列,形式化为 $A=(a_{ij})$,第i行j列元素为 $a_ij$,如元素为实数的所有元素mXn矩阵组合的元素用 $R_{mXn}$表示.<br><img src=\"/images/matrix.png\" alt=\"matrix\"></p>\n<p>矩阵转置AT：是矩阵A的行和列互相交换而产生的矩阵.</p>\n<p>向量(Vector)：是数字的一维向量,列向量看成是nX1的矩阵,转置成行向量就是1Xn的矩阵.</p>\n<p>单位向量$e_i$：矩阵第一个元素为1而其他元素均为0的常量.</p>\n<p>零矩阵：所有元素都是0的矩阵.</p>\n<p>对角矩阵：当i≠j时,$a_ij$,所有非对角线上的元素均为0.</p>\n<p>nXn单位矩阵 $I_n$：是对角线元素都是1的对角矩阵.</p>\n<p>三对角矩阵T：满足 $|i-j|&gt;1$ 的元素 $t_ij$=0的矩阵,非零元素仅出现在主对角线上、靠主对角线上面和对角线下面.</p>\n<p>上三角矩阵U：满足i&gt;j的元素 $U_ij=0$的矩阵,对角线下面的所有元素均为0,若对角线元素为1,则是单位上三角矩阵.</p>\n<p>下三角矩阵L：满足i&lt;j的元素 $L_ij=0$的矩阵,对角线上面的所有元素均为0,若对角线元素为1,则是单位下三角矩阵.</p>\n<p>置换矩阵P：每一行或列中仅包含一个1,其他元素都为0,可以把一个向量x和一个置换矩阵相乘,结果是向量x中的元素的一种置换.</p>\n<p>对称矩阵A：满足条件 $A= A^T$.</p>\n<p>矩阵加法：$C(c_ij)=A(a_ij)+B(b_ij),c_ij=a_ij+b_ij$,都是mXn矩阵.</p>\n<p>矩阵乘法：相容(A的列数等于B的行数)的两个矩阵才可以相乘,$C(c_ij)= \\sum_{k=1}^{m} A(a_ik)*B(b_kj)$,矩阵和单位矩阵等于自己、和零矩阵相乘等于零、和向量相乘得到向量,满足结合律和分配律,但不满足交换律.</p>\n<p>逆矩阵A-1：满足 $A A^{-1} = I_n= A^{-1}A$,不可逆的矩阵称为奇异矩阵.</p>\n<p>线性相关：设 $x_1,x_2, \\dots, x_n$是n个向量,若存在不全为零的常系数 $c_1,c_2, \\dots, c_n$,使 $c_1x_1+c_2x_2+ \\dots +c_nx_n=0$成立,就称 $x_1,x_2, \\dots, x_n$线性相关.</p>\n<p>非零mXn矩阵A的秩：A的极大线性无关列向量组中向量的个数为列秩,A的极大线性无关行向量组中向量的个数为列秩.任意一个矩阵的行秩和列秩都是相等.mXn的秩是0和min(m,n)之间的一个整数.</p>\n<p>非零mXn矩阵A的秩满足下列条件的最小的数r：存在mXr矩阵B和rXn矩阵C且有A=BC.如果一个nXn的矩阵秩为n,则是满秩,如果一个mXn矩阵的秩为n,则是列满秩.<br>一个方阵满秩当且仅当它为非奇异矩阵.当前仅当A无空向量时,矩阵A为列满秩.<br>当且仅当A具有空向量时,方阵A是奇异的.</p>\n<p>余子式：对于n&gt;1,nXn矩阵A的第ij个余子式是把A的第i行和第j列元素去掉后所形成的一个(n-1)X(n-1)矩阵A[ij],表示为det(A[ij]).</p>\n<p>方阵A的行列式具有如下性质：如果A的任何行或列的元素为0,则det(A)=0;用常如a乘A的行列式任意一行(或任意一列)的诸元素,等于用a乘A的行列式;A的行列式中的一行(或一列)元素加上另一行(或另一列)中的相应元素,行列式的值不变;A的行列式值与其转置矩阵AT的行列式的值相等;行列式的任意两行(或两列)互换,则其值异号.</p>\n<p>正定矩阵：nXn矩阵A,如果对所有n维向量x≠0都有$x^TAx&gt;0$,则矩阵A为正定矩阵.</p>\n<p>对任意列满秩矩阵A,矩阵$A^TA$是正定的.</p>\n<p>2.矩阵乘法的Strassen算法<br>矩阵乘法是种极其耗时的运算.以C = AB为例,其中A和B都是 n x n 的矩阵.根据矩阵乘法的定义,计算过程如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">SQUARE-MATRIX-MULTIPLY(A, B)</div><div class=\"line\">n = A.rows</div><div class=\"line\">let C be a new nxn matrix</div><div class=\"line\">for i = 1 to n</div><div class=\"line\">    for j = 1 to n</div><div class=\"line\">        c[i][j] = 0</div><div class=\"line\">        for k = 1 to n</div><div class=\"line\">            c[i][j] += a[i][k] * b[k][j]</div><div class=\"line\">return C</div></pre></td></tr></table></figure></p>\n<p>由于存在三层循环,它的时间复杂度将达到 $O(n^3)$.<br>Strassen算法运用分治法将两个nXn的矩阵乘积运行时间,从简易矩阵乘法算法 $O(n^3)$提升到 $O(n^{\\log 7}) = O(n^{2.81})$.下面是算法的主要思想和步骤.</p>\n<blockquote>\n<p>一般情况下,矩阵乘积C=AB,其中A、B和C都是nXn方阵,假定n是2的幂,把A、B和C划分成四个n/2Xn/2矩阵：<br><img src=\"/images/matrix.png\" alt=\"matrix2\"><br>则矩阵乘法对应四个等式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">r=ae+bg</div><div class=\"line\">s=af+bh</div><div class=\"line\">t=ce+dg</div><div class=\"line\">u=cf+dh</div></pre></td></tr></table></figure></p>\n<p>每个等式运行包含两次 $n/2 <em> n/2$矩阵乘法和两次乘积所得的 $n/2 </em> n/2$矩阵的加法运算,推出 $n * n$ 矩阵相乘所需时间T(n)的递归式：<br>$$T(n)=8T(n/2)+  O(n^2)$$</p>\n</blockquote>\n<p>Strassen算法在这个一般性的递归式上,发现只需要进行7次 $n/2 * n/2$矩阵乘法即可解决,即<br>$$T(n)=7T(n/2)+O(n^2)= O(n^{\\log 7}) = O(n^{2.81})$$<br>具体算法步骤如下：</p>\n<ul>\n<li>1.输入矩阵A和B划分为 $n/2 * n/2$的子矩阵;</li>\n<li>2.运行 $O(n^2)$标量加法和减法运算,计算出14个 $n/2 * n/2$的矩阵 $A_1,B_1,A_2,B_2, \\dots, A_7,B_7$;</li>\n<li>3.递归计算出7个矩阵的乘积 $P_i=A_i * B_i,i=1,2, \\dots, 7$;</li>\n<li>4.使用 $O(n^2)$ 次标量加法与减法运算,对 $P_i$ 矩阵的各种组合进行求和或求差运算,从而获得结果矩阵C的四个子矩阵r\\s\\t\\u.</li>\n</ul>\n<p>Strassen算法的核心思想是什么呢？何以产生如此一个步骤的算法呢？依据是什么？<br>设想每个矩阵的积 $P_i$可以写成如下形式：<br> $$P_i=A_iB_i=(α_{i1}a+α_{i2}b+α_{i3}c+α_{i4}d)( β_{i1}e+β_{i2}f+β_{i3}g+β_{i4}h)$$<br> 其中系数α和β都属于集合{-1,0,1},就是说,对矩阵A和B的子矩阵进行加减运算,并对所得的结果进行相乘法来计算出每个子矩阵的乘积.简单说,将子矩阵的乘法运算变成加减运算,从而将8次乘法减少到7次.这是Strassen算法的核心思想和依据.</p>\n<p>上面给出的描述很好理解算法的思路和步骤.正如算法导论中对该算法的讨论中所指出的问题,对于矩阵乘法的困难(多项式时间内完成的算法)是合理的.Strassen算法并不是最佳,但目前并没有更多的突破.</p>\n<p>2.求解线性方程组(LUP分解思想)<br>求解一组同时成立的线性方程式在很多应用中都会出现,也是线性代数的基本问题.可以将一个线性系统表示为一个矩阵方程,其中每个矩阵或向量元素都属于一个域,如实数域R.<br>n个未知量的n个方程用矩阵表示如下：<br><img src=\"/images/matrix.png\" alt=\"matrix3\"><br>设 $A=(a_{ij}),x=(x_i),b=(b_i)$,有Ax=b.</p>\n<p>如果A是非奇异矩阵(秩为n),存在逆矩阵 $A^{-1}$,则 $x= A^{-1}b$,且x是唯一解.方程数目少于未知量数目(或A的秩小于n)为不定方程组,具有无穷多解,如果方程组不相容则可能无解;方程数目多于未知量数目为超定方程组,可能无解.<br>LUP分解在求解线性方程组具有数值稳定和速度快的优点.<strong>LUP分解的思想就是找出三个n*n矩阵L、U和P,满足PA=LU,其中L是一个单位下三角矩阵、U是一个上三角矩阵、P是一个置换矩阵.</strong></p>\n<p>定义y=Ux,其中x是要求解的未知向量.用正向替换($O(n^2)$)方法求解Ly=Pb,在用逆向替换($O(n^2)$)方法求解Ux=y,可得：</p>\n<p>$$Ax = P^{-1}LUx = P^{-1}Ly = P^{-1}Pb=b$$</p>\n<p>问题是如何有效找出LUP呢？只要找出LUP就可以通过正向替换和逆向替换求解x.</p>\n<p>LU分解是采用高斯消元法.首先考虑A是nXn的非奇异矩阵,且P等价于$I_n$,找出A=LU,矩阵L和U称为A的LU分解.基于LU分解基础上开展LUP分解,数学基础一致,不失一般性而已,增加对置换矩阵P中值为1的元素的刻画.最重要还是要对矩阵运算和高斯消元法的数据基础有初步掌握.LUP分解如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">lu-decomposition(A)</div><div class=\"line\">n &lt;- rows[A]</div><div class=\"line\">for k &lt;- 1 to n</div><div class=\"line\">    do u&#123;kk&#125; &lt;- a&#123;kk&#125;</div><div class=\"line\">        for i &lt;- k + 1 to n</div><div class=\"line\">            do l&#123;ik&#125; &lt;- a&#123;ik&#125;/u&#123;kk&#125;</div><div class=\"line\">                u&#123;ki&#125; &lt;- a&#123;ki&#125;</div><div class=\"line\">        for i &lt;- k + 1 to n</div><div class=\"line\">            do for j &lt;- k + 1 to n</div><div class=\"line\">                do a&#123;ij&#125; &lt;- a&#123;ij&#125; - l&#123;ik&#125;u&#123;kj&#125;</div><div class=\"line\">return L and U</div></pre></td></tr></table></figure></p>\n<p>LU分解执行过程如下:<br><img src=\"/images/lu.png\" alt=\"lu\"></p>\n<p>总结:基于LUP分解矩阵求解线性方程组的方法,同样适用于非奇异矩阵的求逆.矩阵乘法和计算逆矩阵问题具有相同难度的两个问题,在一定技术条件限制下可以使用一个算法在相同渐进时间内解决另外一个问题,即可用Strassen矩阵乘法算法来求一个矩阵的逆.</p>\n<h3 id=\"Chapter28-线性规划\"><a href=\"#Chapter28-线性规划\" class=\"headerlink\" title=\"Chapter28 线性规划\"></a>Chapter28 线性规划</h3><p>怎么样问题可以建模为线性规划来解决呢？在给定的有限的资源和竞争约束情况下,取得最大化或最小化目标的问题.导论中给出政治竞选问题、航空航线调度问题、钻井采油问题.最大化或最小化目标是函数的因变量,自变量就是资源的约束因素,其函数就是由这些制约因素构成的等式或不等式.<br>1.线性规划定义.</p>\n<blockquote>\n<p>在一般线性规划问题中,最优化一个满足一组线性不等式约束的线性函数.已知一组实数 $a_1,a_2, \\dots,a_n$和一组变量 $x_1,x_2, \\dots,x_n$,基于这些变量的一个线性函数f定义为<br>$$ f(x_1,x_2, \\dots,x_n) = a_1x_1 + a_2x_2 + \\dots + a_nx_n = \\sum_{j=1}^n a_jx_j$$<br>如果b是一个实数而f是一个线性函数,则等式：<br>$f(x_1,x_2, \\dots,x_n) = b$ 是一个线性等式.<br>$f(x_1,x_2, \\dots,x_n) \\leq b$ 和 $f(x_1,x_2, \\dots,x_n) \\geq b$ 是线性不等式.<br>线性约束就是函数f和b的关系,就是求解n个变量m个线性不等式的最大化,约束为线性不等式的线性函数最大化称为标准型;而约束为线性等式的线性函数的最大化称为松弛型.</p>\n</blockquote>\n<p>基于上面描述可知,线性规划问题是要最小化或最大化一个受限于一组有限的线性约束的线性函数.最小化线性规划和最大化线性规划的分类,是基于目标的需求,同样是m个线性不等式约束,去求解n个变量的值,达到目标(最大化或最小化).</p>\n<p>2.凸形区域定义：<br>区域内的任何两点之间连线上的点都属于这个区域.<br>线性规划中,二维空间(两个变量)所构成的凸形区域为可行区域,要最大化的函数为目标函数.可行区域内的每个点都会去评估目标函数$x_1+x_2$,将目标函数的一个特点点上的值称为目标值,识别出一个有最大目标值的点就是最优解.当然有二维线性规划不等式所构成的可行区域上是有无数个点,不可能都去求值,因此需要找出一个有效的方式来寻找最大目标值的点.线性规划的最优解必定是在可行区域的边界上,所以只要沿着边界寻找顶点就可以很快找到最大目标值的点.<br>推而广之,如果有三个变量,则每个约束以三位空间的一个半空间来描述,三个半空间的交集构成了可行区域,目标函数取目标值的点集合是一个平面.因为可行区域也是凸的,取得最优目标值的点集合必然包含可行区域的一个顶点.延伸到n个变量的超平面,每个约束定义了n维空间中的一个半空间,这些半空间的交集形成的可行区域称作单纯形,目标函数是一个超平面,且是凸性,一个最优解也是在单纯形的一个顶点上取得.理解下,无论多少维,找出凸形区域,目标函数的最优解就是在凸形区域的顶点集合之一或多个.</p>\n<p>3.单纯型算法<br>单纯形算法输入一个线性规划(n个变量m个线性不等式),输出一个最优解.算法从单纯形的某个顶点开始,执行一系列迭代,每次迭代中,沿着单纯形的一条边从当前顶点移动到一个目标值不小于当前顶点的相邻顶点.当达到一个局部最大值,即一个顶点的目标值大于其所有相邻顶点的目标值时,算法终止.因为可行区域是凸的且目标函数是线性的,所以具备最优事实就是全局最优的.</p>\n<p>单纯形算法需要指数时间.线性规划的第一类多项式时间算法是椭圆算法,运行缓慢;第二类指数时间的算法是内点法,在大型输入上,性能优于单纯形算法.如果在线性规划中,所有的变量都取整数值,即整数线性规划,对于该问题,找出一个可行解是NP难度的.目前还没有已知的多项式时间算法能NP难度问题,所以没有有效的整数线性规划多项式时间算法.当然,一般的线性规划可以在多项式时间内解决.</p>\n<p>线性规划的关键步骤:<br>1.标准型/松弛型转化<br>标准型的线性规划所有的约束条件都是不等式,而松弛型中的约束是等式.要用单纯形算法求解线性规划,需要将所有线性规划转化为标准型,再将标准型转化为松弛型,线性方程组等式求解.<br>标准型定义：<br>已知n个实数 $c_1,c_2, \\dots,c_n$;m个实数 $b_1,b_2, \\dots, b_m$;以及m * n个实数 $a_ij,其中i=1,2,\\dots, m,而j=1,2, \\dots, n$ 希望找出n个实数$x_1,x_2, \\dots, x_n$来最大化目标函数：<br>$$ \\sum_{j=1}^n c_jx_j$$<br>满足n + m个不等式, 其中n个约束为非负性约束:<br>$$ \\sum_{j=1}^n a_{ij}x_j \\leq b_i, i = 1,2, \\dots, m<br>x_j \\geq 0, j= 1, 2, \\dots, n$$<br>用矩阵表示更紧凑：<br>$$最大化c^Tx,满足约束：Ax \\leq b,x \\geq 0$$</p>\n<p>满足所有约束的变量 $x_s$设定为可行解,而不满足至少一个约束的变量 $x_s$ 设定为不可解.称一个解xs拥有目标值 $c^Tx_s$,在所有可行解中其目标值最大的一个可行解 $x_s$是一个最优解,称其为目标值 $c^Tx_s$的最优目标值.如果一个线性规划没有可行解,则称此线性规划不可行,否则是可行的.如果一个线性规划有一些可行解但没有有限的最优目标值,则称此线性规划是无界的.<br>已知一个最小化或最大化的线性函数受若干线性约束,总可以将这个线性规划转换为标准型.换句话说,要将非标准型的线性规划转化为标准型的.为什么会有非标准型的线性规划呢？可能目标函数是一个最小化而不是最大化;可能拥有的变量不具有非负性约束;可能有等式约束;可能有大于等于的不等式约束,而不是小于等于.<br>将非标准的线性规划转化线性规划,最重要是确保转换后的线性规划最优解也是转换前的线性规划最优解,转化前后的两个线性规划是等价的.转化思路就是对目标函数系数取负,并将不具有非负约束性的变量转换成具有非负性约束的变量.</p>\n<p>为了利用单纯形算法高效地求解线性规划,需要将标准型转换成松弛型,就是非负约束是不等式,其他约束都是等式.转换思路就是利用松弛变量,就是将不等式的余量用s来接收,从而使不等式变成等式,形式如下：<br>$$目标函数: z = v + \\sum_{j=1}^n c_jx_j \\\\<br>约束条件(不含变量的非负性约束: b_i - \\sum_{j=1}^n a_{ij}x_j = x_i$$<br>基于松弛型线性规划,就可以用单纯形算法求解.</p>\n<p>2.将问题表达为线性规划：建模<br>既然定义了线性规划,也知道线性规划可以在多项式时间内求解,那么对于现实的问题,那些事如果形式化为线性规划的问题来求解呢？这就涉及到建模了,现实中的问题如何建模为线性规划来求解.建模：将问题转化成数学形式来求解.</p>\n<p>算法导论中对单源最短路径变形的单对最短路径、最大流以及最大流变形的最小费用流和多商品流形式化为线性规划.这里描述下单源最短路径的线性规划形式化</p>\n<blockquote>\n<p>在单对最短路径问题中,已知一个带权有向图G=(V,E),加权函数w:E-&gt;R将边映射到实数值的权值、一个源顶点s、一个目的顶点t,要计算从s到t的一条最短路径的权值d[t].将该问题用线性规划表示,要确定变量和约束的集合.在Belleman-Ford算法终止时,对每个顶点v,都一个值d[v],使得每条边 $(u,v) \\in E$,有 $d[v] \\leq d[u]+w(u,v)$.源顶点初始得到一个值d[s]=0,如此有计算从s到t的最短路径权值的线性规划：<br>最大化：d[t]<br>满足约束：$d[v] \\leq d[u]+w(u,v)$,对每条边 $(u,v) \\in E$成立d[s]=0<br>共有|V|个变量d[v],每个顶点v∈V各有一个,有|E|+1个约束,每条边各有一个再加上源顶点d[s]=0的额外约束.</p>\n</blockquote>\n<p>3.单纯形算法实现<br>单纯形算法是求解线性规划的古典方法.单纯形算法和高斯消元法迭代原理类似,高斯消元法是从解未知的一个线性等式系统开始.可以将单纯形算法看成是线性不等式系统上的高斯消元法.单纯形算法的迭代主要思想是：从线性规划的松弛型中得到每次迭代关联的基本解,将每个非基本变量设为0,并从等式约束中计算基本变量的值;一个基本解对应于单纯形的一个顶点;代数上,一次迭代将一个松弛型转换成一个等价的松弛型;相应的基本解的目标值不小于前一次迭代中的目标值,要实现迭代过程中目标值的递增,要选择一个非基本变量作为指示变量,从0开始增加这个变量的值,和目标值一起增加,增加到某个基本变量变为0为止再重写松弛型,将这个基本变量和所选的非基本变量进行角色互换,就是重写线性规划直到最优解很明显.</p>\n<p>单纯形算法主要关键是主元选择,并且有三个关键点:</p>\n<ul>\n<li>1.确定线性规划是可行的;</li>\n<li>2.确定线性规划是具有可行解而不是无界;</li>\n<li>3.主元如何选择换入变量和换出变量.</li>\n</ul>\n<p>主元选择算法如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">pivot(N, B, A, b.c. v, l, e)</div><div class=\"line\">#compute the conefficients of the equation ofr new basic variable x</div><div class=\"line\">b&#123;e&#125; &lt;- b&#123;l&#125;/a&#123;le&#125;</div><div class=\"line\">for each j in N - &#123;e&#125;</div><div class=\"line\">    do a&#123;ej&#125; &lt;- a&#123;lj&#125;/a&#123;le&#125;</div><div class=\"line\">a&#123;el&#125; &lt;- 1/a&#123;le&#125;</div><div class=\"line\">#compute the conefficients of the remaining constraints</div><div class=\"line\">for each i in B - &#123;l&#125;</div><div class=\"line\">    do b&#123;i&#125; &lt;- b&#123;i&#125; - a&#123;ie&#125;b&#123;e&#125;</div><div class=\"line\">    for eahc j in N - &#123;e&#125;</div><div class=\"line\">        do a&#123;ij&#125; &lt;- a&#123;ij&#125; - a&#123;ie&#125;a&#123;ej&#125;</div><div class=\"line\">    a&#123;il&#125; &lt;- a&#123;ie&#125;a&#123;el&#125;</div><div class=\"line\">#compute the objective function</div><div class=\"line\">v &lt;- v + c&#123;e&#125;b&#123;e&#125;</div><div class=\"line\">for each j in N - &#123;e&#125;</div><div class=\"line\">    do c&#123;j&#125; &lt;- c&#123;j&#125; - c&#123;e&#125;a&#123;ej&#125;</div><div class=\"line\">cl&#123;e&#125; &lt;- -c&#123;e&#125;a&#123;el&#125;</div><div class=\"line\">#compute new ses of basic and nonbasic variables</div><div class=\"line\">N = N - &#123;e&#125; union &#123;l&#125;</div><div class=\"line\">B = B - &#123;l&#125; union &#123;e&#125;</div><div class=\"line\">return (N, B, A, b, c, v)</div></pre></td></tr></table></figure></p>\n<p>对标准型的输入来求解最优解的算法描述如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">simple(A, b ,c)</div><div class=\"line\">(N, B, A, b, c, v) &lt;0 initialize-simple(A, b, c)</div><div class=\"line\">while some index j in N has c&#123;j&#125; &gt; 0</div><div class=\"line\">    do choose an index e in N for which c&#123;e&#125; &gt; 0</div><div class=\"line\">        for each index i in B</div><div class=\"line\">            do if a&#123;ie&#125; &gt; 0</div><div class=\"line\">                then delta&#123;i&#125; &lt;- b&#123;i&#125;/a&#123;ie&#125;</div><div class=\"line\">                else delta&#123;i&#125; &lt;- INT</div><div class=\"line\">            choose an index l in B that minimizes delta&#123;i&#125;</div><div class=\"line\">            if delta&#123;i&#125; = INT</div><div class=\"line\">                then return &quot;unbounded&quot;</div><div class=\"line\">                else (N, B, A, b, c, v) &lt;- pivot(N, B, A, b, c, v, l, e)</div><div class=\"line\">for i &lt;- 1 to n</div><div class=\"line\">    do if i in B</div><div class=\"line\">        then x&#123;i&#125; &lt;- b&#123;i&#125;</div><div class=\"line\">        else x&#123;i&#125; &lt;- 0</div><div class=\"line\">return (x&#123;1&#125;, x&#123;2&#125;, ..., x&#123;n&#125;)</div></pre></td></tr></table></figure></p>\n<p>这里一般性地理解下,要通过单纯形算法来求解,在算法之前要肯定线性是可行(单纯性算法最初有一个初始化过程,会判断线性规划是否可行,返回一个初始基本解可行的松弛型),在算法之中要确保不陷入退化或说循环(目标值越迭代越小),能够终止返回最优解.单纯形算法输入一个标准型线性规划,返回线性规划一个最优解,能够顺利找到最优解并终止算法,后续对偶型可以说明.</p>\n<p>一个典型的单纯形算法例子：</p>\n<blockquote>\n<p>首先初始化标准型线性规划,返回一个初始基本解可行的松弛型,或者返回这个线性规划不可行,推出算法;其次对松弛型线性规划开始主元操作,选择非负系数最紧约束的换出变量,和换入变量交换,得到新的线性规划(和原来的线性规划是等价的);不断迭代这个过程,直到最优解确定,并终止返回一个最优解.<br>对于松弛型线性规划通过主元操作生成的新线性规划,二者是等价的.现在很重要的就是主元操作迭代,是如何选择换出变量的.选择一个在目标函数中系数为正值的非基本变量,尽可能增加其值而不违反任何约束.现在通过一个例子来理解单纯形算法的过程.</p>\n</blockquote>\n<p>1.标准型线性规划转化为松弛型线性规划<br>标准型：<br>最大化：<br>3x1+x2+2x3<br>满足约束：<br>x1+x2+3x3≤30<br>2x1+2x2+5x3≤24<br>4x1+x2+2x3≤36<br>x1,x2,x3≥0</p>\n<p>松弛型：<br>最大化：<br>z=3x1+x2+2x3<br>满足约束：<br>x4=30-x1-x2-3x3<br>x5=24-2x1-2x2-5x3<br>x6=36-4x1-x2-2x3</p>\n<p>确定基本解：把等式右边的所有变量设为0,可得基本解(x1,x2,x3,x4, x5, x6)=(0,0,0,30,24,36),目标值z=0;</p>\n<p>2.主元操作迭代第一次,选择增加x1的值.当增加x1值时,x4, x5, x6的值随之减小,但每个变量都有非负约束,所以不能减小到负值,这个时候就要在约束函数上选择最紧约束(就是选择最小增加值).<br>如果x1值增加到30,那么x4是负值;增加到12,则x5是负值;增加到9,则x6是负值;这个就知道了,9是x1值所能增加的最大值,就是最紧约束,对约束函数x6=36-4x1-x2-2x3互换变量x1和x6的角色,得到：x1=9- x2/4- x3/2- x6/4,代入原线性规划据此可得新的松弛型线性规划,如下：<br>最大化：<br>z=27+x2/4+ x3/2- 3x6/4<br>满足约束：<br>x1=9- x2/4- x3/2-x6/4<br>x4=21-3x2/4-5x3/2+x6/4<br>x5=6-3x2/2-4x3+x6/2<br>确定基本解,同样把等式右边的所有变量设为0,可得基本解(x1,x2,x3,x4, x5, x6)=(9,0,0,21,6,0),目标值z=27;</p>\n<p>3.主元操作迭代第二次,选择增加x3的值,最紧约束是x5=6-3x2/2-4x3+x6/2,最大增加到3/2,否则x5的值为负,和第一次迭代一样,互换x3和x5并代入线性等式获得新的线性规划,可得基本解(x1,x2,x3, x4, x5,x6)=(33/4,0,3/2,69/4,0,0),目标值z=111/4;<br>第四：主元操作迭代第三次,互换x2和x4并代入线性等式获得新的线性规划,可得基本解(x1,x2,x3, x4, x5,x6)=(8,4,0,18,0,0),目标值z=28,为最优解,(x1,x2,x3)=(8,4,0).<br>最关心的问题还是具有可行解的线性规划经过这样的迭代,在算法终止时是否确实能找到最优解,这个就留给线性规划对偶性来说明.</p>\n<ol>\n<li>单纯形算法分析<br>现在我们知道单纯形算法可以在多项式时间内求解线性规划最优解,那么关心两点：</li>\n</ol>\n<ul>\n<li>是算法终止时,获得的是最优解,这个就是对偶性要回答;</li>\n<li>二是输入一个线性规划要判断出是可行可解的,这个就是辅助线性规划要回答的.<br>任何线性规划都可能是不可行的,或是无界的,或有一个优先目标值得最优解,针对这些个情况,单纯形算法要能正确识别.</li>\n</ul>\n<p><strong>线性规划的基本定理</strong>：<br>以标准型给出任意的线性规划L可能是以下三者之一：<br>第一：有一个有限目标值的最优解;<br>第二：不可行;<br>第三：无界;</p>\n<p>如果L是不可行的,单纯形算法在初始化中就会返回不可行;如果L是无界的,单纯形算法返回无界,无界就是找不到最优解或者有无限个目标值;当然,满足第一情况的,就会返回有限目标值的最优解.<br>单纯形算法在初始化过程中,会确定线性规划是否有可行解,如果有,则给出一个基本解可行的松弛型线性规划.这个初始化过程其实就是对线性规划测试可行解.那么是如何来确认存在可行解呢？通过构造辅助线性规划,这个辅助线性规划,比较容易找到一个基本解可行的松弛型.只要辅助线性规划有可行解,则要输入的线性规划也就有可行解.如果线性规划L没有可行解,则初始化返回不可行,否则返回一个基本解可行的合法松弛型.怎么构造辅助线性规划呢？</p>\n<p>辅助线性规划：令L是一个标准型的线性规划,令 $L_{aux}$是带有n+1个变量的线性规划：<br>最小化：-x0<br>满足约束：<br>$$ \\sum_{j-1}^{n} a_{ij}x_j - x_0 \\leq b_i, i = 1, 2, \\dots, m \\\\<br>x_j \\geq 0, j = 0, 1, \\dots, n<br>$$<br>则当且仅当 $L_{aux}$的最优目标值为0时,L是可行的.<br>辅助线性规划,增加一个x0变量,并且令目标值为0.对辅助线性规划求解可行解,也是按照主元操作,将标准型转换成松弛型后不断交换变量迭代.辅助线性规划较容易找到可行解.算法导论中证明了辅助线性规划存在可行解就是要求解的线性规划存在可行解.</p>\n<p>现在我们要引进线性规划<strong>对偶性</strong>的概念.对偶性有一个很重要的性质：在一个最优化问题中,一个对偶问题的识别总是可以在一个多项式时间内发现.对偶性是用来证明某个解确实是最优解.还是动态规划思想：已知一个最大化问题,定义个相关的最小化问题,来让着两个问题有相同的最优目标值.如最大流问题的最大流最小割原理.对偶的字面意义,就是我的解也是你的解,大问题的解是小问题的解.</p>\n<p>已知一个目标是最大化的线性规划,制定一个对偶线性规划,其目标是最小化,而且最优值与原始线性规划相同.给定一个标准的原线性规划,定义对偶线性规划为：<br>$$<br>最小化: \\sum_{i=1}^{m} b_iy_i \\\\<br>满足约束: \\sum_{i=1}^{m} a_{ij}y_i \\geq c_j, j = 1,2, \\dots, n \\\\<br>y_i \\geq 0, i = 1, 2, \\dots, m<br>$$<br>构造对偶,将最大化改成最小化,将约束右边的与目标函数的稀疏角色互换,并且小于等于号变成大于等于号.在原问题的m个约束中,每一个在对偶问题中都一个对应的变量yi,在对偶问题的n个约束中,每一个在原问题中都一个对应的变量xj.</p>\n<p>对偶性能证明最优解主要是两点：</p>\n<ul>\n<li>原线性规划中的目标函数的系数变成对偶线性规划中约束函数的右边值,原线性规划中的约束函数的右边值变成对偶线性规划中目标函数的系数;</li>\n<li>原线性规划中每一个约束函数的左边等于对偶线性规划中的一个变量,就是原线性规划中的m个约束函数等于m个对偶线性规划中的变量,反之也是.最后证明了对偶线性规划的最优值总是等于原线性规划的最优值.</li>\n</ul>\n<h3 id=\"Chapter28-寻找子串\"><a href=\"#Chapter28-寻找子串\" class=\"headerlink\" title=\"Chapter28 寻找子串\"></a>Chapter28 寻找子串</h3><p>字符串匹配是一个很常见的问题,可以扩展为模式的识别,解决字符串问题的思想被广泛地应用.字符串匹配问题可以描述如下:<br><img src=\"/images/string-match1.png\" alt=\"string-match1\"><br>介绍3种解决该问题的办法,包括：最朴素的遍历法,Rabin-Karp算法,自Knuth-Morris-Pratt算法即KMP.<br>首先对时间复杂度做出一个概括(从大到小)：</p>\n<ul>\n<li>朴素法：$O((n-m+1)m)$;</li>\n<li>Rabin-Karp：预处理：$O(m)$,匹配：最坏 $O((n-m+1)m)$,但是平均和实际中比这个好得多;</li>\n<li>KMP：预处理O(m),匹配O(n).<br>其中,m代表模式P的长度,n代表被匹配的数组S的长度,Σ代表P和S的字符表.</li>\n</ul>\n<p>接下来分开学习对应的算法和思想.</p>\n<p>1.朴素法(native)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">navite-string-matcher(T, P)</div><div class=\"line\">n &lt;- length[T]</div><div class=\"line\">m &lt;- length[P]</div><div class=\"line\">for s &lt;- 0 to n - m</div><div class=\"line\">    do if p[1...m] = T[s+1...s+m]</div><div class=\"line\">        then print &quot;Pattern occurs with shift&quot;</div></pre></td></tr></table></figure></p>\n<p>朴素法简单直接,就是从T的每一个字符开始,看它之后(包括它)的m个字符与P是否一样.P从S中第几个字符开始,可以看作,P在S中位移了几步.<br>朴素法的效率低的问题在于,它几乎忽视了所有的信息,每一次匹配都是“全新地”.如果P=abc,S=abdabc,从位置0开始,当我们匹配到 位置2,即c != d,朴素的做法是下一步从位置1开始匹配, 然而,在之前的匹配过程中,我们可以知道位置1的值b必然不匹配位置0的a.这是我们光通过P就能知道的,因为既然前一步已经开始去匹配位置2了,证明说明0和1已经成功匹配,而通过P自己,我们知道P的位置1不匹配0,则前一步的S位置1必然也不匹配P的位置1,这样就可以跳过这一步.问题在于,告诉程序跳过多少步,这就是我们接下来的算法要做的.显然,跳过得越多匹配越快,同时我们为了尽可能得到跳步的信息,可能需要进行预处理,预处理会产生另外的时间.</p>\n<p>2.Rabin-Karp<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">rabin-karp-matcher(T, P, d, q)</div><div class=\"line\">n &lt;- length[T]</div><div class=\"line\">m &lt;- length[P]</div><div class=\"line\">j &lt;- d^&#123;m-1&#125; mod q</div><div class=\"line\">p &lt;- 0</div><div class=\"line\">t&#123;0&#125; &lt;- 0</div><div class=\"line\">for i &lt;- 1 to m   #预处理</div><div class=\"line\">    do p &lt;- (dp + p[i]) mod q</div><div class=\"line\">        t&#123;0&#125; &lt;- (dt&#123;0&#125; + T[i]) mod q</div><div class=\"line\">for s &lt;- 0 to n - m  #匹配</div><div class=\"line\">    do if p = t&#123;s&#125;</div><div class=\"line\">        then if P[1..m] = T[s+1...s+m]</div><div class=\"line\">            then print &quot;Pattern occurs with shift&quot;s</div><div class=\"line\">        if s &lt;- n - m</div><div class=\"line\">            then t&#123;s+1&#125; &lt;- (d(t&#123;s&#125; - T[s+1]h) + T[s+m+1]) mod q</div></pre></td></tr></table></figure></p>\n<p>执行过程如下:<br><img src=\"/images/robin-karp.png\" alt=\"robin-karp\"></p>\n<p>算法将字符串转化为数,进制就是字符表的字符数目.那么,P是一个m位数,这个转化很容易用 $O(m)$ 算出来,通过遍历可以解决.再将S变为n-m+1个数：第一个数同P一样,$O(m)$ 完成预处理;当有了第k个数,算第k+1个数的时候,只需要去掉高位,补上低位,$O(1)$ 完成这个递推过程;总的预处理还是 $O(m)$.匹配的时候就是比较n-m+1次,所以复杂度是 $O(n-m+1)$.那么,为什么说它匹配最坏是 $O((n-m+1)m)$ 呢？<br>原因在于这个转化得来的数可能很大,算术运算不是常数,怎么处理大数呢？这个时候可以用模除来做一个简单的hash,匹配的数hash一定匹配,hash匹配原数不一定匹配,需要再回去做检查.最差的情况下,所有的hash都一样,每个hash都匹配了,全部需要回去检查一遍,那么这个时候匹配过程和朴素法一样.工程上来说,通常选取一个较大的素数来做模除.算法的最差运行时间是 $O((n-m+1)m)$, 当素数比模式P长度大很多时,期望运行时间是 $O(n+ m)$.</p>\n<p>3.KMP<br>KMP实际上是利用自动机的思想,但是我们并不是预先算好变迁函数.KMP遇到新字符,如果匹配当然是下一个状态,不匹配的话并不像自动机一步到位地接收新字符后到另一个状态,而是先到另一个状态,再递归地看是否接收这个字符,最终接收后在看下一个字符.关键在于,不匹配时,改变状态时是带着新字符还是不带.那么辅助的数组(数组也好,函数也好,总归还是查表),就从多维降到一维,多维是因为自动机遇到不同新字符跳到不同的状态,一维是KMP遇到新字符不匹配时直接跳到另一个状态,跳的时候不考虑新字符.直观上看,构建这样的数组也不再需要遍历Σ,预处理过程复杂度应该会降低.事实,确实省去了O(|Σ|)的复杂度,降到O(m)复杂度.同时,匹配时的复杂度还保持在了O(n).分析复杂度用到平摊分析法.<br>匹配过程是简单直观的,如前所述,遇到新字符,借助辅助数组π不断地改变状态.伪代码乳如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">kmp-matcher(T,P)</div><div class=\"line\">n &lt;- length[T]</div><div class=\"line\">m &lt;- length[P]</div><div class=\"line\">π &lt;- kmp-computer-prefix(P)</div><div class=\"line\">q &lt;- 0               // state , number of char matched</div><div class=\"line\">for i &lt;- 1 to n</div><div class=\"line\">    while q &gt; 0 &amp;&amp; P[q+1] != T[i]  // P and T range from 1 to n, not 0 to n-1</div><div class=\"line\">        do q &lt;- π[q]</div><div class=\"line\">        if P[q+1] = T[i]</div><div class=\"line\">            then q &lt;- q+1</div><div class=\"line\">        if q = m</div><div class=\"line\">            then print &quot;Pattern occurs with shift&quot; i-m</div><div class=\"line\">                q &lt;- π[q]</div></pre></td></tr></table></figure></p>\n<p>那么,问题的关键还是在于计算辅助数组π,即状态如何转移.这里KMP计算的时候,从P的低位(左边)开始计算π,显然只会用到前面低位的信息,不会用到后面高位的信息.那么利用动态规划中利用记录减少迭代的思想,再把计算π的过程看做与匹配过程类似,比如计算q+1那么就是用Pq去匹配Pq+1嘛,而Pq的数组π已经建立好了.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">kmp-computer-prefix(P)</div><div class=\"line\"></div><div class=\"line\">m &lt;- length[P]</div><div class=\"line\">π[1] &lt;- 0</div><div class=\"line\">k &lt;- 0               // just like q above, number of char matched</div><div class=\"line\">for q &lt;-  2 to m     // like i above, and actually it is state, so its name is q</div><div class=\"line\">    while k&gt;0 &amp;&amp; P[k+1] != P[q]  // P range from 1 to n, not 0 to n-1</div><div class=\"line\">        do k &lt;- π[k]</div><div class=\"line\">        if P[k+1] = P[q]</div><div class=\"line\">            then k &lt;- k+1</div><div class=\"line\">        π[q] &lt;- k</div><div class=\"line\">return π</div></pre></td></tr></table></figure></p>\n<p>kmp算法执行如下:<br><img src=\"/images/kmp1.png\" alt=\"kmp1\"><br><img src=\"/images/kmp2.png\" alt=\"kmp2\"></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"＜Introduction-to-algorithms＞笔记\"><a href=\"#＜Introduction-to-algorithms＞笔记\" class=\"headerlink\" title=\"＜Introduction to algorithms＞笔记\"></a>＜Introduction to algorithms＞笔记</h1><h2 id=\"Part7-高级算法问题\"><a href=\"#Part7-高级算法问题\" class=\"headerlink\" title=\"Part7 高级算法问题\"></a>Part7 高级算法问题</h2><p>在part1-6学习基本的数据结构和算法问题后, part7不再集中于对一个算法问题专题进行学习, 而是就不同的高级算法问题进行基本的介绍,其其覆盖的内容十分全面,涉及一下几个领域:</p>\n<ul>\n<li>排序网络</li>\n<li>矩阵运算</li>\n<li>线性规划</li>\n<li>字符串匹配</li>\n</ul>\n<h3 id=\"Chapter26-如何利用多核来并行排序\"><a href=\"#Chapter26-如何利用多核来并行排序\" class=\"headerlink\" title=\"Chapter26 如何利用多核来并行排序?\"></a>Chapter26 如何利用多核来并行排序?</h3><p>在part2中学习了基本的排序算法,包括插入,快排,归并,堆排序等,它们都是在串行计算机上线性执行的算法.随着硬件的发展,多处理器的进步,如何利用多核来进行并行排序?如何推而广之到多核并行算法?这一章就套路基于计算的一种比较网络模型,同时进行多个比较操作.</p>\n<p>比较网络与串行排序算法的区别:</p>\n<ul>\n<li>比较网络只能执行比较操作, 即只能执行基于比较操作的算法.因此part2中学习的计数排序就无法再比较网络中实现</li>\n<li>比较网络中比较操作可以并行的执行, 而串行排序算法各操作是依次执行的.故前者拥有更好的算法效率- 更小的算法复杂度</li>\n</ul>\n<p>1.比较网络定义</p>\n<ul>\n<li>组成：<br>基本构件:线路和比较器<br><img src=\"/images/comparsion.png\" alt=\"comparsion\"></li>\n</ul>","more":"<ul>\n<li>比较网络含义：</li>\n<li>一个由线路互相联接着的比较器的集合,我们把具有n个输入的比较网络画成一个由n条水平线组成的图,比较器则垂直地与两条水平线相连接.每个比较器的输入端要么与网络的n条输入线路 $a_1,a_2, \\dots, a_n$ 中的一条相连,要么与另一个比较器的输出端相连接.类似地,每个比较器的输出端要么与网络的n条输出线路 $b_1,b_2, \\dots, b_n$中的一条相连,要么与另一个比较器的输入端相连接.互相连接的比较器主要应满足如下要求：<blockquote>\n<ol>\n<li>其互相连接所成的图中必须没有回路.</li>\n<li>只有当同时有两个输入时,比较器才能产生输出值.</li>\n</ol>\n</blockquote>\n</li>\n</ul>\n<p>在每个比较器均运行单位时间的假设下,我们可以对比较网络的“运行时间”作出定义,这就是从输入线路接收到其值的时刻到所有输出线路收到其值所花费的时间.</p>\n<ul>\n<li><p>比较网络示意图:<br><img src=\"/images/sortnet.png\" alt=\"sortnet\"></p>\n</li>\n<li><p>排序网络定义:<br>对每个输入序列其输出序列均为单调递增(即 $b_1 \\leq<br>b_2, \\dots, b_n$ )的一种比较网络</p>\n</li>\n<li><p>0-1原理：<br>如果一个具有n个输入的比较网络,能够对所有可能存在的2^n个0和1组成的序列进行正确的排序,则对所有任意数组成的序列,该比较网络也可能对其正确排序.<br>0-1原理推定认为：如果对于属于集合{0,1}的每个输入值,排序网络都能正确运行,则对任意输入值,它也能争取而运行(输入值可以是整数、实数或者任意线性排序的值的集合).这样在构造排序网络时,可以专注在0和1组成的输入序列上设计比较器.这个原理目的是简化输入值,而通过0和1来设计比较网络的线路和比较器,只要0和1可运行,那么其他任意值的序列也都可以运行.<br>0-1原理的证明依赖单调递增函数.如果比较网络把输入序列 $a=<a\\_1,a\\_2, \\dots,=\"\" a\\_n=\"\">$ 转化为输出序列 $b=<b\\_1,b\\_2, \\dots,=\"\" b\\_n=\"\">$,则对任意单调递增函数f,该网络把输入序列f(a)=<f(a1),f(a2),…,f(an)>转化为输出序列f(b)=<f(b1),f(b2),…,f(bn)>.<br>这个可以这样理解,对输入序列a施以f(a)单调递增函数,比较网络(线路和比较器)能够使序列a输出序列b,那么该比较网络同样可以使输入序列f(a)输出序列f(b).<br>这就为0-1原理奠定了基础,只要证明比较网络可以运行于0和1的输入,那么设计一个单调递增函数,0和1是因变量,其自变量自然也可以通过同样比较网络来排序.<br>如果一个具有n个输入的比较网络能够对所有可能存在的2n个0和1组成的序列进行正确的排序,则对所有任意数组成的序列,该比较网络也可能对其正确排序.<br>0-1原理证明用到了单调递增函数概念,同时采用数学归纳法和反证法来证明.这也给出了一个很重要的思想,那就是对现实问题的解决,在构建数学模型时,可以简单到0-1,然后再推广到复杂数.</f(b1),f(b2),…,f(bn)></f(a1),f(a2),…,f(an)></b\\_1,b\\_2,></a\\_1,a\\_2,></p>\n</li>\n<li><p>双调序列：<br>序列要么先单调递增然后再单调递减,要么先单调递减然后又单调递增.例如序列<1,4,6,8,3,2>和<9,8,3,2,4,6>都是双调的</9,8,3,2,4,6></1,4,6,8,3,2></p>\n</li>\n</ul>\n<p>2.双调排序网络</p>\n<ul>\n<li><p>双调排序程序由 $log_2n$个阶段组成,其中每一个阶段称为一个半清洁器.每个半清洁器是一个深度为1的比较网络,其中输入线I与输入线I+n/2进行比较,I=1,2,…,n/2(这里假设n为偶数).下图即为一个具有8个输入和8个输出的半清洁器(half-cleaner)<br><img src=\"/images/half-cleaner.png\" alt=\"half-cleaner\"></p>\n</li>\n<li><p>当由0和1组成的双调序列用作半清洁器的输入时,半清洁器产生的输出序列满足如下条件：</p>\n<blockquote>\n<ol>\n<li>较小的值位于输出的上半部,较大的值位于输出的下半部.</li>\n<li>两部分序列仍是双调的.</li>\n<li>两部分序列中至少有一个是清洁的——全由0或1组成.</li>\n</ol>\n</blockquote>\n</li>\n<li><p>双调排序器(bitonic-sorter)<br>通过递归地连接半清洁器,我们可以建立一个双调排序网络.双调排序网络[n]的第一阶段由半清洁器[n]组成,可知半清洁器[n]产生两个规模缩小一半的双调序列且满足上半部分的每个元素不比下半部分的任一个元素大.因此,我们可以运用两个双调排序网络[n/2]分别对两部分递归地进行排序,以此完成整个排序工作<br><img src=\"/images/bitonic-sorter.png\" alt=\"bitonic-sorter\"></p>\n</li>\n</ul>\n<p>我们只要把含n个元素的双调排序网络的第一个半清洁器修改一下就可以得到合并网络MERGER[n].由于输入的上半部和下半部都是单调递增的,所以我们把比较网络的下半部分颠倒一下,输入就成了一个双调序列.添上半清洁器,再颠倒回去,半清洁器就变成了把输入 $a_i$和$a_{n-i+1}比较.这时,输出也被颠倒了.但是,一个双调序列颠倒了以后还是一个双调序列.<br>因此就可以用<em>bitonic-sorter</em>对深度为 $\\log n$ 的0-1双调序列进行排序.<br><img src=\"/images/bitonic-sorter2.png\" alt=\"bitonic-sorter2\"></p>\n<p>3.合并网络(mergin network)<br>合并网络,能够把两个已排序的输入序列合并为一个有序的输出序列的网络.基于双调排序网络思想,对已知的两个有序序列进行连接(第二个序列顺序颠倒),所得的序列是双调序列,再利用双调排序器就能完成两个有序序列的合并.其原理如下:<br><img src=\"/images/merger1.png\" alt=\"merger1\"><br><img src=\"/images/merger2.png\" alt=\"merger2\"></p>\n<p>4.基于0-1原理、双调排序网络、合并网络,我们可以构造一个输入任意序列进行排序的比较排序网络.思想很简单：第一步开展最基础的2个元素的两两比较,这个用普通的比较器就可以实现,输出长度为2的有序序列;第二步对长度为2的有序序列进行两两合并,这个用合并网络排序(基于双调排序器,先连接序列构造双调序列)实现,输出长度为4的有序序列;第三步对长度为4的有序序列进行合并网络,直到 $\\log n$次.算法上,可以在 $O(\\log n)$内并行地对n个数进行排序.<br><img src=\"/images/sorter.png\" alt=\"sorter\"></p>\n<p>总结:排序网络可以并行地进行排序,然后再组合各并行排序结果,适合分布式场景的排序需求.</p>\n<h3 id=\"Chapter27-矩阵运算\"><a href=\"#Chapter27-矩阵运算\" class=\"headerlink\" title=\"Chapter27 矩阵运算\"></a>Chapter27 矩阵运算</h3><p>在part4高级设计技术中在动态规划中研究了矩阵链乘法问题后, 这一章深入学习矩阵运算, 特别学习矩阵相乘的Strasssen算法,该算法能在 $O(n^{\\log 7})$ 的时间内计算两个 $n*n$ 的矩阵的乘积.</p>\n<p>1.首先重温下矩阵的相关概念和性质,为后续矩阵运算奠定数据理论基础.</p>\n<p>矩阵A：<br>数字的一个矩形阵列,形式化为 $A=(a_{ij})$,第i行j列元素为 $a_ij$,如元素为实数的所有元素mXn矩阵组合的元素用 $R_{mXn}$表示.<br><img src=\"/images/matrix.png\" alt=\"matrix\"></p>\n<p>矩阵转置AT：是矩阵A的行和列互相交换而产生的矩阵.</p>\n<p>向量(Vector)：是数字的一维向量,列向量看成是nX1的矩阵,转置成行向量就是1Xn的矩阵.</p>\n<p>单位向量$e_i$：矩阵第一个元素为1而其他元素均为0的常量.</p>\n<p>零矩阵：所有元素都是0的矩阵.</p>\n<p>对角矩阵：当i≠j时,$a_ij$,所有非对角线上的元素均为0.</p>\n<p>nXn单位矩阵 $I_n$：是对角线元素都是1的对角矩阵.</p>\n<p>三对角矩阵T：满足 $|i-j|&gt;1$ 的元素 $t_ij$=0的矩阵,非零元素仅出现在主对角线上、靠主对角线上面和对角线下面.</p>\n<p>上三角矩阵U：满足i&gt;j的元素 $U_ij=0$的矩阵,对角线下面的所有元素均为0,若对角线元素为1,则是单位上三角矩阵.</p>\n<p>下三角矩阵L：满足i&lt;j的元素 $L_ij=0$的矩阵,对角线上面的所有元素均为0,若对角线元素为1,则是单位下三角矩阵.</p>\n<p>置换矩阵P：每一行或列中仅包含一个1,其他元素都为0,可以把一个向量x和一个置换矩阵相乘,结果是向量x中的元素的一种置换.</p>\n<p>对称矩阵A：满足条件 $A= A^T$.</p>\n<p>矩阵加法：$C(c_ij)=A(a_ij)+B(b_ij),c_ij=a_ij+b_ij$,都是mXn矩阵.</p>\n<p>矩阵乘法：相容(A的列数等于B的行数)的两个矩阵才可以相乘,$C(c_ij)= \\sum_{k=1}^{m} A(a_ik)*B(b_kj)$,矩阵和单位矩阵等于自己、和零矩阵相乘等于零、和向量相乘得到向量,满足结合律和分配律,但不满足交换律.</p>\n<p>逆矩阵A-1：满足 $A A^{-1} = I_n= A^{-1}A$,不可逆的矩阵称为奇异矩阵.</p>\n<p>线性相关：设 $x_1,x_2, \\dots, x_n$是n个向量,若存在不全为零的常系数 $c_1,c_2, \\dots, c_n$,使 $c_1x_1+c_2x_2+ \\dots +c_nx_n=0$成立,就称 $x_1,x_2, \\dots, x_n$线性相关.</p>\n<p>非零mXn矩阵A的秩：A的极大线性无关列向量组中向量的个数为列秩,A的极大线性无关行向量组中向量的个数为列秩.任意一个矩阵的行秩和列秩都是相等.mXn的秩是0和min(m,n)之间的一个整数.</p>\n<p>非零mXn矩阵A的秩满足下列条件的最小的数r：存在mXr矩阵B和rXn矩阵C且有A=BC.如果一个nXn的矩阵秩为n,则是满秩,如果一个mXn矩阵的秩为n,则是列满秩.<br>一个方阵满秩当且仅当它为非奇异矩阵.当前仅当A无空向量时,矩阵A为列满秩.<br>当且仅当A具有空向量时,方阵A是奇异的.</p>\n<p>余子式：对于n&gt;1,nXn矩阵A的第ij个余子式是把A的第i行和第j列元素去掉后所形成的一个(n-1)X(n-1)矩阵A[ij],表示为det(A[ij]).</p>\n<p>方阵A的行列式具有如下性质：如果A的任何行或列的元素为0,则det(A)=0;用常如a乘A的行列式任意一行(或任意一列)的诸元素,等于用a乘A的行列式;A的行列式中的一行(或一列)元素加上另一行(或另一列)中的相应元素,行列式的值不变;A的行列式值与其转置矩阵AT的行列式的值相等;行列式的任意两行(或两列)互换,则其值异号.</p>\n<p>正定矩阵：nXn矩阵A,如果对所有n维向量x≠0都有$x^TAx&gt;0$,则矩阵A为正定矩阵.</p>\n<p>对任意列满秩矩阵A,矩阵$A^TA$是正定的.</p>\n<p>2.矩阵乘法的Strassen算法<br>矩阵乘法是种极其耗时的运算.以C = AB为例,其中A和B都是 n x n 的矩阵.根据矩阵乘法的定义,计算过程如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">SQUARE-MATRIX-MULTIPLY(A, B)</div><div class=\"line\">n = A.rows</div><div class=\"line\">let C be a new nxn matrix</div><div class=\"line\">for i = 1 to n</div><div class=\"line\">    for j = 1 to n</div><div class=\"line\">        c[i][j] = 0</div><div class=\"line\">        for k = 1 to n</div><div class=\"line\">            c[i][j] += a[i][k] * b[k][j]</div><div class=\"line\">return C</div></pre></td></tr></table></figure></p>\n<p>由于存在三层循环,它的时间复杂度将达到 $O(n^3)$.<br>Strassen算法运用分治法将两个nXn的矩阵乘积运行时间,从简易矩阵乘法算法 $O(n^3)$提升到 $O(n^{\\log 7}) = O(n^{2.81})$.下面是算法的主要思想和步骤.</p>\n<blockquote>\n<p>一般情况下,矩阵乘积C=AB,其中A、B和C都是nXn方阵,假定n是2的幂,把A、B和C划分成四个n/2Xn/2矩阵：<br><img src=\"/images/matrix.png\" alt=\"matrix2\"><br>则矩阵乘法对应四个等式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">r=ae+bg</div><div class=\"line\">s=af+bh</div><div class=\"line\">t=ce+dg</div><div class=\"line\">u=cf+dh</div></pre></td></tr></table></figure></p>\n<p>每个等式运行包含两次 $n/2 <em> n/2$矩阵乘法和两次乘积所得的 $n/2 </em> n/2$矩阵的加法运算,推出 $n * n$ 矩阵相乘所需时间T(n)的递归式：<br>$$T(n)=8T(n/2)+  O(n^2)$$</p>\n</blockquote>\n<p>Strassen算法在这个一般性的递归式上,发现只需要进行7次 $n/2 * n/2$矩阵乘法即可解决,即<br>$$T(n)=7T(n/2)+O(n^2)= O(n^{\\log 7}) = O(n^{2.81})$$<br>具体算法步骤如下：</p>\n<ul>\n<li>1.输入矩阵A和B划分为 $n/2 * n/2$的子矩阵;</li>\n<li>2.运行 $O(n^2)$标量加法和减法运算,计算出14个 $n/2 * n/2$的矩阵 $A_1,B_1,A_2,B_2, \\dots, A_7,B_7$;</li>\n<li>3.递归计算出7个矩阵的乘积 $P_i=A_i * B_i,i=1,2, \\dots, 7$;</li>\n<li>4.使用 $O(n^2)$ 次标量加法与减法运算,对 $P_i$ 矩阵的各种组合进行求和或求差运算,从而获得结果矩阵C的四个子矩阵r\\s\\t\\u.</li>\n</ul>\n<p>Strassen算法的核心思想是什么呢？何以产生如此一个步骤的算法呢？依据是什么？<br>设想每个矩阵的积 $P_i$可以写成如下形式：<br> $$P_i=A_iB_i=(α_{i1}a+α_{i2}b+α_{i3}c+α_{i4}d)( β_{i1}e+β_{i2}f+β_{i3}g+β_{i4}h)$$<br> 其中系数α和β都属于集合{-1,0,1},就是说,对矩阵A和B的子矩阵进行加减运算,并对所得的结果进行相乘法来计算出每个子矩阵的乘积.简单说,将子矩阵的乘法运算变成加减运算,从而将8次乘法减少到7次.这是Strassen算法的核心思想和依据.</p>\n<p>上面给出的描述很好理解算法的思路和步骤.正如算法导论中对该算法的讨论中所指出的问题,对于矩阵乘法的困难(多项式时间内完成的算法)是合理的.Strassen算法并不是最佳,但目前并没有更多的突破.</p>\n<p>2.求解线性方程组(LUP分解思想)<br>求解一组同时成立的线性方程式在很多应用中都会出现,也是线性代数的基本问题.可以将一个线性系统表示为一个矩阵方程,其中每个矩阵或向量元素都属于一个域,如实数域R.<br>n个未知量的n个方程用矩阵表示如下：<br><img src=\"/images/matrix.png\" alt=\"matrix3\"><br>设 $A=(a_{ij}),x=(x_i),b=(b_i)$,有Ax=b.</p>\n<p>如果A是非奇异矩阵(秩为n),存在逆矩阵 $A^{-1}$,则 $x= A^{-1}b$,且x是唯一解.方程数目少于未知量数目(或A的秩小于n)为不定方程组,具有无穷多解,如果方程组不相容则可能无解;方程数目多于未知量数目为超定方程组,可能无解.<br>LUP分解在求解线性方程组具有数值稳定和速度快的优点.<strong>LUP分解的思想就是找出三个n*n矩阵L、U和P,满足PA=LU,其中L是一个单位下三角矩阵、U是一个上三角矩阵、P是一个置换矩阵.</strong></p>\n<p>定义y=Ux,其中x是要求解的未知向量.用正向替换($O(n^2)$)方法求解Ly=Pb,在用逆向替换($O(n^2)$)方法求解Ux=y,可得：</p>\n<p>$$Ax = P^{-1}LUx = P^{-1}Ly = P^{-1}Pb=b$$</p>\n<p>问题是如何有效找出LUP呢？只要找出LUP就可以通过正向替换和逆向替换求解x.</p>\n<p>LU分解是采用高斯消元法.首先考虑A是nXn的非奇异矩阵,且P等价于$I_n$,找出A=LU,矩阵L和U称为A的LU分解.基于LU分解基础上开展LUP分解,数学基础一致,不失一般性而已,增加对置换矩阵P中值为1的元素的刻画.最重要还是要对矩阵运算和高斯消元法的数据基础有初步掌握.LUP分解如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">lu-decomposition(A)</div><div class=\"line\">n &lt;- rows[A]</div><div class=\"line\">for k &lt;- 1 to n</div><div class=\"line\">    do u&#123;kk&#125; &lt;- a&#123;kk&#125;</div><div class=\"line\">        for i &lt;- k + 1 to n</div><div class=\"line\">            do l&#123;ik&#125; &lt;- a&#123;ik&#125;/u&#123;kk&#125;</div><div class=\"line\">                u&#123;ki&#125; &lt;- a&#123;ki&#125;</div><div class=\"line\">        for i &lt;- k + 1 to n</div><div class=\"line\">            do for j &lt;- k + 1 to n</div><div class=\"line\">                do a&#123;ij&#125; &lt;- a&#123;ij&#125; - l&#123;ik&#125;u&#123;kj&#125;</div><div class=\"line\">return L and U</div></pre></td></tr></table></figure></p>\n<p>LU分解执行过程如下:<br><img src=\"/images/lu.png\" alt=\"lu\"></p>\n<p>总结:基于LUP分解矩阵求解线性方程组的方法,同样适用于非奇异矩阵的求逆.矩阵乘法和计算逆矩阵问题具有相同难度的两个问题,在一定技术条件限制下可以使用一个算法在相同渐进时间内解决另外一个问题,即可用Strassen矩阵乘法算法来求一个矩阵的逆.</p>\n<h3 id=\"Chapter28-线性规划\"><a href=\"#Chapter28-线性规划\" class=\"headerlink\" title=\"Chapter28 线性规划\"></a>Chapter28 线性规划</h3><p>怎么样问题可以建模为线性规划来解决呢？在给定的有限的资源和竞争约束情况下,取得最大化或最小化目标的问题.导论中给出政治竞选问题、航空航线调度问题、钻井采油问题.最大化或最小化目标是函数的因变量,自变量就是资源的约束因素,其函数就是由这些制约因素构成的等式或不等式.<br>1.线性规划定义.</p>\n<blockquote>\n<p>在一般线性规划问题中,最优化一个满足一组线性不等式约束的线性函数.已知一组实数 $a_1,a_2, \\dots,a_n$和一组变量 $x_1,x_2, \\dots,x_n$,基于这些变量的一个线性函数f定义为<br>$$ f(x_1,x_2, \\dots,x_n) = a_1x_1 + a_2x_2 + \\dots + a_nx_n = \\sum_{j=1}^n a_jx_j$$<br>如果b是一个实数而f是一个线性函数,则等式：<br>$f(x_1,x_2, \\dots,x_n) = b$ 是一个线性等式.<br>$f(x_1,x_2, \\dots,x_n) \\leq b$ 和 $f(x_1,x_2, \\dots,x_n) \\geq b$ 是线性不等式.<br>线性约束就是函数f和b的关系,就是求解n个变量m个线性不等式的最大化,约束为线性不等式的线性函数最大化称为标准型;而约束为线性等式的线性函数的最大化称为松弛型.</p>\n</blockquote>\n<p>基于上面描述可知,线性规划问题是要最小化或最大化一个受限于一组有限的线性约束的线性函数.最小化线性规划和最大化线性规划的分类,是基于目标的需求,同样是m个线性不等式约束,去求解n个变量的值,达到目标(最大化或最小化).</p>\n<p>2.凸形区域定义：<br>区域内的任何两点之间连线上的点都属于这个区域.<br>线性规划中,二维空间(两个变量)所构成的凸形区域为可行区域,要最大化的函数为目标函数.可行区域内的每个点都会去评估目标函数$x_1+x_2$,将目标函数的一个特点点上的值称为目标值,识别出一个有最大目标值的点就是最优解.当然有二维线性规划不等式所构成的可行区域上是有无数个点,不可能都去求值,因此需要找出一个有效的方式来寻找最大目标值的点.线性规划的最优解必定是在可行区域的边界上,所以只要沿着边界寻找顶点就可以很快找到最大目标值的点.<br>推而广之,如果有三个变量,则每个约束以三位空间的一个半空间来描述,三个半空间的交集构成了可行区域,目标函数取目标值的点集合是一个平面.因为可行区域也是凸的,取得最优目标值的点集合必然包含可行区域的一个顶点.延伸到n个变量的超平面,每个约束定义了n维空间中的一个半空间,这些半空间的交集形成的可行区域称作单纯形,目标函数是一个超平面,且是凸性,一个最优解也是在单纯形的一个顶点上取得.理解下,无论多少维,找出凸形区域,目标函数的最优解就是在凸形区域的顶点集合之一或多个.</p>\n<p>3.单纯型算法<br>单纯形算法输入一个线性规划(n个变量m个线性不等式),输出一个最优解.算法从单纯形的某个顶点开始,执行一系列迭代,每次迭代中,沿着单纯形的一条边从当前顶点移动到一个目标值不小于当前顶点的相邻顶点.当达到一个局部最大值,即一个顶点的目标值大于其所有相邻顶点的目标值时,算法终止.因为可行区域是凸的且目标函数是线性的,所以具备最优事实就是全局最优的.</p>\n<p>单纯形算法需要指数时间.线性规划的第一类多项式时间算法是椭圆算法,运行缓慢;第二类指数时间的算法是内点法,在大型输入上,性能优于单纯形算法.如果在线性规划中,所有的变量都取整数值,即整数线性规划,对于该问题,找出一个可行解是NP难度的.目前还没有已知的多项式时间算法能NP难度问题,所以没有有效的整数线性规划多项式时间算法.当然,一般的线性规划可以在多项式时间内解决.</p>\n<p>线性规划的关键步骤:<br>1.标准型/松弛型转化<br>标准型的线性规划所有的约束条件都是不等式,而松弛型中的约束是等式.要用单纯形算法求解线性规划,需要将所有线性规划转化为标准型,再将标准型转化为松弛型,线性方程组等式求解.<br>标准型定义：<br>已知n个实数 $c_1,c_2, \\dots,c_n$;m个实数 $b_1,b_2, \\dots, b_m$;以及m * n个实数 $a_ij,其中i=1,2,\\dots, m,而j=1,2, \\dots, n$ 希望找出n个实数$x_1,x_2, \\dots, x_n$来最大化目标函数：<br>$$ \\sum_{j=1}^n c_jx_j$$<br>满足n + m个不等式, 其中n个约束为非负性约束:<br>$$ \\sum_{j=1}^n a_{ij}x_j \\leq b_i, i = 1,2, \\dots, m<br>x_j \\geq 0, j= 1, 2, \\dots, n$$<br>用矩阵表示更紧凑：<br>$$最大化c^Tx,满足约束：Ax \\leq b,x \\geq 0$$</p>\n<p>满足所有约束的变量 $x_s$设定为可行解,而不满足至少一个约束的变量 $x_s$ 设定为不可解.称一个解xs拥有目标值 $c^Tx_s$,在所有可行解中其目标值最大的一个可行解 $x_s$是一个最优解,称其为目标值 $c^Tx_s$的最优目标值.如果一个线性规划没有可行解,则称此线性规划不可行,否则是可行的.如果一个线性规划有一些可行解但没有有限的最优目标值,则称此线性规划是无界的.<br>已知一个最小化或最大化的线性函数受若干线性约束,总可以将这个线性规划转换为标准型.换句话说,要将非标准型的线性规划转化为标准型的.为什么会有非标准型的线性规划呢？可能目标函数是一个最小化而不是最大化;可能拥有的变量不具有非负性约束;可能有等式约束;可能有大于等于的不等式约束,而不是小于等于.<br>将非标准的线性规划转化线性规划,最重要是确保转换后的线性规划最优解也是转换前的线性规划最优解,转化前后的两个线性规划是等价的.转化思路就是对目标函数系数取负,并将不具有非负约束性的变量转换成具有非负性约束的变量.</p>\n<p>为了利用单纯形算法高效地求解线性规划,需要将标准型转换成松弛型,就是非负约束是不等式,其他约束都是等式.转换思路就是利用松弛变量,就是将不等式的余量用s来接收,从而使不等式变成等式,形式如下：<br>$$目标函数: z = v + \\sum_{j=1}^n c_jx_j \\\\<br>约束条件(不含变量的非负性约束: b_i - \\sum_{j=1}^n a_{ij}x_j = x_i$$<br>基于松弛型线性规划,就可以用单纯形算法求解.</p>\n<p>2.将问题表达为线性规划：建模<br>既然定义了线性规划,也知道线性规划可以在多项式时间内求解,那么对于现实的问题,那些事如果形式化为线性规划的问题来求解呢？这就涉及到建模了,现实中的问题如何建模为线性规划来求解.建模：将问题转化成数学形式来求解.</p>\n<p>算法导论中对单源最短路径变形的单对最短路径、最大流以及最大流变形的最小费用流和多商品流形式化为线性规划.这里描述下单源最短路径的线性规划形式化</p>\n<blockquote>\n<p>在单对最短路径问题中,已知一个带权有向图G=(V,E),加权函数w:E-&gt;R将边映射到实数值的权值、一个源顶点s、一个目的顶点t,要计算从s到t的一条最短路径的权值d[t].将该问题用线性规划表示,要确定变量和约束的集合.在Belleman-Ford算法终止时,对每个顶点v,都一个值d[v],使得每条边 $(u,v) \\in E$,有 $d[v] \\leq d[u]+w(u,v)$.源顶点初始得到一个值d[s]=0,如此有计算从s到t的最短路径权值的线性规划：<br>最大化：d[t]<br>满足约束：$d[v] \\leq d[u]+w(u,v)$,对每条边 $(u,v) \\in E$成立d[s]=0<br>共有|V|个变量d[v],每个顶点v∈V各有一个,有|E|+1个约束,每条边各有一个再加上源顶点d[s]=0的额外约束.</p>\n</blockquote>\n<p>3.单纯形算法实现<br>单纯形算法是求解线性规划的古典方法.单纯形算法和高斯消元法迭代原理类似,高斯消元法是从解未知的一个线性等式系统开始.可以将单纯形算法看成是线性不等式系统上的高斯消元法.单纯形算法的迭代主要思想是：从线性规划的松弛型中得到每次迭代关联的基本解,将每个非基本变量设为0,并从等式约束中计算基本变量的值;一个基本解对应于单纯形的一个顶点;代数上,一次迭代将一个松弛型转换成一个等价的松弛型;相应的基本解的目标值不小于前一次迭代中的目标值,要实现迭代过程中目标值的递增,要选择一个非基本变量作为指示变量,从0开始增加这个变量的值,和目标值一起增加,增加到某个基本变量变为0为止再重写松弛型,将这个基本变量和所选的非基本变量进行角色互换,就是重写线性规划直到最优解很明显.</p>\n<p>单纯形算法主要关键是主元选择,并且有三个关键点:</p>\n<ul>\n<li>1.确定线性规划是可行的;</li>\n<li>2.确定线性规划是具有可行解而不是无界;</li>\n<li>3.主元如何选择换入变量和换出变量.</li>\n</ul>\n<p>主元选择算法如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">pivot(N, B, A, b.c. v, l, e)</div><div class=\"line\">#compute the conefficients of the equation ofr new basic variable x</div><div class=\"line\">b&#123;e&#125; &lt;- b&#123;l&#125;/a&#123;le&#125;</div><div class=\"line\">for each j in N - &#123;e&#125;</div><div class=\"line\">    do a&#123;ej&#125; &lt;- a&#123;lj&#125;/a&#123;le&#125;</div><div class=\"line\">a&#123;el&#125; &lt;- 1/a&#123;le&#125;</div><div class=\"line\">#compute the conefficients of the remaining constraints</div><div class=\"line\">for each i in B - &#123;l&#125;</div><div class=\"line\">    do b&#123;i&#125; &lt;- b&#123;i&#125; - a&#123;ie&#125;b&#123;e&#125;</div><div class=\"line\">    for eahc j in N - &#123;e&#125;</div><div class=\"line\">        do a&#123;ij&#125; &lt;- a&#123;ij&#125; - a&#123;ie&#125;a&#123;ej&#125;</div><div class=\"line\">    a&#123;il&#125; &lt;- a&#123;ie&#125;a&#123;el&#125;</div><div class=\"line\">#compute the objective function</div><div class=\"line\">v &lt;- v + c&#123;e&#125;b&#123;e&#125;</div><div class=\"line\">for each j in N - &#123;e&#125;</div><div class=\"line\">    do c&#123;j&#125; &lt;- c&#123;j&#125; - c&#123;e&#125;a&#123;ej&#125;</div><div class=\"line\">cl&#123;e&#125; &lt;- -c&#123;e&#125;a&#123;el&#125;</div><div class=\"line\">#compute new ses of basic and nonbasic variables</div><div class=\"line\">N = N - &#123;e&#125; union &#123;l&#125;</div><div class=\"line\">B = B - &#123;l&#125; union &#123;e&#125;</div><div class=\"line\">return (N, B, A, b, c, v)</div></pre></td></tr></table></figure></p>\n<p>对标准型的输入来求解最优解的算法描述如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">simple(A, b ,c)</div><div class=\"line\">(N, B, A, b, c, v) &lt;0 initialize-simple(A, b, c)</div><div class=\"line\">while some index j in N has c&#123;j&#125; &gt; 0</div><div class=\"line\">    do choose an index e in N for which c&#123;e&#125; &gt; 0</div><div class=\"line\">        for each index i in B</div><div class=\"line\">            do if a&#123;ie&#125; &gt; 0</div><div class=\"line\">                then delta&#123;i&#125; &lt;- b&#123;i&#125;/a&#123;ie&#125;</div><div class=\"line\">                else delta&#123;i&#125; &lt;- INT</div><div class=\"line\">            choose an index l in B that minimizes delta&#123;i&#125;</div><div class=\"line\">            if delta&#123;i&#125; = INT</div><div class=\"line\">                then return &quot;unbounded&quot;</div><div class=\"line\">                else (N, B, A, b, c, v) &lt;- pivot(N, B, A, b, c, v, l, e)</div><div class=\"line\">for i &lt;- 1 to n</div><div class=\"line\">    do if i in B</div><div class=\"line\">        then x&#123;i&#125; &lt;- b&#123;i&#125;</div><div class=\"line\">        else x&#123;i&#125; &lt;- 0</div><div class=\"line\">return (x&#123;1&#125;, x&#123;2&#125;, ..., x&#123;n&#125;)</div></pre></td></tr></table></figure></p>\n<p>这里一般性地理解下,要通过单纯形算法来求解,在算法之前要肯定线性是可行(单纯性算法最初有一个初始化过程,会判断线性规划是否可行,返回一个初始基本解可行的松弛型),在算法之中要确保不陷入退化或说循环(目标值越迭代越小),能够终止返回最优解.单纯形算法输入一个标准型线性规划,返回线性规划一个最优解,能够顺利找到最优解并终止算法,后续对偶型可以说明.</p>\n<p>一个典型的单纯形算法例子：</p>\n<blockquote>\n<p>首先初始化标准型线性规划,返回一个初始基本解可行的松弛型,或者返回这个线性规划不可行,推出算法;其次对松弛型线性规划开始主元操作,选择非负系数最紧约束的换出变量,和换入变量交换,得到新的线性规划(和原来的线性规划是等价的);不断迭代这个过程,直到最优解确定,并终止返回一个最优解.<br>对于松弛型线性规划通过主元操作生成的新线性规划,二者是等价的.现在很重要的就是主元操作迭代,是如何选择换出变量的.选择一个在目标函数中系数为正值的非基本变量,尽可能增加其值而不违反任何约束.现在通过一个例子来理解单纯形算法的过程.</p>\n</blockquote>\n<p>1.标准型线性规划转化为松弛型线性规划<br>标准型：<br>最大化：<br>3x1+x2+2x3<br>满足约束：<br>x1+x2+3x3≤30<br>2x1+2x2+5x3≤24<br>4x1+x2+2x3≤36<br>x1,x2,x3≥0</p>\n<p>松弛型：<br>最大化：<br>z=3x1+x2+2x3<br>满足约束：<br>x4=30-x1-x2-3x3<br>x5=24-2x1-2x2-5x3<br>x6=36-4x1-x2-2x3</p>\n<p>确定基本解：把等式右边的所有变量设为0,可得基本解(x1,x2,x3,x4, x5, x6)=(0,0,0,30,24,36),目标值z=0;</p>\n<p>2.主元操作迭代第一次,选择增加x1的值.当增加x1值时,x4, x5, x6的值随之减小,但每个变量都有非负约束,所以不能减小到负值,这个时候就要在约束函数上选择最紧约束(就是选择最小增加值).<br>如果x1值增加到30,那么x4是负值;增加到12,则x5是负值;增加到9,则x6是负值;这个就知道了,9是x1值所能增加的最大值,就是最紧约束,对约束函数x6=36-4x1-x2-2x3互换变量x1和x6的角色,得到：x1=9- x2/4- x3/2- x6/4,代入原线性规划据此可得新的松弛型线性规划,如下：<br>最大化：<br>z=27+x2/4+ x3/2- 3x6/4<br>满足约束：<br>x1=9- x2/4- x3/2-x6/4<br>x4=21-3x2/4-5x3/2+x6/4<br>x5=6-3x2/2-4x3+x6/2<br>确定基本解,同样把等式右边的所有变量设为0,可得基本解(x1,x2,x3,x4, x5, x6)=(9,0,0,21,6,0),目标值z=27;</p>\n<p>3.主元操作迭代第二次,选择增加x3的值,最紧约束是x5=6-3x2/2-4x3+x6/2,最大增加到3/2,否则x5的值为负,和第一次迭代一样,互换x3和x5并代入线性等式获得新的线性规划,可得基本解(x1,x2,x3, x4, x5,x6)=(33/4,0,3/2,69/4,0,0),目标值z=111/4;<br>第四：主元操作迭代第三次,互换x2和x4并代入线性等式获得新的线性规划,可得基本解(x1,x2,x3, x4, x5,x6)=(8,4,0,18,0,0),目标值z=28,为最优解,(x1,x2,x3)=(8,4,0).<br>最关心的问题还是具有可行解的线性规划经过这样的迭代,在算法终止时是否确实能找到最优解,这个就留给线性规划对偶性来说明.</p>\n<ol>\n<li>单纯形算法分析<br>现在我们知道单纯形算法可以在多项式时间内求解线性规划最优解,那么关心两点：</li>\n</ol>\n<ul>\n<li>是算法终止时,获得的是最优解,这个就是对偶性要回答;</li>\n<li>二是输入一个线性规划要判断出是可行可解的,这个就是辅助线性规划要回答的.<br>任何线性规划都可能是不可行的,或是无界的,或有一个优先目标值得最优解,针对这些个情况,单纯形算法要能正确识别.</li>\n</ul>\n<p><strong>线性规划的基本定理</strong>：<br>以标准型给出任意的线性规划L可能是以下三者之一：<br>第一：有一个有限目标值的最优解;<br>第二：不可行;<br>第三：无界;</p>\n<p>如果L是不可行的,单纯形算法在初始化中就会返回不可行;如果L是无界的,单纯形算法返回无界,无界就是找不到最优解或者有无限个目标值;当然,满足第一情况的,就会返回有限目标值的最优解.<br>单纯形算法在初始化过程中,会确定线性规划是否有可行解,如果有,则给出一个基本解可行的松弛型线性规划.这个初始化过程其实就是对线性规划测试可行解.那么是如何来确认存在可行解呢？通过构造辅助线性规划,这个辅助线性规划,比较容易找到一个基本解可行的松弛型.只要辅助线性规划有可行解,则要输入的线性规划也就有可行解.如果线性规划L没有可行解,则初始化返回不可行,否则返回一个基本解可行的合法松弛型.怎么构造辅助线性规划呢？</p>\n<p>辅助线性规划：令L是一个标准型的线性规划,令 $L_{aux}$是带有n+1个变量的线性规划：<br>最小化：-x0<br>满足约束：<br>$$ \\sum_{j-1}^{n} a_{ij}x_j - x_0 \\leq b_i, i = 1, 2, \\dots, m \\\\<br>x_j \\geq 0, j = 0, 1, \\dots, n<br>$$<br>则当且仅当 $L_{aux}$的最优目标值为0时,L是可行的.<br>辅助线性规划,增加一个x0变量,并且令目标值为0.对辅助线性规划求解可行解,也是按照主元操作,将标准型转换成松弛型后不断交换变量迭代.辅助线性规划较容易找到可行解.算法导论中证明了辅助线性规划存在可行解就是要求解的线性规划存在可行解.</p>\n<p>现在我们要引进线性规划<strong>对偶性</strong>的概念.对偶性有一个很重要的性质：在一个最优化问题中,一个对偶问题的识别总是可以在一个多项式时间内发现.对偶性是用来证明某个解确实是最优解.还是动态规划思想：已知一个最大化问题,定义个相关的最小化问题,来让着两个问题有相同的最优目标值.如最大流问题的最大流最小割原理.对偶的字面意义,就是我的解也是你的解,大问题的解是小问题的解.</p>\n<p>已知一个目标是最大化的线性规划,制定一个对偶线性规划,其目标是最小化,而且最优值与原始线性规划相同.给定一个标准的原线性规划,定义对偶线性规划为：<br>$$<br>最小化: \\sum_{i=1}^{m} b_iy_i \\\\<br>满足约束: \\sum_{i=1}^{m} a_{ij}y_i \\geq c_j, j = 1,2, \\dots, n \\\\<br>y_i \\geq 0, i = 1, 2, \\dots, m<br>$$<br>构造对偶,将最大化改成最小化,将约束右边的与目标函数的稀疏角色互换,并且小于等于号变成大于等于号.在原问题的m个约束中,每一个在对偶问题中都一个对应的变量yi,在对偶问题的n个约束中,每一个在原问题中都一个对应的变量xj.</p>\n<p>对偶性能证明最优解主要是两点：</p>\n<ul>\n<li>原线性规划中的目标函数的系数变成对偶线性规划中约束函数的右边值,原线性规划中的约束函数的右边值变成对偶线性规划中目标函数的系数;</li>\n<li>原线性规划中每一个约束函数的左边等于对偶线性规划中的一个变量,就是原线性规划中的m个约束函数等于m个对偶线性规划中的变量,反之也是.最后证明了对偶线性规划的最优值总是等于原线性规划的最优值.</li>\n</ul>\n<h3 id=\"Chapter28-寻找子串\"><a href=\"#Chapter28-寻找子串\" class=\"headerlink\" title=\"Chapter28 寻找子串\"></a>Chapter28 寻找子串</h3><p>字符串匹配是一个很常见的问题,可以扩展为模式的识别,解决字符串问题的思想被广泛地应用.字符串匹配问题可以描述如下:<br><img src=\"/images/string-match1.png\" alt=\"string-match1\"><br>介绍3种解决该问题的办法,包括：最朴素的遍历法,Rabin-Karp算法,自Knuth-Morris-Pratt算法即KMP.<br>首先对时间复杂度做出一个概括(从大到小)：</p>\n<ul>\n<li>朴素法：$O((n-m+1)m)$;</li>\n<li>Rabin-Karp：预处理：$O(m)$,匹配：最坏 $O((n-m+1)m)$,但是平均和实际中比这个好得多;</li>\n<li>KMP：预处理O(m),匹配O(n).<br>其中,m代表模式P的长度,n代表被匹配的数组S的长度,Σ代表P和S的字符表.</li>\n</ul>\n<p>接下来分开学习对应的算法和思想.</p>\n<p>1.朴素法(native)<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">navite-string-matcher(T, P)</div><div class=\"line\">n &lt;- length[T]</div><div class=\"line\">m &lt;- length[P]</div><div class=\"line\">for s &lt;- 0 to n - m</div><div class=\"line\">    do if p[1...m] = T[s+1...s+m]</div><div class=\"line\">        then print &quot;Pattern occurs with shift&quot;</div></pre></td></tr></table></figure></p>\n<p>朴素法简单直接,就是从T的每一个字符开始,看它之后(包括它)的m个字符与P是否一样.P从S中第几个字符开始,可以看作,P在S中位移了几步.<br>朴素法的效率低的问题在于,它几乎忽视了所有的信息,每一次匹配都是“全新地”.如果P=abc,S=abdabc,从位置0开始,当我们匹配到 位置2,即c != d,朴素的做法是下一步从位置1开始匹配, 然而,在之前的匹配过程中,我们可以知道位置1的值b必然不匹配位置0的a.这是我们光通过P就能知道的,因为既然前一步已经开始去匹配位置2了,证明说明0和1已经成功匹配,而通过P自己,我们知道P的位置1不匹配0,则前一步的S位置1必然也不匹配P的位置1,这样就可以跳过这一步.问题在于,告诉程序跳过多少步,这就是我们接下来的算法要做的.显然,跳过得越多匹配越快,同时我们为了尽可能得到跳步的信息,可能需要进行预处理,预处理会产生另外的时间.</p>\n<p>2.Rabin-Karp<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">rabin-karp-matcher(T, P, d, q)</div><div class=\"line\">n &lt;- length[T]</div><div class=\"line\">m &lt;- length[P]</div><div class=\"line\">j &lt;- d^&#123;m-1&#125; mod q</div><div class=\"line\">p &lt;- 0</div><div class=\"line\">t&#123;0&#125; &lt;- 0</div><div class=\"line\">for i &lt;- 1 to m   #预处理</div><div class=\"line\">    do p &lt;- (dp + p[i]) mod q</div><div class=\"line\">        t&#123;0&#125; &lt;- (dt&#123;0&#125; + T[i]) mod q</div><div class=\"line\">for s &lt;- 0 to n - m  #匹配</div><div class=\"line\">    do if p = t&#123;s&#125;</div><div class=\"line\">        then if P[1..m] = T[s+1...s+m]</div><div class=\"line\">            then print &quot;Pattern occurs with shift&quot;s</div><div class=\"line\">        if s &lt;- n - m</div><div class=\"line\">            then t&#123;s+1&#125; &lt;- (d(t&#123;s&#125; - T[s+1]h) + T[s+m+1]) mod q</div></pre></td></tr></table></figure></p>\n<p>执行过程如下:<br><img src=\"/images/robin-karp.png\" alt=\"robin-karp\"></p>\n<p>算法将字符串转化为数,进制就是字符表的字符数目.那么,P是一个m位数,这个转化很容易用 $O(m)$ 算出来,通过遍历可以解决.再将S变为n-m+1个数：第一个数同P一样,$O(m)$ 完成预处理;当有了第k个数,算第k+1个数的时候,只需要去掉高位,补上低位,$O(1)$ 完成这个递推过程;总的预处理还是 $O(m)$.匹配的时候就是比较n-m+1次,所以复杂度是 $O(n-m+1)$.那么,为什么说它匹配最坏是 $O((n-m+1)m)$ 呢？<br>原因在于这个转化得来的数可能很大,算术运算不是常数,怎么处理大数呢？这个时候可以用模除来做一个简单的hash,匹配的数hash一定匹配,hash匹配原数不一定匹配,需要再回去做检查.最差的情况下,所有的hash都一样,每个hash都匹配了,全部需要回去检查一遍,那么这个时候匹配过程和朴素法一样.工程上来说,通常选取一个较大的素数来做模除.算法的最差运行时间是 $O((n-m+1)m)$, 当素数比模式P长度大很多时,期望运行时间是 $O(n+ m)$.</p>\n<p>3.KMP<br>KMP实际上是利用自动机的思想,但是我们并不是预先算好变迁函数.KMP遇到新字符,如果匹配当然是下一个状态,不匹配的话并不像自动机一步到位地接收新字符后到另一个状态,而是先到另一个状态,再递归地看是否接收这个字符,最终接收后在看下一个字符.关键在于,不匹配时,改变状态时是带着新字符还是不带.那么辅助的数组(数组也好,函数也好,总归还是查表),就从多维降到一维,多维是因为自动机遇到不同新字符跳到不同的状态,一维是KMP遇到新字符不匹配时直接跳到另一个状态,跳的时候不考虑新字符.直观上看,构建这样的数组也不再需要遍历Σ,预处理过程复杂度应该会降低.事实,确实省去了O(|Σ|)的复杂度,降到O(m)复杂度.同时,匹配时的复杂度还保持在了O(n).分析复杂度用到平摊分析法.<br>匹配过程是简单直观的,如前所述,遇到新字符,借助辅助数组π不断地改变状态.伪代码乳如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">kmp-matcher(T,P)</div><div class=\"line\">n &lt;- length[T]</div><div class=\"line\">m &lt;- length[P]</div><div class=\"line\">π &lt;- kmp-computer-prefix(P)</div><div class=\"line\">q &lt;- 0               // state , number of char matched</div><div class=\"line\">for i &lt;- 1 to n</div><div class=\"line\">    while q &gt; 0 &amp;&amp; P[q+1] != T[i]  // P and T range from 1 to n, not 0 to n-1</div><div class=\"line\">        do q &lt;- π[q]</div><div class=\"line\">        if P[q+1] = T[i]</div><div class=\"line\">            then q &lt;- q+1</div><div class=\"line\">        if q = m</div><div class=\"line\">            then print &quot;Pattern occurs with shift&quot; i-m</div><div class=\"line\">                q &lt;- π[q]</div></pre></td></tr></table></figure></p>\n<p>那么,问题的关键还是在于计算辅助数组π,即状态如何转移.这里KMP计算的时候,从P的低位(左边)开始计算π,显然只会用到前面低位的信息,不会用到后面高位的信息.那么利用动态规划中利用记录减少迭代的思想,再把计算π的过程看做与匹配过程类似,比如计算q+1那么就是用Pq去匹配Pq+1嘛,而Pq的数组π已经建立好了.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">kmp-computer-prefix(P)</div><div class=\"line\"></div><div class=\"line\">m &lt;- length[P]</div><div class=\"line\">π[1] &lt;- 0</div><div class=\"line\">k &lt;- 0               // just like q above, number of char matched</div><div class=\"line\">for q &lt;-  2 to m     // like i above, and actually it is state, so its name is q</div><div class=\"line\">    while k&gt;0 &amp;&amp; P[k+1] != P[q]  // P range from 1 to n, not 0 to n-1</div><div class=\"line\">        do k &lt;- π[k]</div><div class=\"line\">        if P[k+1] = P[q]</div><div class=\"line\">            then k &lt;- k+1</div><div class=\"line\">        π[q] &lt;- k</div><div class=\"line\">return π</div></pre></td></tr></table></figure></p>\n<p>kmp算法执行如下:<br><img src=\"/images/kmp1.png\" alt=\"kmp1\"><br><img src=\"/images/kmp2.png\" alt=\"kmp2\"></p>"},{"title":"hw1-boot-xv6","date":"2017-04-08T16:00:00.000Z","_content":"\n# hw1: boot xv6\n### 摘要\n>   6.828课程包括JOS实验和xv6系统两部分,其中JOS是从xv6中抽取的学习环境,学习xv6(阅读和修改)把握操作系统的全局, 实践JOS(project)则深入os的核心构建,相互辅助.\nxv6学习主要通过xv6-book以及编译xv6实现, homework1即是启动xv6系统.\n\n### answer\n#### 1. xv6源码\n```bash\ngit clone git://github.com/mit-pdos/xv6-public.git\n```\n#### 2. 编译\n```bash\ncd xv6\nmake\n```\n生成xv6.img镜像文件, 在qemu上模拟运行.\n\n<!-- more -->\n\n#### 3. 定位_start\n```bash\n$ nm kernel | grep _start\n```\n![_start.png](./_start.png)\n定位_start的address为0x10000c\n接着运行xv6, 在_start打断点,确定xv6启动时的系统信息\n双开终端, 在一个终端`make qemu-gdb`, 另一个`gdb`,gdb成功连接上qemu的远程调试后,调试xv6\n```\nbr * 0x10000c\n0x10000c:\tmov    %cr4,%eax\n```\n![br_start](./br_start.png)\n\n#### 4. 启动时堆栈上有什么?\n根据boot.S、boot.c和boot.asm中的代码，并结合四个问题\n> 1.在0x7c00设置断点，单步指令调试，查看堆栈指针$esp在哪里被初始化。\n2.单步调试，直到调用bootmain函数，观察堆栈内容。\n3.在bootmain函数中第1条汇编指令做了什么。\n4.在boot.asm中查找使eip变为0x10000c的指令，观察堆栈的变化。\n\n\n1.在调用bootmain函数前，esp被初始化为0x7c00，即boot.s的入口。\n```asm\nboot.asm  mov    $start,  $esp\n0x7c40:   mov    $0x7c00, $esp\n```\n２.在调用bootmain函数时，调用者保存调用地址，即下一条指令，并使$esp-4。\n```asm\nboot.asm\n0x7c45:  call bootmain\nspin:\n0x7c4a:  jmp spin\n```\n\n3.在bootmain函数中，第1条汇编指令`为push     $ebp`，将$ebp压入堆栈，即保存调用者的栈帧。\n```asm\nboot.asm\n0x7d0c:  push $ebp\n```\n４.当eip变为0x10000c时，bootmain函数将调用地址压入堆栈。 ","source":"_posts/hw1.md","raw":"title: hw1-boot-xv6\ndate: 2017/04/09\ntags: \n\t- os\n\t- xv6\n\n---\n\n# hw1: boot xv6\n### 摘要\n>   6.828课程包括JOS实验和xv6系统两部分,其中JOS是从xv6中抽取的学习环境,学习xv6(阅读和修改)把握操作系统的全局, 实践JOS(project)则深入os的核心构建,相互辅助.\nxv6学习主要通过xv6-book以及编译xv6实现, homework1即是启动xv6系统.\n\n### answer\n#### 1. xv6源码\n```bash\ngit clone git://github.com/mit-pdos/xv6-public.git\n```\n#### 2. 编译\n```bash\ncd xv6\nmake\n```\n生成xv6.img镜像文件, 在qemu上模拟运行.\n\n<!-- more -->\n\n#### 3. 定位_start\n```bash\n$ nm kernel | grep _start\n```\n![_start.png](./_start.png)\n定位_start的address为0x10000c\n接着运行xv6, 在_start打断点,确定xv6启动时的系统信息\n双开终端, 在一个终端`make qemu-gdb`, 另一个`gdb`,gdb成功连接上qemu的远程调试后,调试xv6\n```\nbr * 0x10000c\n0x10000c:\tmov    %cr4,%eax\n```\n![br_start](./br_start.png)\n\n#### 4. 启动时堆栈上有什么?\n根据boot.S、boot.c和boot.asm中的代码，并结合四个问题\n> 1.在0x7c00设置断点，单步指令调试，查看堆栈指针$esp在哪里被初始化。\n2.单步调试，直到调用bootmain函数，观察堆栈内容。\n3.在bootmain函数中第1条汇编指令做了什么。\n4.在boot.asm中查找使eip变为0x10000c的指令，观察堆栈的变化。\n\n\n1.在调用bootmain函数前，esp被初始化为0x7c00，即boot.s的入口。\n```asm\nboot.asm  mov    $start,  $esp\n0x7c40:   mov    $0x7c00, $esp\n```\n２.在调用bootmain函数时，调用者保存调用地址，即下一条指令，并使$esp-4。\n```asm\nboot.asm\n0x7c45:  call bootmain\nspin:\n0x7c4a:  jmp spin\n```\n\n3.在bootmain函数中，第1条汇编指令`为push     $ebp`，将$ebp压入堆栈，即保存调用者的栈帧。\n```asm\nboot.asm\n0x7d0c:  push $ebp\n```\n４.当eip变为0x10000c时，bootmain函数将调用地址压入堆栈。 ","slug":"hw1","published":1,"updated":"2017-08-26T03:38:21.598Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6sslhay000e3gamvmb9ap3z","content":"<h1 id=\"hw1-boot-xv6\"><a href=\"#hw1-boot-xv6\" class=\"headerlink\" title=\"hw1: boot xv6\"></a>hw1: boot xv6</h1><h3 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h3><blockquote>\n<p>  6.828课程包括JOS实验和xv6系统两部分,其中JOS是从xv6中抽取的学习环境,学习xv6(阅读和修改)把握操作系统的全局, 实践JOS(project)则深入os的核心构建,相互辅助.<br>xv6学习主要通过xv6-book以及编译xv6实现, homework1即是启动xv6系统.</p>\n</blockquote>\n<h3 id=\"answer\"><a href=\"#answer\" class=\"headerlink\" title=\"answer\"></a>answer</h3><h4 id=\"1-xv6源码\"><a href=\"#1-xv6源码\" class=\"headerlink\" title=\"1. xv6源码\"></a>1. xv6源码</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git <span class=\"built_in\">clone</span> git://github.com/mit-pdos/xv6-public.git</div></pre></td></tr></table></figure>\n<h4 id=\"2-编译\"><a href=\"#2-编译\" class=\"headerlink\" title=\"2. 编译\"></a>2. 编译</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">cd</span> xv6</div><div class=\"line\">make</div></pre></td></tr></table></figure>\n<p>生成xv6.img镜像文件, 在qemu上模拟运行.</p>\n<a id=\"more\"></a>\n<h4 id=\"3-定位-start\"><a href=\"#3-定位-start\" class=\"headerlink\" title=\"3. 定位_start\"></a>3. 定位_start</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ nm kernel | grep _start</div></pre></td></tr></table></figure>\n<p><img src=\"./_start.png\" alt=\"_start.png\"><br>定位_start的address为0x10000c<br>接着运行xv6, 在_start打断点,确定xv6启动时的系统信息<br>双开终端, 在一个终端<code>make qemu-gdb</code>, 另一个<code>gdb</code>,gdb成功连接上qemu的远程调试后,调试xv6<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">br * 0x10000c</div><div class=\"line\">0x10000c:\tmov    %cr4,%eax</div></pre></td></tr></table></figure></p>\n<p><img src=\"./br_start.png\" alt=\"br_start\"></p>\n<h4 id=\"4-启动时堆栈上有什么\"><a href=\"#4-启动时堆栈上有什么\" class=\"headerlink\" title=\"4. 启动时堆栈上有什么?\"></a>4. 启动时堆栈上有什么?</h4><p>根据boot.S、boot.c和boot.asm中的代码，并结合四个问题</p>\n<blockquote>\n<p>1.在0x7c00设置断点，单步指令调试，查看堆栈指针$esp在哪里被初始化。<br>2.单步调试，直到调用bootmain函数，观察堆栈内容。<br>3.在bootmain函数中第1条汇编指令做了什么。<br>4.在boot.asm中查找使eip变为0x10000c的指令，观察堆栈的变化。</p>\n</blockquote>\n<p>1.在调用bootmain函数前，esp被初始化为0x7c00，即boot.s的入口。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">boot.asm  mov    $start,  $esp</div><div class=\"line\">0x7c40:   mov    $0x7c00, $esp</div></pre></td></tr></table></figure></p>\n<p>２.在调用bootmain函数时，调用者保存调用地址，即下一条指令，并使$esp-4。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">boot.asm</div><div class=\"line\">0x7c45:  call bootmain</div><div class=\"line\">spin:</div><div class=\"line\">0x7c4a:  jmp spin</div></pre></td></tr></table></figure></p>\n<p>3.在bootmain函数中，第1条汇编指令<code>为push     $ebp</code>，将$ebp压入堆栈，即保存调用者的栈帧。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">boot.asm</div><div class=\"line\">0x7d0c:  push $ebp</div></pre></td></tr></table></figure></p>\n<p>４.当eip变为0x10000c时，bootmain函数将调用地址压入堆栈。 </p>\n","site":{"data":{}},"excerpt":"<h1 id=\"hw1-boot-xv6\"><a href=\"#hw1-boot-xv6\" class=\"headerlink\" title=\"hw1: boot xv6\"></a>hw1: boot xv6</h1><h3 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h3><blockquote>\n<p>  6.828课程包括JOS实验和xv6系统两部分,其中JOS是从xv6中抽取的学习环境,学习xv6(阅读和修改)把握操作系统的全局, 实践JOS(project)则深入os的核心构建,相互辅助.<br>xv6学习主要通过xv6-book以及编译xv6实现, homework1即是启动xv6系统.</p>\n</blockquote>\n<h3 id=\"answer\"><a href=\"#answer\" class=\"headerlink\" title=\"answer\"></a>answer</h3><h4 id=\"1-xv6源码\"><a href=\"#1-xv6源码\" class=\"headerlink\" title=\"1. xv6源码\"></a>1. xv6源码</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">git <span class=\"built_in\">clone</span> git://github.com/mit-pdos/xv6-public.git</div></pre></td></tr></table></figure>\n<h4 id=\"2-编译\"><a href=\"#2-编译\" class=\"headerlink\" title=\"2. 编译\"></a>2. 编译</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">cd</span> xv6</div><div class=\"line\">make</div></pre></td></tr></table></figure>\n<p>生成xv6.img镜像文件, 在qemu上模拟运行.</p>","more":"<h4 id=\"3-定位-start\"><a href=\"#3-定位-start\" class=\"headerlink\" title=\"3. 定位_start\"></a>3. 定位_start</h4><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ nm kernel | grep _start</div></pre></td></tr></table></figure>\n<p><img src=\"./_start.png\" alt=\"_start.png\"><br>定位_start的address为0x10000c<br>接着运行xv6, 在_start打断点,确定xv6启动时的系统信息<br>双开终端, 在一个终端<code>make qemu-gdb</code>, 另一个<code>gdb</code>,gdb成功连接上qemu的远程调试后,调试xv6<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">br * 0x10000c</div><div class=\"line\">0x10000c:\tmov    %cr4,%eax</div></pre></td></tr></table></figure></p>\n<p><img src=\"./br_start.png\" alt=\"br_start\"></p>\n<h4 id=\"4-启动时堆栈上有什么\"><a href=\"#4-启动时堆栈上有什么\" class=\"headerlink\" title=\"4. 启动时堆栈上有什么?\"></a>4. 启动时堆栈上有什么?</h4><p>根据boot.S、boot.c和boot.asm中的代码，并结合四个问题</p>\n<blockquote>\n<p>1.在0x7c00设置断点，单步指令调试，查看堆栈指针$esp在哪里被初始化。<br>2.单步调试，直到调用bootmain函数，观察堆栈内容。<br>3.在bootmain函数中第1条汇编指令做了什么。<br>4.在boot.asm中查找使eip变为0x10000c的指令，观察堆栈的变化。</p>\n</blockquote>\n<p>1.在调用bootmain函数前，esp被初始化为0x7c00，即boot.s的入口。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">boot.asm  mov    $start,  $esp</div><div class=\"line\">0x7c40:   mov    $0x7c00, $esp</div></pre></td></tr></table></figure></p>\n<p>２.在调用bootmain函数时，调用者保存调用地址，即下一条指令，并使$esp-4。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">boot.asm</div><div class=\"line\">0x7c45:  call bootmain</div><div class=\"line\">spin:</div><div class=\"line\">0x7c4a:  jmp spin</div></pre></td></tr></table></figure></p>\n<p>3.在bootmain函数中，第1条汇编指令<code>为push     $ebp</code>，将$ebp压入堆栈，即保存调用者的栈帧。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">boot.asm</div><div class=\"line\">0x7d0c:  push $ebp</div></pre></td></tr></table></figure></p>\n<p>４.当eip变为0x10000c时，bootmain函数将调用地址压入堆栈。 </p>"},{"title":"hw2-shell","date":"2017-04-15T16:00:00.000Z","_content":"# hw2 shell\n## 目标\nhw2主要是根据xv6,学习linux的系统调用,实现一个简化版的shell.\n目标可以分解为:\n> * 阅读源代码\n> * 添加执行命令的功能\n> * 添加IO重定向\n> * 添加管道功能\n\n## part1: command\n### 命令的种类\n#### 命令参数个数\n> 首先,一个命令的参数总数是限制的,xv6 shell规定一个命令的参数最多只能有10个.\n`#define MAXARGS 10`\n\n<!-- more -->\n\n#### 命令的基类\n> 所有的命令都必须有一个种类。这里声明一个`struct cmd`的作用是为了用来指向特定的某个cmd的类型。注意后面声明的`struct`都是在一个结构的开头int指明了一个type.后面可以把这个结构体在`struct *cmd`之间进行转换.这里采用了C++的面向对象的思想，struct cmd是execcmd, redircmd, pipecmd的基类。后面要处理各种命令的时候，都是使用的是`struct *cmd`类型的指针。\n实际结构如下：\n```c\npipecmd {\n\t- left = pipecmd {\n\t\t\t\t   - left: a\n\t\t\t\t   - right: b\n\t\t\t  }\n   - right = execcmd {\n   \t\t\t\t   - cmd: c\n       \t  }\n}\n\n// All commands have at least a type. Have looked at the type, the code\n// typically casts the *cmd to some specific cmd type.\nstruct cmd {\n  int type;          //  ' ' (exec), | (pipe), '<' or '>' for redirection\n};\n```\n#### execcmd\n> 可以直接执行的命令。也就是说不存在IO重定向，管道等情况。所以这里的type注释写的是空格' '。\n```c\nstruct execcmd {\n  int type;              // ' '\n  char *argv[MAXARGS];   // arguments to the command to be exec-ed\n};\n```\n#### redircmd\n重定向输入输出的命令。这里记录下的参数包含了：\n> * 命令类型，重定向输入还是重定向输出\n> * 要执行的命令\n> * 输入或者输出文件\n> * 打开文件的模式\n> * 文件描述符\n```c\nstruct redircmd {\n  int type;          // < or >\n  struct cmd *cmd;   // the command to be run (e.g., an execcmd)\n  char *file;        // the input/output file\n  int mode;          // the mode to open the file with\n  int fd;            // the file descriptor number to use for the file\n};\n```\n#### pipecmd\npipecmd执行是实现重定向输出的情况.\n```c\nstruct pipecmd {\n  int type;          // |\n  struct cmd *left;  // left side of pipe\n  struct cmd *right; // right side of pipe\n};\n```\n\n### 命令的执行\n命令的执行则主要是在runcmd函数里面进行。runcmd根据命令的类型来决定执行何种操作:\n> * 如果是未定义的命令类型，直接报错，并退出。\n> * 如果是execcmd类型，需要添加执行代码。实际上作业需要完成的代码也是在这里完成。\n> * '>'和'<'表示输入输出重定向。\n> * '|'管道操作，就是把前面一个程序的输出，重定向为后面一个程序的输入。\n上面这些功能，都处于未完成的状态。都还需要添加代码。\n```c\n// Execute cmd.  Never returns.\nvoid runcmd(struct cmd *cmd)\n{\n  int p[2], r;\n  struct execcmd *ecmd;\n  struct pipecmd *pcmd;\n  struct redircmd *rcmd;\n  if(cmd == 0)\n    exit(0);\n  switch(cmd->type){\n  default:\n    fprintf(stderr, \"unknown runcmd\\n\");\n    exit(-1);\n  case ' ':\n    ecmd = (struct execcmd*)cmd;\n    if(ecmd->argv[0] == 0)\n      exit(0);\n    fprintf(stderr, \"exec not implemented\\n\");\n    // Your code here ...\n    break;\n  case '>':\n  case '<':\n    rcmd = (struct redircmd*)cmd;\n    fprintf(stderr, \"redir not implemented\\n\");\n    // Your code here ...\n    runcmd(rcmd->cmd);\n    break;\n  case '|':\n    pcmd = (struct pipecmd*)cmd;\n    fprintf(stderr, \"pipe not implemented\\n\");\n    // Your code here ...\n    break;\n  }\n  exit(0);\n}\n```\n\n### 命令的获取\n从终端中读取需要执行的命令。getcmd的三个任务:\n> * 判断是不是终端，如果是，那么输出\"6.828$\"提标符。\n> * 清空内存，然后读取输入。\n> * 判断是不是读入了EOF结束标志。如果是，返回-1。\n```c\nint getcmd(char *buf, int nbuf)\n{\n  if (isatty(fileno(stdin)))\n    fprintf(stdout, \"6.828$ \");\n  memset(buf, 0, nbuf);\n  fgets(buf, nbuf, stdin);\n  if(buf[0] == 0) // EOF\n    return -1;\n  return 0;\n}\n```\n\n### 主程序\n主程序比较简单,分为两部分：\n> * 查看是不是cd命令，如果是，那么调用chdir系统调用。\n> * 否则调用fork，利用子进程rumcmd。\n```c\nint main(void)\n{\n  static char buf[100];\n  int fd, r;\n  // Read and run input commands.\n  while(getcmd(buf, sizeof(buf)) >= 0){\n    if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){\n      // Clumsy but will have to do for now.\n      // Chdir has no effect on the parent if run in the child.\n      buf[strlen(buf)-1] = 0;  // chop \\n\n      if(chdir(buf+3) < 0)\n        fprintf(stderr, \"cannot cd %s\\n\", buf+3);\n      continue;\n    }\n    if(fork1() == 0)\n      runcmd(parsecmd(buf));\n    wait(&r);\n  }\n  exit(0);\n}\n```\n\n### homework\n代码实现如下:\n```c\nvoid runcmd(struct cmd *cmd)\n{\n  int p[2], r;\n  struct execcmd *ecmd;\n  struct pipecmd *pcmd;\n  struct redircmd *rcmd;\n\n  char * path;\n  path = malloc(MAXPATH * sizeof(char*));\n\n  if(cmd == 0)\n    exit(0);\n\n  switch(cmd->type){\n  default:\n    fprintf(stderr, \"unknown runcmd\\n\");\n    exit(-1);\n\n  case ' ':\n    ecmd = (struct execcmd*)cmd;\n    if(ecmd->argv[0] == 0)\n      exit(0);\n\n    // 任务 1: 实现简单指令的调用与缺省路径\n    strcat(path, ecmd->argv[0]);\n        // My code here...\n    strcpy(path, \"\");\n    strcat(path, ecmd->argv[0]);\n    if(!access(path, F_OK)) {\n      execv(path, ecmd->argv);\n      break;\n    }\n\n    strcpy(path, \"/bin/\");\n    strcat(path, ecmd->argv[0]);\n    if(!access(path, F_OK)) {\n      execv(path, ecmd->argv);\n      break;\n    }\n\n    strcpy(path, \"/usr/bin/\");\n    strcat(path, ecmd->argv[0]);\n    if(!access(path, F_OK)) {\n      execv(path, ecmd->argv);\n      break;\n    }\n\n    fprintf(stderr, \"exec not implemented\\n\");\n    break;\n\n  // 任务 2: 实现I/O重定向  \n  case '>':\n  case '<':\n    rcmd = (struct redircmd*)cmd;\n\n    // sub 1. 关闭被重定向覆盖的文件描述符\n    close(rcmd->fd);\n\n    // sub 2. 处理系统调用失败的情况, 注意文件权限(0777)为八进制数保证符合约定\n    if (open(rcmd->flie, rcmd->mode, 0777) < 0) {\n      fprintf(stderr, \"open file %s failed.\", rcmd->file);\n      exit(0);\n    }\n\n    runcmd(rcmd->cmd);\n    break;\n\n  // 任务 3. 实现管道功能\n  case '|':\n    pcmd = (struct pipecmd*)cmd;\n\n    // sub 1. 调用系统接口pipe()创建一个管道, 首先检查失败情况\n    if(pipe(p) < 0){\n        fprintf(stderr, \"create pipe failed!\\n\");\n        exit(0);\n    }\n\n    // sub 2. 根据管道的语义, 创建子进程来处理两个过程\n    if((fork() == 0)) {\n        close(STDOUT_FILENO);\n        dup(p[1]);\n        close(p[0]);\n        close(p[1]);\n        runcmd(pcmd->left);\n    } else {\n        close(0);\n        dup(p[0]);\n        close(p[0]);\n        close(p[1]);\n        runcmd(pcmd->right);\n    }\n    wait(&r);\n    break;\n  }\n  exit(0);\n}\n```\n\n## 总结\n通过这个调用图可以看出命令处理的层次结构。\n![call graph](http://img.blog.csdn.net/20150419132244069)\n> * 首先根据|管道来切分块。比如{block_a} | {block_b} | {block_c} | {block_d}。处理逻辑不是通过for循环来处理，而是通过递归调用来解决。每一个block的处理都是通过parseexec来完成。\n```c\nstruct cmd*\nparsepipe(char **ps, char *es)\n{\n  struct cmd *cmd;\n  cmd = parseexec(ps, es);\n  if(peek(ps, es, \"|\")){\n    gettoken(ps, es, 0, 0);\n    cmd = pipecmd(cmd, parsepipe(ps, es));\n  }\n  return cmd;\n}\n```\n> * parseexec处理的时候，代码里面是同时处理了execcmd, redircmd这两种命令。也就是说，如果从C++的角度来看，类的继承关系就是：cmd->execcmd->redircmd。每个block的处理方式如下：\n```c\nargc = 0;\nret = parseredirs(ret, ps, es);\nwhile(!peek(ps, es, \"|\")){\n  if((tok=gettoken(ps, es, &q, &eq)) == 0)\n    break;\n  if(tok != 'a') {\n    fprintf(stderr, \"syntax error\\n\");\n    exit(-1);\n  }\n  cmd->argv[argc] = mkcopy(q, eq);\n  argc++;\n  if(argc >= MAXARGS) {\n    fprintf(stderr, \"too many args\\n\");\n    exit(-1);\n  }\n  ret = parseredirs(ret, ps, es);\n}\ncmd->argv[argc] = 0;\n```\n> * 如果没有IO重定向，那么parseredirs函数相当于空函数。没有任何作用。\n> * parseredirs的处理就比较简单，就只负责处理execcmd的<input.txt或者>output.txt部分。\n```c\nwhile(peek(ps, es, \"<>\")){\n  tok = gettoken(ps, es, 0, 0);\n  if(gettoken(ps, es, &q, &eq) != 'a') {\n    fprintf(stderr, \"missing file for redirection\\n\");\n    exit(-1);\n  }\n  switch(tok){\n  case '<':\n    cmd = redircmd(cmd, mkcopy(q, eq), '<');\n    break;\n  case '>':\n    cmd = redircmd(cmd, mkcopy(q, eq), '>');\n    break;\n  }\n}\n```\n\n## 参考链接\n1. [hw2 shell](https://pdos.csail.mit.edu/6.828/2016/homework/xv6-shell.html)\n2. [xv6 system call](https://pdos.csail.mit.edu/6.828/2016/xv6/book-rev9.pdf)\n3. [6.828 shell](https://pdos.csail.mit.edu/6.828/2016/homework/sh.c)\n","source":"_posts/hw2.md","raw":"title: hw2-shell\ndate: 2017/04/16\ntags:\n\t- os\n\t- xv6\n\n---\n# hw2 shell\n## 目标\nhw2主要是根据xv6,学习linux的系统调用,实现一个简化版的shell.\n目标可以分解为:\n> * 阅读源代码\n> * 添加执行命令的功能\n> * 添加IO重定向\n> * 添加管道功能\n\n## part1: command\n### 命令的种类\n#### 命令参数个数\n> 首先,一个命令的参数总数是限制的,xv6 shell规定一个命令的参数最多只能有10个.\n`#define MAXARGS 10`\n\n<!-- more -->\n\n#### 命令的基类\n> 所有的命令都必须有一个种类。这里声明一个`struct cmd`的作用是为了用来指向特定的某个cmd的类型。注意后面声明的`struct`都是在一个结构的开头int指明了一个type.后面可以把这个结构体在`struct *cmd`之间进行转换.这里采用了C++的面向对象的思想，struct cmd是execcmd, redircmd, pipecmd的基类。后面要处理各种命令的时候，都是使用的是`struct *cmd`类型的指针。\n实际结构如下：\n```c\npipecmd {\n\t- left = pipecmd {\n\t\t\t\t   - left: a\n\t\t\t\t   - right: b\n\t\t\t  }\n   - right = execcmd {\n   \t\t\t\t   - cmd: c\n       \t  }\n}\n\n// All commands have at least a type. Have looked at the type, the code\n// typically casts the *cmd to some specific cmd type.\nstruct cmd {\n  int type;          //  ' ' (exec), | (pipe), '<' or '>' for redirection\n};\n```\n#### execcmd\n> 可以直接执行的命令。也就是说不存在IO重定向，管道等情况。所以这里的type注释写的是空格' '。\n```c\nstruct execcmd {\n  int type;              // ' '\n  char *argv[MAXARGS];   // arguments to the command to be exec-ed\n};\n```\n#### redircmd\n重定向输入输出的命令。这里记录下的参数包含了：\n> * 命令类型，重定向输入还是重定向输出\n> * 要执行的命令\n> * 输入或者输出文件\n> * 打开文件的模式\n> * 文件描述符\n```c\nstruct redircmd {\n  int type;          // < or >\n  struct cmd *cmd;   // the command to be run (e.g., an execcmd)\n  char *file;        // the input/output file\n  int mode;          // the mode to open the file with\n  int fd;            // the file descriptor number to use for the file\n};\n```\n#### pipecmd\npipecmd执行是实现重定向输出的情况.\n```c\nstruct pipecmd {\n  int type;          // |\n  struct cmd *left;  // left side of pipe\n  struct cmd *right; // right side of pipe\n};\n```\n\n### 命令的执行\n命令的执行则主要是在runcmd函数里面进行。runcmd根据命令的类型来决定执行何种操作:\n> * 如果是未定义的命令类型，直接报错，并退出。\n> * 如果是execcmd类型，需要添加执行代码。实际上作业需要完成的代码也是在这里完成。\n> * '>'和'<'表示输入输出重定向。\n> * '|'管道操作，就是把前面一个程序的输出，重定向为后面一个程序的输入。\n上面这些功能，都处于未完成的状态。都还需要添加代码。\n```c\n// Execute cmd.  Never returns.\nvoid runcmd(struct cmd *cmd)\n{\n  int p[2], r;\n  struct execcmd *ecmd;\n  struct pipecmd *pcmd;\n  struct redircmd *rcmd;\n  if(cmd == 0)\n    exit(0);\n  switch(cmd->type){\n  default:\n    fprintf(stderr, \"unknown runcmd\\n\");\n    exit(-1);\n  case ' ':\n    ecmd = (struct execcmd*)cmd;\n    if(ecmd->argv[0] == 0)\n      exit(0);\n    fprintf(stderr, \"exec not implemented\\n\");\n    // Your code here ...\n    break;\n  case '>':\n  case '<':\n    rcmd = (struct redircmd*)cmd;\n    fprintf(stderr, \"redir not implemented\\n\");\n    // Your code here ...\n    runcmd(rcmd->cmd);\n    break;\n  case '|':\n    pcmd = (struct pipecmd*)cmd;\n    fprintf(stderr, \"pipe not implemented\\n\");\n    // Your code here ...\n    break;\n  }\n  exit(0);\n}\n```\n\n### 命令的获取\n从终端中读取需要执行的命令。getcmd的三个任务:\n> * 判断是不是终端，如果是，那么输出\"6.828$\"提标符。\n> * 清空内存，然后读取输入。\n> * 判断是不是读入了EOF结束标志。如果是，返回-1。\n```c\nint getcmd(char *buf, int nbuf)\n{\n  if (isatty(fileno(stdin)))\n    fprintf(stdout, \"6.828$ \");\n  memset(buf, 0, nbuf);\n  fgets(buf, nbuf, stdin);\n  if(buf[0] == 0) // EOF\n    return -1;\n  return 0;\n}\n```\n\n### 主程序\n主程序比较简单,分为两部分：\n> * 查看是不是cd命令，如果是，那么调用chdir系统调用。\n> * 否则调用fork，利用子进程rumcmd。\n```c\nint main(void)\n{\n  static char buf[100];\n  int fd, r;\n  // Read and run input commands.\n  while(getcmd(buf, sizeof(buf)) >= 0){\n    if(buf[0] == 'c' && buf[1] == 'd' && buf[2] == ' '){\n      // Clumsy but will have to do for now.\n      // Chdir has no effect on the parent if run in the child.\n      buf[strlen(buf)-1] = 0;  // chop \\n\n      if(chdir(buf+3) < 0)\n        fprintf(stderr, \"cannot cd %s\\n\", buf+3);\n      continue;\n    }\n    if(fork1() == 0)\n      runcmd(parsecmd(buf));\n    wait(&r);\n  }\n  exit(0);\n}\n```\n\n### homework\n代码实现如下:\n```c\nvoid runcmd(struct cmd *cmd)\n{\n  int p[2], r;\n  struct execcmd *ecmd;\n  struct pipecmd *pcmd;\n  struct redircmd *rcmd;\n\n  char * path;\n  path = malloc(MAXPATH * sizeof(char*));\n\n  if(cmd == 0)\n    exit(0);\n\n  switch(cmd->type){\n  default:\n    fprintf(stderr, \"unknown runcmd\\n\");\n    exit(-1);\n\n  case ' ':\n    ecmd = (struct execcmd*)cmd;\n    if(ecmd->argv[0] == 0)\n      exit(0);\n\n    // 任务 1: 实现简单指令的调用与缺省路径\n    strcat(path, ecmd->argv[0]);\n        // My code here...\n    strcpy(path, \"\");\n    strcat(path, ecmd->argv[0]);\n    if(!access(path, F_OK)) {\n      execv(path, ecmd->argv);\n      break;\n    }\n\n    strcpy(path, \"/bin/\");\n    strcat(path, ecmd->argv[0]);\n    if(!access(path, F_OK)) {\n      execv(path, ecmd->argv);\n      break;\n    }\n\n    strcpy(path, \"/usr/bin/\");\n    strcat(path, ecmd->argv[0]);\n    if(!access(path, F_OK)) {\n      execv(path, ecmd->argv);\n      break;\n    }\n\n    fprintf(stderr, \"exec not implemented\\n\");\n    break;\n\n  // 任务 2: 实现I/O重定向  \n  case '>':\n  case '<':\n    rcmd = (struct redircmd*)cmd;\n\n    // sub 1. 关闭被重定向覆盖的文件描述符\n    close(rcmd->fd);\n\n    // sub 2. 处理系统调用失败的情况, 注意文件权限(0777)为八进制数保证符合约定\n    if (open(rcmd->flie, rcmd->mode, 0777) < 0) {\n      fprintf(stderr, \"open file %s failed.\", rcmd->file);\n      exit(0);\n    }\n\n    runcmd(rcmd->cmd);\n    break;\n\n  // 任务 3. 实现管道功能\n  case '|':\n    pcmd = (struct pipecmd*)cmd;\n\n    // sub 1. 调用系统接口pipe()创建一个管道, 首先检查失败情况\n    if(pipe(p) < 0){\n        fprintf(stderr, \"create pipe failed!\\n\");\n        exit(0);\n    }\n\n    // sub 2. 根据管道的语义, 创建子进程来处理两个过程\n    if((fork() == 0)) {\n        close(STDOUT_FILENO);\n        dup(p[1]);\n        close(p[0]);\n        close(p[1]);\n        runcmd(pcmd->left);\n    } else {\n        close(0);\n        dup(p[0]);\n        close(p[0]);\n        close(p[1]);\n        runcmd(pcmd->right);\n    }\n    wait(&r);\n    break;\n  }\n  exit(0);\n}\n```\n\n## 总结\n通过这个调用图可以看出命令处理的层次结构。\n![call graph](http://img.blog.csdn.net/20150419132244069)\n> * 首先根据|管道来切分块。比如{block_a} | {block_b} | {block_c} | {block_d}。处理逻辑不是通过for循环来处理，而是通过递归调用来解决。每一个block的处理都是通过parseexec来完成。\n```c\nstruct cmd*\nparsepipe(char **ps, char *es)\n{\n  struct cmd *cmd;\n  cmd = parseexec(ps, es);\n  if(peek(ps, es, \"|\")){\n    gettoken(ps, es, 0, 0);\n    cmd = pipecmd(cmd, parsepipe(ps, es));\n  }\n  return cmd;\n}\n```\n> * parseexec处理的时候，代码里面是同时处理了execcmd, redircmd这两种命令。也就是说，如果从C++的角度来看，类的继承关系就是：cmd->execcmd->redircmd。每个block的处理方式如下：\n```c\nargc = 0;\nret = parseredirs(ret, ps, es);\nwhile(!peek(ps, es, \"|\")){\n  if((tok=gettoken(ps, es, &q, &eq)) == 0)\n    break;\n  if(tok != 'a') {\n    fprintf(stderr, \"syntax error\\n\");\n    exit(-1);\n  }\n  cmd->argv[argc] = mkcopy(q, eq);\n  argc++;\n  if(argc >= MAXARGS) {\n    fprintf(stderr, \"too many args\\n\");\n    exit(-1);\n  }\n  ret = parseredirs(ret, ps, es);\n}\ncmd->argv[argc] = 0;\n```\n> * 如果没有IO重定向，那么parseredirs函数相当于空函数。没有任何作用。\n> * parseredirs的处理就比较简单，就只负责处理execcmd的<input.txt或者>output.txt部分。\n```c\nwhile(peek(ps, es, \"<>\")){\n  tok = gettoken(ps, es, 0, 0);\n  if(gettoken(ps, es, &q, &eq) != 'a') {\n    fprintf(stderr, \"missing file for redirection\\n\");\n    exit(-1);\n  }\n  switch(tok){\n  case '<':\n    cmd = redircmd(cmd, mkcopy(q, eq), '<');\n    break;\n  case '>':\n    cmd = redircmd(cmd, mkcopy(q, eq), '>');\n    break;\n  }\n}\n```\n\n## 参考链接\n1. [hw2 shell](https://pdos.csail.mit.edu/6.828/2016/homework/xv6-shell.html)\n2. [xv6 system call](https://pdos.csail.mit.edu/6.828/2016/xv6/book-rev9.pdf)\n3. [6.828 shell](https://pdos.csail.mit.edu/6.828/2016/homework/sh.c)\n","slug":"hw2","published":1,"updated":"2017-08-26T03:38:21.614Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6sslhaz000g3gam0ukwsdal","content":"<h1 id=\"hw2-shell\"><a href=\"#hw2-shell\" class=\"headerlink\" title=\"hw2 shell\"></a>hw2 shell</h1><h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><p>hw2主要是根据xv6,学习linux的系统调用,实现一个简化版的shell.<br>目标可以分解为:</p>\n<blockquote>\n<ul>\n<li>阅读源代码</li>\n<li>添加执行命令的功能</li>\n<li>添加IO重定向</li>\n<li>添加管道功能</li>\n</ul>\n</blockquote>\n<h2 id=\"part1-command\"><a href=\"#part1-command\" class=\"headerlink\" title=\"part1: command\"></a>part1: command</h2><h3 id=\"命令的种类\"><a href=\"#命令的种类\" class=\"headerlink\" title=\"命令的种类\"></a>命令的种类</h3><h4 id=\"命令参数个数\"><a href=\"#命令参数个数\" class=\"headerlink\" title=\"命令参数个数\"></a>命令参数个数</h4><blockquote>\n<p>首先,一个命令的参数总数是限制的,xv6 shell规定一个命令的参数最多只能有10个.<br><code>#define MAXARGS 10</code></p>\n</blockquote>\n<a id=\"more\"></a>\n<h4 id=\"命令的基类\"><a href=\"#命令的基类\" class=\"headerlink\" title=\"命令的基类\"></a>命令的基类</h4><blockquote>\n<p>所有的命令都必须有一个种类。这里声明一个<code>struct cmd</code>的作用是为了用来指向特定的某个cmd的类型。注意后面声明的<code>struct</code>都是在一个结构的开头int指明了一个type.后面可以把这个结构体在<code>struct *cmd</code>之间进行转换.这里采用了C++的面向对象的思想，struct cmd是execcmd, redircmd, pipecmd的基类。后面要处理各种命令的时候，都是使用的是<code>struct *cmd</code>类型的指针。<br>实际结构如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">pipecmd &#123;</div><div class=\"line\">\t- left = pipecmd &#123;</div><div class=\"line\">\t\t\t\t   - left: a</div><div class=\"line\">\t\t\t\t   - right: b</div><div class=\"line\">\t\t\t  &#125;</div><div class=\"line\">   - right = execcmd &#123;</div><div class=\"line\">   \t\t\t\t   - cmd: c</div><div class=\"line\">       \t  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// All commands have at least a type. Have looked at the type, the code</span></div><div class=\"line\"><span class=\"comment\">// typically casts the *cmd to some specific cmd type.</span></div><div class=\"line\"><span class=\"keyword\">struct</span> cmd &#123;</div><div class=\"line\">  <span class=\"keyword\">int</span> type;          <span class=\"comment\">//  ' ' (exec), | (pipe), '&lt;' or '&gt;' for redirection</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h4 id=\"execcmd\"><a href=\"#execcmd\" class=\"headerlink\" title=\"execcmd\"></a>execcmd</h4><blockquote>\n<p>可以直接执行的命令。也就是说不存在IO重定向，管道等情况。所以这里的type注释写的是空格’ ‘。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> execcmd &#123;</div><div class=\"line\">  <span class=\"keyword\">int</span> type;              <span class=\"comment\">// ' '</span></div><div class=\"line\">  <span class=\"keyword\">char</span> *argv[MAXARGS];   <span class=\"comment\">// arguments to the command to be exec-ed</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h4 id=\"redircmd\"><a href=\"#redircmd\" class=\"headerlink\" title=\"redircmd\"></a>redircmd</h4><p>重定向输入输出的命令。这里记录下的参数包含了：</p>\n<blockquote>\n<ul>\n<li>命令类型，重定向输入还是重定向输出</li>\n<li>要执行的命令</li>\n<li>输入或者输出文件</li>\n<li>打开文件的模式</li>\n<li>文件描述符<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> redircmd &#123;</div><div class=\"line\">  <span class=\"keyword\">int</span> type;          <span class=\"comment\">// &lt; or &gt;</span></div><div class=\"line\">  <span class=\"keyword\">struct</span> cmd *cmd;   <span class=\"comment\">// the command to be run (e.g., an execcmd)</span></div><div class=\"line\">  <span class=\"keyword\">char</span> *file;        <span class=\"comment\">// the input/output file</span></div><div class=\"line\">  <span class=\"keyword\">int</span> mode;          <span class=\"comment\">// the mode to open the file with</span></div><div class=\"line\">  <span class=\"keyword\">int</span> fd;            <span class=\"comment\">// the file descriptor number to use for the file</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<h4 id=\"pipecmd\"><a href=\"#pipecmd\" class=\"headerlink\" title=\"pipecmd\"></a>pipecmd</h4><p>pipecmd执行是实现重定向输出的情况.<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> pipecmd &#123;</div><div class=\"line\">  <span class=\"keyword\">int</span> type;          <span class=\"comment\">// |</span></div><div class=\"line\">  <span class=\"keyword\">struct</span> cmd *left;  <span class=\"comment\">// left side of pipe</span></div><div class=\"line\">  <span class=\"keyword\">struct</span> cmd *right; <span class=\"comment\">// right side of pipe</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<h3 id=\"命令的执行\"><a href=\"#命令的执行\" class=\"headerlink\" title=\"命令的执行\"></a>命令的执行</h3><p>命令的执行则主要是在runcmd函数里面进行。runcmd根据命令的类型来决定执行何种操作:</p>\n<blockquote>\n<ul>\n<li>如果是未定义的命令类型，直接报错，并退出。</li>\n<li>如果是execcmd类型，需要添加执行代码。实际上作业需要完成的代码也是在这里完成。</li>\n<li>‘&gt;’和’&lt;’表示输入输出重定向。</li>\n<li>‘|’管道操作，就是把前面一个程序的输出，重定向为后面一个程序的输入。<br>上面这些功能，都处于未完成的状态。都还需要添加代码。<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Execute cmd.  Never returns.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">runcmd</span><span class=\"params\">(<span class=\"keyword\">struct</span> cmd *cmd)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">int</span> p[<span class=\"number\">2</span>], r;</div><div class=\"line\">  <span class=\"keyword\">struct</span> execcmd *ecmd;</div><div class=\"line\">  <span class=\"keyword\">struct</span> pipecmd *pcmd;</div><div class=\"line\">  <span class=\"keyword\">struct</span> redircmd *rcmd;</div><div class=\"line\">  <span class=\"keyword\">if</span>(cmd == <span class=\"number\">0</span>)</div><div class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</div><div class=\"line\">  <span class=\"keyword\">switch</span>(cmd-&gt;type)&#123;</div><div class=\"line\">  <span class=\"keyword\">default</span>:</div><div class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"unknown runcmd\\n\"</span>);</div><div class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</div><div class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">' '</span>:</div><div class=\"line\">    ecmd = (<span class=\"keyword\">struct</span> execcmd*)cmd;</div><div class=\"line\">    <span class=\"keyword\">if</span>(ecmd-&gt;argv[<span class=\"number\">0</span>] == <span class=\"number\">0</span>)</div><div class=\"line\">      <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</div><div class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"exec not implemented\\n\"</span>);</div><div class=\"line\">    <span class=\"comment\">// Your code here ...</span></div><div class=\"line\">    <span class=\"keyword\">break</span>;</div><div class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'&gt;'</span>:</div><div class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'&lt;'</span>:</div><div class=\"line\">    rcmd = (<span class=\"keyword\">struct</span> redircmd*)cmd;</div><div class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"redir not implemented\\n\"</span>);</div><div class=\"line\">    <span class=\"comment\">// Your code here ...</span></div><div class=\"line\">    runcmd(rcmd-&gt;cmd);</div><div class=\"line\">    <span class=\"keyword\">break</span>;</div><div class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'|'</span>:</div><div class=\"line\">    pcmd = (<span class=\"keyword\">struct</span> pipecmd*)cmd;</div><div class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"pipe not implemented\\n\"</span>);</div><div class=\"line\">    <span class=\"comment\">// Your code here ...</span></div><div class=\"line\">    <span class=\"keyword\">break</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"命令的获取\"><a href=\"#命令的获取\" class=\"headerlink\" title=\"命令的获取\"></a>命令的获取</h3><p>从终端中读取需要执行的命令。getcmd的三个任务:</p>\n<blockquote>\n<ul>\n<li>判断是不是终端，如果是，那么输出”6.828$”提标符。</li>\n<li>清空内存，然后读取输入。</li>\n<li>判断是不是读入了EOF结束标志。如果是，返回-1。<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getcmd</span><span class=\"params\">(<span class=\"keyword\">char</span> *buf, <span class=\"keyword\">int</span> nbuf)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (isatty(fileno(<span class=\"built_in\">stdin</span>)))</div><div class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stdout</span>, <span class=\"string\">\"6.828$ \"</span>);</div><div class=\"line\">  <span class=\"built_in\">memset</span>(buf, <span class=\"number\">0</span>, nbuf);</div><div class=\"line\">  fgets(buf, nbuf, <span class=\"built_in\">stdin</span>);</div><div class=\"line\">  <span class=\"keyword\">if</span>(buf[<span class=\"number\">0</span>] == <span class=\"number\">0</span>) <span class=\"comment\">// EOF</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"主程序\"><a href=\"#主程序\" class=\"headerlink\" title=\"主程序\"></a>主程序</h3><p>主程序比较简单,分为两部分：</p>\n<blockquote>\n<ul>\n<li>查看是不是cd命令，如果是，那么调用chdir系统调用。</li>\n<li>否则调用fork，利用子进程rumcmd。<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">char</span> buf[<span class=\"number\">100</span>];</div><div class=\"line\">  <span class=\"keyword\">int</span> fd, r;</div><div class=\"line\">  <span class=\"comment\">// Read and run input commands.</span></div><div class=\"line\">  <span class=\"keyword\">while</span>(getcmd(buf, <span class=\"keyword\">sizeof</span>(buf)) &gt;= <span class=\"number\">0</span>)&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(buf[<span class=\"number\">0</span>] == <span class=\"string\">'c'</span> &amp;&amp; buf[<span class=\"number\">1</span>] == <span class=\"string\">'d'</span> &amp;&amp; buf[<span class=\"number\">2</span>] == <span class=\"string\">' '</span>)&#123;</div><div class=\"line\">      <span class=\"comment\">// Clumsy but will have to do for now.</span></div><div class=\"line\">      <span class=\"comment\">// Chdir has no effect on the parent if run in the child.</span></div><div class=\"line\">      buf[<span class=\"built_in\">strlen</span>(buf)<span class=\"number\">-1</span>] = <span class=\"number\">0</span>;  <span class=\"comment\">// chop \\n</span></div><div class=\"line\">      <span class=\"keyword\">if</span>(chdir(buf+<span class=\"number\">3</span>) &lt; <span class=\"number\">0</span>)</div><div class=\"line\">        <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"cannot cd %s\\n\"</span>, buf+<span class=\"number\">3</span>);</div><div class=\"line\">      <span class=\"keyword\">continue</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span>(fork1() == <span class=\"number\">0</span>)</div><div class=\"line\">      runcmd(parsecmd(buf));</div><div class=\"line\">    wait(&amp;r);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"homework\"><a href=\"#homework\" class=\"headerlink\" title=\"homework\"></a>homework</h3><p>代码实现如下:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">runcmd</span><span class=\"params\">(<span class=\"keyword\">struct</span> cmd *cmd)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">int</span> p[<span class=\"number\">2</span>], r;</div><div class=\"line\">  <span class=\"keyword\">struct</span> execcmd *ecmd;</div><div class=\"line\">  <span class=\"keyword\">struct</span> pipecmd *pcmd;</div><div class=\"line\">  <span class=\"keyword\">struct</span> redircmd *rcmd;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">char</span> * path;</div><div class=\"line\">  path = <span class=\"built_in\">malloc</span>(MAXPATH * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">char</span>*));</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span>(cmd == <span class=\"number\">0</span>)</div><div class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">switch</span>(cmd-&gt;type)&#123;</div><div class=\"line\">  <span class=\"keyword\">default</span>:</div><div class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"unknown runcmd\\n\"</span>);</div><div class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">' '</span>:</div><div class=\"line\">    ecmd = (<span class=\"keyword\">struct</span> execcmd*)cmd;</div><div class=\"line\">    <span class=\"keyword\">if</span>(ecmd-&gt;argv[<span class=\"number\">0</span>] == <span class=\"number\">0</span>)</div><div class=\"line\">      <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 任务 1: 实现简单指令的调用与缺省路径</span></div><div class=\"line\">    <span class=\"built_in\">strcat</span>(path, ecmd-&gt;argv[<span class=\"number\">0</span>]);</div><div class=\"line\">        <span class=\"comment\">// My code here...</span></div><div class=\"line\">    <span class=\"built_in\">strcpy</span>(path, <span class=\"string\">\"\"</span>);</div><div class=\"line\">    <span class=\"built_in\">strcat</span>(path, ecmd-&gt;argv[<span class=\"number\">0</span>]);</div><div class=\"line\">    <span class=\"keyword\">if</span>(!access(path, F_OK)) &#123;</div><div class=\"line\">      execv(path, ecmd-&gt;argv);</div><div class=\"line\">      <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">strcpy</span>(path, <span class=\"string\">\"/bin/\"</span>);</div><div class=\"line\">    <span class=\"built_in\">strcat</span>(path, ecmd-&gt;argv[<span class=\"number\">0</span>]);</div><div class=\"line\">    <span class=\"keyword\">if</span>(!access(path, F_OK)) &#123;</div><div class=\"line\">      execv(path, ecmd-&gt;argv);</div><div class=\"line\">      <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">strcpy</span>(path, <span class=\"string\">\"/usr/bin/\"</span>);</div><div class=\"line\">    <span class=\"built_in\">strcat</span>(path, ecmd-&gt;argv[<span class=\"number\">0</span>]);</div><div class=\"line\">    <span class=\"keyword\">if</span>(!access(path, F_OK)) &#123;</div><div class=\"line\">      execv(path, ecmd-&gt;argv);</div><div class=\"line\">      <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"exec not implemented\\n\"</span>);</div><div class=\"line\">    <span class=\"keyword\">break</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 任务 2: 实现I/O重定向  </span></div><div class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'&gt;'</span>:</div><div class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'&lt;'</span>:</div><div class=\"line\">    rcmd = (<span class=\"keyword\">struct</span> redircmd*)cmd;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// sub 1. 关闭被重定向覆盖的文件描述符</span></div><div class=\"line\">    close(rcmd-&gt;fd);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// sub 2. 处理系统调用失败的情况, 注意文件权限(0777)为八进制数保证符合约定</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (open(rcmd-&gt;flie, rcmd-&gt;mode, <span class=\"number\">0777</span>) &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"open file %s failed.\"</span>, rcmd-&gt;file);</div><div class=\"line\">      <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    runcmd(rcmd-&gt;cmd);</div><div class=\"line\">    <span class=\"keyword\">break</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 任务 3. 实现管道功能</span></div><div class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'|'</span>:</div><div class=\"line\">    pcmd = (<span class=\"keyword\">struct</span> pipecmd*)cmd;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// sub 1. 调用系统接口pipe()创建一个管道, 首先检查失败情况</span></div><div class=\"line\">    <span class=\"keyword\">if</span>(pipe(p) &lt; <span class=\"number\">0</span>)&#123;</div><div class=\"line\">        <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"create pipe failed!\\n\"</span>);</div><div class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// sub 2. 根据管道的语义, 创建子进程来处理两个过程</span></div><div class=\"line\">    <span class=\"keyword\">if</span>((fork() == <span class=\"number\">0</span>)) &#123;</div><div class=\"line\">        close(STDOUT_FILENO);</div><div class=\"line\">        dup(p[<span class=\"number\">1</span>]);</div><div class=\"line\">        close(p[<span class=\"number\">0</span>]);</div><div class=\"line\">        close(p[<span class=\"number\">1</span>]);</div><div class=\"line\">        runcmd(pcmd-&gt;left);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        close(<span class=\"number\">0</span>);</div><div class=\"line\">        dup(p[<span class=\"number\">0</span>]);</div><div class=\"line\">        close(p[<span class=\"number\">0</span>]);</div><div class=\"line\">        close(p[<span class=\"number\">1</span>]);</div><div class=\"line\">        runcmd(pcmd-&gt;right);</div><div class=\"line\">    &#125;</div><div class=\"line\">    wait(&amp;r);</div><div class=\"line\">    <span class=\"keyword\">break</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过这个调用图可以看出命令处理的层次结构。<br><img src=\"http://img.blog.csdn.net/20150419132244069\" alt=\"call graph\"></p>\n<blockquote>\n<ul>\n<li><p>首先根据|管道来切分块。比如{block_a} | {block_b} | {block_c} | {block_d}。处理逻辑不是通过for循环来处理，而是通过递归调用来解决。每一个block的处理都是通过parseexec来完成。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">struct</span> cmd*</span></div><div class=\"line\"><span class=\"title\">parsepipe</span><span class=\"params\">(<span class=\"keyword\">char</span> **ps, <span class=\"keyword\">char</span> *es)</span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">struct</span> cmd *cmd;</div><div class=\"line\">  cmd = parseexec(ps, es);</div><div class=\"line\">  <span class=\"keyword\">if</span>(peek(ps, es, <span class=\"string\">\"|\"</span>))&#123;</div><div class=\"line\">    gettoken(ps, es, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">    cmd = pipecmd(cmd, parsepipe(ps, es));</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> cmd;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>parseexec处理的时候，代码里面是同时处理了execcmd, redircmd这两种命令。也就是说，如果从C++的角度来看，类的继承关系就是：cmd-&gt;execcmd-&gt;redircmd。每个block的处理方式如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">argc = <span class=\"number\">0</span>;</div><div class=\"line\">ret = parseredirs(ret, ps, es);</div><div class=\"line\"><span class=\"keyword\">while</span>(!peek(ps, es, <span class=\"string\">\"|\"</span>))&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>((tok=gettoken(ps, es, &amp;q, &amp;eq)) == <span class=\"number\">0</span>)</div><div class=\"line\">    <span class=\"keyword\">break</span>;</div><div class=\"line\">  <span class=\"keyword\">if</span>(tok != <span class=\"string\">'a'</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"syntax error\\n\"</span>);</div><div class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">  cmd-&gt;argv[argc] = mkcopy(q, eq);</div><div class=\"line\">  argc++;</div><div class=\"line\">  <span class=\"keyword\">if</span>(argc &gt;= MAXARGS) &#123;</div><div class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"too many args\\n\"</span>);</div><div class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">  ret = parseredirs(ret, ps, es);</div><div class=\"line\">&#125;</div><div class=\"line\">cmd-&gt;argv[argc] = <span class=\"number\">0</span>;</div></pre></td></tr></table></figure>\n</li>\n<li><p>如果没有IO重定向，那么parseredirs函数相当于空函数。没有任何作用。</p>\n</li>\n<li>parseredirs的处理就比较简单，就只负责处理execcmd的<input.txt或者>output.txt部分。<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">while</span>(peek(ps, es, <span class=\"string\">\"&lt;&gt;\"</span>))&#123;</div><div class=\"line\">  tok = gettoken(ps, es, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">  <span class=\"keyword\">if</span>(gettoken(ps, es, &amp;q, &amp;eq) != <span class=\"string\">'a'</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"missing file for redirection\\n\"</span>);</div><div class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">switch</span>(tok)&#123;</div><div class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'&lt;'</span>:</div><div class=\"line\">    cmd = redircmd(cmd, mkcopy(q, eq), <span class=\"string\">'&lt;'</span>);</div><div class=\"line\">    <span class=\"keyword\">break</span>;</div><div class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'&gt;'</span>:</div><div class=\"line\">    cmd = redircmd(cmd, mkcopy(q, eq), <span class=\"string\">'&gt;'</span>);</div><div class=\"line\">    <span class=\"keyword\">break</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</input.txt或者></li>\n</ul>\n</blockquote>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ol>\n<li><a href=\"https://pdos.csail.mit.edu/6.828/2016/homework/xv6-shell.html\" target=\"_blank\" rel=\"external\">hw2 shell</a></li>\n<li><a href=\"https://pdos.csail.mit.edu/6.828/2016/xv6/book-rev9.pdf\" target=\"_blank\" rel=\"external\">xv6 system call</a></li>\n<li><a href=\"https://pdos.csail.mit.edu/6.828/2016/homework/sh.c\" target=\"_blank\" rel=\"external\">6.828 shell</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"hw2-shell\"><a href=\"#hw2-shell\" class=\"headerlink\" title=\"hw2 shell\"></a>hw2 shell</h1><h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><p>hw2主要是根据xv6,学习linux的系统调用,实现一个简化版的shell.<br>目标可以分解为:</p>\n<blockquote>\n<ul>\n<li>阅读源代码</li>\n<li>添加执行命令的功能</li>\n<li>添加IO重定向</li>\n<li>添加管道功能</li>\n</ul>\n</blockquote>\n<h2 id=\"part1-command\"><a href=\"#part1-command\" class=\"headerlink\" title=\"part1: command\"></a>part1: command</h2><h3 id=\"命令的种类\"><a href=\"#命令的种类\" class=\"headerlink\" title=\"命令的种类\"></a>命令的种类</h3><h4 id=\"命令参数个数\"><a href=\"#命令参数个数\" class=\"headerlink\" title=\"命令参数个数\"></a>命令参数个数</h4><blockquote>\n<p>首先,一个命令的参数总数是限制的,xv6 shell规定一个命令的参数最多只能有10个.<br><code>#define MAXARGS 10</code></p>\n</blockquote>","more":"<h4 id=\"命令的基类\"><a href=\"#命令的基类\" class=\"headerlink\" title=\"命令的基类\"></a>命令的基类</h4><blockquote>\n<p>所有的命令都必须有一个种类。这里声明一个<code>struct cmd</code>的作用是为了用来指向特定的某个cmd的类型。注意后面声明的<code>struct</code>都是在一个结构的开头int指明了一个type.后面可以把这个结构体在<code>struct *cmd</code>之间进行转换.这里采用了C++的面向对象的思想，struct cmd是execcmd, redircmd, pipecmd的基类。后面要处理各种命令的时候，都是使用的是<code>struct *cmd</code>类型的指针。<br>实际结构如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">pipecmd &#123;</div><div class=\"line\">\t- left = pipecmd &#123;</div><div class=\"line\">\t\t\t\t   - left: a</div><div class=\"line\">\t\t\t\t   - right: b</div><div class=\"line\">\t\t\t  &#125;</div><div class=\"line\">   - right = execcmd &#123;</div><div class=\"line\">   \t\t\t\t   - cmd: c</div><div class=\"line\">       \t  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// All commands have at least a type. Have looked at the type, the code</span></div><div class=\"line\"><span class=\"comment\">// typically casts the *cmd to some specific cmd type.</span></div><div class=\"line\"><span class=\"keyword\">struct</span> cmd &#123;</div><div class=\"line\">  <span class=\"keyword\">int</span> type;          <span class=\"comment\">//  ' ' (exec), | (pipe), '&lt;' or '&gt;' for redirection</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h4 id=\"execcmd\"><a href=\"#execcmd\" class=\"headerlink\" title=\"execcmd\"></a>execcmd</h4><blockquote>\n<p>可以直接执行的命令。也就是说不存在IO重定向，管道等情况。所以这里的type注释写的是空格’ ‘。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> execcmd &#123;</div><div class=\"line\">  <span class=\"keyword\">int</span> type;              <span class=\"comment\">// ' '</span></div><div class=\"line\">  <span class=\"keyword\">char</span> *argv[MAXARGS];   <span class=\"comment\">// arguments to the command to be exec-ed</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h4 id=\"redircmd\"><a href=\"#redircmd\" class=\"headerlink\" title=\"redircmd\"></a>redircmd</h4><p>重定向输入输出的命令。这里记录下的参数包含了：</p>\n<blockquote>\n<ul>\n<li>命令类型，重定向输入还是重定向输出</li>\n<li>要执行的命令</li>\n<li>输入或者输出文件</li>\n<li>打开文件的模式</li>\n<li>文件描述符<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> redircmd &#123;</div><div class=\"line\">  <span class=\"keyword\">int</span> type;          <span class=\"comment\">// &lt; or &gt;</span></div><div class=\"line\">  <span class=\"keyword\">struct</span> cmd *cmd;   <span class=\"comment\">// the command to be run (e.g., an execcmd)</span></div><div class=\"line\">  <span class=\"keyword\">char</span> *file;        <span class=\"comment\">// the input/output file</span></div><div class=\"line\">  <span class=\"keyword\">int</span> mode;          <span class=\"comment\">// the mode to open the file with</span></div><div class=\"line\">  <span class=\"keyword\">int</span> fd;            <span class=\"comment\">// the file descriptor number to use for the file</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<h4 id=\"pipecmd\"><a href=\"#pipecmd\" class=\"headerlink\" title=\"pipecmd\"></a>pipecmd</h4><p>pipecmd执行是实现重定向输出的情况.<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> pipecmd &#123;</div><div class=\"line\">  <span class=\"keyword\">int</span> type;          <span class=\"comment\">// |</span></div><div class=\"line\">  <span class=\"keyword\">struct</span> cmd *left;  <span class=\"comment\">// left side of pipe</span></div><div class=\"line\">  <span class=\"keyword\">struct</span> cmd *right; <span class=\"comment\">// right side of pipe</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<h3 id=\"命令的执行\"><a href=\"#命令的执行\" class=\"headerlink\" title=\"命令的执行\"></a>命令的执行</h3><p>命令的执行则主要是在runcmd函数里面进行。runcmd根据命令的类型来决定执行何种操作:</p>\n<blockquote>\n<ul>\n<li>如果是未定义的命令类型，直接报错，并退出。</li>\n<li>如果是execcmd类型，需要添加执行代码。实际上作业需要完成的代码也是在这里完成。</li>\n<li>‘&gt;’和’&lt;’表示输入输出重定向。</li>\n<li>‘|’管道操作，就是把前面一个程序的输出，重定向为后面一个程序的输入。<br>上面这些功能，都处于未完成的状态。都还需要添加代码。<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Execute cmd.  Never returns.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">runcmd</span><span class=\"params\">(<span class=\"keyword\">struct</span> cmd *cmd)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">int</span> p[<span class=\"number\">2</span>], r;</div><div class=\"line\">  <span class=\"keyword\">struct</span> execcmd *ecmd;</div><div class=\"line\">  <span class=\"keyword\">struct</span> pipecmd *pcmd;</div><div class=\"line\">  <span class=\"keyword\">struct</span> redircmd *rcmd;</div><div class=\"line\">  <span class=\"keyword\">if</span>(cmd == <span class=\"number\">0</span>)</div><div class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</div><div class=\"line\">  <span class=\"keyword\">switch</span>(cmd-&gt;type)&#123;</div><div class=\"line\">  <span class=\"keyword\">default</span>:</div><div class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"unknown runcmd\\n\"</span>);</div><div class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</div><div class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">' '</span>:</div><div class=\"line\">    ecmd = (<span class=\"keyword\">struct</span> execcmd*)cmd;</div><div class=\"line\">    <span class=\"keyword\">if</span>(ecmd-&gt;argv[<span class=\"number\">0</span>] == <span class=\"number\">0</span>)</div><div class=\"line\">      <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</div><div class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"exec not implemented\\n\"</span>);</div><div class=\"line\">    <span class=\"comment\">// Your code here ...</span></div><div class=\"line\">    <span class=\"keyword\">break</span>;</div><div class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'&gt;'</span>:</div><div class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'&lt;'</span>:</div><div class=\"line\">    rcmd = (<span class=\"keyword\">struct</span> redircmd*)cmd;</div><div class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"redir not implemented\\n\"</span>);</div><div class=\"line\">    <span class=\"comment\">// Your code here ...</span></div><div class=\"line\">    runcmd(rcmd-&gt;cmd);</div><div class=\"line\">    <span class=\"keyword\">break</span>;</div><div class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'|'</span>:</div><div class=\"line\">    pcmd = (<span class=\"keyword\">struct</span> pipecmd*)cmd;</div><div class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"pipe not implemented\\n\"</span>);</div><div class=\"line\">    <span class=\"comment\">// Your code here ...</span></div><div class=\"line\">    <span class=\"keyword\">break</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"命令的获取\"><a href=\"#命令的获取\" class=\"headerlink\" title=\"命令的获取\"></a>命令的获取</h3><p>从终端中读取需要执行的命令。getcmd的三个任务:</p>\n<blockquote>\n<ul>\n<li>判断是不是终端，如果是，那么输出”6.828$”提标符。</li>\n<li>清空内存，然后读取输入。</li>\n<li>判断是不是读入了EOF结束标志。如果是，返回-1。<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getcmd</span><span class=\"params\">(<span class=\"keyword\">char</span> *buf, <span class=\"keyword\">int</span> nbuf)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span> (isatty(fileno(<span class=\"built_in\">stdin</span>)))</div><div class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stdout</span>, <span class=\"string\">\"6.828$ \"</span>);</div><div class=\"line\">  <span class=\"built_in\">memset</span>(buf, <span class=\"number\">0</span>, nbuf);</div><div class=\"line\">  fgets(buf, nbuf, <span class=\"built_in\">stdin</span>);</div><div class=\"line\">  <span class=\"keyword\">if</span>(buf[<span class=\"number\">0</span>] == <span class=\"number\">0</span>) <span class=\"comment\">// EOF</span></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"主程序\"><a href=\"#主程序\" class=\"headerlink\" title=\"主程序\"></a>主程序</h3><p>主程序比较简单,分为两部分：</p>\n<blockquote>\n<ul>\n<li>查看是不是cd命令，如果是，那么调用chdir系统调用。</li>\n<li>否则调用fork，利用子进程rumcmd。<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">static</span> <span class=\"keyword\">char</span> buf[<span class=\"number\">100</span>];</div><div class=\"line\">  <span class=\"keyword\">int</span> fd, r;</div><div class=\"line\">  <span class=\"comment\">// Read and run input commands.</span></div><div class=\"line\">  <span class=\"keyword\">while</span>(getcmd(buf, <span class=\"keyword\">sizeof</span>(buf)) &gt;= <span class=\"number\">0</span>)&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(buf[<span class=\"number\">0</span>] == <span class=\"string\">'c'</span> &amp;&amp; buf[<span class=\"number\">1</span>] == <span class=\"string\">'d'</span> &amp;&amp; buf[<span class=\"number\">2</span>] == <span class=\"string\">' '</span>)&#123;</div><div class=\"line\">      <span class=\"comment\">// Clumsy but will have to do for now.</span></div><div class=\"line\">      <span class=\"comment\">// Chdir has no effect on the parent if run in the child.</span></div><div class=\"line\">      buf[<span class=\"built_in\">strlen</span>(buf)<span class=\"number\">-1</span>] = <span class=\"number\">0</span>;  <span class=\"comment\">// chop \\n</span></div><div class=\"line\">      <span class=\"keyword\">if</span>(chdir(buf+<span class=\"number\">3</span>) &lt; <span class=\"number\">0</span>)</div><div class=\"line\">        <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"cannot cd %s\\n\"</span>, buf+<span class=\"number\">3</span>);</div><div class=\"line\">      <span class=\"keyword\">continue</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span>(fork1() == <span class=\"number\">0</span>)</div><div class=\"line\">      runcmd(parsecmd(buf));</div><div class=\"line\">    wait(&amp;r);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"homework\"><a href=\"#homework\" class=\"headerlink\" title=\"homework\"></a>homework</h3><p>代码实现如下:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">runcmd</span><span class=\"params\">(<span class=\"keyword\">struct</span> cmd *cmd)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">int</span> p[<span class=\"number\">2</span>], r;</div><div class=\"line\">  <span class=\"keyword\">struct</span> execcmd *ecmd;</div><div class=\"line\">  <span class=\"keyword\">struct</span> pipecmd *pcmd;</div><div class=\"line\">  <span class=\"keyword\">struct</span> redircmd *rcmd;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">char</span> * path;</div><div class=\"line\">  path = <span class=\"built_in\">malloc</span>(MAXPATH * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">char</span>*));</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span>(cmd == <span class=\"number\">0</span>)</div><div class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">switch</span>(cmd-&gt;type)&#123;</div><div class=\"line\">  <span class=\"keyword\">default</span>:</div><div class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"unknown runcmd\\n\"</span>);</div><div class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">' '</span>:</div><div class=\"line\">    ecmd = (<span class=\"keyword\">struct</span> execcmd*)cmd;</div><div class=\"line\">    <span class=\"keyword\">if</span>(ecmd-&gt;argv[<span class=\"number\">0</span>] == <span class=\"number\">0</span>)</div><div class=\"line\">      <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// 任务 1: 实现简单指令的调用与缺省路径</span></div><div class=\"line\">    <span class=\"built_in\">strcat</span>(path, ecmd-&gt;argv[<span class=\"number\">0</span>]);</div><div class=\"line\">        <span class=\"comment\">// My code here...</span></div><div class=\"line\">    <span class=\"built_in\">strcpy</span>(path, <span class=\"string\">\"\"</span>);</div><div class=\"line\">    <span class=\"built_in\">strcat</span>(path, ecmd-&gt;argv[<span class=\"number\">0</span>]);</div><div class=\"line\">    <span class=\"keyword\">if</span>(!access(path, F_OK)) &#123;</div><div class=\"line\">      execv(path, ecmd-&gt;argv);</div><div class=\"line\">      <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">strcpy</span>(path, <span class=\"string\">\"/bin/\"</span>);</div><div class=\"line\">    <span class=\"built_in\">strcat</span>(path, ecmd-&gt;argv[<span class=\"number\">0</span>]);</div><div class=\"line\">    <span class=\"keyword\">if</span>(!access(path, F_OK)) &#123;</div><div class=\"line\">      execv(path, ecmd-&gt;argv);</div><div class=\"line\">      <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">strcpy</span>(path, <span class=\"string\">\"/usr/bin/\"</span>);</div><div class=\"line\">    <span class=\"built_in\">strcat</span>(path, ecmd-&gt;argv[<span class=\"number\">0</span>]);</div><div class=\"line\">    <span class=\"keyword\">if</span>(!access(path, F_OK)) &#123;</div><div class=\"line\">      execv(path, ecmd-&gt;argv);</div><div class=\"line\">      <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"exec not implemented\\n\"</span>);</div><div class=\"line\">    <span class=\"keyword\">break</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 任务 2: 实现I/O重定向  </span></div><div class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'&gt;'</span>:</div><div class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'&lt;'</span>:</div><div class=\"line\">    rcmd = (<span class=\"keyword\">struct</span> redircmd*)cmd;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// sub 1. 关闭被重定向覆盖的文件描述符</span></div><div class=\"line\">    close(rcmd-&gt;fd);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// sub 2. 处理系统调用失败的情况, 注意文件权限(0777)为八进制数保证符合约定</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (open(rcmd-&gt;flie, rcmd-&gt;mode, <span class=\"number\">0777</span>) &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">      <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"open file %s failed.\"</span>, rcmd-&gt;file);</div><div class=\"line\">      <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    runcmd(rcmd-&gt;cmd);</div><div class=\"line\">    <span class=\"keyword\">break</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// 任务 3. 实现管道功能</span></div><div class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'|'</span>:</div><div class=\"line\">    pcmd = (<span class=\"keyword\">struct</span> pipecmd*)cmd;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// sub 1. 调用系统接口pipe()创建一个管道, 首先检查失败情况</span></div><div class=\"line\">    <span class=\"keyword\">if</span>(pipe(p) &lt; <span class=\"number\">0</span>)&#123;</div><div class=\"line\">        <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"create pipe failed!\\n\"</span>);</div><div class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// sub 2. 根据管道的语义, 创建子进程来处理两个过程</span></div><div class=\"line\">    <span class=\"keyword\">if</span>((fork() == <span class=\"number\">0</span>)) &#123;</div><div class=\"line\">        close(STDOUT_FILENO);</div><div class=\"line\">        dup(p[<span class=\"number\">1</span>]);</div><div class=\"line\">        close(p[<span class=\"number\">0</span>]);</div><div class=\"line\">        close(p[<span class=\"number\">1</span>]);</div><div class=\"line\">        runcmd(pcmd-&gt;left);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        close(<span class=\"number\">0</span>);</div><div class=\"line\">        dup(p[<span class=\"number\">0</span>]);</div><div class=\"line\">        close(p[<span class=\"number\">0</span>]);</div><div class=\"line\">        close(p[<span class=\"number\">1</span>]);</div><div class=\"line\">        runcmd(pcmd-&gt;right);</div><div class=\"line\">    &#125;</div><div class=\"line\">    wait(&amp;r);</div><div class=\"line\">    <span class=\"keyword\">break</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>通过这个调用图可以看出命令处理的层次结构。<br><img src=\"http://img.blog.csdn.net/20150419132244069\" alt=\"call graph\"></p>\n<blockquote>\n<ul>\n<li><p>首先根据|管道来切分块。比如{block_a} | {block_b} | {block_c} | {block_d}。处理逻辑不是通过for循环来处理，而是通过递归调用来解决。每一个block的处理都是通过parseexec来完成。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">struct</span> cmd*</span></div><div class=\"line\"><span class=\"title\">parsepipe</span><span class=\"params\">(<span class=\"keyword\">char</span> **ps, <span class=\"keyword\">char</span> *es)</span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">struct</span> cmd *cmd;</div><div class=\"line\">  cmd = parseexec(ps, es);</div><div class=\"line\">  <span class=\"keyword\">if</span>(peek(ps, es, <span class=\"string\">\"|\"</span>))&#123;</div><div class=\"line\">    gettoken(ps, es, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">    cmd = pipecmd(cmd, parsepipe(ps, es));</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> cmd;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>parseexec处理的时候，代码里面是同时处理了execcmd, redircmd这两种命令。也就是说，如果从C++的角度来看，类的继承关系就是：cmd-&gt;execcmd-&gt;redircmd。每个block的处理方式如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">argc = <span class=\"number\">0</span>;</div><div class=\"line\">ret = parseredirs(ret, ps, es);</div><div class=\"line\"><span class=\"keyword\">while</span>(!peek(ps, es, <span class=\"string\">\"|\"</span>))&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>((tok=gettoken(ps, es, &amp;q, &amp;eq)) == <span class=\"number\">0</span>)</div><div class=\"line\">    <span class=\"keyword\">break</span>;</div><div class=\"line\">  <span class=\"keyword\">if</span>(tok != <span class=\"string\">'a'</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"syntax error\\n\"</span>);</div><div class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">  cmd-&gt;argv[argc] = mkcopy(q, eq);</div><div class=\"line\">  argc++;</div><div class=\"line\">  <span class=\"keyword\">if</span>(argc &gt;= MAXARGS) &#123;</div><div class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"too many args\\n\"</span>);</div><div class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">  ret = parseredirs(ret, ps, es);</div><div class=\"line\">&#125;</div><div class=\"line\">cmd-&gt;argv[argc] = <span class=\"number\">0</span>;</div></pre></td></tr></table></figure>\n</li>\n<li><p>如果没有IO重定向，那么parseredirs函数相当于空函数。没有任何作用。</p>\n</li>\n<li>parseredirs的处理就比较简单，就只负责处理execcmd的<input.txt或者>output.txt部分。<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">while</span>(peek(ps, es, <span class=\"string\">\"&lt;&gt;\"</span>))&#123;</div><div class=\"line\">  tok = gettoken(ps, es, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">  <span class=\"keyword\">if</span>(gettoken(ps, es, &amp;q, &amp;eq) != <span class=\"string\">'a'</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"missing file for redirection\\n\"</span>);</div><div class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">switch</span>(tok)&#123;</div><div class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'&lt;'</span>:</div><div class=\"line\">    cmd = redircmd(cmd, mkcopy(q, eq), <span class=\"string\">'&lt;'</span>);</div><div class=\"line\">    <span class=\"keyword\">break</span>;</div><div class=\"line\">  <span class=\"keyword\">case</span> <span class=\"string\">'&gt;'</span>:</div><div class=\"line\">    cmd = redircmd(cmd, mkcopy(q, eq), <span class=\"string\">'&gt;'</span>);</div><div class=\"line\">    <span class=\"keyword\">break</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</input.txt或者></li>\n</ul>\n</blockquote>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><ol>\n<li><a href=\"https://pdos.csail.mit.edu/6.828/2016/homework/xv6-shell.html\" target=\"_blank\" rel=\"external\">hw2 shell</a></li>\n<li><a href=\"https://pdos.csail.mit.edu/6.828/2016/xv6/book-rev9.pdf\" target=\"_blank\" rel=\"external\">xv6 system call</a></li>\n<li><a href=\"https://pdos.csail.mit.edu/6.828/2016/homework/sh.c\" target=\"_blank\" rel=\"external\">6.828 shell</a></li>\n</ol>"},{"title":"hw4-lazy-page-allocation","date":"2017-04-20T16:00:00.000Z","_content":"# hw4 lazy page allocation\n## 目标\n> OS可以使用页表硬件的技巧之一是 **堆内存的懒惰分配**.当进程需要更多的内存的时候,调用`malloc()`函数申请更多的堆内存,底层系统调用`sbrk`实际完成这个工作.`sbrk`系统调用分配物理内存,并映射到进程的虚拟地址.但是有的进程会一次申请大量的内存,但是又可能根本用不到,比如稀疏数组(sparse array).所以说复杂的内核涉及会将实际的allocation的工作推迟到应用程序尝试使用该页面的时候,即发生了`page fault`,然后再进行实际的分配.  -\n\n## Part1 删除'sbrk'的内存分配\n### 任务\n> 从`sbrk(n)`系统调用实现中删除页分配,实现为`sysproc.c`中的`sys_sbrk()`函数.`sbrk(n)`系统调用将进程的内存大小增加n个字节,然后返回新分配区域的开始地址.\n\n<!-- more -->\n\n### 实现\n> 对系统调用`sbrk`的实际实现`sys_sbrk()`进行修改,删除对`growproc()`的调用只将进程的内存空间大小增加n,而不进行实际的分配.修改代码如下\n``` c\n//sysproc.c\nint\nsys_sbrk(void)\n{\n  int addr, newsz;\n  int n;\n\n  if(argint(0, &n) < 0)\n    return -1;\n  addr = proc->sz;\n  newsz = addr + n;\n  if (newsz >= KERNBASE)\n      return -1;\n  proc->sz = newsz;\n  return addr;\n}\n```\n> 再次启动xv6,运行`echo hi`,得到如下错误提示：\n``` bash\npid 3 sh: trap 14 err 6 on cpu 0 eip 0x12f1 addr 0x4004--kill proc\n```\n> 因为在shell中运行`echo`时,需要调用`malloc`函数.运行`malloc`的时候,虽然返回值是显示内存分配成功,但是当程序实际试图操作cmd指向的内存区域的时候,发现该内存区域不是当前进程所有的,因为在`sys_sbrk`中实际没有调用`growproc()`进行分配.\n\n## Part2 懒惰分配\n### 任务\n> 通过在故障地址映射新分配的物理内存页面,然后返回到用户空间让程序继续执行,修改trap.c中的代码以响应用户空间的页面错误.代码不需要完美到照顾到每个细节,当前我们只需要能够执行`echo`等简单代码即可.　　\n\n### 实现\n> 在`trap.c`中,当发现是`page fault`错误的时候,可以按照当前进程的`proc->sz`来实际的分配内存.所以首先应该获取发生`page fault`时刻的虚地址,该虚地址之后的部分就应该是本来应该分配但是实际没有分配的(lazy allocation),而实际需要分配多少,应该根据`proc->sz`的大小来定.\n因为在发生`page fault`的地址为在`malloc`之后返回给进程的地址,而这个地址正是`proc->sz`,所以该虚地址的大小为实际的内存的大小.\n``` c\nif (tf->trapno == T_PGFLT) {\n      char* mem;\n      uint a;\n\n      a = PGROUNDDOWN(rcr2()); //rcr2()返回页错误时的地址\n      mem = kalloc();\n      if (mem == 0) {\n          cprintf(\"run out of memory!\\n\");\n          proc->killed = 1;\n          break;\n      }\n      memset(mem, 0, PGSIZE);\n      mappages(proc->pgdir, (char*)a, PGSIZE, v2p(mem), PTE_W|PTE_U);\n      break;\n}\n```\n","source":"_posts/hw4.md","raw":"title: hw4-lazy-page-allocation\ndate: 2017/04/21\ntags:\n\t- os\n\t- xv6\n\n---\n# hw4 lazy page allocation\n## 目标\n> OS可以使用页表硬件的技巧之一是 **堆内存的懒惰分配**.当进程需要更多的内存的时候,调用`malloc()`函数申请更多的堆内存,底层系统调用`sbrk`实际完成这个工作.`sbrk`系统调用分配物理内存,并映射到进程的虚拟地址.但是有的进程会一次申请大量的内存,但是又可能根本用不到,比如稀疏数组(sparse array).所以说复杂的内核涉及会将实际的allocation的工作推迟到应用程序尝试使用该页面的时候,即发生了`page fault`,然后再进行实际的分配.  -\n\n## Part1 删除'sbrk'的内存分配\n### 任务\n> 从`sbrk(n)`系统调用实现中删除页分配,实现为`sysproc.c`中的`sys_sbrk()`函数.`sbrk(n)`系统调用将进程的内存大小增加n个字节,然后返回新分配区域的开始地址.\n\n<!-- more -->\n\n### 实现\n> 对系统调用`sbrk`的实际实现`sys_sbrk()`进行修改,删除对`growproc()`的调用只将进程的内存空间大小增加n,而不进行实际的分配.修改代码如下\n``` c\n//sysproc.c\nint\nsys_sbrk(void)\n{\n  int addr, newsz;\n  int n;\n\n  if(argint(0, &n) < 0)\n    return -1;\n  addr = proc->sz;\n  newsz = addr + n;\n  if (newsz >= KERNBASE)\n      return -1;\n  proc->sz = newsz;\n  return addr;\n}\n```\n> 再次启动xv6,运行`echo hi`,得到如下错误提示：\n``` bash\npid 3 sh: trap 14 err 6 on cpu 0 eip 0x12f1 addr 0x4004--kill proc\n```\n> 因为在shell中运行`echo`时,需要调用`malloc`函数.运行`malloc`的时候,虽然返回值是显示内存分配成功,但是当程序实际试图操作cmd指向的内存区域的时候,发现该内存区域不是当前进程所有的,因为在`sys_sbrk`中实际没有调用`growproc()`进行分配.\n\n## Part2 懒惰分配\n### 任务\n> 通过在故障地址映射新分配的物理内存页面,然后返回到用户空间让程序继续执行,修改trap.c中的代码以响应用户空间的页面错误.代码不需要完美到照顾到每个细节,当前我们只需要能够执行`echo`等简单代码即可.　　\n\n### 实现\n> 在`trap.c`中,当发现是`page fault`错误的时候,可以按照当前进程的`proc->sz`来实际的分配内存.所以首先应该获取发生`page fault`时刻的虚地址,该虚地址之后的部分就应该是本来应该分配但是实际没有分配的(lazy allocation),而实际需要分配多少,应该根据`proc->sz`的大小来定.\n因为在发生`page fault`的地址为在`malloc`之后返回给进程的地址,而这个地址正是`proc->sz`,所以该虚地址的大小为实际的内存的大小.\n``` c\nif (tf->trapno == T_PGFLT) {\n      char* mem;\n      uint a;\n\n      a = PGROUNDDOWN(rcr2()); //rcr2()返回页错误时的地址\n      mem = kalloc();\n      if (mem == 0) {\n          cprintf(\"run out of memory!\\n\");\n          proc->killed = 1;\n          break;\n      }\n      memset(mem, 0, PGSIZE);\n      mappages(proc->pgdir, (char*)a, PGSIZE, v2p(mem), PTE_W|PTE_U);\n      break;\n}\n```\n","slug":"hw4","published":1,"updated":"2017-08-26T03:38:21.598Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6sslhb0000j3gamxa3120jz","content":"<h1 id=\"hw4-lazy-page-allocation\"><a href=\"#hw4-lazy-page-allocation\" class=\"headerlink\" title=\"hw4 lazy page allocation\"></a>hw4 lazy page allocation</h1><h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><blockquote>\n<p>OS可以使用页表硬件的技巧之一是 <strong>堆内存的懒惰分配</strong>.当进程需要更多的内存的时候,调用<code>malloc()</code>函数申请更多的堆内存,底层系统调用<code>sbrk</code>实际完成这个工作.<code>sbrk</code>系统调用分配物理内存,并映射到进程的虚拟地址.但是有的进程会一次申请大量的内存,但是又可能根本用不到,比如稀疏数组(sparse array).所以说复杂的内核涉及会将实际的allocation的工作推迟到应用程序尝试使用该页面的时候,即发生了<code>page fault</code>,然后再进行实际的分配.  -</p>\n</blockquote>\n<h2 id=\"Part1-删除’sbrk’的内存分配\"><a href=\"#Part1-删除’sbrk’的内存分配\" class=\"headerlink\" title=\"Part1 删除’sbrk’的内存分配\"></a>Part1 删除’sbrk’的内存分配</h2><h3 id=\"任务\"><a href=\"#任务\" class=\"headerlink\" title=\"任务\"></a>任务</h3><blockquote>\n<p>从<code>sbrk(n)</code>系统调用实现中删除页分配,实现为<code>sysproc.c</code>中的<code>sys_sbrk()</code>函数.<code>sbrk(n)</code>系统调用将进程的内存大小增加n个字节,然后返回新分配区域的开始地址.</p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><blockquote>\n<p>对系统调用<code>sbrk</code>的实际实现<code>sys_sbrk()</code>进行修改,删除对<code>growproc()</code>的调用只将进程的内存空间大小增加n,而不进行实际的分配.修改代码如下<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//sysproc.c</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span></span></div><div class=\"line\"><span class=\"title\">sys_sbrk</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">int</span> addr, newsz;</div><div class=\"line\">  <span class=\"keyword\">int</span> n;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span>(argint(<span class=\"number\">0</span>, &amp;n) &lt; <span class=\"number\">0</span>)</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">  addr = proc-&gt;sz;</div><div class=\"line\">  newsz = addr + n;</div><div class=\"line\">  <span class=\"keyword\">if</span> (newsz &gt;= KERNBASE)</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">  proc-&gt;sz = newsz;</div><div class=\"line\">  <span class=\"keyword\">return</span> addr;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>再次启动xv6,运行<code>echo hi</code>,得到如下错误提示：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pid 3 sh: <span class=\"built_in\">trap</span> 14 err 6 on cpu 0 eip 0x12f1 addr 0x4004--kill proc</div></pre></td></tr></table></figure></p>\n<p>因为在shell中运行<code>echo</code>时,需要调用<code>malloc</code>函数.运行<code>malloc</code>的时候,虽然返回值是显示内存分配成功,但是当程序实际试图操作cmd指向的内存区域的时候,发现该内存区域不是当前进程所有的,因为在<code>sys_sbrk</code>中实际没有调用<code>growproc()</code>进行分配.</p>\n</blockquote>\n<h2 id=\"Part2-懒惰分配\"><a href=\"#Part2-懒惰分配\" class=\"headerlink\" title=\"Part2 懒惰分配\"></a>Part2 懒惰分配</h2><h3 id=\"任务-1\"><a href=\"#任务-1\" class=\"headerlink\" title=\"任务\"></a>任务</h3><blockquote>\n<p>通过在故障地址映射新分配的物理内存页面,然后返回到用户空间让程序继续执行,修改trap.c中的代码以响应用户空间的页面错误.代码不需要完美到照顾到每个细节,当前我们只需要能够执行<code>echo</code>等简单代码即可.　　</p>\n</blockquote>\n<h3 id=\"实现-1\"><a href=\"#实现-1\" class=\"headerlink\" title=\"实现\"></a>实现</h3><blockquote>\n<p>在<code>trap.c</code>中,当发现是<code>page fault</code>错误的时候,可以按照当前进程的<code>proc-&gt;sz</code>来实际的分配内存.所以首先应该获取发生<code>page fault</code>时刻的虚地址,该虚地址之后的部分就应该是本来应该分配但是实际没有分配的(lazy allocation),而实际需要分配多少,应该根据<code>proc-&gt;sz</code>的大小来定.<br>因为在发生<code>page fault</code>的地址为在<code>malloc</code>之后返回给进程的地址,而这个地址正是<code>proc-&gt;sz</code>,所以该虚地址的大小为实际的内存的大小.<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (tf-&gt;trapno == T_PGFLT) &#123;</div><div class=\"line\">      <span class=\"keyword\">char</span>* mem;</div><div class=\"line\">      uint a;</div><div class=\"line\"></div><div class=\"line\">      a = PGROUNDDOWN(rcr2()); <span class=\"comment\">//rcr2()返回页错误时的地址</span></div><div class=\"line\">      mem = kalloc();</div><div class=\"line\">      <span class=\"keyword\">if</span> (mem == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">          cprintf(<span class=\"string\">\"run out of memory!\\n\"</span>);</div><div class=\"line\">          proc-&gt;killed = <span class=\"number\">1</span>;</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"built_in\">memset</span>(mem, <span class=\"number\">0</span>, PGSIZE);</div><div class=\"line\">      mappages(proc-&gt;pgdir, (<span class=\"keyword\">char</span>*)a, PGSIZE, v2p(mem), PTE_W|PTE_U);</div><div class=\"line\">      <span class=\"keyword\">break</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"hw4-lazy-page-allocation\"><a href=\"#hw4-lazy-page-allocation\" class=\"headerlink\" title=\"hw4 lazy page allocation\"></a>hw4 lazy page allocation</h1><h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><blockquote>\n<p>OS可以使用页表硬件的技巧之一是 <strong>堆内存的懒惰分配</strong>.当进程需要更多的内存的时候,调用<code>malloc()</code>函数申请更多的堆内存,底层系统调用<code>sbrk</code>实际完成这个工作.<code>sbrk</code>系统调用分配物理内存,并映射到进程的虚拟地址.但是有的进程会一次申请大量的内存,但是又可能根本用不到,比如稀疏数组(sparse array).所以说复杂的内核涉及会将实际的allocation的工作推迟到应用程序尝试使用该页面的时候,即发生了<code>page fault</code>,然后再进行实际的分配.  -</p>\n</blockquote>\n<h2 id=\"Part1-删除’sbrk’的内存分配\"><a href=\"#Part1-删除’sbrk’的内存分配\" class=\"headerlink\" title=\"Part1 删除’sbrk’的内存分配\"></a>Part1 删除’sbrk’的内存分配</h2><h3 id=\"任务\"><a href=\"#任务\" class=\"headerlink\" title=\"任务\"></a>任务</h3><blockquote>\n<p>从<code>sbrk(n)</code>系统调用实现中删除页分配,实现为<code>sysproc.c</code>中的<code>sys_sbrk()</code>函数.<code>sbrk(n)</code>系统调用将进程的内存大小增加n个字节,然后返回新分配区域的开始地址.</p>\n</blockquote>","more":"<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><blockquote>\n<p>对系统调用<code>sbrk</code>的实际实现<code>sys_sbrk()</code>进行修改,删除对<code>growproc()</code>的调用只将进程的内存空间大小增加n,而不进行实际的分配.修改代码如下<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//sysproc.c</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span></span></div><div class=\"line\"><span class=\"title\">sys_sbrk</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">int</span> addr, newsz;</div><div class=\"line\">  <span class=\"keyword\">int</span> n;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span>(argint(<span class=\"number\">0</span>, &amp;n) &lt; <span class=\"number\">0</span>)</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">  addr = proc-&gt;sz;</div><div class=\"line\">  newsz = addr + n;</div><div class=\"line\">  <span class=\"keyword\">if</span> (newsz &gt;= KERNBASE)</div><div class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">  proc-&gt;sz = newsz;</div><div class=\"line\">  <span class=\"keyword\">return</span> addr;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>再次启动xv6,运行<code>echo hi</code>,得到如下错误提示：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">pid 3 sh: <span class=\"built_in\">trap</span> 14 err 6 on cpu 0 eip 0x12f1 addr 0x4004--kill proc</div></pre></td></tr></table></figure></p>\n<p>因为在shell中运行<code>echo</code>时,需要调用<code>malloc</code>函数.运行<code>malloc</code>的时候,虽然返回值是显示内存分配成功,但是当程序实际试图操作cmd指向的内存区域的时候,发现该内存区域不是当前进程所有的,因为在<code>sys_sbrk</code>中实际没有调用<code>growproc()</code>进行分配.</p>\n</blockquote>\n<h2 id=\"Part2-懒惰分配\"><a href=\"#Part2-懒惰分配\" class=\"headerlink\" title=\"Part2 懒惰分配\"></a>Part2 懒惰分配</h2><h3 id=\"任务-1\"><a href=\"#任务-1\" class=\"headerlink\" title=\"任务\"></a>任务</h3><blockquote>\n<p>通过在故障地址映射新分配的物理内存页面,然后返回到用户空间让程序继续执行,修改trap.c中的代码以响应用户空间的页面错误.代码不需要完美到照顾到每个细节,当前我们只需要能够执行<code>echo</code>等简单代码即可.　　</p>\n</blockquote>\n<h3 id=\"实现-1\"><a href=\"#实现-1\" class=\"headerlink\" title=\"实现\"></a>实现</h3><blockquote>\n<p>在<code>trap.c</code>中,当发现是<code>page fault</code>错误的时候,可以按照当前进程的<code>proc-&gt;sz</code>来实际的分配内存.所以首先应该获取发生<code>page fault</code>时刻的虚地址,该虚地址之后的部分就应该是本来应该分配但是实际没有分配的(lazy allocation),而实际需要分配多少,应该根据<code>proc-&gt;sz</code>的大小来定.<br>因为在发生<code>page fault</code>的地址为在<code>malloc</code>之后返回给进程的地址,而这个地址正是<code>proc-&gt;sz</code>,所以该虚地址的大小为实际的内存的大小.<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span> (tf-&gt;trapno == T_PGFLT) &#123;</div><div class=\"line\">      <span class=\"keyword\">char</span>* mem;</div><div class=\"line\">      uint a;</div><div class=\"line\"></div><div class=\"line\">      a = PGROUNDDOWN(rcr2()); <span class=\"comment\">//rcr2()返回页错误时的地址</span></div><div class=\"line\">      mem = kalloc();</div><div class=\"line\">      <span class=\"keyword\">if</span> (mem == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">          cprintf(<span class=\"string\">\"run out of memory!\\n\"</span>);</div><div class=\"line\">          proc-&gt;killed = <span class=\"number\">1</span>;</div><div class=\"line\">          <span class=\"keyword\">break</span>;</div><div class=\"line\">      &#125;</div><div class=\"line\">      <span class=\"built_in\">memset</span>(mem, <span class=\"number\">0</span>, PGSIZE);</div><div class=\"line\">      mappages(proc-&gt;pgdir, (<span class=\"keyword\">char</span>*)a, PGSIZE, v2p(mem), PTE_W|PTE_U);</div><div class=\"line\">      <span class=\"keyword\">break</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>"},{"title":"cs-update","date":"2017-04-01T16:00:00.000Z","_content":"# CS学习update\n\n### 摘要\n>在被浙江大学计算机学院拟录取之后, 我现阶段的两个任务是:\n> * 1. 完成本科土木工程的学业,主要是毕业设计\n> * 2. 弥补计算机科学的基础知识和素养,并向研究方向靠拢\n> 为了能循序渐进的奠定计算机科学的基础,在此记录学习的内容和自己的收获总结.文章更新周期为一周一次, 每周全面的总结一周七天后写成.文章格式为问答式,提出问题并自己解答,以此自检.\n    \n### 周期1: 已学总结与学习计划\n#### 时间: 2017/03/20 - 2017/04/01\n-----\n#### Q1: 我已学过的计算机科学的专题有哪些?\n\n数学和物理: 微积分, 线性代数, 概率论, 大学物理(电路)\n计算机: C/Python, 算法与数据结构,操作系统,网络,组成原理,\n\n下面分别概括各科的情况并确定加强的方向:\n>> **1. 微积分**\n　　**以离散的数列和连续的函数为核心,用极限和微分/积分为基础工具,微积分使我学习到严格的推导过程和缜密的计算流程,同时,有两个基本的解决问题的思路:**\n　　**a. 如何通过离散的角度(数列极限)考察连续的函数.**\n　　例如:考虑函数在一个点(x,y)是否是连续的,这里有三个量:点(x,y)的函数值f(x),左侧无限逼近x的离散的自变量序列{An},和右侧的序列{Bn}.左右两侧对应无穷数列的极限和f(x)相等则证明该点连续.公式如下:\n$$f(x)=\\lim\\_{x \\to x-}f(x)=\\lim\\_{x \\to x+}f(x)$$\n　　**b. 如何利用连续的概念解决离散的问题.**\n　　例如: 在数列极限难以求解的问题中,采用连续化为函数的方法,适用范围内,数列极限等于函数极限.公式如下:\n$$\\lim\\_{n \\to \\infty}a\\_n=\\lim_{x \\to x\\_0}f(x)$$\n　　微积分对概率论中的连续随机变量,以及任何形式的函数关系(数据科学领域)打下坚实的基础.但考虑到计算机本质上是一个离散的系统,虽然微积分中连续的概念可以指导计算机中离散对连续变量的模拟,但我认为离散数学应该更能奠定计算机的数学基础.加强方向:  **离散数学**[课程 MIT ](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-spring-2015/index.htm)\n\n<!-- more -->\n\n>>** 2. 线性代数:**\n　　**本科学习的核心概念包括:行列式,矩阵,线性方程组,相似及二次型,向量,线性空间.**\n　　向量和矩阵作为一个离散的概念,十分适合描述一个系统的信息,例如如何定量的描述一个网站的信息?定义一个向量对应网页,向量的每一个元素定义为网页的特征,如关键词,词频,访问量等可定量的特征,如此,所有网页对应的向量构成的矩阵就可以描述该网站,基于矩阵的运算理论则使整个网站参与运算,用于如搜索网站的排名,推荐系统等等.用矩阵来思考内存的组织是很形象生动,加深对内存空间的理解的.\n　　线性方程组的理论,我认为可以用以理解其他线性代数中的概念,并作为一种基础工具来求解其它问题.矩阵运算有时很难思考对应的实际意义,那么将其看成线性方程组的求解,看矩阵的行向量代表的含义,则能很好的和实际应用联系起来.方程组理论中的有解,有非零解,解空间的理论贯穿在整个线性代数中,例如行列式是否为零,矩阵是否奇异,特征向量都可以通过方程组来解决.\n　　遗憾的是没有深入学习线性空间,我认为这是线性代数最能推而广之解决一般性问题的方法,用线性系统的观点来建模实际的问题.因此我计划在这方面重点加强[**课程 MIT Linear Algebra**](https://ocw.mit.edu/courses/mathematics/18-06-linear-algebra-spring-2010/)\n    \n>> **3. 概率论与数理统计:**\n　　**概率论中的核心概念是:概率与分布(离散型,连续型), 数字特征(均值,方差).**\n　　概率是定量化的可能性,记录事件发生的可能,是对世界的最真实的描述.概率基于对已发生事件的频率, 描述可重复事件的可能,例如科研中的可重复的大量实验,在得到很多实验数据后,如何根据数据调整实验参数.一个很好的例子是贝叶斯公式:\n$$P(A|B) = \\frac {P(B|A) \\times P(A)}{P(B)}$$\n基于已知的事件的可能性{P(A)P(B)}和过去的{经验P(B|A)},推断事件{P(B|A)}发生的可能性,这是预测的基本的方式.\n　　我认为,数理统计将会是与计算机科学以及研究生阶段关联最紧密的主题.例如:课题项目的实验获取的大量数据如何处理?计算均值,方差,做回归分析,建立统计模型,验证模型,反馈调整实验参数...做科研的一个基本能力是数据分析能力,也离不开对数理统计的扎实掌握.我计划在这个主题加强[**课程 MIT**](https://ocw.mit.edu/courses/mathematics/18-05-introduction-to-probability-and-statistics-spring-2014/)\n\n>> **4. 物理**\n　　大学物理课与计算机科学相关的主要是电路,加上自学{[CODE](https://book.douban.com/subject/1494026/)},对逻辑电路有了基本的理解.二进制与开关的闭合对应的关系,正是Shannon在[他的论文](https://en.wikipedia.org/wiki/A_Symbolic_Analysis_of_Relay_and_Switching_Circuits)确定的计算机用电路实现的基础.与门,非们,或们,触发器实现的时序电路构成内存,寄存器+加法器+控制逻辑构成基本的ALU,组合逻辑电路构成完整的CPU.\n　　另外,物理课与实验密切结合,如何实验验证假设,如何控制变量,处理数据,得到结论,物理课训练我用一个正确的实验过程是怎样的实现的.\n\n>> **5. C**\n　　**C的核心概念:强类型, 数组与指针, 函数与递归,预处理和宏**.\n　　即使加上C标准库,C仍然是一门简洁清晰的编程语言:C结构清晰,以main()函数为入口,调用其他函数,声明和定义时要求类型定义;面向过程编程,抽象机制明确,过程抽象的语法是函数func(),数据抽象的语法是结构体struct;有指针pointer这个强力工具,连接计算机的底层,实现地址的操纵(&和\\*操作符)和内存的管理(malloc()等函数);项目组织有.h头文件和.c源文件,make控制编译.\n　　有内存管理和地址操纵这些底层功能,加上编译优化后高效的运行性能,使得C成为操作系统kernel,编译器complier,数据库database等的核心语言,尤其长于系统和硬件编程,我计划在学习这几个主题实现对应project的过程中,努力进阶C的编程能力.\n　　C中指针是个强大的概念，从最简单的交换两个变量值swap(),到函数指针func,内存管理的返回值类型void\\*,指针发挥了传递对象首地址而不是拷贝对象的作用.另外,基于指针的线性表-链表,具有了数组没有的易动态变化(增删)的优点,也使得树和图结构的实现更容易.\n　　但相比与其他高级语言如Java/Python,C不支持面向对象的特性,难以直接进行面向对象的程序设计.除去标准库/GNU-lib,同时没有相对丰富的库支持,不适合high-level(如GUI)的编程.但是,有了gcc,make等toolchain的支持,C仍然适合大型/要求性能/系统底层的开发工作,这也是我C加强的方向.\n　　\n>> **6. 算法与数据结构, 操作系统**最近正在学习,见下面的问题.\n\n>> **7. 组成原理**\n　　相比较与计算机体系机构注重在不同硬件平台上的具体实现，即一台RISC计算机内部结构是怎样的,指令系统是如何实现的,组成原理重点关注一般的计算机内部具有哪些通用的基本的结构,整个计算机的结构是如何联系起来共同工作的,而不在意具体的实现形式.\n　　**计算机基本的冯诺依曼架构, CPU(运算器ALU, 控制器CU), 内存Mem, 输入输出I/O,以及串联所有构件的总线BUS.**在CPU内部,运算由基本的加法器实现,通过控制部件用加法器实现减法,乘法和除法;数据由二进制表示,可以编码为原码/补码/反码/移码,浮点数由IEEE745标准规定;CU控制指令的执行过程,PC确定下一条指令的地址,一个完整的指令周期包括取指/译码/执行,以及取指/取数过程中的间指,以及处理外部产生的中断;一个指令的基本结构是{指令地址;操作码;操作数},由硬布线组合逻辑或微程序设计实现.\n　　存储的架构 CPU内部register - 缓存cache - 主存memory - 外存(硬盘,闪存),有ROM, RAM, FLASH等具体实现方式.\n　　输入输出I/O的结构: CPU or mem - I/O接口 - I/O设备.CPU通过程序查询(轮询)或中断和设备进行信息传递, mem可采用DMA方式直接与高速外设交换数据.\n　　总线可采用单/双/多总线结构,有基本的数据/地址/控制/控制等总线分类,主要解决的问题是总线仲裁和判优,针对不同的结构连接采用不同的总线标准,如ISA/PCI/USB.\n　　组成原理站在硬件角度考察计算机的结构性,注重计算机构件及其连接的原理,从整体的角度思考为什么硬件要这样组合,出现的问题如何解决?例如要使加法器实现加减乘除四种运算,首先要用补码编码,这样很容易就解决了加减统一的问题,乘除时符号位在运算中得出,基本的实现是循环(Booth算法);又比如如何提高指令执行的效率这一问题,除过对指令进行优化, 最佳的解决方案就是提高指令执行的并行性,流水线将指令划分为多个阶段,不同指令不同的周期并行,最大限度的提高部件的使用率,另外采用多核结构,直接实现程序的并行执行,提高计算机的吞吐率.\n　　对组成原理主题的加强,我认为可以通过实现软件与硬件的接口[Computer Orgianization and Design](https://book.douban.com/subject/1468468/).\n\n>> **8. 网络**\n    **计算机网络最大的特点是层次化设计,分布式解决.**\n　　TCP/IP四层协议和OSI七层协议,清晰的罗列网络的分级,也正是因为网络的复杂性,所以只有通过层次结构,一层一层的抽象分工,才能有效的解决不同计算机通信的问题.\n　　考虑一条链路上两个节点的通信,在底层物理的线路上封装比特流有物理层实现,比特流打包为数据帧保证数据不出错由链路层实现,数据包从哪里出发目的地是哪里由网络(iP)层实现,数据包传输的是面向连接还是无连接/是否保证无差错送达/解决网络的拥塞问题由传输层(TCP/UDP)实现,用户的不同的应用如何通信由应用层实现.\n　　分层明确,各司其职.下层通过访问服务点SAP为上层提供服务,对等层peer之间实现相同的协议,下层的抽象使得对等层似乎在直接通信.通过学习计算机网络,主要明确一个复杂的系统如何通过抽象分层,把大型的复杂的问题化为小问题来分析,然后通过层级架构之间的交互组合成大问题的解决方案,这样的思路在计算机科学是一种普遍的思维方式,例如操作系统位于用户层和硬件层之间,解决硬件的管理和对用户提供舒适的服务又比如算法中递归将问题向下分解为一层层的子问题(递归式),最终化为直接解决的简单问题(递归基base case),向上合并为要求解的问题.抽象和分层在网络中发挥了巨大的威力.\n　　分布式是指不同的计算机有不同的结构,不同的网络有不同的组织(异构网络),如何有效的利用这些资源?不同的网络直连时如何解决不兼容的问题?这都是分布式的概念.网络之间通过节点(网桥,路由器)和相关算法(如OSPF,BGP)实现异构网络之间的通信和同步,而不是各自为政,无法协调.\n　　网络这个主题我的实践还很少,努力加强的方向是linux环境下的[网络编程](https://book.douban.com/subject/1756533/).\n\n------\n### Q2:周期1内我学习的内容有哪些?\n周期1内我主要学习的是:算法与数据结构, 操作系统\n下面分别详述:\n>> **1. 算法与数据结构**\n　　算法主题我采用的教材是MIT的[introduction to algorithms](https://book.douban.com/subject/3904676/)以及配套的[课程](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/index.htm).下面是我的学习笔记:\n　　算法主题可以分为三个方向:算法的数学理论,算法的设计分析,算法的应用.算法导论主要包括强两个方面的内容, 尤其注重算法的推导和证明.\n　　算法的定义为将输入转换为输出的计算步骤序列(An algorithm is thus a sequence of computational steps that transform the input into the output.),有确定的输入,和明确实现实现的步骤,以及满足要求的输出.在用编程语言实现算法的过程中,清晰性(无歧义)/可实现/有穷性是算法的基本的要求.\n　　面对的具体的问题,有不同的算法,对应着不同的性能.我们主要考虑这样几个问题:空间复杂度, 时间复杂度,可扩展性等等.该算法在运行时是否要求额外的内存,需要多少空间?最坏/最好/平均的数据分布情况下,消耗多少时间?在解决特定规模的问题后,是否能扩展到一般的更大规模的问题?算法分析时考量这几个主要特征.\n　　已排序算法为例,基本的排序算法有插入排序(直接插入,折半插入,希尔排序), 选择排序(选择排序,堆排序),交换排序(冒泡,快排),归并排序,基数排序.排序算法的基本特征是复杂度(空间,时间),稳定性(关键字相同的数据排序前后相对顺序不变).\n　　从平均时间复杂度讲快排/堆排序/归并排序是O(nlogn),快排在基本有序的情况下退化为O(n^2),归并排序需要额外的O(n)的空间,堆排序在任何情况下都是很优秀的O(nlogn);选择/冒泡/直接插入是O(n^2);基数排序为O(d(n+radix)),可以达到接近线性O(n)的性能,但依赖与基数和位数的多少.\n　　当数据排序时要求有多个关键字时(关键字A相同的按关键字B排序),要求排序的稳定性,冒泡/选择/插入/归并/基数排序是稳定的,快速/希尔/堆是不稳定的.\n　　当数据量较大,内存无法一次放下,需要从外存调入数据,归并排序则是最佳的选择.归并将数据分段,然后构造归并树由叶子节点向上归并到根节点,非常符合外部排序的要求.另外,归并排序既可以用递归(递归排序前一半数据,递归排序后一半数据,归并前后两段)实现,极好的体现了问题分解为子问题,逐个击破的递归特点;也可以用迭代实现,将序列分为两个数据一组,从两个开始归并直到合成总的有序序列.与此类似的还有快速排序的分割思想,用key将序列分解为小于key和大于key的序列.\n　　从归并的递归和迭代实现可以看到,这是两种解决算法问题的思路:递归top-down,将问题分解为相似的子问题,divide and conquer,逐个解决;迭代bottom-up,从基本的最小问题开始,构造出求解的大问题.\n　　mit课程中第一节课讲到了peek-problem,搜索数据意义上的极大值.从一维序列的角度讲, 序列$ [a\\_1, a\\_2, a\\_3, \\ldots, a\\_n]$的peek $a\\_i$满足条件$ a\\_i > a\\_{i-1} \\,  and \\, a\\_i > a\\_{i+1}$ ．\n线性算法O(n)遍历序列可以寻找peek,是否有更好的算法呢?运用二分的思想, 如下\n$$\\begin{align}\nif \\, a\\_{n/2} < a\\_{n/2-1}, peek \\, in \\, [a\\_1, a\\_2, \\ldots, a\\_{n/2-1}]\\\\\\\nif \\, a\\_{n/2} < a\\_{n/2+1}, peek \\, in \\, [a\\_{n/2+1}, \\ldots, a\\_{n-1}, a\\_n]\\\\\\\nelse \\, a\\_{n/2} \\, is \\,peek\n\\end{align}$$\n可以得到O(logn)的结果.\n解决一位的问题后推广到二维(m\\*n),线性遍历O(mn)仍然是适用的,但二分不能解决问题.是否可以采用优化后的二分思想解决问题?将二维问题看成一个由列向量构成的矩阵,增加一个函数max(),求解列向量的最大值及其位置,然后由最大值作为一列的代表运用二分的思想得到O(mlogn)的算法.\n 　从解决peek-problem的过程中,我学到的的是如何正确的求解一个算法问题:首先选择规模最小,最简单的问题形式(如一维),是提出最直观的暴力解法{如线性的遍历,O(n^2)的筛选},虽然能解决问题但往往性能是很差;然后寻找优化的方向{如二分的O(logn), 归并的O(nlogn)};接下来向一般的/更复杂的情况(如二维,多变量)推广,考察一维的方法是否仍然适用,如果不适用是什么原因导致的,能否改进调整.我认为**对比解决同一问题的不同算法, 泛化到一般情况**是学好算法的好标准.\n 　\n>> **2. 操作系统**\n　　操作系统采用的教材是[Operating System Concepts](https://book.douban.com/subject/10076960/),配套实验是[MIT xv6](https://pdos.csail.mit.edu/6.828/2016/schedule.html).下面是我的学习笔记:\n　　操作系统课程我在考研时学习了理论的知识,但学习是有不完整/系统的,因此需要重点弥补理论的部分和动手实践的能力.\n　　从最初的解决批处理的问题,到分时给不同的用户交互,再到实时系统要求的快速反馈/高稳定性,到现在分布式系统的同步/网络系统的通信.我认为始终有两个核心内容贯穿其间:一是如何实现对计算机资源的管理,尤其是独占资源(CPU的计算,内存的储存,外设);二是如何实现与用户的交互,操作系统归根到底是要为用户服务的,用户的应用如何通过操作系统得到资源.\n　　操作系统位于中间层,介于计算机资源与用户应用之间,向上提供服务,向下管理资源,是一个大型的系统软件.就上述两个主题来详述:\n　　一台主机要向多个用户提供分时服务就在同一主机上产了不同的用户程序,或者同一用户有不同的应用需求(如在编辑文档时听音乐/访问网络),因此产生了进程的概念:\"一组数据集在程序上的动态运行\".进程要使用CPU/mem等有限的独占资源,在时间上是交错开使用这些资源的,产生了诸多关键问题:\n　　进程:\n　　1. 进程之间如何切换?产生了进程调度算法(先来先服务,时间片轮转,优先级,响应比,多级反馈队列);\n　　2. 进程切换十分消耗资源,是否有更好的方法?共享进程空间,切换代价很小的线程\n　　3. 不同进程在占用资源时是否有先后顺序,之间是否有前后依赖关系?要求进程的同步和互斥(信号量机制及其解决的经典同步问题,管程,原语的原子性)\n　　4. 进程使用资源顺序不当时,如何防止产生死锁,产生后死锁如何解决?破坏死所的四个必要条件来预防,银行家算法来避免死锁,化简资源分配图来检测死锁,终止进程来解决死锁.\n　　内存:\n　　1. 程序是如何运行的?程序的编译,链接与装载,地址空间的映射,内存保护.\n　　2. 多组程序和数据存储在内存,如何管理?交换与覆盖技术,静态分页与分段.\n　　3. 内存不够使用,如何扩展内存?用外存扩展,虚拟内存技术(请求分页,页面置换\n　　文件:\n　　1. 站在用户角度,如何更好的使用文件?文件系统接口(FCB,文件的逻辑实现,目录的结构,文件共享和保护)\n　　2. 站在计算机的角度,如何管理文件?文件系统实现(分配硬盘空间, 管理空闲磁盘快, 目录实现)\n　　3. 硬件层面如何管理磁盘?磁盘结构,调度,管理磁盘(格式化,引导)\n　　设备:\n　　1. 用户如何使用设备,设备如何与CPU/mem实现信息传递?I/O设备管理器与接口,轮询/中断/DMA\n　　2. 计算机如何实现对设备的管理?I/O子系统(缓冲机制,SPOOLING, 内核管理设备的数据结构)\n　  除过上面的问题，还有一个核心问题是用户的应用如何使用计算机的资源？通过系统调用(system call)，从用户态切换到内核态，由内核执行系统调用子程序，返回用户想要的结果．\n　　以上是我对操作系统理论的基本认识，还有待扩展细化，并且和MIT xv6操作系统实验结合起来．MIT实验笔记正在总结，另外写一个update.\n                                    \n最后完成日期：2017-04-02","source":"_posts/cs-update.md","raw":"title: cs-update\ndate: 2017/04/02\ntags: CS\n\n---\n# CS学习update\n\n### 摘要\n>在被浙江大学计算机学院拟录取之后, 我现阶段的两个任务是:\n> * 1. 完成本科土木工程的学业,主要是毕业设计\n> * 2. 弥补计算机科学的基础知识和素养,并向研究方向靠拢\n> 为了能循序渐进的奠定计算机科学的基础,在此记录学习的内容和自己的收获总结.文章更新周期为一周一次, 每周全面的总结一周七天后写成.文章格式为问答式,提出问题并自己解答,以此自检.\n    \n### 周期1: 已学总结与学习计划\n#### 时间: 2017/03/20 - 2017/04/01\n-----\n#### Q1: 我已学过的计算机科学的专题有哪些?\n\n数学和物理: 微积分, 线性代数, 概率论, 大学物理(电路)\n计算机: C/Python, 算法与数据结构,操作系统,网络,组成原理,\n\n下面分别概括各科的情况并确定加强的方向:\n>> **1. 微积分**\n　　**以离散的数列和连续的函数为核心,用极限和微分/积分为基础工具,微积分使我学习到严格的推导过程和缜密的计算流程,同时,有两个基本的解决问题的思路:**\n　　**a. 如何通过离散的角度(数列极限)考察连续的函数.**\n　　例如:考虑函数在一个点(x,y)是否是连续的,这里有三个量:点(x,y)的函数值f(x),左侧无限逼近x的离散的自变量序列{An},和右侧的序列{Bn}.左右两侧对应无穷数列的极限和f(x)相等则证明该点连续.公式如下:\n$$f(x)=\\lim\\_{x \\to x-}f(x)=\\lim\\_{x \\to x+}f(x)$$\n　　**b. 如何利用连续的概念解决离散的问题.**\n　　例如: 在数列极限难以求解的问题中,采用连续化为函数的方法,适用范围内,数列极限等于函数极限.公式如下:\n$$\\lim\\_{n \\to \\infty}a\\_n=\\lim_{x \\to x\\_0}f(x)$$\n　　微积分对概率论中的连续随机变量,以及任何形式的函数关系(数据科学领域)打下坚实的基础.但考虑到计算机本质上是一个离散的系统,虽然微积分中连续的概念可以指导计算机中离散对连续变量的模拟,但我认为离散数学应该更能奠定计算机的数学基础.加强方向:  **离散数学**[课程 MIT ](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-spring-2015/index.htm)\n\n<!-- more -->\n\n>>** 2. 线性代数:**\n　　**本科学习的核心概念包括:行列式,矩阵,线性方程组,相似及二次型,向量,线性空间.**\n　　向量和矩阵作为一个离散的概念,十分适合描述一个系统的信息,例如如何定量的描述一个网站的信息?定义一个向量对应网页,向量的每一个元素定义为网页的特征,如关键词,词频,访问量等可定量的特征,如此,所有网页对应的向量构成的矩阵就可以描述该网站,基于矩阵的运算理论则使整个网站参与运算,用于如搜索网站的排名,推荐系统等等.用矩阵来思考内存的组织是很形象生动,加深对内存空间的理解的.\n　　线性方程组的理论,我认为可以用以理解其他线性代数中的概念,并作为一种基础工具来求解其它问题.矩阵运算有时很难思考对应的实际意义,那么将其看成线性方程组的求解,看矩阵的行向量代表的含义,则能很好的和实际应用联系起来.方程组理论中的有解,有非零解,解空间的理论贯穿在整个线性代数中,例如行列式是否为零,矩阵是否奇异,特征向量都可以通过方程组来解决.\n　　遗憾的是没有深入学习线性空间,我认为这是线性代数最能推而广之解决一般性问题的方法,用线性系统的观点来建模实际的问题.因此我计划在这方面重点加强[**课程 MIT Linear Algebra**](https://ocw.mit.edu/courses/mathematics/18-06-linear-algebra-spring-2010/)\n    \n>> **3. 概率论与数理统计:**\n　　**概率论中的核心概念是:概率与分布(离散型,连续型), 数字特征(均值,方差).**\n　　概率是定量化的可能性,记录事件发生的可能,是对世界的最真实的描述.概率基于对已发生事件的频率, 描述可重复事件的可能,例如科研中的可重复的大量实验,在得到很多实验数据后,如何根据数据调整实验参数.一个很好的例子是贝叶斯公式:\n$$P(A|B) = \\frac {P(B|A) \\times P(A)}{P(B)}$$\n基于已知的事件的可能性{P(A)P(B)}和过去的{经验P(B|A)},推断事件{P(B|A)}发生的可能性,这是预测的基本的方式.\n　　我认为,数理统计将会是与计算机科学以及研究生阶段关联最紧密的主题.例如:课题项目的实验获取的大量数据如何处理?计算均值,方差,做回归分析,建立统计模型,验证模型,反馈调整实验参数...做科研的一个基本能力是数据分析能力,也离不开对数理统计的扎实掌握.我计划在这个主题加强[**课程 MIT**](https://ocw.mit.edu/courses/mathematics/18-05-introduction-to-probability-and-statistics-spring-2014/)\n\n>> **4. 物理**\n　　大学物理课与计算机科学相关的主要是电路,加上自学{[CODE](https://book.douban.com/subject/1494026/)},对逻辑电路有了基本的理解.二进制与开关的闭合对应的关系,正是Shannon在[他的论文](https://en.wikipedia.org/wiki/A_Symbolic_Analysis_of_Relay_and_Switching_Circuits)确定的计算机用电路实现的基础.与门,非们,或们,触发器实现的时序电路构成内存,寄存器+加法器+控制逻辑构成基本的ALU,组合逻辑电路构成完整的CPU.\n　　另外,物理课与实验密切结合,如何实验验证假设,如何控制变量,处理数据,得到结论,物理课训练我用一个正确的实验过程是怎样的实现的.\n\n>> **5. C**\n　　**C的核心概念:强类型, 数组与指针, 函数与递归,预处理和宏**.\n　　即使加上C标准库,C仍然是一门简洁清晰的编程语言:C结构清晰,以main()函数为入口,调用其他函数,声明和定义时要求类型定义;面向过程编程,抽象机制明确,过程抽象的语法是函数func(),数据抽象的语法是结构体struct;有指针pointer这个强力工具,连接计算机的底层,实现地址的操纵(&和\\*操作符)和内存的管理(malloc()等函数);项目组织有.h头文件和.c源文件,make控制编译.\n　　有内存管理和地址操纵这些底层功能,加上编译优化后高效的运行性能,使得C成为操作系统kernel,编译器complier,数据库database等的核心语言,尤其长于系统和硬件编程,我计划在学习这几个主题实现对应project的过程中,努力进阶C的编程能力.\n　　C中指针是个强大的概念，从最简单的交换两个变量值swap(),到函数指针func,内存管理的返回值类型void\\*,指针发挥了传递对象首地址而不是拷贝对象的作用.另外,基于指针的线性表-链表,具有了数组没有的易动态变化(增删)的优点,也使得树和图结构的实现更容易.\n　　但相比与其他高级语言如Java/Python,C不支持面向对象的特性,难以直接进行面向对象的程序设计.除去标准库/GNU-lib,同时没有相对丰富的库支持,不适合high-level(如GUI)的编程.但是,有了gcc,make等toolchain的支持,C仍然适合大型/要求性能/系统底层的开发工作,这也是我C加强的方向.\n　　\n>> **6. 算法与数据结构, 操作系统**最近正在学习,见下面的问题.\n\n>> **7. 组成原理**\n　　相比较与计算机体系机构注重在不同硬件平台上的具体实现，即一台RISC计算机内部结构是怎样的,指令系统是如何实现的,组成原理重点关注一般的计算机内部具有哪些通用的基本的结构,整个计算机的结构是如何联系起来共同工作的,而不在意具体的实现形式.\n　　**计算机基本的冯诺依曼架构, CPU(运算器ALU, 控制器CU), 内存Mem, 输入输出I/O,以及串联所有构件的总线BUS.**在CPU内部,运算由基本的加法器实现,通过控制部件用加法器实现减法,乘法和除法;数据由二进制表示,可以编码为原码/补码/反码/移码,浮点数由IEEE745标准规定;CU控制指令的执行过程,PC确定下一条指令的地址,一个完整的指令周期包括取指/译码/执行,以及取指/取数过程中的间指,以及处理外部产生的中断;一个指令的基本结构是{指令地址;操作码;操作数},由硬布线组合逻辑或微程序设计实现.\n　　存储的架构 CPU内部register - 缓存cache - 主存memory - 外存(硬盘,闪存),有ROM, RAM, FLASH等具体实现方式.\n　　输入输出I/O的结构: CPU or mem - I/O接口 - I/O设备.CPU通过程序查询(轮询)或中断和设备进行信息传递, mem可采用DMA方式直接与高速外设交换数据.\n　　总线可采用单/双/多总线结构,有基本的数据/地址/控制/控制等总线分类,主要解决的问题是总线仲裁和判优,针对不同的结构连接采用不同的总线标准,如ISA/PCI/USB.\n　　组成原理站在硬件角度考察计算机的结构性,注重计算机构件及其连接的原理,从整体的角度思考为什么硬件要这样组合,出现的问题如何解决?例如要使加法器实现加减乘除四种运算,首先要用补码编码,这样很容易就解决了加减统一的问题,乘除时符号位在运算中得出,基本的实现是循环(Booth算法);又比如如何提高指令执行的效率这一问题,除过对指令进行优化, 最佳的解决方案就是提高指令执行的并行性,流水线将指令划分为多个阶段,不同指令不同的周期并行,最大限度的提高部件的使用率,另外采用多核结构,直接实现程序的并行执行,提高计算机的吞吐率.\n　　对组成原理主题的加强,我认为可以通过实现软件与硬件的接口[Computer Orgianization and Design](https://book.douban.com/subject/1468468/).\n\n>> **8. 网络**\n    **计算机网络最大的特点是层次化设计,分布式解决.**\n　　TCP/IP四层协议和OSI七层协议,清晰的罗列网络的分级,也正是因为网络的复杂性,所以只有通过层次结构,一层一层的抽象分工,才能有效的解决不同计算机通信的问题.\n　　考虑一条链路上两个节点的通信,在底层物理的线路上封装比特流有物理层实现,比特流打包为数据帧保证数据不出错由链路层实现,数据包从哪里出发目的地是哪里由网络(iP)层实现,数据包传输的是面向连接还是无连接/是否保证无差错送达/解决网络的拥塞问题由传输层(TCP/UDP)实现,用户的不同的应用如何通信由应用层实现.\n　　分层明确,各司其职.下层通过访问服务点SAP为上层提供服务,对等层peer之间实现相同的协议,下层的抽象使得对等层似乎在直接通信.通过学习计算机网络,主要明确一个复杂的系统如何通过抽象分层,把大型的复杂的问题化为小问题来分析,然后通过层级架构之间的交互组合成大问题的解决方案,这样的思路在计算机科学是一种普遍的思维方式,例如操作系统位于用户层和硬件层之间,解决硬件的管理和对用户提供舒适的服务又比如算法中递归将问题向下分解为一层层的子问题(递归式),最终化为直接解决的简单问题(递归基base case),向上合并为要求解的问题.抽象和分层在网络中发挥了巨大的威力.\n　　分布式是指不同的计算机有不同的结构,不同的网络有不同的组织(异构网络),如何有效的利用这些资源?不同的网络直连时如何解决不兼容的问题?这都是分布式的概念.网络之间通过节点(网桥,路由器)和相关算法(如OSPF,BGP)实现异构网络之间的通信和同步,而不是各自为政,无法协调.\n　　网络这个主题我的实践还很少,努力加强的方向是linux环境下的[网络编程](https://book.douban.com/subject/1756533/).\n\n------\n### Q2:周期1内我学习的内容有哪些?\n周期1内我主要学习的是:算法与数据结构, 操作系统\n下面分别详述:\n>> **1. 算法与数据结构**\n　　算法主题我采用的教材是MIT的[introduction to algorithms](https://book.douban.com/subject/3904676/)以及配套的[课程](https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/index.htm).下面是我的学习笔记:\n　　算法主题可以分为三个方向:算法的数学理论,算法的设计分析,算法的应用.算法导论主要包括强两个方面的内容, 尤其注重算法的推导和证明.\n　　算法的定义为将输入转换为输出的计算步骤序列(An algorithm is thus a sequence of computational steps that transform the input into the output.),有确定的输入,和明确实现实现的步骤,以及满足要求的输出.在用编程语言实现算法的过程中,清晰性(无歧义)/可实现/有穷性是算法的基本的要求.\n　　面对的具体的问题,有不同的算法,对应着不同的性能.我们主要考虑这样几个问题:空间复杂度, 时间复杂度,可扩展性等等.该算法在运行时是否要求额外的内存,需要多少空间?最坏/最好/平均的数据分布情况下,消耗多少时间?在解决特定规模的问题后,是否能扩展到一般的更大规模的问题?算法分析时考量这几个主要特征.\n　　已排序算法为例,基本的排序算法有插入排序(直接插入,折半插入,希尔排序), 选择排序(选择排序,堆排序),交换排序(冒泡,快排),归并排序,基数排序.排序算法的基本特征是复杂度(空间,时间),稳定性(关键字相同的数据排序前后相对顺序不变).\n　　从平均时间复杂度讲快排/堆排序/归并排序是O(nlogn),快排在基本有序的情况下退化为O(n^2),归并排序需要额外的O(n)的空间,堆排序在任何情况下都是很优秀的O(nlogn);选择/冒泡/直接插入是O(n^2);基数排序为O(d(n+radix)),可以达到接近线性O(n)的性能,但依赖与基数和位数的多少.\n　　当数据排序时要求有多个关键字时(关键字A相同的按关键字B排序),要求排序的稳定性,冒泡/选择/插入/归并/基数排序是稳定的,快速/希尔/堆是不稳定的.\n　　当数据量较大,内存无法一次放下,需要从外存调入数据,归并排序则是最佳的选择.归并将数据分段,然后构造归并树由叶子节点向上归并到根节点,非常符合外部排序的要求.另外,归并排序既可以用递归(递归排序前一半数据,递归排序后一半数据,归并前后两段)实现,极好的体现了问题分解为子问题,逐个击破的递归特点;也可以用迭代实现,将序列分为两个数据一组,从两个开始归并直到合成总的有序序列.与此类似的还有快速排序的分割思想,用key将序列分解为小于key和大于key的序列.\n　　从归并的递归和迭代实现可以看到,这是两种解决算法问题的思路:递归top-down,将问题分解为相似的子问题,divide and conquer,逐个解决;迭代bottom-up,从基本的最小问题开始,构造出求解的大问题.\n　　mit课程中第一节课讲到了peek-problem,搜索数据意义上的极大值.从一维序列的角度讲, 序列$ [a\\_1, a\\_2, a\\_3, \\ldots, a\\_n]$的peek $a\\_i$满足条件$ a\\_i > a\\_{i-1} \\,  and \\, a\\_i > a\\_{i+1}$ ．\n线性算法O(n)遍历序列可以寻找peek,是否有更好的算法呢?运用二分的思想, 如下\n$$\\begin{align}\nif \\, a\\_{n/2} < a\\_{n/2-1}, peek \\, in \\, [a\\_1, a\\_2, \\ldots, a\\_{n/2-1}]\\\\\\\nif \\, a\\_{n/2} < a\\_{n/2+1}, peek \\, in \\, [a\\_{n/2+1}, \\ldots, a\\_{n-1}, a\\_n]\\\\\\\nelse \\, a\\_{n/2} \\, is \\,peek\n\\end{align}$$\n可以得到O(logn)的结果.\n解决一位的问题后推广到二维(m\\*n),线性遍历O(mn)仍然是适用的,但二分不能解决问题.是否可以采用优化后的二分思想解决问题?将二维问题看成一个由列向量构成的矩阵,增加一个函数max(),求解列向量的最大值及其位置,然后由最大值作为一列的代表运用二分的思想得到O(mlogn)的算法.\n 　从解决peek-problem的过程中,我学到的的是如何正确的求解一个算法问题:首先选择规模最小,最简单的问题形式(如一维),是提出最直观的暴力解法{如线性的遍历,O(n^2)的筛选},虽然能解决问题但往往性能是很差;然后寻找优化的方向{如二分的O(logn), 归并的O(nlogn)};接下来向一般的/更复杂的情况(如二维,多变量)推广,考察一维的方法是否仍然适用,如果不适用是什么原因导致的,能否改进调整.我认为**对比解决同一问题的不同算法, 泛化到一般情况**是学好算法的好标准.\n 　\n>> **2. 操作系统**\n　　操作系统采用的教材是[Operating System Concepts](https://book.douban.com/subject/10076960/),配套实验是[MIT xv6](https://pdos.csail.mit.edu/6.828/2016/schedule.html).下面是我的学习笔记:\n　　操作系统课程我在考研时学习了理论的知识,但学习是有不完整/系统的,因此需要重点弥补理论的部分和动手实践的能力.\n　　从最初的解决批处理的问题,到分时给不同的用户交互,再到实时系统要求的快速反馈/高稳定性,到现在分布式系统的同步/网络系统的通信.我认为始终有两个核心内容贯穿其间:一是如何实现对计算机资源的管理,尤其是独占资源(CPU的计算,内存的储存,外设);二是如何实现与用户的交互,操作系统归根到底是要为用户服务的,用户的应用如何通过操作系统得到资源.\n　　操作系统位于中间层,介于计算机资源与用户应用之间,向上提供服务,向下管理资源,是一个大型的系统软件.就上述两个主题来详述:\n　　一台主机要向多个用户提供分时服务就在同一主机上产了不同的用户程序,或者同一用户有不同的应用需求(如在编辑文档时听音乐/访问网络),因此产生了进程的概念:\"一组数据集在程序上的动态运行\".进程要使用CPU/mem等有限的独占资源,在时间上是交错开使用这些资源的,产生了诸多关键问题:\n　　进程:\n　　1. 进程之间如何切换?产生了进程调度算法(先来先服务,时间片轮转,优先级,响应比,多级反馈队列);\n　　2. 进程切换十分消耗资源,是否有更好的方法?共享进程空间,切换代价很小的线程\n　　3. 不同进程在占用资源时是否有先后顺序,之间是否有前后依赖关系?要求进程的同步和互斥(信号量机制及其解决的经典同步问题,管程,原语的原子性)\n　　4. 进程使用资源顺序不当时,如何防止产生死锁,产生后死锁如何解决?破坏死所的四个必要条件来预防,银行家算法来避免死锁,化简资源分配图来检测死锁,终止进程来解决死锁.\n　　内存:\n　　1. 程序是如何运行的?程序的编译,链接与装载,地址空间的映射,内存保护.\n　　2. 多组程序和数据存储在内存,如何管理?交换与覆盖技术,静态分页与分段.\n　　3. 内存不够使用,如何扩展内存?用外存扩展,虚拟内存技术(请求分页,页面置换\n　　文件:\n　　1. 站在用户角度,如何更好的使用文件?文件系统接口(FCB,文件的逻辑实现,目录的结构,文件共享和保护)\n　　2. 站在计算机的角度,如何管理文件?文件系统实现(分配硬盘空间, 管理空闲磁盘快, 目录实现)\n　　3. 硬件层面如何管理磁盘?磁盘结构,调度,管理磁盘(格式化,引导)\n　　设备:\n　　1. 用户如何使用设备,设备如何与CPU/mem实现信息传递?I/O设备管理器与接口,轮询/中断/DMA\n　　2. 计算机如何实现对设备的管理?I/O子系统(缓冲机制,SPOOLING, 内核管理设备的数据结构)\n　  除过上面的问题，还有一个核心问题是用户的应用如何使用计算机的资源？通过系统调用(system call)，从用户态切换到内核态，由内核执行系统调用子程序，返回用户想要的结果．\n　　以上是我对操作系统理论的基本认识，还有待扩展细化，并且和MIT xv6操作系统实验结合起来．MIT实验笔记正在总结，另外写一个update.\n                                    \n最后完成日期：2017-04-02","slug":"cs-update","published":1,"updated":"2017-08-26T03:38:21.618Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6sslhb1000l3gamopmetrhn","content":"<h1 id=\"CS学习update\"><a href=\"#CS学习update\" class=\"headerlink\" title=\"CS学习update\"></a>CS学习update</h1><h3 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h3><blockquote>\n<p>在被浙江大学计算机学院拟录取之后, 我现阶段的两个任务是:</p>\n<ul>\n<li><ol>\n<li>完成本科土木工程的学业,主要是毕业设计</li>\n</ol>\n</li>\n<li><ol>\n<li>弥补计算机科学的基础知识和素养,并向研究方向靠拢<br>为了能循序渐进的奠定计算机科学的基础,在此记录学习的内容和自己的收获总结.文章更新周期为一周一次, 每周全面的总结一周七天后写成.文章格式为问答式,提出问题并自己解答,以此自检.</li>\n</ol>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"周期1-已学总结与学习计划\"><a href=\"#周期1-已学总结与学习计划\" class=\"headerlink\" title=\"周期1: 已学总结与学习计划\"></a>周期1: 已学总结与学习计划</h3><h4 id=\"时间-2017-03-20-2017-04-01\"><a href=\"#时间-2017-03-20-2017-04-01\" class=\"headerlink\" title=\"时间: 2017/03/20 - 2017/04/01\"></a>时间: 2017/03/20 - 2017/04/01</h4><hr>\n<h4 id=\"Q1-我已学过的计算机科学的专题有哪些\"><a href=\"#Q1-我已学过的计算机科学的专题有哪些\" class=\"headerlink\" title=\"Q1: 我已学过的计算机科学的专题有哪些?\"></a>Q1: 我已学过的计算机科学的专题有哪些?</h4><p>数学和物理: 微积分, 线性代数, 概率论, 大学物理(电路)<br>计算机: C/Python, 算法与数据结构,操作系统,网络,组成原理,</p>\n<p>下面分别概括各科的情况并确定加强的方向:</p>\n<blockquote>\n<blockquote>\n<p><strong>1. 微积分</strong><br>　　<strong>以离散的数列和连续的函数为核心,用极限和微分/积分为基础工具,微积分使我学习到严格的推导过程和缜密的计算流程,同时,有两个基本的解决问题的思路:</strong><br>　　<strong>a. 如何通过离散的角度(数列极限)考察连续的函数.</strong><br>　　例如:考虑函数在一个点(x,y)是否是连续的,这里有三个量:点(x,y)的函数值f(x),左侧无限逼近x的离散的自变量序列{An},和右侧的序列{Bn}.左右两侧对应无穷数列的极限和f(x)相等则证明该点连续.公式如下:<br>$$f(x)=\\lim_{x \\to x-}f(x)=\\lim_{x \\to x+}f(x)$$<br>　　<strong>b. 如何利用连续的概念解决离散的问题.</strong><br>　　例如: 在数列极限难以求解的问题中,采用连续化为函数的方法,适用范围内,数列极限等于函数极限.公式如下:<br>$$\\lim_{n \\to \\infty}a_n=\\lim_{x \\to x_0}f(x)$$<br>　　微积分对概率论中的连续随机变量,以及任何形式的函数关系(数据科学领域)打下坚实的基础.但考虑到计算机本质上是一个离散的系统,虽然微积分中连续的概念可以指导计算机中离散对连续变量的模拟,但我认为离散数学应该更能奠定计算机的数学基础.加强方向:  <strong>离散数学</strong><a href=\"https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-spring-2015/index.htm\" target=\"_blank\" rel=\"external\">课程 MIT </a></p>\n</blockquote>\n</blockquote>\n<a id=\"more\"></a>\n<blockquote>\n<blockquote>\n<p><strong> 2. 线性代数:</strong><br>　　<strong>本科学习的核心概念包括:行列式,矩阵,线性方程组,相似及二次型,向量,线性空间.</strong><br>　　向量和矩阵作为一个离散的概念,十分适合描述一个系统的信息,例如如何定量的描述一个网站的信息?定义一个向量对应网页,向量的每一个元素定义为网页的特征,如关键词,词频,访问量等可定量的特征,如此,所有网页对应的向量构成的矩阵就可以描述该网站,基于矩阵的运算理论则使整个网站参与运算,用于如搜索网站的排名,推荐系统等等.用矩阵来思考内存的组织是很形象生动,加深对内存空间的理解的.<br>　　线性方程组的理论,我认为可以用以理解其他线性代数中的概念,并作为一种基础工具来求解其它问题.矩阵运算有时很难思考对应的实际意义,那么将其看成线性方程组的求解,看矩阵的行向量代表的含义,则能很好的和实际应用联系起来.方程组理论中的有解,有非零解,解空间的理论贯穿在整个线性代数中,例如行列式是否为零,矩阵是否奇异,特征向量都可以通过方程组来解决.<br>　　遗憾的是没有深入学习线性空间,我认为这是线性代数最能推而广之解决一般性问题的方法,用线性系统的观点来建模实际的问题.因此我计划在这方面重点加强<a href=\"https://ocw.mit.edu/courses/mathematics/18-06-linear-algebra-spring-2010/\" target=\"_blank\" rel=\"external\"><strong>课程 MIT Linear Algebra</strong></a></p>\n<p><strong>3. 概率论与数理统计:</strong><br>　　<strong>概率论中的核心概念是:概率与分布(离散型,连续型), 数字特征(均值,方差).</strong><br>　　概率是定量化的可能性,记录事件发生的可能,是对世界的最真实的描述.概率基于对已发生事件的频率, 描述可重复事件的可能,例如科研中的可重复的大量实验,在得到很多实验数据后,如何根据数据调整实验参数.一个很好的例子是贝叶斯公式:<br>$$P(A|B) = \\frac {P(B|A) \\times P(A)}{P(B)}$$<br>基于已知的事件的可能性{P(A)P(B)}和过去的{经验P(B|A)},推断事件{P(B|A)}发生的可能性,这是预测的基本的方式.<br>　　我认为,数理统计将会是与计算机科学以及研究生阶段关联最紧密的主题.例如:课题项目的实验获取的大量数据如何处理?计算均值,方差,做回归分析,建立统计模型,验证模型,反馈调整实验参数…做科研的一个基本能力是数据分析能力,也离不开对数理统计的扎实掌握.我计划在这个主题加强<a href=\"https://ocw.mit.edu/courses/mathematics/18-05-introduction-to-probability-and-statistics-spring-2014/\" target=\"_blank\" rel=\"external\"><strong>课程 MIT</strong></a></p>\n<p><strong>4. 物理</strong><br>　　大学物理课与计算机科学相关的主要是电路,加上自学{<a href=\"https://book.douban.com/subject/1494026/\" target=\"_blank\" rel=\"external\">CODE</a>},对逻辑电路有了基本的理解.二进制与开关的闭合对应的关系,正是Shannon在<a href=\"https://en.wikipedia.org/wiki/A_Symbolic_Analysis_of_Relay_and_Switching_Circuits\" target=\"_blank\" rel=\"external\">他的论文</a>确定的计算机用电路实现的基础.与门,非们,或们,触发器实现的时序电路构成内存,寄存器+加法器+控制逻辑构成基本的ALU,组合逻辑电路构成完整的CPU.<br>　　另外,物理课与实验密切结合,如何实验验证假设,如何控制变量,处理数据,得到结论,物理课训练我用一个正确的实验过程是怎样的实现的.</p>\n<p><strong>5. C</strong><br>　　<strong>C的核心概念:强类型, 数组与指针, 函数与递归,预处理和宏</strong>.<br>　　即使加上C标准库,C仍然是一门简洁清晰的编程语言:C结构清晰,以main()函数为入口,调用其他函数,声明和定义时要求类型定义;面向过程编程,抽象机制明确,过程抽象的语法是函数func(),数据抽象的语法是结构体struct;有指针pointer这个强力工具,连接计算机的底层,实现地址的操纵(&amp;和*操作符)和内存的管理(malloc()等函数);项目组织有.h头文件和.c源文件,make控制编译.<br>　　有内存管理和地址操纵这些底层功能,加上编译优化后高效的运行性能,使得C成为操作系统kernel,编译器complier,数据库database等的核心语言,尤其长于系统和硬件编程,我计划在学习这几个主题实现对应project的过程中,努力进阶C的编程能力.<br>　　C中指针是个强大的概念，从最简单的交换两个变量值swap(),到函数指针func,内存管理的返回值类型void*,指针发挥了传递对象首地址而不是拷贝对象的作用.另外,基于指针的线性表-链表,具有了数组没有的易动态变化(增删)的优点,也使得树和图结构的实现更容易.<br>　　但相比与其他高级语言如Java/Python,C不支持面向对象的特性,难以直接进行面向对象的程序设计.除去标准库/GNU-lib,同时没有相对丰富的库支持,不适合high-level(如GUI)的编程.但是,有了gcc,make等toolchain的支持,C仍然适合大型/要求性能/系统底层的开发工作,这也是我C加强的方向.<br>　　<br><strong>6. 算法与数据结构, 操作系统</strong>最近正在学习,见下面的问题.</p>\n<p><strong>7. 组成原理</strong><br>　　相比较与计算机体系机构注重在不同硬件平台上的具体实现，即一台RISC计算机内部结构是怎样的,指令系统是如何实现的,组成原理重点关注一般的计算机内部具有哪些通用的基本的结构,整个计算机的结构是如何联系起来共同工作的,而不在意具体的实现形式.<br>　　<strong>计算机基本的冯诺依曼架构, CPU(运算器ALU, 控制器CU), 内存Mem, 输入输出I/O,以及串联所有构件的总线BUS.</strong>在CPU内部,运算由基本的加法器实现,通过控制部件用加法器实现减法,乘法和除法;数据由二进制表示,可以编码为原码/补码/反码/移码,浮点数由IEEE745标准规定;CU控制指令的执行过程,PC确定下一条指令的地址,一个完整的指令周期包括取指/译码/执行,以及取指/取数过程中的间指,以及处理外部产生的中断;一个指令的基本结构是{指令地址;操作码;操作数},由硬布线组合逻辑或微程序设计实现.<br>　　存储的架构 CPU内部register - 缓存cache - 主存memory - 外存(硬盘,闪存),有ROM, RAM, FLASH等具体实现方式.<br>　　输入输出I/O的结构: CPU or mem - I/O接口 - I/O设备.CPU通过程序查询(轮询)或中断和设备进行信息传递, mem可采用DMA方式直接与高速外设交换数据.<br>　　总线可采用单/双/多总线结构,有基本的数据/地址/控制/控制等总线分类,主要解决的问题是总线仲裁和判优,针对不同的结构连接采用不同的总线标准,如ISA/PCI/USB.<br>　　组成原理站在硬件角度考察计算机的结构性,注重计算机构件及其连接的原理,从整体的角度思考为什么硬件要这样组合,出现的问题如何解决?例如要使加法器实现加减乘除四种运算,首先要用补码编码,这样很容易就解决了加减统一的问题,乘除时符号位在运算中得出,基本的实现是循环(Booth算法);又比如如何提高指令执行的效率这一问题,除过对指令进行优化, 最佳的解决方案就是提高指令执行的并行性,流水线将指令划分为多个阶段,不同指令不同的周期并行,最大限度的提高部件的使用率,另外采用多核结构,直接实现程序的并行执行,提高计算机的吞吐率.<br>　　对组成原理主题的加强,我认为可以通过实现软件与硬件的接口<a href=\"https://book.douban.com/subject/1468468/\" target=\"_blank\" rel=\"external\">Computer Orgianization and Design</a>.</p>\n<p><strong>8. 网络</strong><br>    <strong>计算机网络最大的特点是层次化设计,分布式解决.</strong><br>　　TCP/IP四层协议和OSI七层协议,清晰的罗列网络的分级,也正是因为网络的复杂性,所以只有通过层次结构,一层一层的抽象分工,才能有效的解决不同计算机通信的问题.<br>　　考虑一条链路上两个节点的通信,在底层物理的线路上封装比特流有物理层实现,比特流打包为数据帧保证数据不出错由链路层实现,数据包从哪里出发目的地是哪里由网络(iP)层实现,数据包传输的是面向连接还是无连接/是否保证无差错送达/解决网络的拥塞问题由传输层(TCP/UDP)实现,用户的不同的应用如何通信由应用层实现.<br>　　分层明确,各司其职.下层通过访问服务点SAP为上层提供服务,对等层peer之间实现相同的协议,下层的抽象使得对等层似乎在直接通信.通过学习计算机网络,主要明确一个复杂的系统如何通过抽象分层,把大型的复杂的问题化为小问题来分析,然后通过层级架构之间的交互组合成大问题的解决方案,这样的思路在计算机科学是一种普遍的思维方式,例如操作系统位于用户层和硬件层之间,解决硬件的管理和对用户提供舒适的服务又比如算法中递归将问题向下分解为一层层的子问题(递归式),最终化为直接解决的简单问题(递归基base case),向上合并为要求解的问题.抽象和分层在网络中发挥了巨大的威力.<br>　　分布式是指不同的计算机有不同的结构,不同的网络有不同的组织(异构网络),如何有效的利用这些资源?不同的网络直连时如何解决不兼容的问题?这都是分布式的概念.网络之间通过节点(网桥,路由器)和相关算法(如OSPF,BGP)实现异构网络之间的通信和同步,而不是各自为政,无法协调.<br>　　网络这个主题我的实践还很少,努力加强的方向是linux环境下的<a href=\"https://book.douban.com/subject/1756533/\" target=\"_blank\" rel=\"external\">网络编程</a>.</p>\n</blockquote>\n</blockquote>\n<hr>\n<h3 id=\"Q2-周期1内我学习的内容有哪些\"><a href=\"#Q2-周期1内我学习的内容有哪些\" class=\"headerlink\" title=\"Q2:周期1内我学习的内容有哪些?\"></a>Q2:周期1内我学习的内容有哪些?</h3><p>周期1内我主要学习的是:算法与数据结构, 操作系统<br>下面分别详述:</p>\n<blockquote>\n<blockquote>\n<p><strong>1. 算法与数据结构</strong><br>　　算法主题我采用的教材是MIT的<a href=\"https://book.douban.com/subject/3904676/\" target=\"_blank\" rel=\"external\">introduction to algorithms</a>以及配套的<a href=\"https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/index.htm\" target=\"_blank\" rel=\"external\">课程</a>.下面是我的学习笔记:<br>　　算法主题可以分为三个方向:算法的数学理论,算法的设计分析,算法的应用.算法导论主要包括强两个方面的内容, 尤其注重算法的推导和证明.<br>　　算法的定义为将输入转换为输出的计算步骤序列(An algorithm is thus a sequence of computational steps that transform the input into the output.),有确定的输入,和明确实现实现的步骤,以及满足要求的输出.在用编程语言实现算法的过程中,清晰性(无歧义)/可实现/有穷性是算法的基本的要求.<br>　　面对的具体的问题,有不同的算法,对应着不同的性能.我们主要考虑这样几个问题:空间复杂度, 时间复杂度,可扩展性等等.该算法在运行时是否要求额外的内存,需要多少空间?最坏/最好/平均的数据分布情况下,消耗多少时间?在解决特定规模的问题后,是否能扩展到一般的更大规模的问题?算法分析时考量这几个主要特征.<br>　　已排序算法为例,基本的排序算法有插入排序(直接插入,折半插入,希尔排序), 选择排序(选择排序,堆排序),交换排序(冒泡,快排),归并排序,基数排序.排序算法的基本特征是复杂度(空间,时间),稳定性(关键字相同的数据排序前后相对顺序不变).<br>　　从平均时间复杂度讲快排/堆排序/归并排序是O(nlogn),快排在基本有序的情况下退化为O(n^2),归并排序需要额外的O(n)的空间,堆排序在任何情况下都是很优秀的O(nlogn);选择/冒泡/直接插入是O(n^2);基数排序为O(d(n+radix)),可以达到接近线性O(n)的性能,但依赖与基数和位数的多少.<br>　　当数据排序时要求有多个关键字时(关键字A相同的按关键字B排序),要求排序的稳定性,冒泡/选择/插入/归并/基数排序是稳定的,快速/希尔/堆是不稳定的.<br>　　当数据量较大,内存无法一次放下,需要从外存调入数据,归并排序则是最佳的选择.归并将数据分段,然后构造归并树由叶子节点向上归并到根节点,非常符合外部排序的要求.另外,归并排序既可以用递归(递归排序前一半数据,递归排序后一半数据,归并前后两段)实现,极好的体现了问题分解为子问题,逐个击破的递归特点;也可以用迭代实现,将序列分为两个数据一组,从两个开始归并直到合成总的有序序列.与此类似的还有快速排序的分割思想,用key将序列分解为小于key和大于key的序列.<br>　　从归并的递归和迭代实现可以看到,这是两种解决算法问题的思路:递归top-down,将问题分解为相似的子问题,divide and conquer,逐个解决;迭代bottom-up,从基本的最小问题开始,构造出求解的大问题.<br>　　mit课程中第一节课讲到了peek-problem,搜索数据意义上的极大值.从一维序列的角度讲, 序列$ [a_1, a_2, a_3, \\ldots, a_n]$的peek $a_i$满足条件$ a_i &gt; a_{i-1} \\,  and \\, a_i &gt; a_{i+1}$ ．<br>线性算法O(n)遍历序列可以寻找peek,是否有更好的算法呢?运用二分的思想, 如下<br>$$\\begin{align}<br>if \\, a_{n/2} &lt; a_{n/2-1}, peek \\, in \\, [a_1, a_2, \\ldots, a_{n/2-1}]\\\\<br>if \\, a_{n/2} &lt; a_{n/2+1}, peek \\, in \\, [a_{n/2+1}, \\ldots, a_{n-1}, a_n]\\\\<br>else \\, a_{n/2} \\, is \\,peek<br>\\end{align}$$<br>可以得到O(logn)的结果.<br>解决一位的问题后推广到二维(m*n),线性遍历O(mn)仍然是适用的,但二分不能解决问题.是否可以采用优化后的二分思想解决问题?将二维问题看成一个由列向量构成的矩阵,增加一个函数max(),求解列向量的最大值及其位置,然后由最大值作为一列的代表运用二分的思想得到O(mlogn)的算法.<br> 　从解决peek-problem的过程中,我学到的的是如何正确的求解一个算法问题:首先选择规模最小,最简单的问题形式(如一维),是提出最直观的暴力解法{如线性的遍历,O(n^2)的筛选},虽然能解决问题但往往性能是很差;然后寻找优化的方向{如二分的O(logn), 归并的O(nlogn)};接下来向一般的/更复杂的情况(如二维,多变量)推广,考察一维的方法是否仍然适用,如果不适用是什么原因导致的,能否改进调整.我认为<strong>对比解决同一问题的不同算法, 泛化到一般情况</strong>是学好算法的好标准.<br> 　<br><strong>2. 操作系统</strong><br>　　操作系统采用的教材是<a href=\"https://book.douban.com/subject/10076960/\" target=\"_blank\" rel=\"external\">Operating System Concepts</a>,配套实验是<a href=\"https://pdos.csail.mit.edu/6.828/2016/schedule.html\" target=\"_blank\" rel=\"external\">MIT xv6</a>.下面是我的学习笔记:<br>　　操作系统课程我在考研时学习了理论的知识,但学习是有不完整/系统的,因此需要重点弥补理论的部分和动手实践的能力.<br>　　从最初的解决批处理的问题,到分时给不同的用户交互,再到实时系统要求的快速反馈/高稳定性,到现在分布式系统的同步/网络系统的通信.我认为始终有两个核心内容贯穿其间:一是如何实现对计算机资源的管理,尤其是独占资源(CPU的计算,内存的储存,外设);二是如何实现与用户的交互,操作系统归根到底是要为用户服务的,用户的应用如何通过操作系统得到资源.<br>　　操作系统位于中间层,介于计算机资源与用户应用之间,向上提供服务,向下管理资源,是一个大型的系统软件.就上述两个主题来详述:<br>　　一台主机要向多个用户提供分时服务就在同一主机上产了不同的用户程序,或者同一用户有不同的应用需求(如在编辑文档时听音乐/访问网络),因此产生了进程的概念:”一组数据集在程序上的动态运行”.进程要使用CPU/mem等有限的独占资源,在时间上是交错开使用这些资源的,产生了诸多关键问题:<br>　　进程:<br>　　1. 进程之间如何切换?产生了进程调度算法(先来先服务,时间片轮转,优先级,响应比,多级反馈队列);<br>　　2. 进程切换十分消耗资源,是否有更好的方法?共享进程空间,切换代价很小的线程<br>　　3. 不同进程在占用资源时是否有先后顺序,之间是否有前后依赖关系?要求进程的同步和互斥(信号量机制及其解决的经典同步问题,管程,原语的原子性)<br>　　4. 进程使用资源顺序不当时,如何防止产生死锁,产生后死锁如何解决?破坏死所的四个必要条件来预防,银行家算法来避免死锁,化简资源分配图来检测死锁,终止进程来解决死锁.<br>　　内存:<br>　　1. 程序是如何运行的?程序的编译,链接与装载,地址空间的映射,内存保护.<br>　　2. 多组程序和数据存储在内存,如何管理?交换与覆盖技术,静态分页与分段.<br>　　3. 内存不够使用,如何扩展内存?用外存扩展,虚拟内存技术(请求分页,页面置换<br>　　文件:<br>　　1. 站在用户角度,如何更好的使用文件?文件系统接口(FCB,文件的逻辑实现,目录的结构,文件共享和保护)<br>　　2. 站在计算机的角度,如何管理文件?文件系统实现(分配硬盘空间, 管理空闲磁盘快, 目录实现)<br>　　3. 硬件层面如何管理磁盘?磁盘结构,调度,管理磁盘(格式化,引导)<br>　　设备:<br>　　1. 用户如何使用设备,设备如何与CPU/mem实现信息传递?I/O设备管理器与接口,轮询/中断/DMA<br>　　2. 计算机如何实现对设备的管理?I/O子系统(缓冲机制,SPOOLING, 内核管理设备的数据结构)<br>　  除过上面的问题，还有一个核心问题是用户的应用如何使用计算机的资源？通过系统调用(system call)，从用户态切换到内核态，由内核执行系统调用子程序，返回用户想要的结果．<br>　　以上是我对操作系统理论的基本认识，还有待扩展细化，并且和MIT xv6操作系统实验结合起来．MIT实验笔记正在总结，另外写一个update.</p>\n</blockquote>\n</blockquote>\n<p>最后完成日期：2017-04-02</p>\n","site":{"data":{}},"excerpt":"<h1 id=\"CS学习update\"><a href=\"#CS学习update\" class=\"headerlink\" title=\"CS学习update\"></a>CS学习update</h1><h3 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h3><blockquote>\n<p>在被浙江大学计算机学院拟录取之后, 我现阶段的两个任务是:</p>\n<ul>\n<li><ol>\n<li>完成本科土木工程的学业,主要是毕业设计</li>\n</ol>\n</li>\n<li><ol>\n<li>弥补计算机科学的基础知识和素养,并向研究方向靠拢<br>为了能循序渐进的奠定计算机科学的基础,在此记录学习的内容和自己的收获总结.文章更新周期为一周一次, 每周全面的总结一周七天后写成.文章格式为问答式,提出问题并自己解答,以此自检.</li>\n</ol>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"周期1-已学总结与学习计划\"><a href=\"#周期1-已学总结与学习计划\" class=\"headerlink\" title=\"周期1: 已学总结与学习计划\"></a>周期1: 已学总结与学习计划</h3><h4 id=\"时间-2017-03-20-2017-04-01\"><a href=\"#时间-2017-03-20-2017-04-01\" class=\"headerlink\" title=\"时间: 2017/03/20 - 2017/04/01\"></a>时间: 2017/03/20 - 2017/04/01</h4><hr>\n<h4 id=\"Q1-我已学过的计算机科学的专题有哪些\"><a href=\"#Q1-我已学过的计算机科学的专题有哪些\" class=\"headerlink\" title=\"Q1: 我已学过的计算机科学的专题有哪些?\"></a>Q1: 我已学过的计算机科学的专题有哪些?</h4><p>数学和物理: 微积分, 线性代数, 概率论, 大学物理(电路)<br>计算机: C/Python, 算法与数据结构,操作系统,网络,组成原理,</p>\n<p>下面分别概括各科的情况并确定加强的方向:</p>\n<blockquote>\n<blockquote>\n<p><strong>1. 微积分</strong><br>　　<strong>以离散的数列和连续的函数为核心,用极限和微分/积分为基础工具,微积分使我学习到严格的推导过程和缜密的计算流程,同时,有两个基本的解决问题的思路:</strong><br>　　<strong>a. 如何通过离散的角度(数列极限)考察连续的函数.</strong><br>　　例如:考虑函数在一个点(x,y)是否是连续的,这里有三个量:点(x,y)的函数值f(x),左侧无限逼近x的离散的自变量序列{An},和右侧的序列{Bn}.左右两侧对应无穷数列的极限和f(x)相等则证明该点连续.公式如下:<br>$$f(x)=\\lim_{x \\to x-}f(x)=\\lim_{x \\to x+}f(x)$$<br>　　<strong>b. 如何利用连续的概念解决离散的问题.</strong><br>　　例如: 在数列极限难以求解的问题中,采用连续化为函数的方法,适用范围内,数列极限等于函数极限.公式如下:<br>$$\\lim_{n \\to \\infty}a_n=\\lim_{x \\to x_0}f(x)$$<br>　　微积分对概率论中的连续随机变量,以及任何形式的函数关系(数据科学领域)打下坚实的基础.但考虑到计算机本质上是一个离散的系统,虽然微积分中连续的概念可以指导计算机中离散对连续变量的模拟,但我认为离散数学应该更能奠定计算机的数学基础.加强方向:  <strong>离散数学</strong><a href=\"https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-042j-mathematics-for-computer-science-spring-2015/index.htm\" target=\"_blank\" rel=\"external\">课程 MIT </a></p>\n</blockquote>\n</blockquote>","more":"<blockquote>\n<blockquote>\n<p><strong> 2. 线性代数:</strong><br>　　<strong>本科学习的核心概念包括:行列式,矩阵,线性方程组,相似及二次型,向量,线性空间.</strong><br>　　向量和矩阵作为一个离散的概念,十分适合描述一个系统的信息,例如如何定量的描述一个网站的信息?定义一个向量对应网页,向量的每一个元素定义为网页的特征,如关键词,词频,访问量等可定量的特征,如此,所有网页对应的向量构成的矩阵就可以描述该网站,基于矩阵的运算理论则使整个网站参与运算,用于如搜索网站的排名,推荐系统等等.用矩阵来思考内存的组织是很形象生动,加深对内存空间的理解的.<br>　　线性方程组的理论,我认为可以用以理解其他线性代数中的概念,并作为一种基础工具来求解其它问题.矩阵运算有时很难思考对应的实际意义,那么将其看成线性方程组的求解,看矩阵的行向量代表的含义,则能很好的和实际应用联系起来.方程组理论中的有解,有非零解,解空间的理论贯穿在整个线性代数中,例如行列式是否为零,矩阵是否奇异,特征向量都可以通过方程组来解决.<br>　　遗憾的是没有深入学习线性空间,我认为这是线性代数最能推而广之解决一般性问题的方法,用线性系统的观点来建模实际的问题.因此我计划在这方面重点加强<a href=\"https://ocw.mit.edu/courses/mathematics/18-06-linear-algebra-spring-2010/\" target=\"_blank\" rel=\"external\"><strong>课程 MIT Linear Algebra</strong></a></p>\n<p><strong>3. 概率论与数理统计:</strong><br>　　<strong>概率论中的核心概念是:概率与分布(离散型,连续型), 数字特征(均值,方差).</strong><br>　　概率是定量化的可能性,记录事件发生的可能,是对世界的最真实的描述.概率基于对已发生事件的频率, 描述可重复事件的可能,例如科研中的可重复的大量实验,在得到很多实验数据后,如何根据数据调整实验参数.一个很好的例子是贝叶斯公式:<br>$$P(A|B) = \\frac {P(B|A) \\times P(A)}{P(B)}$$<br>基于已知的事件的可能性{P(A)P(B)}和过去的{经验P(B|A)},推断事件{P(B|A)}发生的可能性,这是预测的基本的方式.<br>　　我认为,数理统计将会是与计算机科学以及研究生阶段关联最紧密的主题.例如:课题项目的实验获取的大量数据如何处理?计算均值,方差,做回归分析,建立统计模型,验证模型,反馈调整实验参数…做科研的一个基本能力是数据分析能力,也离不开对数理统计的扎实掌握.我计划在这个主题加强<a href=\"https://ocw.mit.edu/courses/mathematics/18-05-introduction-to-probability-and-statistics-spring-2014/\" target=\"_blank\" rel=\"external\"><strong>课程 MIT</strong></a></p>\n<p><strong>4. 物理</strong><br>　　大学物理课与计算机科学相关的主要是电路,加上自学{<a href=\"https://book.douban.com/subject/1494026/\" target=\"_blank\" rel=\"external\">CODE</a>},对逻辑电路有了基本的理解.二进制与开关的闭合对应的关系,正是Shannon在<a href=\"https://en.wikipedia.org/wiki/A_Symbolic_Analysis_of_Relay_and_Switching_Circuits\" target=\"_blank\" rel=\"external\">他的论文</a>确定的计算机用电路实现的基础.与门,非们,或们,触发器实现的时序电路构成内存,寄存器+加法器+控制逻辑构成基本的ALU,组合逻辑电路构成完整的CPU.<br>　　另外,物理课与实验密切结合,如何实验验证假设,如何控制变量,处理数据,得到结论,物理课训练我用一个正确的实验过程是怎样的实现的.</p>\n<p><strong>5. C</strong><br>　　<strong>C的核心概念:强类型, 数组与指针, 函数与递归,预处理和宏</strong>.<br>　　即使加上C标准库,C仍然是一门简洁清晰的编程语言:C结构清晰,以main()函数为入口,调用其他函数,声明和定义时要求类型定义;面向过程编程,抽象机制明确,过程抽象的语法是函数func(),数据抽象的语法是结构体struct;有指针pointer这个强力工具,连接计算机的底层,实现地址的操纵(&amp;和*操作符)和内存的管理(malloc()等函数);项目组织有.h头文件和.c源文件,make控制编译.<br>　　有内存管理和地址操纵这些底层功能,加上编译优化后高效的运行性能,使得C成为操作系统kernel,编译器complier,数据库database等的核心语言,尤其长于系统和硬件编程,我计划在学习这几个主题实现对应project的过程中,努力进阶C的编程能力.<br>　　C中指针是个强大的概念，从最简单的交换两个变量值swap(),到函数指针func,内存管理的返回值类型void*,指针发挥了传递对象首地址而不是拷贝对象的作用.另外,基于指针的线性表-链表,具有了数组没有的易动态变化(增删)的优点,也使得树和图结构的实现更容易.<br>　　但相比与其他高级语言如Java/Python,C不支持面向对象的特性,难以直接进行面向对象的程序设计.除去标准库/GNU-lib,同时没有相对丰富的库支持,不适合high-level(如GUI)的编程.但是,有了gcc,make等toolchain的支持,C仍然适合大型/要求性能/系统底层的开发工作,这也是我C加强的方向.<br>　　<br><strong>6. 算法与数据结构, 操作系统</strong>最近正在学习,见下面的问题.</p>\n<p><strong>7. 组成原理</strong><br>　　相比较与计算机体系机构注重在不同硬件平台上的具体实现，即一台RISC计算机内部结构是怎样的,指令系统是如何实现的,组成原理重点关注一般的计算机内部具有哪些通用的基本的结构,整个计算机的结构是如何联系起来共同工作的,而不在意具体的实现形式.<br>　　<strong>计算机基本的冯诺依曼架构, CPU(运算器ALU, 控制器CU), 内存Mem, 输入输出I/O,以及串联所有构件的总线BUS.</strong>在CPU内部,运算由基本的加法器实现,通过控制部件用加法器实现减法,乘法和除法;数据由二进制表示,可以编码为原码/补码/反码/移码,浮点数由IEEE745标准规定;CU控制指令的执行过程,PC确定下一条指令的地址,一个完整的指令周期包括取指/译码/执行,以及取指/取数过程中的间指,以及处理外部产生的中断;一个指令的基本结构是{指令地址;操作码;操作数},由硬布线组合逻辑或微程序设计实现.<br>　　存储的架构 CPU内部register - 缓存cache - 主存memory - 外存(硬盘,闪存),有ROM, RAM, FLASH等具体实现方式.<br>　　输入输出I/O的结构: CPU or mem - I/O接口 - I/O设备.CPU通过程序查询(轮询)或中断和设备进行信息传递, mem可采用DMA方式直接与高速外设交换数据.<br>　　总线可采用单/双/多总线结构,有基本的数据/地址/控制/控制等总线分类,主要解决的问题是总线仲裁和判优,针对不同的结构连接采用不同的总线标准,如ISA/PCI/USB.<br>　　组成原理站在硬件角度考察计算机的结构性,注重计算机构件及其连接的原理,从整体的角度思考为什么硬件要这样组合,出现的问题如何解决?例如要使加法器实现加减乘除四种运算,首先要用补码编码,这样很容易就解决了加减统一的问题,乘除时符号位在运算中得出,基本的实现是循环(Booth算法);又比如如何提高指令执行的效率这一问题,除过对指令进行优化, 最佳的解决方案就是提高指令执行的并行性,流水线将指令划分为多个阶段,不同指令不同的周期并行,最大限度的提高部件的使用率,另外采用多核结构,直接实现程序的并行执行,提高计算机的吞吐率.<br>　　对组成原理主题的加强,我认为可以通过实现软件与硬件的接口<a href=\"https://book.douban.com/subject/1468468/\" target=\"_blank\" rel=\"external\">Computer Orgianization and Design</a>.</p>\n<p><strong>8. 网络</strong><br>    <strong>计算机网络最大的特点是层次化设计,分布式解决.</strong><br>　　TCP/IP四层协议和OSI七层协议,清晰的罗列网络的分级,也正是因为网络的复杂性,所以只有通过层次结构,一层一层的抽象分工,才能有效的解决不同计算机通信的问题.<br>　　考虑一条链路上两个节点的通信,在底层物理的线路上封装比特流有物理层实现,比特流打包为数据帧保证数据不出错由链路层实现,数据包从哪里出发目的地是哪里由网络(iP)层实现,数据包传输的是面向连接还是无连接/是否保证无差错送达/解决网络的拥塞问题由传输层(TCP/UDP)实现,用户的不同的应用如何通信由应用层实现.<br>　　分层明确,各司其职.下层通过访问服务点SAP为上层提供服务,对等层peer之间实现相同的协议,下层的抽象使得对等层似乎在直接通信.通过学习计算机网络,主要明确一个复杂的系统如何通过抽象分层,把大型的复杂的问题化为小问题来分析,然后通过层级架构之间的交互组合成大问题的解决方案,这样的思路在计算机科学是一种普遍的思维方式,例如操作系统位于用户层和硬件层之间,解决硬件的管理和对用户提供舒适的服务又比如算法中递归将问题向下分解为一层层的子问题(递归式),最终化为直接解决的简单问题(递归基base case),向上合并为要求解的问题.抽象和分层在网络中发挥了巨大的威力.<br>　　分布式是指不同的计算机有不同的结构,不同的网络有不同的组织(异构网络),如何有效的利用这些资源?不同的网络直连时如何解决不兼容的问题?这都是分布式的概念.网络之间通过节点(网桥,路由器)和相关算法(如OSPF,BGP)实现异构网络之间的通信和同步,而不是各自为政,无法协调.<br>　　网络这个主题我的实践还很少,努力加强的方向是linux环境下的<a href=\"https://book.douban.com/subject/1756533/\" target=\"_blank\" rel=\"external\">网络编程</a>.</p>\n</blockquote>\n</blockquote>\n<hr>\n<h3 id=\"Q2-周期1内我学习的内容有哪些\"><a href=\"#Q2-周期1内我学习的内容有哪些\" class=\"headerlink\" title=\"Q2:周期1内我学习的内容有哪些?\"></a>Q2:周期1内我学习的内容有哪些?</h3><p>周期1内我主要学习的是:算法与数据结构, 操作系统<br>下面分别详述:</p>\n<blockquote>\n<blockquote>\n<p><strong>1. 算法与数据结构</strong><br>　　算法主题我采用的教材是MIT的<a href=\"https://book.douban.com/subject/3904676/\" target=\"_blank\" rel=\"external\">introduction to algorithms</a>以及配套的<a href=\"https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-006-introduction-to-algorithms-fall-2011/index.htm\" target=\"_blank\" rel=\"external\">课程</a>.下面是我的学习笔记:<br>　　算法主题可以分为三个方向:算法的数学理论,算法的设计分析,算法的应用.算法导论主要包括强两个方面的内容, 尤其注重算法的推导和证明.<br>　　算法的定义为将输入转换为输出的计算步骤序列(An algorithm is thus a sequence of computational steps that transform the input into the output.),有确定的输入,和明确实现实现的步骤,以及满足要求的输出.在用编程语言实现算法的过程中,清晰性(无歧义)/可实现/有穷性是算法的基本的要求.<br>　　面对的具体的问题,有不同的算法,对应着不同的性能.我们主要考虑这样几个问题:空间复杂度, 时间复杂度,可扩展性等等.该算法在运行时是否要求额外的内存,需要多少空间?最坏/最好/平均的数据分布情况下,消耗多少时间?在解决特定规模的问题后,是否能扩展到一般的更大规模的问题?算法分析时考量这几个主要特征.<br>　　已排序算法为例,基本的排序算法有插入排序(直接插入,折半插入,希尔排序), 选择排序(选择排序,堆排序),交换排序(冒泡,快排),归并排序,基数排序.排序算法的基本特征是复杂度(空间,时间),稳定性(关键字相同的数据排序前后相对顺序不变).<br>　　从平均时间复杂度讲快排/堆排序/归并排序是O(nlogn),快排在基本有序的情况下退化为O(n^2),归并排序需要额外的O(n)的空间,堆排序在任何情况下都是很优秀的O(nlogn);选择/冒泡/直接插入是O(n^2);基数排序为O(d(n+radix)),可以达到接近线性O(n)的性能,但依赖与基数和位数的多少.<br>　　当数据排序时要求有多个关键字时(关键字A相同的按关键字B排序),要求排序的稳定性,冒泡/选择/插入/归并/基数排序是稳定的,快速/希尔/堆是不稳定的.<br>　　当数据量较大,内存无法一次放下,需要从外存调入数据,归并排序则是最佳的选择.归并将数据分段,然后构造归并树由叶子节点向上归并到根节点,非常符合外部排序的要求.另外,归并排序既可以用递归(递归排序前一半数据,递归排序后一半数据,归并前后两段)实现,极好的体现了问题分解为子问题,逐个击破的递归特点;也可以用迭代实现,将序列分为两个数据一组,从两个开始归并直到合成总的有序序列.与此类似的还有快速排序的分割思想,用key将序列分解为小于key和大于key的序列.<br>　　从归并的递归和迭代实现可以看到,这是两种解决算法问题的思路:递归top-down,将问题分解为相似的子问题,divide and conquer,逐个解决;迭代bottom-up,从基本的最小问题开始,构造出求解的大问题.<br>　　mit课程中第一节课讲到了peek-problem,搜索数据意义上的极大值.从一维序列的角度讲, 序列$ [a_1, a_2, a_3, \\ldots, a_n]$的peek $a_i$满足条件$ a_i &gt; a_{i-1} \\,  and \\, a_i &gt; a_{i+1}$ ．<br>线性算法O(n)遍历序列可以寻找peek,是否有更好的算法呢?运用二分的思想, 如下<br>$$\\begin{align}<br>if \\, a_{n/2} &lt; a_{n/2-1}, peek \\, in \\, [a_1, a_2, \\ldots, a_{n/2-1}]\\\\<br>if \\, a_{n/2} &lt; a_{n/2+1}, peek \\, in \\, [a_{n/2+1}, \\ldots, a_{n-1}, a_n]\\\\<br>else \\, a_{n/2} \\, is \\,peek<br>\\end{align}$$<br>可以得到O(logn)的结果.<br>解决一位的问题后推广到二维(m*n),线性遍历O(mn)仍然是适用的,但二分不能解决问题.是否可以采用优化后的二分思想解决问题?将二维问题看成一个由列向量构成的矩阵,增加一个函数max(),求解列向量的最大值及其位置,然后由最大值作为一列的代表运用二分的思想得到O(mlogn)的算法.<br> 　从解决peek-problem的过程中,我学到的的是如何正确的求解一个算法问题:首先选择规模最小,最简单的问题形式(如一维),是提出最直观的暴力解法{如线性的遍历,O(n^2)的筛选},虽然能解决问题但往往性能是很差;然后寻找优化的方向{如二分的O(logn), 归并的O(nlogn)};接下来向一般的/更复杂的情况(如二维,多变量)推广,考察一维的方法是否仍然适用,如果不适用是什么原因导致的,能否改进调整.我认为<strong>对比解决同一问题的不同算法, 泛化到一般情况</strong>是学好算法的好标准.<br> 　<br><strong>2. 操作系统</strong><br>　　操作系统采用的教材是<a href=\"https://book.douban.com/subject/10076960/\" target=\"_blank\" rel=\"external\">Operating System Concepts</a>,配套实验是<a href=\"https://pdos.csail.mit.edu/6.828/2016/schedule.html\" target=\"_blank\" rel=\"external\">MIT xv6</a>.下面是我的学习笔记:<br>　　操作系统课程我在考研时学习了理论的知识,但学习是有不完整/系统的,因此需要重点弥补理论的部分和动手实践的能力.<br>　　从最初的解决批处理的问题,到分时给不同的用户交互,再到实时系统要求的快速反馈/高稳定性,到现在分布式系统的同步/网络系统的通信.我认为始终有两个核心内容贯穿其间:一是如何实现对计算机资源的管理,尤其是独占资源(CPU的计算,内存的储存,外设);二是如何实现与用户的交互,操作系统归根到底是要为用户服务的,用户的应用如何通过操作系统得到资源.<br>　　操作系统位于中间层,介于计算机资源与用户应用之间,向上提供服务,向下管理资源,是一个大型的系统软件.就上述两个主题来详述:<br>　　一台主机要向多个用户提供分时服务就在同一主机上产了不同的用户程序,或者同一用户有不同的应用需求(如在编辑文档时听音乐/访问网络),因此产生了进程的概念:”一组数据集在程序上的动态运行”.进程要使用CPU/mem等有限的独占资源,在时间上是交错开使用这些资源的,产生了诸多关键问题:<br>　　进程:<br>　　1. 进程之间如何切换?产生了进程调度算法(先来先服务,时间片轮转,优先级,响应比,多级反馈队列);<br>　　2. 进程切换十分消耗资源,是否有更好的方法?共享进程空间,切换代价很小的线程<br>　　3. 不同进程在占用资源时是否有先后顺序,之间是否有前后依赖关系?要求进程的同步和互斥(信号量机制及其解决的经典同步问题,管程,原语的原子性)<br>　　4. 进程使用资源顺序不当时,如何防止产生死锁,产生后死锁如何解决?破坏死所的四个必要条件来预防,银行家算法来避免死锁,化简资源分配图来检测死锁,终止进程来解决死锁.<br>　　内存:<br>　　1. 程序是如何运行的?程序的编译,链接与装载,地址空间的映射,内存保护.<br>　　2. 多组程序和数据存储在内存,如何管理?交换与覆盖技术,静态分页与分段.<br>　　3. 内存不够使用,如何扩展内存?用外存扩展,虚拟内存技术(请求分页,页面置换<br>　　文件:<br>　　1. 站在用户角度,如何更好的使用文件?文件系统接口(FCB,文件的逻辑实现,目录的结构,文件共享和保护)<br>　　2. 站在计算机的角度,如何管理文件?文件系统实现(分配硬盘空间, 管理空闲磁盘快, 目录实现)<br>　　3. 硬件层面如何管理磁盘?磁盘结构,调度,管理磁盘(格式化,引导)<br>　　设备:<br>　　1. 用户如何使用设备,设备如何与CPU/mem实现信息传递?I/O设备管理器与接口,轮询/中断/DMA<br>　　2. 计算机如何实现对设备的管理?I/O子系统(缓冲机制,SPOOLING, 内核管理设备的数据结构)<br>　  除过上面的问题，还有一个核心问题是用户的应用如何使用计算机的资源？通过系统调用(system call)，从用户态切换到内核态，由内核执行系统调用子程序，返回用户想要的结果．<br>　　以上是我对操作系统理论的基本认识，还有待扩展细化，并且和MIT xv6操作系统实验结合起来．MIT实验笔记正在总结，另外写一个update.</p>\n</blockquote>\n</blockquote>\n<p>最后完成日期：2017-04-02</p>"},{"title":"hw3-system-calls","date":"2017-04-18T16:00:00.000Z","_content":"# hw3 xv6 system calls\n## 目标\n在[hw1 boot pc]的基础上,学习xv6的系统调用:\n> * 运用xv6的系统调用\n> * 修改xv6 kernel, 添加新系统调用\n\n## Part1: 系统调用追踪\n\n### 任务\n> 修改`systemcall.c`,在进行系统调用时,打印出系统调用的名字和返回值.实现后,在xv6启动时是打印如下内容:\n``` bash\n...\nfork -> 2\nexec -> 0\nopen -> 3\nclose -> 0\n$write -> 1\n write -> 1\n```\n<!-- more -->\n\n### 实现\n> 系统调用的储存形式是: 在`syscall[]`数组中指向系统调用函数的指针.因此修改`syscall()`函数, 使其获取函数指针的索引, 而从索引到系统调用的映射在` syscall.h`头文件中.添加`syscall_name`字符串数组, 映射系统调用索引到其名称上, 然后在`syscall()`函数内添加`cprintf`输出:\n``` c\nstatic char syscalls_name[][8] = {\n[SYS_fork]    \"fork\",\n[SYS_exit]    \"exit\",\n[SYS_wait]    \"wait\",\n[SYS_pipe]    \"pipe\",\n[SYS_read]    \"read\",\n[SYS_kill]    \"kill\",\n[SYS_exec]    \"exec\",\n[SYS_fstat]   \"fstat\",\n[SYS_chdir]   \"chdir\",\n[SYS_dup]     \"dup\",\n[SYS_getpid]  \"getpid\",\n[SYS_sbrk]    \"sbrk\",\n[SYS_sleep]   \"sleep\",\n[SYS_uptime]  \"uptime\",\n[SYS_open]    \"open\",\n[SYS_write]   \"write\",\n[SYS_mknod]   \"mknod\",\n[SYS_unlink]  \"unlink\",\n[SYS_link]    \"link\",\n[SYS_mkdir]   \"mkdir\",\n[SYS_close]   \"close\",\n[SYS_date]    \"date\",\n};\n\nvoid\nsyscall(void)\n{\n  int num;\n\n  num = proc->tf->eax;  //获取系统调用号\n  if(num > 0 && num < NELEM(syscalls) && syscalls[num])\n\t{\n    proc->tf->eax = syscalls[num]();  //存储系统调用返回值\n    cprintf(\"%s -> %d\\n\", syscalls_name[num], proc->tf->eax);\n  } else {\n    cprintf(\"%d %s: unknown sys call %d\\n\",\n            proc->pid, proc->name, num);\n    proc->tf->eax = -1;\n  }\n}\n```\n\n## Part2 日期系统调用\n\n### 任务\n> 添加一个新的系统调用`date`,其获取当前的UTC时间并将其返回给用户程序.完成后,在xv6 shell提示符下输入`date`可打印当前的UTC时间.\n\n### 实现\n> 使用帮助函数`cmostime()`(定义在`lapic.c`)来读取实时时钟,然后根据`date.h`中定义的struct rtcdate结构体,作为一指针参数传递给`cmostime()`.\n查看`uptime`系统调用的实现如下\n``` c\ngrep -n uptime *.[chS]\n#output\nsyscall.c: extern int sys_uptime(void);\nsyscall.c:[SYS_uptime] sys_uptime,\nsyscall.c:[SYS_uptime] \"uptime\",\nsyscall.h:#define SYS_uptime 14\nsysproc.c:sys_uptime(void)\nuser.h:int uptime(void);\nusys.S:SYSCALL(uptime)\n```\n> 归纳出添加系统调用的一般步骤:\n* 在`syscall.h`中添加系统调用号\n* 在`user.h`中添加用户态函数的定义\n* 在`usys.S`中添加用户态函数的实现\n* 在`syscall.c`中添加系统调用函数的外部声明\n* 在`sysproc.c`中添加系统调用函数的实现\n\n> 'date'系统调用函数具体实现代码：\n``` c\nint\nsys_date(void)\n{\n  struct rtcdate *r;\n\n  if (argptr(0, (void *)&r, sizeof(*r)) < 0)\n          return -1;\n  cmostime(r);\n  return 0;\n}\n```\n","source":"_posts/hw3.md","raw":"title: hw3-system-calls\ndate: 2017/04/19\ntags:\n\t- os\n\t- xv6\n\n---\n# hw3 xv6 system calls\n## 目标\n在[hw1 boot pc]的基础上,学习xv6的系统调用:\n> * 运用xv6的系统调用\n> * 修改xv6 kernel, 添加新系统调用\n\n## Part1: 系统调用追踪\n\n### 任务\n> 修改`systemcall.c`,在进行系统调用时,打印出系统调用的名字和返回值.实现后,在xv6启动时是打印如下内容:\n``` bash\n...\nfork -> 2\nexec -> 0\nopen -> 3\nclose -> 0\n$write -> 1\n write -> 1\n```\n<!-- more -->\n\n### 实现\n> 系统调用的储存形式是: 在`syscall[]`数组中指向系统调用函数的指针.因此修改`syscall()`函数, 使其获取函数指针的索引, 而从索引到系统调用的映射在` syscall.h`头文件中.添加`syscall_name`字符串数组, 映射系统调用索引到其名称上, 然后在`syscall()`函数内添加`cprintf`输出:\n``` c\nstatic char syscalls_name[][8] = {\n[SYS_fork]    \"fork\",\n[SYS_exit]    \"exit\",\n[SYS_wait]    \"wait\",\n[SYS_pipe]    \"pipe\",\n[SYS_read]    \"read\",\n[SYS_kill]    \"kill\",\n[SYS_exec]    \"exec\",\n[SYS_fstat]   \"fstat\",\n[SYS_chdir]   \"chdir\",\n[SYS_dup]     \"dup\",\n[SYS_getpid]  \"getpid\",\n[SYS_sbrk]    \"sbrk\",\n[SYS_sleep]   \"sleep\",\n[SYS_uptime]  \"uptime\",\n[SYS_open]    \"open\",\n[SYS_write]   \"write\",\n[SYS_mknod]   \"mknod\",\n[SYS_unlink]  \"unlink\",\n[SYS_link]    \"link\",\n[SYS_mkdir]   \"mkdir\",\n[SYS_close]   \"close\",\n[SYS_date]    \"date\",\n};\n\nvoid\nsyscall(void)\n{\n  int num;\n\n  num = proc->tf->eax;  //获取系统调用号\n  if(num > 0 && num < NELEM(syscalls) && syscalls[num])\n\t{\n    proc->tf->eax = syscalls[num]();  //存储系统调用返回值\n    cprintf(\"%s -> %d\\n\", syscalls_name[num], proc->tf->eax);\n  } else {\n    cprintf(\"%d %s: unknown sys call %d\\n\",\n            proc->pid, proc->name, num);\n    proc->tf->eax = -1;\n  }\n}\n```\n\n## Part2 日期系统调用\n\n### 任务\n> 添加一个新的系统调用`date`,其获取当前的UTC时间并将其返回给用户程序.完成后,在xv6 shell提示符下输入`date`可打印当前的UTC时间.\n\n### 实现\n> 使用帮助函数`cmostime()`(定义在`lapic.c`)来读取实时时钟,然后根据`date.h`中定义的struct rtcdate结构体,作为一指针参数传递给`cmostime()`.\n查看`uptime`系统调用的实现如下\n``` c\ngrep -n uptime *.[chS]\n#output\nsyscall.c: extern int sys_uptime(void);\nsyscall.c:[SYS_uptime] sys_uptime,\nsyscall.c:[SYS_uptime] \"uptime\",\nsyscall.h:#define SYS_uptime 14\nsysproc.c:sys_uptime(void)\nuser.h:int uptime(void);\nusys.S:SYSCALL(uptime)\n```\n> 归纳出添加系统调用的一般步骤:\n* 在`syscall.h`中添加系统调用号\n* 在`user.h`中添加用户态函数的定义\n* 在`usys.S`中添加用户态函数的实现\n* 在`syscall.c`中添加系统调用函数的外部声明\n* 在`sysproc.c`中添加系统调用函数的实现\n\n> 'date'系统调用函数具体实现代码：\n``` c\nint\nsys_date(void)\n{\n  struct rtcdate *r;\n\n  if (argptr(0, (void *)&r, sizeof(*r)) < 0)\n          return -1;\n  cmostime(r);\n  return 0;\n}\n```\n","slug":"hw3","published":1,"updated":"2017-08-26T03:38:21.618Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6sslhb2000o3gam42svhnu1","content":"<h1 id=\"hw3-xv6-system-calls\"><a href=\"#hw3-xv6-system-calls\" class=\"headerlink\" title=\"hw3 xv6 system calls\"></a>hw3 xv6 system calls</h1><h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><p>在[hw1 boot pc]的基础上,学习xv6的系统调用:</p>\n<blockquote>\n<ul>\n<li>运用xv6的系统调用</li>\n<li>修改xv6 kernel, 添加新系统调用</li>\n</ul>\n</blockquote>\n<h2 id=\"Part1-系统调用追踪\"><a href=\"#Part1-系统调用追踪\" class=\"headerlink\" title=\"Part1: 系统调用追踪\"></a>Part1: 系统调用追踪</h2><h3 id=\"任务\"><a href=\"#任务\" class=\"headerlink\" title=\"任务\"></a>任务</h3><blockquote>\n<p>修改<code>systemcall.c</code>,在进行系统调用时,打印出系统调用的名字和返回值.实现后,在xv6启动时是打印如下内容:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\">fork -&gt; 2</div><div class=\"line\"><span class=\"built_in\">exec</span> -&gt; 0</div><div class=\"line\">open -&gt; 3</div><div class=\"line\">close -&gt; 0</div><div class=\"line\"><span class=\"variable\">$write</span> -&gt; 1</div><div class=\"line\"> write -&gt; 1</div></pre></td></tr></table></figure></p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><blockquote>\n<p>系统调用的储存形式是: 在<code>syscall[]</code>数组中指向系统调用函数的指针.因此修改<code>syscall()</code>函数, 使其获取函数指针的索引, 而从索引到系统调用的映射在<code>syscall.h</code>头文件中.添加<code>syscall_name</code>字符串数组, 映射系统调用索引到其名称上, 然后在<code>syscall()</code>函数内添加<code>cprintf</code>输出:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">char</span> syscalls_name[][<span class=\"number\">8</span>] = &#123;</div><div class=\"line\">[SYS_fork]    <span class=\"string\">\"fork\"</span>,</div><div class=\"line\">[SYS_exit]    <span class=\"string\">\"exit\"</span>,</div><div class=\"line\">[SYS_wait]    <span class=\"string\">\"wait\"</span>,</div><div class=\"line\">[SYS_pipe]    <span class=\"string\">\"pipe\"</span>,</div><div class=\"line\">[SYS_read]    <span class=\"string\">\"read\"</span>,</div><div class=\"line\">[SYS_kill]    <span class=\"string\">\"kill\"</span>,</div><div class=\"line\">[SYS_exec]    <span class=\"string\">\"exec\"</span>,</div><div class=\"line\">[SYS_fstat]   <span class=\"string\">\"fstat\"</span>,</div><div class=\"line\">[SYS_chdir]   <span class=\"string\">\"chdir\"</span>,</div><div class=\"line\">[SYS_dup]     <span class=\"string\">\"dup\"</span>,</div><div class=\"line\">[SYS_getpid]  <span class=\"string\">\"getpid\"</span>,</div><div class=\"line\">[SYS_sbrk]    <span class=\"string\">\"sbrk\"</span>,</div><div class=\"line\">[SYS_sleep]   <span class=\"string\">\"sleep\"</span>,</div><div class=\"line\">[SYS_uptime]  <span class=\"string\">\"uptime\"</span>,</div><div class=\"line\">[SYS_open]    <span class=\"string\">\"open\"</span>,</div><div class=\"line\">[SYS_write]   <span class=\"string\">\"write\"</span>,</div><div class=\"line\">[SYS_mknod]   <span class=\"string\">\"mknod\"</span>,</div><div class=\"line\">[SYS_unlink]  <span class=\"string\">\"unlink\"</span>,</div><div class=\"line\">[SYS_link]    <span class=\"string\">\"link\"</span>,</div><div class=\"line\">[SYS_mkdir]   <span class=\"string\">\"mkdir\"</span>,</div><div class=\"line\">[SYS_close]   <span class=\"string\">\"close\"</span>,</div><div class=\"line\">[SYS_date]    <span class=\"string\">\"date\"</span>,</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">syscall</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">int</span> num;</div><div class=\"line\"></div><div class=\"line\">  num = proc-&gt;tf-&gt;eax;  <span class=\"comment\">//获取系统调用号</span></div><div class=\"line\">  <span class=\"keyword\">if</span>(num &gt; <span class=\"number\">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num])</div><div class=\"line\">\t&#123;</div><div class=\"line\">    proc-&gt;tf-&gt;eax = syscalls[num]();  <span class=\"comment\">//存储系统调用返回值</span></div><div class=\"line\">    cprintf(<span class=\"string\">\"%s -&gt; %d\\n\"</span>, syscalls_name[num], proc-&gt;tf-&gt;eax);</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    cprintf(<span class=\"string\">\"%d %s: unknown sys call %d\\n\"</span>,</div><div class=\"line\">            proc-&gt;pid, proc-&gt;name, num);</div><div class=\"line\">    proc-&gt;tf-&gt;eax = <span class=\"number\">-1</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h2 id=\"Part2-日期系统调用\"><a href=\"#Part2-日期系统调用\" class=\"headerlink\" title=\"Part2 日期系统调用\"></a>Part2 日期系统调用</h2><h3 id=\"任务-1\"><a href=\"#任务-1\" class=\"headerlink\" title=\"任务\"></a>任务</h3><blockquote>\n<p>添加一个新的系统调用<code>date</code>,其获取当前的UTC时间并将其返回给用户程序.完成后,在xv6 shell提示符下输入<code>date</code>可打印当前的UTC时间.</p>\n</blockquote>\n<h3 id=\"实现-1\"><a href=\"#实现-1\" class=\"headerlink\" title=\"实现\"></a>实现</h3><blockquote>\n<p>使用帮助函数<code>cmostime()</code>(定义在<code>lapic.c</code>)来读取实时时钟,然后根据<code>date.h</code>中定义的struct rtcdate结构体,作为一指针参数传递给<code>cmostime()</code>.<br>查看<code>uptime</code>系统调用的实现如下<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">grep -n uptime *.[chS]</div><div class=\"line\"><span class=\"meta\">#output</span></div><div class=\"line\">syscall.c: <span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> <span class=\"title\">sys_uptime</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</div><div class=\"line\">syscall.c:[SYS_uptime] sys_uptime,</div><div class=\"line\">syscall.c:[SYS_uptime] <span class=\"string\">\"uptime\"</span>,</div><div class=\"line\">syscall.h:<span class=\"meta\">#<span class=\"meta-keyword\">define</span> SYS_uptime 14</span></div><div class=\"line\">sysproc.c:sys_uptime(<span class=\"keyword\">void</span>)</div><div class=\"line\">user.h:<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">uptime</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</div><div class=\"line\">usys.S:SYSCALL(uptime)</div></pre></td></tr></table></figure></p>\n<p>归纳出添加系统调用的一般步骤:</p>\n<ul>\n<li>在<code>syscall.h</code>中添加系统调用号</li>\n<li>在<code>user.h</code>中添加用户态函数的定义</li>\n<li>在<code>usys.S</code>中添加用户态函数的实现</li>\n<li>在<code>syscall.c</code>中添加系统调用函数的外部声明</li>\n<li>在<code>sysproc.c</code>中添加系统调用函数的实现</li>\n</ul>\n<p>‘date’系统调用函数具体实现代码：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span></span></div><div class=\"line\"><span class=\"title\">sys_date</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">struct</span> rtcdate *r;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (argptr(<span class=\"number\">0</span>, (<span class=\"keyword\">void</span> *)&amp;r, <span class=\"keyword\">sizeof</span>(*r)) &lt; <span class=\"number\">0</span>)</div><div class=\"line\">          <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">  cmostime(r);</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"hw3-xv6-system-calls\"><a href=\"#hw3-xv6-system-calls\" class=\"headerlink\" title=\"hw3 xv6 system calls\"></a>hw3 xv6 system calls</h1><h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><p>在[hw1 boot pc]的基础上,学习xv6的系统调用:</p>\n<blockquote>\n<ul>\n<li>运用xv6的系统调用</li>\n<li>修改xv6 kernel, 添加新系统调用</li>\n</ul>\n</blockquote>\n<h2 id=\"Part1-系统调用追踪\"><a href=\"#Part1-系统调用追踪\" class=\"headerlink\" title=\"Part1: 系统调用追踪\"></a>Part1: 系统调用追踪</h2><h3 id=\"任务\"><a href=\"#任务\" class=\"headerlink\" title=\"任务\"></a>任务</h3><blockquote>\n<p>修改<code>systemcall.c</code>,在进行系统调用时,打印出系统调用的名字和返回值.实现后,在xv6启动时是打印如下内容:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\">fork -&gt; 2</div><div class=\"line\"><span class=\"built_in\">exec</span> -&gt; 0</div><div class=\"line\">open -&gt; 3</div><div class=\"line\">close -&gt; 0</div><div class=\"line\"><span class=\"variable\">$write</span> -&gt; 1</div><div class=\"line\"> write -&gt; 1</div></pre></td></tr></table></figure></p>\n</blockquote>","more":"<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><blockquote>\n<p>系统调用的储存形式是: 在<code>syscall[]</code>数组中指向系统调用函数的指针.因此修改<code>syscall()</code>函数, 使其获取函数指针的索引, 而从索引到系统调用的映射在<code>syscall.h</code>头文件中.添加<code>syscall_name</code>字符串数组, 映射系统调用索引到其名称上, 然后在<code>syscall()</code>函数内添加<code>cprintf</code>输出:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">char</span> syscalls_name[][<span class=\"number\">8</span>] = &#123;</div><div class=\"line\">[SYS_fork]    <span class=\"string\">\"fork\"</span>,</div><div class=\"line\">[SYS_exit]    <span class=\"string\">\"exit\"</span>,</div><div class=\"line\">[SYS_wait]    <span class=\"string\">\"wait\"</span>,</div><div class=\"line\">[SYS_pipe]    <span class=\"string\">\"pipe\"</span>,</div><div class=\"line\">[SYS_read]    <span class=\"string\">\"read\"</span>,</div><div class=\"line\">[SYS_kill]    <span class=\"string\">\"kill\"</span>,</div><div class=\"line\">[SYS_exec]    <span class=\"string\">\"exec\"</span>,</div><div class=\"line\">[SYS_fstat]   <span class=\"string\">\"fstat\"</span>,</div><div class=\"line\">[SYS_chdir]   <span class=\"string\">\"chdir\"</span>,</div><div class=\"line\">[SYS_dup]     <span class=\"string\">\"dup\"</span>,</div><div class=\"line\">[SYS_getpid]  <span class=\"string\">\"getpid\"</span>,</div><div class=\"line\">[SYS_sbrk]    <span class=\"string\">\"sbrk\"</span>,</div><div class=\"line\">[SYS_sleep]   <span class=\"string\">\"sleep\"</span>,</div><div class=\"line\">[SYS_uptime]  <span class=\"string\">\"uptime\"</span>,</div><div class=\"line\">[SYS_open]    <span class=\"string\">\"open\"</span>,</div><div class=\"line\">[SYS_write]   <span class=\"string\">\"write\"</span>,</div><div class=\"line\">[SYS_mknod]   <span class=\"string\">\"mknod\"</span>,</div><div class=\"line\">[SYS_unlink]  <span class=\"string\">\"unlink\"</span>,</div><div class=\"line\">[SYS_link]    <span class=\"string\">\"link\"</span>,</div><div class=\"line\">[SYS_mkdir]   <span class=\"string\">\"mkdir\"</span>,</div><div class=\"line\">[SYS_close]   <span class=\"string\">\"close\"</span>,</div><div class=\"line\">[SYS_date]    <span class=\"string\">\"date\"</span>,</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">syscall</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">int</span> num;</div><div class=\"line\"></div><div class=\"line\">  num = proc-&gt;tf-&gt;eax;  <span class=\"comment\">//获取系统调用号</span></div><div class=\"line\">  <span class=\"keyword\">if</span>(num &gt; <span class=\"number\">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num])</div><div class=\"line\">\t&#123;</div><div class=\"line\">    proc-&gt;tf-&gt;eax = syscalls[num]();  <span class=\"comment\">//存储系统调用返回值</span></div><div class=\"line\">    cprintf(<span class=\"string\">\"%s -&gt; %d\\n\"</span>, syscalls_name[num], proc-&gt;tf-&gt;eax);</div><div class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    cprintf(<span class=\"string\">\"%d %s: unknown sys call %d\\n\"</span>,</div><div class=\"line\">            proc-&gt;pid, proc-&gt;name, num);</div><div class=\"line\">    proc-&gt;tf-&gt;eax = <span class=\"number\">-1</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h2 id=\"Part2-日期系统调用\"><a href=\"#Part2-日期系统调用\" class=\"headerlink\" title=\"Part2 日期系统调用\"></a>Part2 日期系统调用</h2><h3 id=\"任务-1\"><a href=\"#任务-1\" class=\"headerlink\" title=\"任务\"></a>任务</h3><blockquote>\n<p>添加一个新的系统调用<code>date</code>,其获取当前的UTC时间并将其返回给用户程序.完成后,在xv6 shell提示符下输入<code>date</code>可打印当前的UTC时间.</p>\n</blockquote>\n<h3 id=\"实现-1\"><a href=\"#实现-1\" class=\"headerlink\" title=\"实现\"></a>实现</h3><blockquote>\n<p>使用帮助函数<code>cmostime()</code>(定义在<code>lapic.c</code>)来读取实时时钟,然后根据<code>date.h</code>中定义的struct rtcdate结构体,作为一指针参数传递给<code>cmostime()</code>.<br>查看<code>uptime</code>系统调用的实现如下<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">grep -n uptime *.[chS]</div><div class=\"line\"><span class=\"meta\">#output</span></div><div class=\"line\">syscall.c: <span class=\"function\"><span class=\"keyword\">extern</span> <span class=\"keyword\">int</span> <span class=\"title\">sys_uptime</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</div><div class=\"line\">syscall.c:[SYS_uptime] sys_uptime,</div><div class=\"line\">syscall.c:[SYS_uptime] <span class=\"string\">\"uptime\"</span>,</div><div class=\"line\">syscall.h:<span class=\"meta\">#<span class=\"meta-keyword\">define</span> SYS_uptime 14</span></div><div class=\"line\">sysproc.c:sys_uptime(<span class=\"keyword\">void</span>)</div><div class=\"line\">user.h:<span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">uptime</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</div><div class=\"line\">usys.S:SYSCALL(uptime)</div></pre></td></tr></table></figure></p>\n<p>归纳出添加系统调用的一般步骤:</p>\n<ul>\n<li>在<code>syscall.h</code>中添加系统调用号</li>\n<li>在<code>user.h</code>中添加用户态函数的定义</li>\n<li>在<code>usys.S</code>中添加用户态函数的实现</li>\n<li>在<code>syscall.c</code>中添加系统调用函数的外部声明</li>\n<li>在<code>sysproc.c</code>中添加系统调用函数的实现</li>\n</ul>\n<p>‘date’系统调用函数具体实现代码：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span></span></div><div class=\"line\"><span class=\"title\">sys_date</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">struct</span> rtcdate *r;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (argptr(<span class=\"number\">0</span>, (<span class=\"keyword\">void</span> *)&amp;r, <span class=\"keyword\">sizeof</span>(*r)) &lt; <span class=\"number\">0</span>)</div><div class=\"line\">          <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">  cmostime(r);</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>"},{"title":"lab0-build-env","date":"2017-04-07T16:00:00.000Z","_content":"# lab 0: 实验环境搭建\n\n### toolchain\n> 在进行os实验之前, 要求有前置的基础:\n> 1. C: 实现语言, 汇编: 阅读x86_64的汇编代码\n> 2. linux: 实验系统环境, 主要是command line下的命令操作\n> 3. git: 版本控制与代码提交\n> 4. gcc, gdb, id: 编译源代码与调试\n> 5. qemu: x86 硬件模拟器, 选择2为Bochs\n\n### toolchain 安装\n> 1.linux: 我的环境是linux mint 18.0 serena(基于ubuntu)\n> 2.git: linux自带, 配置连接github\n> ```bash\ngit -h\ngit add/commit/push/checkout\ngit remote add\n```\n> 3.gcc, gdb安装\n>```bash\nsudo apt-get install build-essential\nsudo apt-get install gcc-multilib\ngcc -h\ngdb -h\n```\n>> 在Linux下已经一套适合6.828课程的工具链， 输入如下命令进行测试\n>> ```bash\n$ objdump -i\noutput: line2 elf32-i386\n\\\n$ gcc -m32 -print-libgcc-file-name\noutput: /usr/lib/gcc/x86_64-linux-gnu/version/32/libgcc.a\n```\n\n> 4.qemu 安装\na. 依赖库安装:\n`sudo apt-get install libsdl1.2-dev, libtool-bin, libglib2.0-dev, libz-dev, libpixman-1-dev.`\nb.由于qemu编译xv6的问题, mit对qemu进行了修改, 用git下载源码:\n`git clone https://github.com/geofft/qemu.git -b 6.828-2.3.0`\nc.编译qemu\n>```bash\ncd qemu\n./configure --disable-kvm --target-list=\"i386-softmmu x86_64-softmmu\"\nmake && make install\n```\n\n> 5.其它问题\n> a. Windows下可采用Cygwin或者virtualbox + ubuntu image, 但更推荐linux\n\n### 参考链接\n> 1. [6.828 toolchains](https://pdos.csail.mit.edu/6.828/2016/tools.html)\n> 2. [lab guide](https://pdos.csail.mit.edu/6.828/2016/labguide.html)\n> 3. [qemu manual](http://wiki.qemu.org/download/qemu-doc.html#pcsys_005fmonitor)\n> 4. [gdb manual](http://sourceware.org/gdb/current/onlinedocs/gdb/)\n","source":"_posts/lab0.md","raw":"title: lab0-build-env\ndate: 2017/04/08\ntags:\n - xv6\n - os\n\n---\n# lab 0: 实验环境搭建\n\n### toolchain\n> 在进行os实验之前, 要求有前置的基础:\n> 1. C: 实现语言, 汇编: 阅读x86_64的汇编代码\n> 2. linux: 实验系统环境, 主要是command line下的命令操作\n> 3. git: 版本控制与代码提交\n> 4. gcc, gdb, id: 编译源代码与调试\n> 5. qemu: x86 硬件模拟器, 选择2为Bochs\n\n### toolchain 安装\n> 1.linux: 我的环境是linux mint 18.0 serena(基于ubuntu)\n> 2.git: linux自带, 配置连接github\n> ```bash\ngit -h\ngit add/commit/push/checkout\ngit remote add\n```\n> 3.gcc, gdb安装\n>```bash\nsudo apt-get install build-essential\nsudo apt-get install gcc-multilib\ngcc -h\ngdb -h\n```\n>> 在Linux下已经一套适合6.828课程的工具链， 输入如下命令进行测试\n>> ```bash\n$ objdump -i\noutput: line2 elf32-i386\n\\\n$ gcc -m32 -print-libgcc-file-name\noutput: /usr/lib/gcc/x86_64-linux-gnu/version/32/libgcc.a\n```\n\n> 4.qemu 安装\na. 依赖库安装:\n`sudo apt-get install libsdl1.2-dev, libtool-bin, libglib2.0-dev, libz-dev, libpixman-1-dev.`\nb.由于qemu编译xv6的问题, mit对qemu进行了修改, 用git下载源码:\n`git clone https://github.com/geofft/qemu.git -b 6.828-2.3.0`\nc.编译qemu\n>```bash\ncd qemu\n./configure --disable-kvm --target-list=\"i386-softmmu x86_64-softmmu\"\nmake && make install\n```\n\n> 5.其它问题\n> a. Windows下可采用Cygwin或者virtualbox + ubuntu image, 但更推荐linux\n\n### 参考链接\n> 1. [6.828 toolchains](https://pdos.csail.mit.edu/6.828/2016/tools.html)\n> 2. [lab guide](https://pdos.csail.mit.edu/6.828/2016/labguide.html)\n> 3. [qemu manual](http://wiki.qemu.org/download/qemu-doc.html#pcsys_005fmonitor)\n> 4. [gdb manual](http://sourceware.org/gdb/current/onlinedocs/gdb/)\n","slug":"lab0","published":1,"updated":"2017-08-26T03:38:21.606Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6sslhb4000q3gamti1tjs5y","content":"<h1 id=\"lab-0-实验环境搭建\"><a href=\"#lab-0-实验环境搭建\" class=\"headerlink\" title=\"lab 0: 实验环境搭建\"></a>lab 0: 实验环境搭建</h1><h3 id=\"toolchain\"><a href=\"#toolchain\" class=\"headerlink\" title=\"toolchain\"></a>toolchain</h3><blockquote>\n<p>在进行os实验之前, 要求有前置的基础:</p>\n<ol>\n<li>C: 实现语言, 汇编: 阅读x86_64的汇编代码</li>\n<li>linux: 实验系统环境, 主要是command line下的命令操作</li>\n<li>git: 版本控制与代码提交</li>\n<li>gcc, gdb, id: 编译源代码与调试</li>\n<li>qemu: x86 硬件模拟器, 选择2为Bochs</li>\n</ol>\n</blockquote>\n<h3 id=\"toolchain-安装\"><a href=\"#toolchain-安装\" class=\"headerlink\" title=\"toolchain 安装\"></a>toolchain 安装</h3><blockquote>\n<p>1.linux: 我的环境是linux mint 18.0 serena(基于ubuntu)<br>2.git: linux自带, 配置连接github<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git -h</div><div class=\"line\">git add/commit/push/checkout</div><div class=\"line\">git remote add</div></pre></td></tr></table></figure></p>\n<p>3.gcc, gdb安装<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install build-essential</div><div class=\"line\">sudo apt-get install gcc-multilib</div><div class=\"line\">gcc -h</div><div class=\"line\">gdb -h</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>在Linux下已经一套适合6.828课程的工具链， 输入如下命令进行测试<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ objdump -i</div><div class=\"line\">output: line2 elf32-i386</div><div class=\"line\">\\</div><div class=\"line\">$ gcc -m32 -print-libgcc-file-name</div><div class=\"line\">output: /usr/lib/gcc/x86_64-linux-gnu/version/32/libgcc.a</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>4.qemu 安装<br>a. 依赖库安装:<br><code>sudo apt-get install libsdl1.2-dev, libtool-bin, libglib2.0-dev, libz-dev, libpixman-1-dev.</code><br>b.由于qemu编译xv6的问题, mit对qemu进行了修改, 用git下载源码:<br><code>git clone https://github.com/geofft/qemu.git -b 6.828-2.3.0</code><br>c.编译qemu<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">cd</span> qemu</div><div class=\"line\">./configure --disable-kvm --target-list=<span class=\"string\">\"i386-softmmu x86_64-softmmu\"</span></div><div class=\"line\">make &amp;&amp; make install</div></pre></td></tr></table></figure></p>\n<p>5.其它问题<br>a. Windows下可采用Cygwin或者virtualbox + ubuntu image, 但更推荐linux</p>\n</blockquote>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3><blockquote>\n<ol>\n<li><a href=\"https://pdos.csail.mit.edu/6.828/2016/tools.html\" target=\"_blank\" rel=\"external\">6.828 toolchains</a></li>\n<li><a href=\"https://pdos.csail.mit.edu/6.828/2016/labguide.html\" target=\"_blank\" rel=\"external\">lab guide</a></li>\n<li><a href=\"http://wiki.qemu.org/download/qemu-doc.html#pcsys_005fmonitor\" target=\"_blank\" rel=\"external\">qemu manual</a></li>\n<li><a href=\"http://sourceware.org/gdb/current/onlinedocs/gdb/\" target=\"_blank\" rel=\"external\">gdb manual</a></li>\n</ol>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"lab-0-实验环境搭建\"><a href=\"#lab-0-实验环境搭建\" class=\"headerlink\" title=\"lab 0: 实验环境搭建\"></a>lab 0: 实验环境搭建</h1><h3 id=\"toolchain\"><a href=\"#toolchain\" class=\"headerlink\" title=\"toolchain\"></a>toolchain</h3><blockquote>\n<p>在进行os实验之前, 要求有前置的基础:</p>\n<ol>\n<li>C: 实现语言, 汇编: 阅读x86_64的汇编代码</li>\n<li>linux: 实验系统环境, 主要是command line下的命令操作</li>\n<li>git: 版本控制与代码提交</li>\n<li>gcc, gdb, id: 编译源代码与调试</li>\n<li>qemu: x86 硬件模拟器, 选择2为Bochs</li>\n</ol>\n</blockquote>\n<h3 id=\"toolchain-安装\"><a href=\"#toolchain-安装\" class=\"headerlink\" title=\"toolchain 安装\"></a>toolchain 安装</h3><blockquote>\n<p>1.linux: 我的环境是linux mint 18.0 serena(基于ubuntu)<br>2.git: linux自带, 配置连接github<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git -h</div><div class=\"line\">git add/commit/push/checkout</div><div class=\"line\">git remote add</div></pre></td></tr></table></figure></p>\n<p>3.gcc, gdb安装<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install build-essential</div><div class=\"line\">sudo apt-get install gcc-multilib</div><div class=\"line\">gcc -h</div><div class=\"line\">gdb -h</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>在Linux下已经一套适合6.828课程的工具链， 输入如下命令进行测试<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ objdump -i</div><div class=\"line\">output: line2 elf32-i386</div><div class=\"line\">\\</div><div class=\"line\">$ gcc -m32 -print-libgcc-file-name</div><div class=\"line\">output: /usr/lib/gcc/x86_64-linux-gnu/version/32/libgcc.a</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>4.qemu 安装<br>a. 依赖库安装:<br><code>sudo apt-get install libsdl1.2-dev, libtool-bin, libglib2.0-dev, libz-dev, libpixman-1-dev.</code><br>b.由于qemu编译xv6的问题, mit对qemu进行了修改, 用git下载源码:<br><code>git clone https://github.com/geofft/qemu.git -b 6.828-2.3.0</code><br>c.编译qemu<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">cd</span> qemu</div><div class=\"line\">./configure --disable-kvm --target-list=<span class=\"string\">\"i386-softmmu x86_64-softmmu\"</span></div><div class=\"line\">make &amp;&amp; make install</div></pre></td></tr></table></figure></p>\n<p>5.其它问题<br>a. Windows下可采用Cygwin或者virtualbox + ubuntu image, 但更推荐linux</p>\n</blockquote>\n<h3 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h3><blockquote>\n<ol>\n<li><a href=\"https://pdos.csail.mit.edu/6.828/2016/tools.html\" target=\"_blank\" rel=\"external\">6.828 toolchains</a></li>\n<li><a href=\"https://pdos.csail.mit.edu/6.828/2016/labguide.html\" target=\"_blank\" rel=\"external\">lab guide</a></li>\n<li><a href=\"http://wiki.qemu.org/download/qemu-doc.html#pcsys_005fmonitor\" target=\"_blank\" rel=\"external\">qemu manual</a></li>\n<li><a href=\"http://sourceware.org/gdb/current/onlinedocs/gdb/\" target=\"_blank\" rel=\"external\">gdb manual</a></li>\n</ol>\n</blockquote>\n"},{"title":"hw5-cpu-alarm","date":"2017-04-23T16:00:00.000Z","_content":"# hw5 cpu alarm\n## 目标\n> 这次hw向xv6添加一个功能，以便在进程使用CPU时,定时提醒进程.这对计算敏感的进程很有帮助，限制他们CPU的使用时间，也让进程在计算的同时执行一些周期性任务.更通用来说来说，我们将实现1个用户级别的中断异常处理.\n在这里会用到上次系统调用的实现机制.即增加1个`alarm(interval, handler)`系统调用.当1个应用调用`alarm(n, fn)`时，那么每隔n个CPU时钟节拍，内核将使应用调用`fn`函数.当`fn`函数返回时，应用从调用地址重新开始执行.\n\n测试程序`alarmtest.c`\n\n<!-- more -->\n\n``` c\n#include \"types.h\"\n#include \"stat.h\"\n#include \"user.h\"\n\nvoid periodic();\n\nint\nmain(int argc, char *argv[])\n{\n  int i;\n  printf(1, \"alarmtest starting\\n\");\n  alarm(10, periodic);\n  for(i = 0; i < 50*500000; i++){\n    if((i++ % 500000) == 0)\n      write(2, \".\", 1);\n  }\n  exit();\n}\n\nvoid\nperiodic()\n{\n  printf(1, \"alarm!\\n\");\n}\n```\n其调用`alarm(10, periodic)`, 使得内核每隔10个tick调用一次`periodic`.输出形式如下:\n``` bash\n$alarmtest\nalarmtest starting\n.....alarm!\n....alarm!\n.....alarm!\n......alarm!\n.....alarm!\n....alarm!\n....alarm!\n......alarm!\n.....alarm!\n...alarm!\n...$\n```\n\n### 实现\n\n实现步骤：\n\n> 1.参照[hw3 system call](https://chestnutme.github.io/2017/04/19/hw3/),按照添加系统调用的方式添加用户态调用程序、系统调用号和系统调用程序\n``` c\n//user.h\nint alarm(int ticks, void(*hander)());\n//usys.S\nSYSCALL(alarm)\n//Makefile    UPROGS:\n_alarmtest\\\n//syscall.h\n#define SYS_alarm 23\n//syscall.c\nextern int sys_alarm(void);\n//syscall.c syscalls[]\n[SYS_alarm]   sys_alarm,\n//sysproc.c\nint\n    sys_alarm(void)\n    {\n      int ticks;\n      void (*handler)();\n\n      if(argint(0, &ticks) < 0)\n        return -1;\n      if(argptr(1, (char**)&handler, 1) < 0)\n        return -1;\n      proc->alarmticks = ticks;\n      proc->alarmhandler = handler;\n      return 0;\n    }\n```\n\n\n> 2.在`proc.c`的`proc`结构体中添加变量记录总`ticks`、当前`ticks`和对应的`handler`\n``` c\n//struct proc\nint alarmticks;\nint curalarmticks;\nvoid (*alarmhander)();\n```\n\n> 3.在`trap.c`中处理时钟中断添加`handler`\n``` c\ncase T_IRQ0 + IRQ_TIMER:\n    if(cpu->id == 0){\n       acquire(&tickslock);\n       ticks++;\n\n      wakeup(&ticks);\n      release(&tickslock);\n    }\n      if(proc && (tf->cs & 3) == 3){\n        proc->curalarmtick++;\n        if(proc->alarmticks == proc->curalarmtick){  // tick到达了周期\n          proc->curalarmtick = 0;\n\n          //将eip压栈\n          tf->esp -= 4;    \n          *((uint *)(tf->esp)) = tf->eip;\n          // 拷贝alarmhandler给eip，准备执行\n          tf->eip =(uint) proc->alarmhandler;\n        }\n      }\n    lapiceoi();\n    break;\n````\n","source":"_posts/hw5.md","raw":"title: hw5-cpu-alarm\ndate: 2017/04/24\ntags:\n\t- os\n\t- xv6\n\n---\n# hw5 cpu alarm\n## 目标\n> 这次hw向xv6添加一个功能，以便在进程使用CPU时,定时提醒进程.这对计算敏感的进程很有帮助，限制他们CPU的使用时间，也让进程在计算的同时执行一些周期性任务.更通用来说来说，我们将实现1个用户级别的中断异常处理.\n在这里会用到上次系统调用的实现机制.即增加1个`alarm(interval, handler)`系统调用.当1个应用调用`alarm(n, fn)`时，那么每隔n个CPU时钟节拍，内核将使应用调用`fn`函数.当`fn`函数返回时，应用从调用地址重新开始执行.\n\n测试程序`alarmtest.c`\n\n<!-- more -->\n\n``` c\n#include \"types.h\"\n#include \"stat.h\"\n#include \"user.h\"\n\nvoid periodic();\n\nint\nmain(int argc, char *argv[])\n{\n  int i;\n  printf(1, \"alarmtest starting\\n\");\n  alarm(10, periodic);\n  for(i = 0; i < 50*500000; i++){\n    if((i++ % 500000) == 0)\n      write(2, \".\", 1);\n  }\n  exit();\n}\n\nvoid\nperiodic()\n{\n  printf(1, \"alarm!\\n\");\n}\n```\n其调用`alarm(10, periodic)`, 使得内核每隔10个tick调用一次`periodic`.输出形式如下:\n``` bash\n$alarmtest\nalarmtest starting\n.....alarm!\n....alarm!\n.....alarm!\n......alarm!\n.....alarm!\n....alarm!\n....alarm!\n......alarm!\n.....alarm!\n...alarm!\n...$\n```\n\n### 实现\n\n实现步骤：\n\n> 1.参照[hw3 system call](https://chestnutme.github.io/2017/04/19/hw3/),按照添加系统调用的方式添加用户态调用程序、系统调用号和系统调用程序\n``` c\n//user.h\nint alarm(int ticks, void(*hander)());\n//usys.S\nSYSCALL(alarm)\n//Makefile    UPROGS:\n_alarmtest\\\n//syscall.h\n#define SYS_alarm 23\n//syscall.c\nextern int sys_alarm(void);\n//syscall.c syscalls[]\n[SYS_alarm]   sys_alarm,\n//sysproc.c\nint\n    sys_alarm(void)\n    {\n      int ticks;\n      void (*handler)();\n\n      if(argint(0, &ticks) < 0)\n        return -1;\n      if(argptr(1, (char**)&handler, 1) < 0)\n        return -1;\n      proc->alarmticks = ticks;\n      proc->alarmhandler = handler;\n      return 0;\n    }\n```\n\n\n> 2.在`proc.c`的`proc`结构体中添加变量记录总`ticks`、当前`ticks`和对应的`handler`\n``` c\n//struct proc\nint alarmticks;\nint curalarmticks;\nvoid (*alarmhander)();\n```\n\n> 3.在`trap.c`中处理时钟中断添加`handler`\n``` c\ncase T_IRQ0 + IRQ_TIMER:\n    if(cpu->id == 0){\n       acquire(&tickslock);\n       ticks++;\n\n      wakeup(&ticks);\n      release(&tickslock);\n    }\n      if(proc && (tf->cs & 3) == 3){\n        proc->curalarmtick++;\n        if(proc->alarmticks == proc->curalarmtick){  // tick到达了周期\n          proc->curalarmtick = 0;\n\n          //将eip压栈\n          tf->esp -= 4;    \n          *((uint *)(tf->esp)) = tf->eip;\n          // 拷贝alarmhandler给eip，准备执行\n          tf->eip =(uint) proc->alarmhandler;\n        }\n      }\n    lapiceoi();\n    break;\n````\n","slug":"hw5","published":1,"updated":"2017-08-26T03:38:21.602Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6sslhb5000t3gamn6iv0usa","content":"<h1 id=\"hw5-cpu-alarm\"><a href=\"#hw5-cpu-alarm\" class=\"headerlink\" title=\"hw5 cpu alarm\"></a>hw5 cpu alarm</h1><h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><blockquote>\n<p>这次hw向xv6添加一个功能，以便在进程使用CPU时,定时提醒进程.这对计算敏感的进程很有帮助，限制他们CPU的使用时间，也让进程在计算的同时执行一些周期性任务.更通用来说来说，我们将实现1个用户级别的中断异常处理.<br>在这里会用到上次系统调用的实现机制.即增加1个<code>alarm(interval, handler)</code>系统调用.当1个应用调用<code>alarm(n, fn)</code>时，那么每隔n个CPU时钟节拍，内核将使应用调用<code>fn</code>函数.当<code>fn</code>函数返回时，应用从调用地址重新开始执行.</p>\n</blockquote>\n<p>测试程序<code>alarmtest.c</code></p>\n<a id=\"more\"></a>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"types.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stat.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"user.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">periodic</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span></span></div><div class=\"line\"><span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">int</span> i;</div><div class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"number\">1</span>, <span class=\"string\">\"alarmtest starting\\n\"</span>);</div><div class=\"line\">  alarm(<span class=\"number\">10</span>, periodic);</div><div class=\"line\">  <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">50</span>*<span class=\"number\">500000</span>; i++)&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>((i++ % <span class=\"number\">500000</span>) == <span class=\"number\">0</span>)</div><div class=\"line\">      write(<span class=\"number\">2</span>, <span class=\"string\">\".\"</span>, <span class=\"number\">1</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"built_in\">exit</span>();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">periodic</span><span class=\"params\">()</span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"number\">1</span>, <span class=\"string\">\"alarm!\\n\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其调用<code>alarm(10, periodic)</code>, 使得内核每隔10个tick调用一次<code>periodic</code>.输出形式如下:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"variable\">$alarmtest</span></div><div class=\"line\">alarmtest starting</div><div class=\"line\">.....alarm!</div><div class=\"line\">....alarm!</div><div class=\"line\">.....alarm!</div><div class=\"line\">......alarm!</div><div class=\"line\">.....alarm!</div><div class=\"line\">....alarm!</div><div class=\"line\">....alarm!</div><div class=\"line\">......alarm!</div><div class=\"line\">.....alarm!</div><div class=\"line\">...alarm!</div><div class=\"line\">...$</div></pre></td></tr></table></figure></p>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>实现步骤：</p>\n<blockquote>\n<p>1.参照<a href=\"https://chestnutme.github.io/2017/04/19/hw3/\" target=\"_blank\" rel=\"external\">hw3 system call</a>,按照添加系统调用的方式添加用户态调用程序、系统调用号和系统调用程序<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">//user.h</div><div class=\"line\">int alarm(int ticks, void(*hander)());</div><div class=\"line\">//usys.S</div><div class=\"line\">SYSCALL(alarm)</div><div class=\"line\">//Makefile    UPROGS:</div><div class=\"line\">_alarmtest\\</div><div class=\"line\">//syscall.h</div><div class=\"line\">#define SYS_alarm 23</div><div class=\"line\">//syscall.c</div><div class=\"line\">extern int sys_alarm(void);</div><div class=\"line\">//syscall.c syscalls[]</div><div class=\"line\">[SYS_alarm]   sys_alarm,</div><div class=\"line\">//sysproc.c</div><div class=\"line\">int</div><div class=\"line\">    sys_alarm(void)</div><div class=\"line\">    &#123;</div><div class=\"line\">      int ticks;</div><div class=\"line\">      void (*handler)();</div><div class=\"line\"></div><div class=\"line\">      if(argint(0, &amp;ticks) &lt; 0)</div><div class=\"line\">        return -1;</div><div class=\"line\">      if(argptr(1, (char**)&amp;handler, 1) &lt; 0)</div><div class=\"line\">        return -1;</div><div class=\"line\">      proc-&gt;alarmticks = ticks;</div><div class=\"line\">      proc-&gt;alarmhandler = handler;</div><div class=\"line\">      return 0;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>2.在<code>proc.c</code>的<code>proc</code>结构体中添加变量记录总<code>ticks</code>、当前<code>ticks</code>和对应的<code>handler</code><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//struct proc</span></div><div class=\"line\"><span class=\"keyword\">int</span> alarmticks;</div><div class=\"line\"><span class=\"keyword\">int</span> curalarmticks;</div><div class=\"line\"><span class=\"keyword\">void</span> (*alarmhander)();</div></pre></td></tr></table></figure></p>\n<p>3.在<code>trap.c</code>中处理时钟中断添加<code>handler</code><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">case</span> T_IRQ0 + IRQ_TIMER:</div><div class=\"line\">    <span class=\"keyword\">if</span>(cpu-&gt;id == <span class=\"number\">0</span>)&#123;</div><div class=\"line\">       acquire(&amp;tickslock);</div><div class=\"line\">       ticks++;</div><div class=\"line\"></div><div class=\"line\">      wakeup(&amp;ticks);</div><div class=\"line\">      release(&amp;tickslock);</div><div class=\"line\">    &#125;</div><div class=\"line\">      <span class=\"keyword\">if</span>(proc &amp;&amp; (tf-&gt;cs &amp; <span class=\"number\">3</span>) == <span class=\"number\">3</span>)&#123;</div><div class=\"line\">        proc-&gt;curalarmtick++;</div><div class=\"line\">        <span class=\"keyword\">if</span>(proc-&gt;alarmticks == proc-&gt;curalarmtick)&#123;  <span class=\"comment\">// tick到达了周期</span></div><div class=\"line\">          proc-&gt;curalarmtick = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">          <span class=\"comment\">//将eip压栈</span></div><div class=\"line\">          tf-&gt;esp -= <span class=\"number\">4</span>;    </div><div class=\"line\">          *((uint *)(tf-&gt;esp)) = tf-&gt;eip;</div><div class=\"line\">          <span class=\"comment\">// 拷贝alarmhandler给eip，准备执行</span></div><div class=\"line\">          tf-&gt;eip =(uint) proc-&gt;alarmhandler;</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    lapiceoi();</div><div class=\"line\">    <span class=\"keyword\">break</span>;</div><div class=\"line\">`</div></pre></td></tr></table></figure></p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"hw5-cpu-alarm\"><a href=\"#hw5-cpu-alarm\" class=\"headerlink\" title=\"hw5 cpu alarm\"></a>hw5 cpu alarm</h1><h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><blockquote>\n<p>这次hw向xv6添加一个功能，以便在进程使用CPU时,定时提醒进程.这对计算敏感的进程很有帮助，限制他们CPU的使用时间，也让进程在计算的同时执行一些周期性任务.更通用来说来说，我们将实现1个用户级别的中断异常处理.<br>在这里会用到上次系统调用的实现机制.即增加1个<code>alarm(interval, handler)</code>系统调用.当1个应用调用<code>alarm(n, fn)</code>时，那么每隔n个CPU时钟节拍，内核将使应用调用<code>fn</code>函数.当<code>fn</code>函数返回时，应用从调用地址重新开始执行.</p>\n</blockquote>\n<p>测试程序<code>alarmtest.c</code></p>","more":"<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"types.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"stat.h\"</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"user.h\"</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">periodic</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span></span></div><div class=\"line\"><span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">int</span> i;</div><div class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"number\">1</span>, <span class=\"string\">\"alarmtest starting\\n\"</span>);</div><div class=\"line\">  alarm(<span class=\"number\">10</span>, periodic);</div><div class=\"line\">  <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">50</span>*<span class=\"number\">500000</span>; i++)&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>((i++ % <span class=\"number\">500000</span>) == <span class=\"number\">0</span>)</div><div class=\"line\">      write(<span class=\"number\">2</span>, <span class=\"string\">\".\"</span>, <span class=\"number\">1</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"built_in\">exit</span>();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">periodic</span><span class=\"params\">()</span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"number\">1</span>, <span class=\"string\">\"alarm!\\n\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其调用<code>alarm(10, periodic)</code>, 使得内核每隔10个tick调用一次<code>periodic</code>.输出形式如下:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"variable\">$alarmtest</span></div><div class=\"line\">alarmtest starting</div><div class=\"line\">.....alarm!</div><div class=\"line\">....alarm!</div><div class=\"line\">.....alarm!</div><div class=\"line\">......alarm!</div><div class=\"line\">.....alarm!</div><div class=\"line\">....alarm!</div><div class=\"line\">....alarm!</div><div class=\"line\">......alarm!</div><div class=\"line\">.....alarm!</div><div class=\"line\">...alarm!</div><div class=\"line\">...$</div></pre></td></tr></table></figure></p>\n<h3 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h3><p>实现步骤：</p>\n<blockquote>\n<p>1.参照<a href=\"https://chestnutme.github.io/2017/04/19/hw3/\" target=\"_blank\" rel=\"external\">hw3 system call</a>,按照添加系统调用的方式添加用户态调用程序、系统调用号和系统调用程序<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">//user.h</div><div class=\"line\">int alarm(int ticks, void(*hander)());</div><div class=\"line\">//usys.S</div><div class=\"line\">SYSCALL(alarm)</div><div class=\"line\">//Makefile    UPROGS:</div><div class=\"line\">_alarmtest\\</div><div class=\"line\">//syscall.h</div><div class=\"line\">#define SYS_alarm 23</div><div class=\"line\">//syscall.c</div><div class=\"line\">extern int sys_alarm(void);</div><div class=\"line\">//syscall.c syscalls[]</div><div class=\"line\">[SYS_alarm]   sys_alarm,</div><div class=\"line\">//sysproc.c</div><div class=\"line\">int</div><div class=\"line\">    sys_alarm(void)</div><div class=\"line\">    &#123;</div><div class=\"line\">      int ticks;</div><div class=\"line\">      void (*handler)();</div><div class=\"line\"></div><div class=\"line\">      if(argint(0, &amp;ticks) &lt; 0)</div><div class=\"line\">        return -1;</div><div class=\"line\">      if(argptr(1, (char**)&amp;handler, 1) &lt; 0)</div><div class=\"line\">        return -1;</div><div class=\"line\">      proc-&gt;alarmticks = ticks;</div><div class=\"line\">      proc-&gt;alarmhandler = handler;</div><div class=\"line\">      return 0;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure></p>\n<p>2.在<code>proc.c</code>的<code>proc</code>结构体中添加变量记录总<code>ticks</code>、当前<code>ticks</code>和对应的<code>handler</code><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//struct proc</span></div><div class=\"line\"><span class=\"keyword\">int</span> alarmticks;</div><div class=\"line\"><span class=\"keyword\">int</span> curalarmticks;</div><div class=\"line\"><span class=\"keyword\">void</span> (*alarmhander)();</div></pre></td></tr></table></figure></p>\n<p>3.在<code>trap.c</code>中处理时钟中断添加<code>handler</code><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">case</span> T_IRQ0 + IRQ_TIMER:</div><div class=\"line\">    <span class=\"keyword\">if</span>(cpu-&gt;id == <span class=\"number\">0</span>)&#123;</div><div class=\"line\">       acquire(&amp;tickslock);</div><div class=\"line\">       ticks++;</div><div class=\"line\"></div><div class=\"line\">      wakeup(&amp;ticks);</div><div class=\"line\">      release(&amp;tickslock);</div><div class=\"line\">    &#125;</div><div class=\"line\">      <span class=\"keyword\">if</span>(proc &amp;&amp; (tf-&gt;cs &amp; <span class=\"number\">3</span>) == <span class=\"number\">3</span>)&#123;</div><div class=\"line\">        proc-&gt;curalarmtick++;</div><div class=\"line\">        <span class=\"keyword\">if</span>(proc-&gt;alarmticks == proc-&gt;curalarmtick)&#123;  <span class=\"comment\">// tick到达了周期</span></div><div class=\"line\">          proc-&gt;curalarmtick = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">          <span class=\"comment\">//将eip压栈</span></div><div class=\"line\">          tf-&gt;esp -= <span class=\"number\">4</span>;    </div><div class=\"line\">          *((uint *)(tf-&gt;esp)) = tf-&gt;eip;</div><div class=\"line\">          <span class=\"comment\">// 拷贝alarmhandler给eip，准备执行</span></div><div class=\"line\">          tf-&gt;eip =(uint) proc-&gt;alarmhandler;</div><div class=\"line\">        &#125;</div><div class=\"line\">      &#125;</div><div class=\"line\">    lapiceoi();</div><div class=\"line\">    <span class=\"keyword\">break</span>;</div><div class=\"line\">`</div></pre></td></tr></table></figure></p>\n</blockquote>"},{"title":"hw6-threads-and-locking","date":"2017-04-29T16:00:00.000Z","_content":"# hw6 threads and locking\n## 目标\n在多线程OS中，通常是在一个进程中包括多个线程，每个线程都是作为利用CPU的基本单位，是花费最小开销的实体.OS中实现进程和线程提高系统的并行性，hw6探索使用线程和锁来并行编程Hash表.\n\n## 准备\nhw6在多核硬件的os上即可编译运行，不依赖于课程的xv6.\n``` bash\nwget https://pdos.csail.mit.edu/6.828/2016/homework/ph.c\ngcc -g -02 ph.c -pthread\n```\n源程序（`ph.c`)如下：\n``` c\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <assert.h>\n#include <pthread.h>\n#include <sys/time.h>\n\n#define SOL\n#define NBUCKET 5\n#define NKEYS 100000\n\nstruct entry {\n  int key;\n  int value;\n  struct entry *next;\n};\nstruct entry *table[NBUCKET];\nint keys[NKEYS];\nint nthread = 1;\nvolatile int done;\n\n\ndouble\nnow()\n{\n struct timeval tv;\n gettimeofday(&tv, 0);\n return tv.tv_sec + tv.tv_usec / 1000000.0;\n}\n\nstatic void\nprint(void)\n{\n  int i;\n  struct entry *e;\n  for (i = 0; i < NBUCKET; i++) {\n    printf(\"%d: \", i);\n    for (e = table[i]; e != 0; e = e->next) {\n      printf(\"%d \", e->key);\n    }\n    printf(\"\\n\");\n  }\n}\n\nstatic void\ninsert(int key, int value, struct entry **p, struct entry *n)\n{\n  struct entry *e = malloc(sizeof(struct entry));\n  e->key = key;\n  e->value = value;\n  e->next = n;\n  *p = e;\n}\n\nstatic\nvoid put(int key, int value)\n{\n  int i = key % NBUCKET;\n  insert(key, value, &table[i], table[i]);\n}\n\nstatic struct entry*\nget(int key)\n{\n  struct entry *e = 0;\n  for (e = table[key % NBUCKET]; e != 0; e = e->next) {\n    if (e->key == key) break;\n  }\n  return e;\n}\n\nstatic void *\nthread(void *xa)\n{\n  long n = (long) xa;\n  int i;\n  int b = NKEYS/nthread;\n  int k = 0;\n  double t1, t0;\n\n  //  printf(\"b = %d\\n\", b);\n  t0 = now();\n  for (i = 0; i < b; i++) {\n    // printf(\"%d: put %d\\n\", n, b*n+i);\n    put(keys[b*n + i], n);\n  }\n  t1 = now();\n  printf(\"%ld: put time = %f\\n\", n, t1-t0);\n\n  // Should use pthread_barrier, but MacOS doesn't support it ...\n  __sync_fetch_and_add(&done, 1);\n  while (done < nthread) ;\n\n  t0 = now();\n  for (i = 0; i < NKEYS; i++) {\n    struct entry *e = get(keys[i]);\n    if (e == 0) k++;\n  }\n  t1 = now();\n  printf(\"%ld: get time = %f\\n\", n, t1-t0);\n  printf(\"%ld: %d keys missing\\n\", n, k);\n  return NULL;\n}\n\nint\nmain(int argc, char *argv[])\n{\n  pthread_t *tha;\n  void *value;\n  long i;\n  double t1, t0;\n\n  if (argc < 2) {\n    fprintf(stderr, \"%s: %s nthread\\n\", argv[0], argv[0]);\n    exit(-1);\n  }\n  nthread = atoi(argv[1]);\n  tha = malloc(sizeof(pthread_t) * nthread);\n  srandom(0);\n  assert(NKEYS % nthread == 0);\n  for (i = 0; i < NKEYS; i++) {\n    keys[i] = random();\n  }\n  t0 = now();\n  for(i = 0; i < nthread; i++) {\n    assert(pthread_create(&tha[i], NULL, thread, (void *) i) == 0);\n  }\n  for(i = 0; i < nthread; i++) {\n    assert(pthread_join(tha[i], &value) == 0);\n  }\n  t1 = now();\n  printf(\"completion time = %f\\n\", t1-t0);\n}\n```\n\n## 并行\n在4核机器上双线程运行程序：\n``` bash\n./a.out 2\n# 2：n_threads为在hash表上执行put和get操作的线程数\n```\n产生如果如下：\n```\n1: put time = 0.007442\n0: put time = 0.007474\n1: get time = 6.559389\n1: 1 keys missing\n0: get time = 6.567974\n0: 1. keys missing\ncompletion time = 6.575672\n```\n> 每个线程分两个阶段运行.在第一阶段`put`，每个线程将`[NKEYS/nthread]`key放入hash表.在第二阶段`get`，每个线程从hash表中获取`NKEYS`.输入结果为每个线程每个阶段花费多长时间，底部的完成时间为应用程序的总运行时间.在上面的输出中，应用程序的完成时间约为6.5秒.\n\n对比单线程，看双线程是否改进了性能：\n```\n./a.out 1\n0: put time = 0.016793\n0: get time = 5.447454\n0: 0 keys missing\ncompletion time = 5.464499\n```\n> 单线程情况（5.5s）的完成时间略小于双线程情况（6.5s），增加的运行时间应该在消耗线程切换上。但双线程在`get`阶段的总工作量是单线程的两倍.因此，双线程在两个内核上实现了两倍的并行加速，效果很好.`put`阶段实现了一些加速; 双线程并行地插入相同数量的key，比单线程多一倍.另外，还有一个问题；`1 keys missing`说明在双线程运行中，程序在阶段2找不到的阶段1中插入1个键.\n\n在4核机器上运行结果如下：\n```\n23: put time = 0.014067\n1: put time = 0.014450\n2: put time = 0.014245\n0: put time = 0.015714\n3: get time = 6.202647\n3: 45 keys missing\n0: get time = 6.211748\n0: 45 keys missing\n2: get time = 6.287174\n2: 45 keys missing\n1: get time = 6.306257\n1: 45 keys missing\ncompletion time = 6.322159\n```\n> 4线程完成时间与双线程大致相同，但是运行时间是双线程的两倍，实现了良好的并行性.但也发现缺失了更多的key的问题，相比较于单线程不会出现缺少key的问题.\n\n## 问题解决\n### key缺失原因\n为什么当两个或多个线程同时运行时，key开始丢失？考虑这样一种情况：假设线程A和B同时运行。如果两个线程同时插入同一个bucket的key，则可能会发生竞争。下面的事件概述将导致这样的结果的操作。\n```\nt-A: calls insert() on bucket 1 (key = 6, 6 % NBUCKETS = 1)\n\nt-B: calls insert() on bucket 1 (key = 21, 21 % NBUCKETS = 1)\n\n...\n\nt-A: executes e->next = n\n\nt-B: executes e->next = n\n\nt-A: executes *p = e\n\nt-B: executes *p = e\n```\n这样做的结果是执行的最后一个线程B有效地`*p = e`覆盖了前一个线程A的动作并设置了新的列表的头指针.按照上面的执行顺序，假设插入线程A的键6将会丢失，因为线程B覆盖了它。\n### **锁机制**\n为了避免上述事件的发生，即线程同时访问同一个资源，采用**锁机制**，给`put`和`get`加锁，实现线程的**互斥**.linux `pthread.h`提供的锁机制如下：\n``` c\npthread_mutex_t lock;     // declare a lock\npthread_mutex_init(&lock, NULL);   // initialize the lock\npthread_mutex_lock(&lock);  // acquire lock\npthread_mutex_unlock(&lock);  // release lock\n```\n首先想到的是给每一个`put`和`get`操作加锁，但发现这种结果导致多线程变成了线性运行，使得并行性降为0.然后发现`get`实际是读操作，不会对hash表进行写操作，在经典的读者-写着进程互斥问题中学到，读操作无需加锁，允许多个读操作并行执行，这样就在保证不出现key缺失的情况下提高了并行性。最后考虑`put`操作是对整个hash表加锁，实际上只需要给`put`操作访问的bucket加锁，而不是全局加锁，这使得其他`put`操作可以同时执行bucket的插入进一步提高了并行性。运行效果如下：\n```\n0: put time = 0.022744\n1: put time = 0.022521\n1: get time = 6.309178\n1: 0 keys missing\n0: get time = 6.323614\n0: 0 keys missing\ncompletion time = 6.350177\n```\n`ph.c`修改结果如下：\n``` c\n...\nint keys[NKEYS];\npthread_mutex_t bucket_locks[NBUCKET];\n...\nstatic\nvoid put(int key, int value)\n{\n  int i = key % NBUCKET;\n  pthread_mutex_lock(&bucket_locks[i]);\n  insert(key, value, &table[i], table[i]);\n  pthread_mutex_unlock(&bucket_locks[i]);\n}\n...\nint\nmain(int argc, char *argv[])\n{\n  pthread_t *tha;\n  void *value;\n  long i;\n  double t1, t0;\n\n  if (argc < 2) {\n    fprintf(stderr, \"%s: %s nthread\\n\", argv[0], argv[0]);\n    exit(-1);\n  }\n  nthread = atoi(argv[1]);\n  tha = malloc(sizeof(pthread_t) * nthread);\n  srandom(0);\n  assert(NKEYS % nthread == 0);\n  for (i = 0; i < NKEYS; i++) {\n    keys[i] = random();\n  }\n\n  //init lock for every bucket\n  for (i = 0; i < NBUCKET; i++) {\n    pthread_mutex_init(&bucket_locks[i], NULL);\n  }\n\n  t0 = now();\n  for(i = 0; i < nthread; i++) {\n    assert(pthread_create(&tha[i], NULL, thread, (void *) i) == 0);\n  }\n  for(i = 0; i < nthread; i++) {\n    assert(pthread_join(tha[i], &value) == 0);\n  }\n  t1 = now();\n  printf(\"completion time = %f\\n\", t1-t0);\n}\n```\n","source":"_posts/hw6.md","raw":"title: hw6-threads-and-locking\ndate: 2017/04/30\ntags:\n\t- os\n\t- xv6\n\n---\n# hw6 threads and locking\n## 目标\n在多线程OS中，通常是在一个进程中包括多个线程，每个线程都是作为利用CPU的基本单位，是花费最小开销的实体.OS中实现进程和线程提高系统的并行性，hw6探索使用线程和锁来并行编程Hash表.\n\n## 准备\nhw6在多核硬件的os上即可编译运行，不依赖于课程的xv6.\n``` bash\nwget https://pdos.csail.mit.edu/6.828/2016/homework/ph.c\ngcc -g -02 ph.c -pthread\n```\n源程序（`ph.c`)如下：\n``` c\n#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <assert.h>\n#include <pthread.h>\n#include <sys/time.h>\n\n#define SOL\n#define NBUCKET 5\n#define NKEYS 100000\n\nstruct entry {\n  int key;\n  int value;\n  struct entry *next;\n};\nstruct entry *table[NBUCKET];\nint keys[NKEYS];\nint nthread = 1;\nvolatile int done;\n\n\ndouble\nnow()\n{\n struct timeval tv;\n gettimeofday(&tv, 0);\n return tv.tv_sec + tv.tv_usec / 1000000.0;\n}\n\nstatic void\nprint(void)\n{\n  int i;\n  struct entry *e;\n  for (i = 0; i < NBUCKET; i++) {\n    printf(\"%d: \", i);\n    for (e = table[i]; e != 0; e = e->next) {\n      printf(\"%d \", e->key);\n    }\n    printf(\"\\n\");\n  }\n}\n\nstatic void\ninsert(int key, int value, struct entry **p, struct entry *n)\n{\n  struct entry *e = malloc(sizeof(struct entry));\n  e->key = key;\n  e->value = value;\n  e->next = n;\n  *p = e;\n}\n\nstatic\nvoid put(int key, int value)\n{\n  int i = key % NBUCKET;\n  insert(key, value, &table[i], table[i]);\n}\n\nstatic struct entry*\nget(int key)\n{\n  struct entry *e = 0;\n  for (e = table[key % NBUCKET]; e != 0; e = e->next) {\n    if (e->key == key) break;\n  }\n  return e;\n}\n\nstatic void *\nthread(void *xa)\n{\n  long n = (long) xa;\n  int i;\n  int b = NKEYS/nthread;\n  int k = 0;\n  double t1, t0;\n\n  //  printf(\"b = %d\\n\", b);\n  t0 = now();\n  for (i = 0; i < b; i++) {\n    // printf(\"%d: put %d\\n\", n, b*n+i);\n    put(keys[b*n + i], n);\n  }\n  t1 = now();\n  printf(\"%ld: put time = %f\\n\", n, t1-t0);\n\n  // Should use pthread_barrier, but MacOS doesn't support it ...\n  __sync_fetch_and_add(&done, 1);\n  while (done < nthread) ;\n\n  t0 = now();\n  for (i = 0; i < NKEYS; i++) {\n    struct entry *e = get(keys[i]);\n    if (e == 0) k++;\n  }\n  t1 = now();\n  printf(\"%ld: get time = %f\\n\", n, t1-t0);\n  printf(\"%ld: %d keys missing\\n\", n, k);\n  return NULL;\n}\n\nint\nmain(int argc, char *argv[])\n{\n  pthread_t *tha;\n  void *value;\n  long i;\n  double t1, t0;\n\n  if (argc < 2) {\n    fprintf(stderr, \"%s: %s nthread\\n\", argv[0], argv[0]);\n    exit(-1);\n  }\n  nthread = atoi(argv[1]);\n  tha = malloc(sizeof(pthread_t) * nthread);\n  srandom(0);\n  assert(NKEYS % nthread == 0);\n  for (i = 0; i < NKEYS; i++) {\n    keys[i] = random();\n  }\n  t0 = now();\n  for(i = 0; i < nthread; i++) {\n    assert(pthread_create(&tha[i], NULL, thread, (void *) i) == 0);\n  }\n  for(i = 0; i < nthread; i++) {\n    assert(pthread_join(tha[i], &value) == 0);\n  }\n  t1 = now();\n  printf(\"completion time = %f\\n\", t1-t0);\n}\n```\n\n## 并行\n在4核机器上双线程运行程序：\n``` bash\n./a.out 2\n# 2：n_threads为在hash表上执行put和get操作的线程数\n```\n产生如果如下：\n```\n1: put time = 0.007442\n0: put time = 0.007474\n1: get time = 6.559389\n1: 1 keys missing\n0: get time = 6.567974\n0: 1. keys missing\ncompletion time = 6.575672\n```\n> 每个线程分两个阶段运行.在第一阶段`put`，每个线程将`[NKEYS/nthread]`key放入hash表.在第二阶段`get`，每个线程从hash表中获取`NKEYS`.输入结果为每个线程每个阶段花费多长时间，底部的完成时间为应用程序的总运行时间.在上面的输出中，应用程序的完成时间约为6.5秒.\n\n对比单线程，看双线程是否改进了性能：\n```\n./a.out 1\n0: put time = 0.016793\n0: get time = 5.447454\n0: 0 keys missing\ncompletion time = 5.464499\n```\n> 单线程情况（5.5s）的完成时间略小于双线程情况（6.5s），增加的运行时间应该在消耗线程切换上。但双线程在`get`阶段的总工作量是单线程的两倍.因此，双线程在两个内核上实现了两倍的并行加速，效果很好.`put`阶段实现了一些加速; 双线程并行地插入相同数量的key，比单线程多一倍.另外，还有一个问题；`1 keys missing`说明在双线程运行中，程序在阶段2找不到的阶段1中插入1个键.\n\n在4核机器上运行结果如下：\n```\n23: put time = 0.014067\n1: put time = 0.014450\n2: put time = 0.014245\n0: put time = 0.015714\n3: get time = 6.202647\n3: 45 keys missing\n0: get time = 6.211748\n0: 45 keys missing\n2: get time = 6.287174\n2: 45 keys missing\n1: get time = 6.306257\n1: 45 keys missing\ncompletion time = 6.322159\n```\n> 4线程完成时间与双线程大致相同，但是运行时间是双线程的两倍，实现了良好的并行性.但也发现缺失了更多的key的问题，相比较于单线程不会出现缺少key的问题.\n\n## 问题解决\n### key缺失原因\n为什么当两个或多个线程同时运行时，key开始丢失？考虑这样一种情况：假设线程A和B同时运行。如果两个线程同时插入同一个bucket的key，则可能会发生竞争。下面的事件概述将导致这样的结果的操作。\n```\nt-A: calls insert() on bucket 1 (key = 6, 6 % NBUCKETS = 1)\n\nt-B: calls insert() on bucket 1 (key = 21, 21 % NBUCKETS = 1)\n\n...\n\nt-A: executes e->next = n\n\nt-B: executes e->next = n\n\nt-A: executes *p = e\n\nt-B: executes *p = e\n```\n这样做的结果是执行的最后一个线程B有效地`*p = e`覆盖了前一个线程A的动作并设置了新的列表的头指针.按照上面的执行顺序，假设插入线程A的键6将会丢失，因为线程B覆盖了它。\n### **锁机制**\n为了避免上述事件的发生，即线程同时访问同一个资源，采用**锁机制**，给`put`和`get`加锁，实现线程的**互斥**.linux `pthread.h`提供的锁机制如下：\n``` c\npthread_mutex_t lock;     // declare a lock\npthread_mutex_init(&lock, NULL);   // initialize the lock\npthread_mutex_lock(&lock);  // acquire lock\npthread_mutex_unlock(&lock);  // release lock\n```\n首先想到的是给每一个`put`和`get`操作加锁，但发现这种结果导致多线程变成了线性运行，使得并行性降为0.然后发现`get`实际是读操作，不会对hash表进行写操作，在经典的读者-写着进程互斥问题中学到，读操作无需加锁，允许多个读操作并行执行，这样就在保证不出现key缺失的情况下提高了并行性。最后考虑`put`操作是对整个hash表加锁，实际上只需要给`put`操作访问的bucket加锁，而不是全局加锁，这使得其他`put`操作可以同时执行bucket的插入进一步提高了并行性。运行效果如下：\n```\n0: put time = 0.022744\n1: put time = 0.022521\n1: get time = 6.309178\n1: 0 keys missing\n0: get time = 6.323614\n0: 0 keys missing\ncompletion time = 6.350177\n```\n`ph.c`修改结果如下：\n``` c\n...\nint keys[NKEYS];\npthread_mutex_t bucket_locks[NBUCKET];\n...\nstatic\nvoid put(int key, int value)\n{\n  int i = key % NBUCKET;\n  pthread_mutex_lock(&bucket_locks[i]);\n  insert(key, value, &table[i], table[i]);\n  pthread_mutex_unlock(&bucket_locks[i]);\n}\n...\nint\nmain(int argc, char *argv[])\n{\n  pthread_t *tha;\n  void *value;\n  long i;\n  double t1, t0;\n\n  if (argc < 2) {\n    fprintf(stderr, \"%s: %s nthread\\n\", argv[0], argv[0]);\n    exit(-1);\n  }\n  nthread = atoi(argv[1]);\n  tha = malloc(sizeof(pthread_t) * nthread);\n  srandom(0);\n  assert(NKEYS % nthread == 0);\n  for (i = 0; i < NKEYS; i++) {\n    keys[i] = random();\n  }\n\n  //init lock for every bucket\n  for (i = 0; i < NBUCKET; i++) {\n    pthread_mutex_init(&bucket_locks[i], NULL);\n  }\n\n  t0 = now();\n  for(i = 0; i < nthread; i++) {\n    assert(pthread_create(&tha[i], NULL, thread, (void *) i) == 0);\n  }\n  for(i = 0; i < nthread; i++) {\n    assert(pthread_join(tha[i], &value) == 0);\n  }\n  t1 = now();\n  printf(\"completion time = %f\\n\", t1-t0);\n}\n```\n","slug":"hw6","published":1,"updated":"2017-08-26T03:38:21.614Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6sslhb6000v3gam8axyzqpx","content":"<h1 id=\"hw6-threads-and-locking\"><a href=\"#hw6-threads-and-locking\" class=\"headerlink\" title=\"hw6 threads and locking\"></a>hw6 threads and locking</h1><h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><p>在多线程OS中，通常是在一个进程中包括多个线程，每个线程都是作为利用CPU的基本单位，是花费最小开销的实体.OS中实现进程和线程提高系统的并行性，hw6探索使用线程和锁来并行编程Hash表.</p>\n<h2 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h2><p>hw6在多核硬件的os上即可编译运行，不依赖于课程的xv6.<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget https://pdos.csail.mit.edu/6.828/2016/homework/ph.c</div><div class=\"line\">gcc -g -02 ph.c -pthread</div></pre></td></tr></table></figure></p>\n<p>源程序（<code>ph.c</code>)如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;assert.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/time.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SOL</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NBUCKET 5</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NKEYS 100000</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">struct</span> entry &#123;</div><div class=\"line\">  <span class=\"keyword\">int</span> key;</div><div class=\"line\">  <span class=\"keyword\">int</span> value;</div><div class=\"line\">  <span class=\"keyword\">struct</span> entry *next;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">struct</span> entry *table[NBUCKET];</div><div class=\"line\"><span class=\"keyword\">int</span> keys[NKEYS];</div><div class=\"line\"><span class=\"keyword\">int</span> nthread = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> done;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span></span></div><div class=\"line\"><span class=\"title\">now</span><span class=\"params\">()</span></div><div class=\"line\">&#123;</div><div class=\"line\"> <span class=\"keyword\">struct</span> timeval tv;</div><div class=\"line\"> gettimeofday(&amp;tv, <span class=\"number\">0</span>);</div><div class=\"line\"> <span class=\"keyword\">return</span> tv.tv_sec + tv.tv_usec / <span class=\"number\">1000000.0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">int</span> i;</div><div class=\"line\">  <span class=\"keyword\">struct</span> entry *e;</div><div class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; NBUCKET; i++) &#123;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d: \"</span>, i);</div><div class=\"line\">    <span class=\"keyword\">for</span> (e = table[i]; e != <span class=\"number\">0</span>; e = e-&gt;next) &#123;</div><div class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>, e-&gt;key);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">insert</span><span class=\"params\">(<span class=\"keyword\">int</span> key, <span class=\"keyword\">int</span> value, <span class=\"keyword\">struct</span> entry **p, <span class=\"keyword\">struct</span> entry *n)</span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">struct</span> entry *e = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> entry));</div><div class=\"line\">  e-&gt;key = key;</div><div class=\"line\">  e-&gt;value = value;</div><div class=\"line\">  e-&gt;next = n;</div><div class=\"line\">  *p = e;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span></span></div><div class=\"line\"><span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(<span class=\"keyword\">int</span> key, <span class=\"keyword\">int</span> value)</span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">int</span> i = key % NBUCKET;</div><div class=\"line\">  insert(key, value, &amp;table[i], table[i]);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">struct</span> entry*</span></div><div class=\"line\"><span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> key)</span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">struct</span> entry *e = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span> (e = table[key % NBUCKET]; e != <span class=\"number\">0</span>; e = e-&gt;next) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (e-&gt;key == key) <span class=\"keyword\">break</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> e;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> *</span></div><div class=\"line\"><span class=\"title\">thread</span><span class=\"params\">(<span class=\"keyword\">void</span> *xa)</span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">long</span> n = (<span class=\"keyword\">long</span>) xa;</div><div class=\"line\">  <span class=\"keyword\">int</span> i;</div><div class=\"line\">  <span class=\"keyword\">int</span> b = NKEYS/nthread;</div><div class=\"line\">  <span class=\"keyword\">int</span> k = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">double</span> t1, t0;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//  printf(\"b = %d\\n\", b);</span></div><div class=\"line\">  t0 = now();</div><div class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; b; i++) &#123;</div><div class=\"line\">    <span class=\"comment\">// printf(\"%d: put %d\\n\", n, b*n+i);</span></div><div class=\"line\">    put(keys[b*n + i], n);</div><div class=\"line\">  &#125;</div><div class=\"line\">  t1 = now();</div><div class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"%ld: put time = %f\\n\"</span>, n, t1-t0);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Should use pthread_barrier, but MacOS doesn't support it ...</span></div><div class=\"line\">  __sync_fetch_and_add(&amp;done, <span class=\"number\">1</span>);</div><div class=\"line\">  <span class=\"keyword\">while</span> (done &lt; nthread) ;</div><div class=\"line\"></div><div class=\"line\">  t0 = now();</div><div class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; NKEYS; i++) &#123;</div><div class=\"line\">    <span class=\"keyword\">struct</span> entry *e = get(keys[i]);</div><div class=\"line\">    <span class=\"keyword\">if</span> (e == <span class=\"number\">0</span>) k++;</div><div class=\"line\">  &#125;</div><div class=\"line\">  t1 = now();</div><div class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"%ld: get time = %f\\n\"</span>, n, t1-t0);</div><div class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"%ld: %d keys missing\\n\"</span>, n, k);</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span></span></div><div class=\"line\"><span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">pthread_t</span> *tha;</div><div class=\"line\">  <span class=\"keyword\">void</span> *value;</div><div class=\"line\">  <span class=\"keyword\">long</span> i;</div><div class=\"line\">  <span class=\"keyword\">double</span> t1, t0;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (argc &lt; <span class=\"number\">2</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"%s: %s nthread\\n\"</span>, argv[<span class=\"number\">0</span>], argv[<span class=\"number\">0</span>]);</div><div class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">  nthread = atoi(argv[<span class=\"number\">1</span>]);</div><div class=\"line\">  tha = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">pthread_t</span>) * nthread);</div><div class=\"line\">  srandom(<span class=\"number\">0</span>);</div><div class=\"line\">  assert(NKEYS % nthread == <span class=\"number\">0</span>);</div><div class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; NKEYS; i++) &#123;</div><div class=\"line\">    keys[i] = random();</div><div class=\"line\">  &#125;</div><div class=\"line\">  t0 = now();</div><div class=\"line\">  <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; nthread; i++) &#123;</div><div class=\"line\">    assert(pthread_create(&amp;tha[i], <span class=\"literal\">NULL</span>, thread, (<span class=\"keyword\">void</span> *) i) == <span class=\"number\">0</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; nthread; i++) &#123;</div><div class=\"line\">    assert(pthread_join(tha[i], &amp;value) == <span class=\"number\">0</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">  t1 = now();</div><div class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"completion time = %f\\n\"</span>, t1-t0);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"并行\"><a href=\"#并行\" class=\"headerlink\" title=\"并行\"></a>并行</h2><p>在4核机器上双线程运行程序：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">./a.out 2</div><div class=\"line\"><span class=\"comment\"># 2：n_threads为在hash表上执行put和get操作的线程数</span></div></pre></td></tr></table></figure></p>\n<p>产生如果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">1: put time = 0.007442</div><div class=\"line\">0: put time = 0.007474</div><div class=\"line\">1: get time = 6.559389</div><div class=\"line\">1: 1 keys missing</div><div class=\"line\">0: get time = 6.567974</div><div class=\"line\">0: 1. keys missing</div><div class=\"line\">completion time = 6.575672</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>每个线程分两个阶段运行.在第一阶段<code>put</code>，每个线程将<code>[NKEYS/nthread]</code>key放入hash表.在第二阶段<code>get</code>，每个线程从hash表中获取<code>NKEYS</code>.输入结果为每个线程每个阶段花费多长时间，底部的完成时间为应用程序的总运行时间.在上面的输出中，应用程序的完成时间约为6.5秒.</p>\n</blockquote>\n<p>对比单线程，看双线程是否改进了性能：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">./a.out 1</div><div class=\"line\">0: put time = 0.016793</div><div class=\"line\">0: get time = 5.447454</div><div class=\"line\">0: 0 keys missing</div><div class=\"line\">completion time = 5.464499</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>单线程情况（5.5s）的完成时间略小于双线程情况（6.5s），增加的运行时间应该在消耗线程切换上。但双线程在<code>get</code>阶段的总工作量是单线程的两倍.因此，双线程在两个内核上实现了两倍的并行加速，效果很好.<code>put</code>阶段实现了一些加速; 双线程并行地插入相同数量的key，比单线程多一倍.另外，还有一个问题；<code>1 keys missing</code>说明在双线程运行中，程序在阶段2找不到的阶段1中插入1个键.</p>\n</blockquote>\n<p>在4核机器上运行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">23: put time = 0.014067</div><div class=\"line\">1: put time = 0.014450</div><div class=\"line\">2: put time = 0.014245</div><div class=\"line\">0: put time = 0.015714</div><div class=\"line\">3: get time = 6.202647</div><div class=\"line\">3: 45 keys missing</div><div class=\"line\">0: get time = 6.211748</div><div class=\"line\">0: 45 keys missing</div><div class=\"line\">2: get time = 6.287174</div><div class=\"line\">2: 45 keys missing</div><div class=\"line\">1: get time = 6.306257</div><div class=\"line\">1: 45 keys missing</div><div class=\"line\">completion time = 6.322159</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>4线程完成时间与双线程大致相同，但是运行时间是双线程的两倍，实现了良好的并行性.但也发现缺失了更多的key的问题，相比较于单线程不会出现缺少key的问题.</p>\n</blockquote>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"key缺失原因\"><a href=\"#key缺失原因\" class=\"headerlink\" title=\"key缺失原因\"></a>key缺失原因</h3><p>为什么当两个或多个线程同时运行时，key开始丢失？考虑这样一种情况：假设线程A和B同时运行。如果两个线程同时插入同一个bucket的key，则可能会发生竞争。下面的事件概述将导致这样的结果的操作。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">t-A: calls insert() on bucket 1 (key = 6, 6 % NBUCKETS = 1)</div><div class=\"line\"></div><div class=\"line\">t-B: calls insert() on bucket 1 (key = 21, 21 % NBUCKETS = 1)</div><div class=\"line\"></div><div class=\"line\">...</div><div class=\"line\"></div><div class=\"line\">t-A: executes e-&gt;next = n</div><div class=\"line\"></div><div class=\"line\">t-B: executes e-&gt;next = n</div><div class=\"line\"></div><div class=\"line\">t-A: executes *p = e</div><div class=\"line\"></div><div class=\"line\">t-B: executes *p = e</div></pre></td></tr></table></figure></p>\n<p>这样做的结果是执行的最后一个线程B有效地<code>*p = e</code>覆盖了前一个线程A的动作并设置了新的列表的头指针.按照上面的执行顺序，假设插入线程A的键6将会丢失，因为线程B覆盖了它。</p>\n<h3 id=\"锁机制\"><a href=\"#锁机制\" class=\"headerlink\" title=\"锁机制\"></a><strong>锁机制</strong></h3><p>为了避免上述事件的发生，即线程同时访问同一个资源，采用<strong>锁机制</strong>，给<code>put</code>和<code>get</code>加锁，实现线程的<strong>互斥</strong>.linux <code>pthread.h</code>提供的锁机制如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">pthread_mutex_t</span> lock;     <span class=\"comment\">// declare a lock</span></div><div class=\"line\">pthread_mutex_init(&amp;lock, <span class=\"literal\">NULL</span>);   <span class=\"comment\">// initialize the lock</span></div><div class=\"line\">pthread_mutex_lock(&amp;lock);  <span class=\"comment\">// acquire lock</span></div><div class=\"line\">pthread_mutex_unlock(&amp;lock);  <span class=\"comment\">// release lock</span></div></pre></td></tr></table></figure></p>\n<p>首先想到的是给每一个<code>put</code>和<code>get</code>操作加锁，但发现这种结果导致多线程变成了线性运行，使得并行性降为0.然后发现<code>get</code>实际是读操作，不会对hash表进行写操作，在经典的读者-写着进程互斥问题中学到，读操作无需加锁，允许多个读操作并行执行，这样就在保证不出现key缺失的情况下提高了并行性。最后考虑<code>put</code>操作是对整个hash表加锁，实际上只需要给<code>put</code>操作访问的bucket加锁，而不是全局加锁，这使得其他<code>put</code>操作可以同时执行bucket的插入进一步提高了并行性。运行效果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">0: put time = 0.022744</div><div class=\"line\">1: put time = 0.022521</div><div class=\"line\">1: get time = 6.309178</div><div class=\"line\">1: 0 keys missing</div><div class=\"line\">0: get time = 6.323614</div><div class=\"line\">0: 0 keys missing</div><div class=\"line\">completion time = 6.350177</div></pre></td></tr></table></figure></p>\n<p><code>ph.c</code>修改结果如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\"><span class=\"keyword\">int</span> keys[NKEYS];</div><div class=\"line\"><span class=\"keyword\">pthread_mutex_t</span> bucket_locks[NBUCKET];</div><div class=\"line\">...</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span></span></div><div class=\"line\"><span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(<span class=\"keyword\">int</span> key, <span class=\"keyword\">int</span> value)</span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">int</span> i = key % NBUCKET;</div><div class=\"line\">  pthread_mutex_lock(&amp;bucket_locks[i]);</div><div class=\"line\">  insert(key, value, &amp;table[i], table[i]);</div><div class=\"line\">  pthread_mutex_unlock(&amp;bucket_locks[i]);</div><div class=\"line\">&#125;</div><div class=\"line\">...</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span></span></div><div class=\"line\"><span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">pthread_t</span> *tha;</div><div class=\"line\">  <span class=\"keyword\">void</span> *value;</div><div class=\"line\">  <span class=\"keyword\">long</span> i;</div><div class=\"line\">  <span class=\"keyword\">double</span> t1, t0;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (argc &lt; <span class=\"number\">2</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"%s: %s nthread\\n\"</span>, argv[<span class=\"number\">0</span>], argv[<span class=\"number\">0</span>]);</div><div class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">  nthread = atoi(argv[<span class=\"number\">1</span>]);</div><div class=\"line\">  tha = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">pthread_t</span>) * nthread);</div><div class=\"line\">  srandom(<span class=\"number\">0</span>);</div><div class=\"line\">  assert(NKEYS % nthread == <span class=\"number\">0</span>);</div><div class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; NKEYS; i++) &#123;</div><div class=\"line\">    keys[i] = random();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//init lock for every bucket</span></div><div class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; NBUCKET; i++) &#123;</div><div class=\"line\">    pthread_mutex_init(&amp;bucket_locks[i], <span class=\"literal\">NULL</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  t0 = now();</div><div class=\"line\">  <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; nthread; i++) &#123;</div><div class=\"line\">    assert(pthread_create(&amp;tha[i], <span class=\"literal\">NULL</span>, thread, (<span class=\"keyword\">void</span> *) i) == <span class=\"number\">0</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; nthread; i++) &#123;</div><div class=\"line\">    assert(pthread_join(tha[i], &amp;value) == <span class=\"number\">0</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">  t1 = now();</div><div class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"completion time = %f\\n\"</span>, t1-t0);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"hw6-threads-and-locking\"><a href=\"#hw6-threads-and-locking\" class=\"headerlink\" title=\"hw6 threads and locking\"></a>hw6 threads and locking</h1><h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><p>在多线程OS中，通常是在一个进程中包括多个线程，每个线程都是作为利用CPU的基本单位，是花费最小开销的实体.OS中实现进程和线程提高系统的并行性，hw6探索使用线程和锁来并行编程Hash表.</p>\n<h2 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h2><p>hw6在多核硬件的os上即可编译运行，不依赖于课程的xv6.<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget https://pdos.csail.mit.edu/6.828/2016/homework/ph.c</div><div class=\"line\">gcc -g -02 ph.c -pthread</div></pre></td></tr></table></figure></p>\n<p>源程序（<code>ph.c</code>)如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;assert.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;sys/time.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SOL</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NBUCKET 5</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NKEYS 100000</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">struct</span> entry &#123;</div><div class=\"line\">  <span class=\"keyword\">int</span> key;</div><div class=\"line\">  <span class=\"keyword\">int</span> value;</div><div class=\"line\">  <span class=\"keyword\">struct</span> entry *next;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">struct</span> entry *table[NBUCKET];</div><div class=\"line\"><span class=\"keyword\">int</span> keys[NKEYS];</div><div class=\"line\"><span class=\"keyword\">int</span> nthread = <span class=\"number\">1</span>;</div><div class=\"line\"><span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> done;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span></span></div><div class=\"line\"><span class=\"title\">now</span><span class=\"params\">()</span></div><div class=\"line\">&#123;</div><div class=\"line\"> <span class=\"keyword\">struct</span> timeval tv;</div><div class=\"line\"> gettimeofday(&amp;tv, <span class=\"number\">0</span>);</div><div class=\"line\"> <span class=\"keyword\">return</span> tv.tv_sec + tv.tv_usec / <span class=\"number\">1000000.0</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">print</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">int</span> i;</div><div class=\"line\">  <span class=\"keyword\">struct</span> entry *e;</div><div class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; NBUCKET; i++) &#123;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d: \"</span>, i);</div><div class=\"line\">    <span class=\"keyword\">for</span> (e = table[i]; e != <span class=\"number\">0</span>; e = e-&gt;next) &#123;</div><div class=\"line\">      <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d \"</span>, e-&gt;key);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">insert</span><span class=\"params\">(<span class=\"keyword\">int</span> key, <span class=\"keyword\">int</span> value, <span class=\"keyword\">struct</span> entry **p, <span class=\"keyword\">struct</span> entry *n)</span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">struct</span> entry *e = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> entry));</div><div class=\"line\">  e-&gt;key = key;</div><div class=\"line\">  e-&gt;value = value;</div><div class=\"line\">  e-&gt;next = n;</div><div class=\"line\">  *p = e;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span></span></div><div class=\"line\"><span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(<span class=\"keyword\">int</span> key, <span class=\"keyword\">int</span> value)</span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">int</span> i = key % NBUCKET;</div><div class=\"line\">  insert(key, value, &amp;table[i], table[i]);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">struct</span> entry*</span></div><div class=\"line\"><span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> key)</span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">struct</span> entry *e = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">for</span> (e = table[key % NBUCKET]; e != <span class=\"number\">0</span>; e = e-&gt;next) &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (e-&gt;key == key) <span class=\"keyword\">break</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> e;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span> *</span></div><div class=\"line\"><span class=\"title\">thread</span><span class=\"params\">(<span class=\"keyword\">void</span> *xa)</span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">long</span> n = (<span class=\"keyword\">long</span>) xa;</div><div class=\"line\">  <span class=\"keyword\">int</span> i;</div><div class=\"line\">  <span class=\"keyword\">int</span> b = NKEYS/nthread;</div><div class=\"line\">  <span class=\"keyword\">int</span> k = <span class=\"number\">0</span>;</div><div class=\"line\">  <span class=\"keyword\">double</span> t1, t0;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//  printf(\"b = %d\\n\", b);</span></div><div class=\"line\">  t0 = now();</div><div class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; b; i++) &#123;</div><div class=\"line\">    <span class=\"comment\">// printf(\"%d: put %d\\n\", n, b*n+i);</span></div><div class=\"line\">    put(keys[b*n + i], n);</div><div class=\"line\">  &#125;</div><div class=\"line\">  t1 = now();</div><div class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"%ld: put time = %f\\n\"</span>, n, t1-t0);</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">// Should use pthread_barrier, but MacOS doesn't support it ...</span></div><div class=\"line\">  __sync_fetch_and_add(&amp;done, <span class=\"number\">1</span>);</div><div class=\"line\">  <span class=\"keyword\">while</span> (done &lt; nthread) ;</div><div class=\"line\"></div><div class=\"line\">  t0 = now();</div><div class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; NKEYS; i++) &#123;</div><div class=\"line\">    <span class=\"keyword\">struct</span> entry *e = get(keys[i]);</div><div class=\"line\">    <span class=\"keyword\">if</span> (e == <span class=\"number\">0</span>) k++;</div><div class=\"line\">  &#125;</div><div class=\"line\">  t1 = now();</div><div class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"%ld: get time = %f\\n\"</span>, n, t1-t0);</div><div class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"%ld: %d keys missing\\n\"</span>, n, k);</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span></span></div><div class=\"line\"><span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">pthread_t</span> *tha;</div><div class=\"line\">  <span class=\"keyword\">void</span> *value;</div><div class=\"line\">  <span class=\"keyword\">long</span> i;</div><div class=\"line\">  <span class=\"keyword\">double</span> t1, t0;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (argc &lt; <span class=\"number\">2</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"%s: %s nthread\\n\"</span>, argv[<span class=\"number\">0</span>], argv[<span class=\"number\">0</span>]);</div><div class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">  nthread = atoi(argv[<span class=\"number\">1</span>]);</div><div class=\"line\">  tha = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">pthread_t</span>) * nthread);</div><div class=\"line\">  srandom(<span class=\"number\">0</span>);</div><div class=\"line\">  assert(NKEYS % nthread == <span class=\"number\">0</span>);</div><div class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; NKEYS; i++) &#123;</div><div class=\"line\">    keys[i] = random();</div><div class=\"line\">  &#125;</div><div class=\"line\">  t0 = now();</div><div class=\"line\">  <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; nthread; i++) &#123;</div><div class=\"line\">    assert(pthread_create(&amp;tha[i], <span class=\"literal\">NULL</span>, thread, (<span class=\"keyword\">void</span> *) i) == <span class=\"number\">0</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; nthread; i++) &#123;</div><div class=\"line\">    assert(pthread_join(tha[i], &amp;value) == <span class=\"number\">0</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">  t1 = now();</div><div class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"completion time = %f\\n\"</span>, t1-t0);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"并行\"><a href=\"#并行\" class=\"headerlink\" title=\"并行\"></a>并行</h2><p>在4核机器上双线程运行程序：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">./a.out 2</div><div class=\"line\"><span class=\"comment\"># 2：n_threads为在hash表上执行put和get操作的线程数</span></div></pre></td></tr></table></figure></p>\n<p>产生如果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">1: put time = 0.007442</div><div class=\"line\">0: put time = 0.007474</div><div class=\"line\">1: get time = 6.559389</div><div class=\"line\">1: 1 keys missing</div><div class=\"line\">0: get time = 6.567974</div><div class=\"line\">0: 1. keys missing</div><div class=\"line\">completion time = 6.575672</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>每个线程分两个阶段运行.在第一阶段<code>put</code>，每个线程将<code>[NKEYS/nthread]</code>key放入hash表.在第二阶段<code>get</code>，每个线程从hash表中获取<code>NKEYS</code>.输入结果为每个线程每个阶段花费多长时间，底部的完成时间为应用程序的总运行时间.在上面的输出中，应用程序的完成时间约为6.5秒.</p>\n</blockquote>\n<p>对比单线程，看双线程是否改进了性能：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">./a.out 1</div><div class=\"line\">0: put time = 0.016793</div><div class=\"line\">0: get time = 5.447454</div><div class=\"line\">0: 0 keys missing</div><div class=\"line\">completion time = 5.464499</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>单线程情况（5.5s）的完成时间略小于双线程情况（6.5s），增加的运行时间应该在消耗线程切换上。但双线程在<code>get</code>阶段的总工作量是单线程的两倍.因此，双线程在两个内核上实现了两倍的并行加速，效果很好.<code>put</code>阶段实现了一些加速; 双线程并行地插入相同数量的key，比单线程多一倍.另外，还有一个问题；<code>1 keys missing</code>说明在双线程运行中，程序在阶段2找不到的阶段1中插入1个键.</p>\n</blockquote>\n<p>在4核机器上运行结果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">23: put time = 0.014067</div><div class=\"line\">1: put time = 0.014450</div><div class=\"line\">2: put time = 0.014245</div><div class=\"line\">0: put time = 0.015714</div><div class=\"line\">3: get time = 6.202647</div><div class=\"line\">3: 45 keys missing</div><div class=\"line\">0: get time = 6.211748</div><div class=\"line\">0: 45 keys missing</div><div class=\"line\">2: get time = 6.287174</div><div class=\"line\">2: 45 keys missing</div><div class=\"line\">1: get time = 6.306257</div><div class=\"line\">1: 45 keys missing</div><div class=\"line\">completion time = 6.322159</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>4线程完成时间与双线程大致相同，但是运行时间是双线程的两倍，实现了良好的并行性.但也发现缺失了更多的key的问题，相比较于单线程不会出现缺少key的问题.</p>\n</blockquote>\n<h2 id=\"问题解决\"><a href=\"#问题解决\" class=\"headerlink\" title=\"问题解决\"></a>问题解决</h2><h3 id=\"key缺失原因\"><a href=\"#key缺失原因\" class=\"headerlink\" title=\"key缺失原因\"></a>key缺失原因</h3><p>为什么当两个或多个线程同时运行时，key开始丢失？考虑这样一种情况：假设线程A和B同时运行。如果两个线程同时插入同一个bucket的key，则可能会发生竞争。下面的事件概述将导致这样的结果的操作。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">t-A: calls insert() on bucket 1 (key = 6, 6 % NBUCKETS = 1)</div><div class=\"line\"></div><div class=\"line\">t-B: calls insert() on bucket 1 (key = 21, 21 % NBUCKETS = 1)</div><div class=\"line\"></div><div class=\"line\">...</div><div class=\"line\"></div><div class=\"line\">t-A: executes e-&gt;next = n</div><div class=\"line\"></div><div class=\"line\">t-B: executes e-&gt;next = n</div><div class=\"line\"></div><div class=\"line\">t-A: executes *p = e</div><div class=\"line\"></div><div class=\"line\">t-B: executes *p = e</div></pre></td></tr></table></figure></p>\n<p>这样做的结果是执行的最后一个线程B有效地<code>*p = e</code>覆盖了前一个线程A的动作并设置了新的列表的头指针.按照上面的执行顺序，假设插入线程A的键6将会丢失，因为线程B覆盖了它。</p>\n<h3 id=\"锁机制\"><a href=\"#锁机制\" class=\"headerlink\" title=\"锁机制\"></a><strong>锁机制</strong></h3><p>为了避免上述事件的发生，即线程同时访问同一个资源，采用<strong>锁机制</strong>，给<code>put</code>和<code>get</code>加锁，实现线程的<strong>互斥</strong>.linux <code>pthread.h</code>提供的锁机制如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">pthread_mutex_t</span> lock;     <span class=\"comment\">// declare a lock</span></div><div class=\"line\">pthread_mutex_init(&amp;lock, <span class=\"literal\">NULL</span>);   <span class=\"comment\">// initialize the lock</span></div><div class=\"line\">pthread_mutex_lock(&amp;lock);  <span class=\"comment\">// acquire lock</span></div><div class=\"line\">pthread_mutex_unlock(&amp;lock);  <span class=\"comment\">// release lock</span></div></pre></td></tr></table></figure></p>\n<p>首先想到的是给每一个<code>put</code>和<code>get</code>操作加锁，但发现这种结果导致多线程变成了线性运行，使得并行性降为0.然后发现<code>get</code>实际是读操作，不会对hash表进行写操作，在经典的读者-写着进程互斥问题中学到，读操作无需加锁，允许多个读操作并行执行，这样就在保证不出现key缺失的情况下提高了并行性。最后考虑<code>put</code>操作是对整个hash表加锁，实际上只需要给<code>put</code>操作访问的bucket加锁，而不是全局加锁，这使得其他<code>put</code>操作可以同时执行bucket的插入进一步提高了并行性。运行效果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">0: put time = 0.022744</div><div class=\"line\">1: put time = 0.022521</div><div class=\"line\">1: get time = 6.309178</div><div class=\"line\">1: 0 keys missing</div><div class=\"line\">0: get time = 6.323614</div><div class=\"line\">0: 0 keys missing</div><div class=\"line\">completion time = 6.350177</div></pre></td></tr></table></figure></p>\n<p><code>ph.c</code>修改结果如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\"><span class=\"keyword\">int</span> keys[NKEYS];</div><div class=\"line\"><span class=\"keyword\">pthread_mutex_t</span> bucket_locks[NBUCKET];</div><div class=\"line\">...</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span></span></div><div class=\"line\"><span class=\"keyword\">void</span> <span class=\"title\">put</span><span class=\"params\">(<span class=\"keyword\">int</span> key, <span class=\"keyword\">int</span> value)</span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">int</span> i = key % NBUCKET;</div><div class=\"line\">  pthread_mutex_lock(&amp;bucket_locks[i]);</div><div class=\"line\">  insert(key, value, &amp;table[i], table[i]);</div><div class=\"line\">  pthread_mutex_unlock(&amp;bucket_locks[i]);</div><div class=\"line\">&#125;</div><div class=\"line\">...</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span></span></div><div class=\"line\"><span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> *argv[])</span></div><div class=\"line\">&#123;</div><div class=\"line\">  <span class=\"keyword\">pthread_t</span> *tha;</div><div class=\"line\">  <span class=\"keyword\">void</span> *value;</div><div class=\"line\">  <span class=\"keyword\">long</span> i;</div><div class=\"line\">  <span class=\"keyword\">double</span> t1, t0;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span> (argc &lt; <span class=\"number\">2</span>) &#123;</div><div class=\"line\">    <span class=\"built_in\">fprintf</span>(<span class=\"built_in\">stderr</span>, <span class=\"string\">\"%s: %s nthread\\n\"</span>, argv[<span class=\"number\">0</span>], argv[<span class=\"number\">0</span>]);</div><div class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">  nthread = atoi(argv[<span class=\"number\">1</span>]);</div><div class=\"line\">  tha = <span class=\"built_in\">malloc</span>(<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">pthread_t</span>) * nthread);</div><div class=\"line\">  srandom(<span class=\"number\">0</span>);</div><div class=\"line\">  assert(NKEYS % nthread == <span class=\"number\">0</span>);</div><div class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; NKEYS; i++) &#123;</div><div class=\"line\">    keys[i] = random();</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//init lock for every bucket</span></div><div class=\"line\">  <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; NBUCKET; i++) &#123;</div><div class=\"line\">    pthread_mutex_init(&amp;bucket_locks[i], <span class=\"literal\">NULL</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  t0 = now();</div><div class=\"line\">  <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; nthread; i++) &#123;</div><div class=\"line\">    assert(pthread_create(&amp;tha[i], <span class=\"literal\">NULL</span>, thread, (<span class=\"keyword\">void</span> *) i) == <span class=\"number\">0</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; nthread; i++) &#123;</div><div class=\"line\">    assert(pthread_join(tha[i], &amp;value) == <span class=\"number\">0</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">  t1 = now();</div><div class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">\"completion time = %f\\n\"</span>, t1-t0);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n"},{"title":"lab1-boot-pc","date":"2017-04-09T16:00:00.000Z","_content":"\n# Lab1 启动pc\n## lab1分为三部分\n> 1.熟悉x86汇编语言，qemu x86模拟器，启动pc\n2.分学习6.828内核的boot loader部分。\n3.深入研究6.828内核JOS的初始化部分，该部分代码在kernel目录下\n\n\n## 1. 实验代码下载\n```bash\ngit clone https://pdos.csail.mit.edu/6.828/2016/jos.git lab\ncd lab\n```\n## 2. part1 启动pc\n### 启动 qemu\n> ` make qemu`\n![make qemu](./boot.png)\n现在JOS内核只有两条命令来监视内核。help和kerninfo\n![kerninfo](./kerninfo.png)\n\n<!-- more -->\n\n### PC物理地址空间\n```\n+------------------+  <- 0xFFFFFFFF (4GB)\n|      32-bit      |\n|  memory mapped   |\n|     devices      |\n|                  |\n/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\\n\n/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\\n|                  |\n|      Unused      |\n|                  |\n+------------------+  <- depends on amount of RAM\n|                  |\n|                  |\n| Extended Memory  |\n|                  |\n|                  |\n+------------------+  <- 0x00100000 (1MB)\n|     BIOS ROM     |\n+------------------+  <- 0x000F0000 (960KB)\n|  16-bit devices, |\n|  expansion ROMs  |\n+------------------+  <- 0x000C0000 (768KB)\n|   VGA Display    |\n+------------------+  <- 0x000A0000 (640KB)\n|                  |\n|    Low Memory    |\n|                  |\n+------------------+  <- 0x00000000\n```\n>　　早期基于16位Intel 8088处理器只能操作1MB物理内存，因此物理地址空间起始于0x00000000到0x000FFFFF，其中640KB为 Low memory，这只能被随机存储器(RAM)使用。\n　　从 0x000A0000 到 0x000FFFFF的384KB留着给特殊使用，例如作为视频显示缓存或者储存在非易失存储器的硬件。从 0x000F0000 到 0x000FFFFF 占据64KB区域的部分是最重要的BIOS.\n　　现在的x86处理器支持超过4GB的物理RAM，所以RAM扩展到了0xFFFFFFFF。当然，BIOS也流出了开始的32位寻址空间为了让32位的设备映射。JOS这里只用开始的256MB，所以假设PC只有32位地址空间。\n\n### **BIOS**\n> 在一个终端中输入 make qemu-gdb, 另一个终端输入 make gdb.开始调试程序。\n> ```asm\n[f000:fff0] 0xffff0: ljmp 0xf000, 0xe05b\n> ```\n> 上面是GDB反汇编出的第一条执行指令，这条指令表面了：\nIBM PC 执行的起始物理地址为 0x000ffff0,PC 的偏移方式为 CS = 0xf000，IP = 0xfff0.第一条指令执行的是 jmp指令，跳转到段地址 CS = 0xf000，IP = 0xe05b\nQEMU模拟了8088处理器的启动，当启动电源，BIOS最先控制机器，这时还没有其他程序执行，之后处理器进入实模式也就是设置 CS 为 0xf000，IP 为 0xfff0。在启动电源也就是实模式时，地址转译根据这个公式工作：物理地址 = 16 * 段地址 + 偏移量。所以 PC 中 CS 为 0xf000 IP 为 0xfff0 的物理地址为：\n   16 * 0xf000 + 0xfff0   # 十六进制中乘16,左移4位\n   = 0xf0000 + 0xfff0\n   = 0xffff0\n0xffff0 在 BIOS (0x100000) 的结束地址之前。\n当BIOS启动，它设置了一个中断描述符表并初始化多个设备比如VGA显示器。在初始化PCI总线和所有重要的设备之后，它寻找可引导的设备，之后读取boot loader 并转移控制。\n\n## Part 2: The Boot Loader\n> 512 byte是区域的扇区是硬盘最小调度单位，每次读或写操作都至少是一个扇区，并且还会进行对齐。BIOS加载引导扇区到内存中是从物理地址0x7c00到0x7dff，然后使用jmp指令设置 CS:IP 为 0000:7c00。因此 boot loader 不能超过512字节，它执行两个功能：\n>> 1. boot loader 切换处理器从实模式到保护模式，这样能访问大于1MB的物理地址空间。\n2. boot loader 从硬盘中读取内核。\n\n### Boot\n> 通过 `b *0x7c00`设置断点，接着`c`运行到断点处，使用`x/i` 来查看当前的指令。\n\n> 在哪执行了32位代码？\n>>`[0:7c2d] => 0x7c2d: ljmp $0x8,$0x7c32 `这条指令之后，即boot.S 中的 `ljmp $PROT_MODE_CSEG, $protcseg` ，地址符号就变成` 0x7c32 `了。\n\n> 最后一条 boot loader 指令后, 执行第一条内核指令在哪里？\n>> boot loader 最后一步是加载kernel，所以在 boot/main.c 中可以找到 \n>> ```c\n\\* call the entry point from the ELF header\n((void (*)(void)) (ELFHDR->e_entry))()\n```\n>表明这是准备读取ELF头。\n通过 `objdump -x obj/kern/kernel `可以查看kernel的信息，开头为` start address 0x0010000c`，通过 `b *0x10000c`然后在` c` 能得到执行的指令是 `movw $0x1234,0x472`.\n\n>第一条kernel指令在哪里\n>> 同上一条的问题，存在kern/entry.S中。\n\n> 设置一个断点在地址0x7c00处，这是boot sector被加载的位置。然后让程序继续运行直到这个断点。跟踪/boot/boot.S文件的每一条指令，同时使用boot.S文件和系统为你反汇编出来的文件obj/boot/boot.asm.也可以使用GDB的x/i指令来获取去任意一个机器指令的反汇编指令，把源文件boot.S文件和boot.asm文件以及在GDB反汇编出来的指令进行比较。\n追踪到bootmain函数中，而且还要具体追踪到readsect()子函数里面。找出和readsect()c语言程序的每一条语句所对应的汇编指令，回到bootmain()，然后找出把内核文件从磁盘读取到内存的那个for循环所对应的汇编语句。找出当循环结束后会执行哪条语句，在那里设置断点，继续运行到断点，然后运行完所有的剩下的语句。\n\n> boot.S\n```asm\nstart:\n  .code16                     # 16位汇编模式\n  cli                         # 关中断\n  cld                         # 操作方向标志位DF，使DF=0。\n```\n>```asm\n  lgdt    gdtdesc\n  movl    %cr0, %eax\n  orl     $CR0_PE_ON, %eax\n  movl    %eax, %cr0\n# 切换到保护模式后，加载GDT(Global Descriptor Table)，接着修改了cr0寄存器的值，$CR0_PE_ON值为0x1，代表启动保护模式的flag标志。\n```\n>```asm\n  movl    $start, %esp\n  call bootmain\n  # 设置栈指针，接着开始调用bootmain函数。\n```\n>```asm\n    7d15:    55                       push   %ebp\n    7d16:    89 e5                    mov    %esp,%ebp\n    7d18:    56                       push   %esi\n    7d19:    53                       push   %ebx\n    # 参数压栈, 准备进入函数\n```\n>```asm\n    // read 1st page off disk\n    readseg((uint32_t) ELFHDR, SECTSIZE*8, 0);\n    7d1a:    6a 00                    push   $0x0\n    7d1c:    68 00 10 00 00           push   $0x1000\n    7d21:    68 00 00 01 00           push   $0x10000\n    7d26:    e8 b1 ff ff ff           call   7cdc <readseg>\n    # 调用readseg函数，对应3个参数(物理地址，页的大小，偏移量)\n```\n>```asm\n0x7ceb: shr $0x9,%edi \n# 执行 offset = (offset / SECTSIZE) + 1, 除法求出扇区号。\n0x7cee: add %ebx,%esi \n# 执行 end_pa = pa + count, 计算这个扇区结束的物理地址。\n0x7cf0: inc %edi \n# 执行了 offset = (offset / SECTSIZE) + 1中的加1。\n0x7cf1: and $0xfffffe00,%ebx \n# 执行了 pa &= ~(SECTSIZE - 1);。\n0x7cf7:    cmp    %esi,%ebx\n0x7cf9:    jae    0x7d0d\n# 执行 while (pa < end_pa) 循环判断语句。\n```\n>```asm\n# 加载程序段\n7d3a:    a1 1c 00 01 00           mov    0x1001c,%eax\n7d3f:    0f b7 35 2c 00 01 00     movzwl 0x1002c,%esi\n7d46:    8d 98 00 00 01 00        lea    0x10000(%eax),%ebx\n7d4c:    c1 e6 05                 shl    $0x5,%esi\n7d4f:    01 de                    add    %ebx,%esi\n# 接着循环调用readseg函数，将Program Header Table中表项读入内存。\n# 最后加载内核\n((void (*)(void)) (ELFHDR->e_entry))();\n```\n\n### 加载内核\n> 　　为了理解 boot/main.c，需要了解ELF二进制文件。编译并链接比如JOS内核这样的C程序，编译器会将源文件(.c)转为包含汇编指令的目标文件(.o)。接着链接器把所有的目标文件组合成一个单独的二进制镜像（binary image），比如 obj/kern/kernel，这种文件就是ELF(是可执行可链接形式的缩写)。\n　　当前只需要知道，可执行的ELF文件由带有加载信息的头，多个程序段表组成。每个程序段表是一个连续代码块或者数据，它们要被加载到内存具体地址中。boot loader 不修改源码和数据，直接加载到内存中并运行。\n　　ELF开头是固定长度的ELF头，之后是一个可变长度的程序头，它列出了需要加载的程序段。ELF头的定义在 inc/elf.h 中。主要学习以下3个程序段：\n>>.text: 程序执行指令\n.rodata:只读数据，比如ASCII字符串\n.data: 存放程序初始化的数据段，比如有初始值的全局变量。\n\n>　　当链接器计算程序内存布局时，会在内存里紧挨着.data段的.bss段中保留空间给未初始化的全局变量。C规定未初始化的全局变量为0。因此没必要在ELF的.bss段储存内容，链接器只储存了.bss段的地址和大小。\n使用 `objdump -h obj/kern/kernel `可以查看ELF头的相关信息。\n　　重点关注 .text段 的VMA(链接地址)和LMA(加载地址)，段的加载地址即加载进内存的地址。段的链接地址就是这个段预计在内存中执行的地址。\n　　回到 boot/main.c， ph->p_pa是每个程序头包含的段目的物理地址。BIOS把引导扇区加载到内存地址0x7c00，这也就是引导扇区的加载地址和链接地址。在 boot/Makefrag 中，是通过传 -Ttext 0x7C00 这个参数给链接程序设置了链接地址，因此链接程序在生成的代码中产生正确的内存地址。\n\n\n## Part 3: The Kernel\n### 使用虚拟内存\n> 　　boot loader 的链接地址和加载地址是一样的，然而 kernel 的链接地址和加载地址有些差异。查看 kern/kernel.ld 可以发现内核地址在 0xF0100000。\n　　操作系统内核通常被链接并且运行在非常高的虚拟地址，比如文件里看到的 0xf0100000，为了让处理器虚拟地址空间的低地址部分给用户程序使用。\n许多机器没有地址为 0xf0100000的物理内存，所以内核不能放在那儿。因此使用处理器内存管理硬件将虚拟地址 0xf0100000 (内核希望运行的链接地址)映射到物理地址 0x00100000 (boot loader加载内核后所放的物理地址)。尽管内核虚拟地址很高，但加载进物理地址位于1MB的地方仅仅高于BIOS的ROM。这需要PC至少有1MB的物理内存。\n在下一个lab，会映射物理地址空间底部256MB，也就是 0x00000000 到 0x0fffffff，到虚拟地址0xf0000000~0xffffffff。所以JOS只使用物理内存开始的256MB。\n　　目前，只是映射了物理内存开始的4MB， 使用手写的静态初始化页目录和也表在 kern/entrypgdir.c。当 kern/entry.S 设置 CR0_PG 标记，存储器引用就变为虚拟地址，即存储器引用是由虚拟存储器硬件转换为物理地址的虚拟地址。entry_pgdir 将虚拟地址 0xf0000000 ~ 0xf0400000 转换为物理地址 0x00000000 ~ 0x00400000，虚拟地址 0x00000000 ~ 0x00400000 也转换为物理地址 0x00000000 ~ 0x00400000。任何不在这两个范围内的虚拟地址会导致硬件异常。\n\n### 堆栈\n> C语言是如何在x86框架上使用堆栈的?需要查看指令寄存器(IP)的值的变化。\n研究内核是在哪初始化堆栈，找出堆栈存放在内存的位置。内核是如何保存一块空间给堆栈的？堆栈指针指向这块区域的哪儿？\n看了几个文件以后，发现在 kern/entry.S 中提到了设置堆指针和栈指针。\n> ```asm\n    # Clear the frame pointer register (EBP)\n    # so that once we get into debugging C code,\n    # stack backtraces will be terminated properly.\n    movl    $0x0,%ebp            # nuke frame pointer\n\n    # Set the stack pointer\n    movl    $(bootstacktop),%esp\n```\n> 为了查看堆的位置，所以要使用gdb，同样还是` b *0x10000c `打断点进入 entry。 si 一步步执行，在 `0x10002d: jmp *%eax `之后，下一条指令变为 `0xf010002f <relocated>: mov $0x0,%ebp`。其实地址应该还是 `0x10002f`，所以这里的 `0xf010002f `是因为开启的虚拟地址。\n通过 gdb 发现 `0xf0100034 <relocated+5>: mov $0xf0110000,%esp`， 也就是说%esp也就是bootstacktop的值为0xf0110000。其中 kern/entry.S 的 KSTKSIZE 应该就是堆栈的大小，通过跳转，发现在 inc/memlayout.h 里提到了堆栈。\n```c\n// Kernel stack.\n#define KSTACKTOP    KERNBASE\n#define KSTKSIZE    (8*PGSIZE)           // size of a kernel stack\n#define KSTKGAP        (8*PGSIZE)           // size of a kernel stack guard\n# PGSIZE 定义在 inc/mmu.h 中，值为 4096，所以 KSTKSIZE 为 32KB。 使用 info registers可以查出esp和ebp的值。最高地址为bootstacktop的值，也就是0xf0110000。\n```\n\n##  参考链接\n> * [boot pc](https://pdos.csail.mit.edu/6.828/2016/labs/lab1/)","source":"_posts/lab1.md","raw":"title: lab1-boot-pc\ndate: 2017/04/10\ntags:\n - xv6\n - os\n\n---\n\n# Lab1 启动pc\n## lab1分为三部分\n> 1.熟悉x86汇编语言，qemu x86模拟器，启动pc\n2.分学习6.828内核的boot loader部分。\n3.深入研究6.828内核JOS的初始化部分，该部分代码在kernel目录下\n\n\n## 1. 实验代码下载\n```bash\ngit clone https://pdos.csail.mit.edu/6.828/2016/jos.git lab\ncd lab\n```\n## 2. part1 启动pc\n### 启动 qemu\n> ` make qemu`\n![make qemu](./boot.png)\n现在JOS内核只有两条命令来监视内核。help和kerninfo\n![kerninfo](./kerninfo.png)\n\n<!-- more -->\n\n### PC物理地址空间\n```\n+------------------+  <- 0xFFFFFFFF (4GB)\n|      32-bit      |\n|  memory mapped   |\n|     devices      |\n|                  |\n/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\\n\n/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\\n|                  |\n|      Unused      |\n|                  |\n+------------------+  <- depends on amount of RAM\n|                  |\n|                  |\n| Extended Memory  |\n|                  |\n|                  |\n+------------------+  <- 0x00100000 (1MB)\n|     BIOS ROM     |\n+------------------+  <- 0x000F0000 (960KB)\n|  16-bit devices, |\n|  expansion ROMs  |\n+------------------+  <- 0x000C0000 (768KB)\n|   VGA Display    |\n+------------------+  <- 0x000A0000 (640KB)\n|                  |\n|    Low Memory    |\n|                  |\n+------------------+  <- 0x00000000\n```\n>　　早期基于16位Intel 8088处理器只能操作1MB物理内存，因此物理地址空间起始于0x00000000到0x000FFFFF，其中640KB为 Low memory，这只能被随机存储器(RAM)使用。\n　　从 0x000A0000 到 0x000FFFFF的384KB留着给特殊使用，例如作为视频显示缓存或者储存在非易失存储器的硬件。从 0x000F0000 到 0x000FFFFF 占据64KB区域的部分是最重要的BIOS.\n　　现在的x86处理器支持超过4GB的物理RAM，所以RAM扩展到了0xFFFFFFFF。当然，BIOS也流出了开始的32位寻址空间为了让32位的设备映射。JOS这里只用开始的256MB，所以假设PC只有32位地址空间。\n\n### **BIOS**\n> 在一个终端中输入 make qemu-gdb, 另一个终端输入 make gdb.开始调试程序。\n> ```asm\n[f000:fff0] 0xffff0: ljmp 0xf000, 0xe05b\n> ```\n> 上面是GDB反汇编出的第一条执行指令，这条指令表面了：\nIBM PC 执行的起始物理地址为 0x000ffff0,PC 的偏移方式为 CS = 0xf000，IP = 0xfff0.第一条指令执行的是 jmp指令，跳转到段地址 CS = 0xf000，IP = 0xe05b\nQEMU模拟了8088处理器的启动，当启动电源，BIOS最先控制机器，这时还没有其他程序执行，之后处理器进入实模式也就是设置 CS 为 0xf000，IP 为 0xfff0。在启动电源也就是实模式时，地址转译根据这个公式工作：物理地址 = 16 * 段地址 + 偏移量。所以 PC 中 CS 为 0xf000 IP 为 0xfff0 的物理地址为：\n   16 * 0xf000 + 0xfff0   # 十六进制中乘16,左移4位\n   = 0xf0000 + 0xfff0\n   = 0xffff0\n0xffff0 在 BIOS (0x100000) 的结束地址之前。\n当BIOS启动，它设置了一个中断描述符表并初始化多个设备比如VGA显示器。在初始化PCI总线和所有重要的设备之后，它寻找可引导的设备，之后读取boot loader 并转移控制。\n\n## Part 2: The Boot Loader\n> 512 byte是区域的扇区是硬盘最小调度单位，每次读或写操作都至少是一个扇区，并且还会进行对齐。BIOS加载引导扇区到内存中是从物理地址0x7c00到0x7dff，然后使用jmp指令设置 CS:IP 为 0000:7c00。因此 boot loader 不能超过512字节，它执行两个功能：\n>> 1. boot loader 切换处理器从实模式到保护模式，这样能访问大于1MB的物理地址空间。\n2. boot loader 从硬盘中读取内核。\n\n### Boot\n> 通过 `b *0x7c00`设置断点，接着`c`运行到断点处，使用`x/i` 来查看当前的指令。\n\n> 在哪执行了32位代码？\n>>`[0:7c2d] => 0x7c2d: ljmp $0x8,$0x7c32 `这条指令之后，即boot.S 中的 `ljmp $PROT_MODE_CSEG, $protcseg` ，地址符号就变成` 0x7c32 `了。\n\n> 最后一条 boot loader 指令后, 执行第一条内核指令在哪里？\n>> boot loader 最后一步是加载kernel，所以在 boot/main.c 中可以找到 \n>> ```c\n\\* call the entry point from the ELF header\n((void (*)(void)) (ELFHDR->e_entry))()\n```\n>表明这是准备读取ELF头。\n通过 `objdump -x obj/kern/kernel `可以查看kernel的信息，开头为` start address 0x0010000c`，通过 `b *0x10000c`然后在` c` 能得到执行的指令是 `movw $0x1234,0x472`.\n\n>第一条kernel指令在哪里\n>> 同上一条的问题，存在kern/entry.S中。\n\n> 设置一个断点在地址0x7c00处，这是boot sector被加载的位置。然后让程序继续运行直到这个断点。跟踪/boot/boot.S文件的每一条指令，同时使用boot.S文件和系统为你反汇编出来的文件obj/boot/boot.asm.也可以使用GDB的x/i指令来获取去任意一个机器指令的反汇编指令，把源文件boot.S文件和boot.asm文件以及在GDB反汇编出来的指令进行比较。\n追踪到bootmain函数中，而且还要具体追踪到readsect()子函数里面。找出和readsect()c语言程序的每一条语句所对应的汇编指令，回到bootmain()，然后找出把内核文件从磁盘读取到内存的那个for循环所对应的汇编语句。找出当循环结束后会执行哪条语句，在那里设置断点，继续运行到断点，然后运行完所有的剩下的语句。\n\n> boot.S\n```asm\nstart:\n  .code16                     # 16位汇编模式\n  cli                         # 关中断\n  cld                         # 操作方向标志位DF，使DF=0。\n```\n>```asm\n  lgdt    gdtdesc\n  movl    %cr0, %eax\n  orl     $CR0_PE_ON, %eax\n  movl    %eax, %cr0\n# 切换到保护模式后，加载GDT(Global Descriptor Table)，接着修改了cr0寄存器的值，$CR0_PE_ON值为0x1，代表启动保护模式的flag标志。\n```\n>```asm\n  movl    $start, %esp\n  call bootmain\n  # 设置栈指针，接着开始调用bootmain函数。\n```\n>```asm\n    7d15:    55                       push   %ebp\n    7d16:    89 e5                    mov    %esp,%ebp\n    7d18:    56                       push   %esi\n    7d19:    53                       push   %ebx\n    # 参数压栈, 准备进入函数\n```\n>```asm\n    // read 1st page off disk\n    readseg((uint32_t) ELFHDR, SECTSIZE*8, 0);\n    7d1a:    6a 00                    push   $0x0\n    7d1c:    68 00 10 00 00           push   $0x1000\n    7d21:    68 00 00 01 00           push   $0x10000\n    7d26:    e8 b1 ff ff ff           call   7cdc <readseg>\n    # 调用readseg函数，对应3个参数(物理地址，页的大小，偏移量)\n```\n>```asm\n0x7ceb: shr $0x9,%edi \n# 执行 offset = (offset / SECTSIZE) + 1, 除法求出扇区号。\n0x7cee: add %ebx,%esi \n# 执行 end_pa = pa + count, 计算这个扇区结束的物理地址。\n0x7cf0: inc %edi \n# 执行了 offset = (offset / SECTSIZE) + 1中的加1。\n0x7cf1: and $0xfffffe00,%ebx \n# 执行了 pa &= ~(SECTSIZE - 1);。\n0x7cf7:    cmp    %esi,%ebx\n0x7cf9:    jae    0x7d0d\n# 执行 while (pa < end_pa) 循环判断语句。\n```\n>```asm\n# 加载程序段\n7d3a:    a1 1c 00 01 00           mov    0x1001c,%eax\n7d3f:    0f b7 35 2c 00 01 00     movzwl 0x1002c,%esi\n7d46:    8d 98 00 00 01 00        lea    0x10000(%eax),%ebx\n7d4c:    c1 e6 05                 shl    $0x5,%esi\n7d4f:    01 de                    add    %ebx,%esi\n# 接着循环调用readseg函数，将Program Header Table中表项读入内存。\n# 最后加载内核\n((void (*)(void)) (ELFHDR->e_entry))();\n```\n\n### 加载内核\n> 　　为了理解 boot/main.c，需要了解ELF二进制文件。编译并链接比如JOS内核这样的C程序，编译器会将源文件(.c)转为包含汇编指令的目标文件(.o)。接着链接器把所有的目标文件组合成一个单独的二进制镜像（binary image），比如 obj/kern/kernel，这种文件就是ELF(是可执行可链接形式的缩写)。\n　　当前只需要知道，可执行的ELF文件由带有加载信息的头，多个程序段表组成。每个程序段表是一个连续代码块或者数据，它们要被加载到内存具体地址中。boot loader 不修改源码和数据，直接加载到内存中并运行。\n　　ELF开头是固定长度的ELF头，之后是一个可变长度的程序头，它列出了需要加载的程序段。ELF头的定义在 inc/elf.h 中。主要学习以下3个程序段：\n>>.text: 程序执行指令\n.rodata:只读数据，比如ASCII字符串\n.data: 存放程序初始化的数据段，比如有初始值的全局变量。\n\n>　　当链接器计算程序内存布局时，会在内存里紧挨着.data段的.bss段中保留空间给未初始化的全局变量。C规定未初始化的全局变量为0。因此没必要在ELF的.bss段储存内容，链接器只储存了.bss段的地址和大小。\n使用 `objdump -h obj/kern/kernel `可以查看ELF头的相关信息。\n　　重点关注 .text段 的VMA(链接地址)和LMA(加载地址)，段的加载地址即加载进内存的地址。段的链接地址就是这个段预计在内存中执行的地址。\n　　回到 boot/main.c， ph->p_pa是每个程序头包含的段目的物理地址。BIOS把引导扇区加载到内存地址0x7c00，这也就是引导扇区的加载地址和链接地址。在 boot/Makefrag 中，是通过传 -Ttext 0x7C00 这个参数给链接程序设置了链接地址，因此链接程序在生成的代码中产生正确的内存地址。\n\n\n## Part 3: The Kernel\n### 使用虚拟内存\n> 　　boot loader 的链接地址和加载地址是一样的，然而 kernel 的链接地址和加载地址有些差异。查看 kern/kernel.ld 可以发现内核地址在 0xF0100000。\n　　操作系统内核通常被链接并且运行在非常高的虚拟地址，比如文件里看到的 0xf0100000，为了让处理器虚拟地址空间的低地址部分给用户程序使用。\n许多机器没有地址为 0xf0100000的物理内存，所以内核不能放在那儿。因此使用处理器内存管理硬件将虚拟地址 0xf0100000 (内核希望运行的链接地址)映射到物理地址 0x00100000 (boot loader加载内核后所放的物理地址)。尽管内核虚拟地址很高，但加载进物理地址位于1MB的地方仅仅高于BIOS的ROM。这需要PC至少有1MB的物理内存。\n在下一个lab，会映射物理地址空间底部256MB，也就是 0x00000000 到 0x0fffffff，到虚拟地址0xf0000000~0xffffffff。所以JOS只使用物理内存开始的256MB。\n　　目前，只是映射了物理内存开始的4MB， 使用手写的静态初始化页目录和也表在 kern/entrypgdir.c。当 kern/entry.S 设置 CR0_PG 标记，存储器引用就变为虚拟地址，即存储器引用是由虚拟存储器硬件转换为物理地址的虚拟地址。entry_pgdir 将虚拟地址 0xf0000000 ~ 0xf0400000 转换为物理地址 0x00000000 ~ 0x00400000，虚拟地址 0x00000000 ~ 0x00400000 也转换为物理地址 0x00000000 ~ 0x00400000。任何不在这两个范围内的虚拟地址会导致硬件异常。\n\n### 堆栈\n> C语言是如何在x86框架上使用堆栈的?需要查看指令寄存器(IP)的值的变化。\n研究内核是在哪初始化堆栈，找出堆栈存放在内存的位置。内核是如何保存一块空间给堆栈的？堆栈指针指向这块区域的哪儿？\n看了几个文件以后，发现在 kern/entry.S 中提到了设置堆指针和栈指针。\n> ```asm\n    # Clear the frame pointer register (EBP)\n    # so that once we get into debugging C code,\n    # stack backtraces will be terminated properly.\n    movl    $0x0,%ebp            # nuke frame pointer\n\n    # Set the stack pointer\n    movl    $(bootstacktop),%esp\n```\n> 为了查看堆的位置，所以要使用gdb，同样还是` b *0x10000c `打断点进入 entry。 si 一步步执行，在 `0x10002d: jmp *%eax `之后，下一条指令变为 `0xf010002f <relocated>: mov $0x0,%ebp`。其实地址应该还是 `0x10002f`，所以这里的 `0xf010002f `是因为开启的虚拟地址。\n通过 gdb 发现 `0xf0100034 <relocated+5>: mov $0xf0110000,%esp`， 也就是说%esp也就是bootstacktop的值为0xf0110000。其中 kern/entry.S 的 KSTKSIZE 应该就是堆栈的大小，通过跳转，发现在 inc/memlayout.h 里提到了堆栈。\n```c\n// Kernel stack.\n#define KSTACKTOP    KERNBASE\n#define KSTKSIZE    (8*PGSIZE)           // size of a kernel stack\n#define KSTKGAP        (8*PGSIZE)           // size of a kernel stack guard\n# PGSIZE 定义在 inc/mmu.h 中，值为 4096，所以 KSTKSIZE 为 32KB。 使用 info registers可以查出esp和ebp的值。最高地址为bootstacktop的值，也就是0xf0110000。\n```\n\n##  参考链接\n> * [boot pc](https://pdos.csail.mit.edu/6.828/2016/labs/lab1/)","slug":"lab1","published":1,"updated":"2017-08-26T03:38:21.606Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6sslhb8000y3gamg8oxnej7","content":"<h1 id=\"Lab1-启动pc\"><a href=\"#Lab1-启动pc\" class=\"headerlink\" title=\"Lab1 启动pc\"></a>Lab1 启动pc</h1><h2 id=\"lab1分为三部分\"><a href=\"#lab1分为三部分\" class=\"headerlink\" title=\"lab1分为三部分\"></a>lab1分为三部分</h2><blockquote>\n<p>1.熟悉x86汇编语言，qemu x86模拟器，启动pc<br>2.分学习6.828内核的boot loader部分。<br>3.深入研究6.828内核JOS的初始化部分，该部分代码在kernel目录下</p>\n</blockquote>\n<h2 id=\"1-实验代码下载\"><a href=\"#1-实验代码下载\" class=\"headerlink\" title=\"1. 实验代码下载\"></a>1. 实验代码下载</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git <span class=\"built_in\">clone</span> https://pdos.csail.mit.edu/6.828/2016/jos.git lab</div><div class=\"line\"><span class=\"built_in\">cd</span> lab</div></pre></td></tr></table></figure>\n<h2 id=\"2-part1-启动pc\"><a href=\"#2-part1-启动pc\" class=\"headerlink\" title=\"2. part1 启动pc\"></a>2. part1 启动pc</h2><h3 id=\"启动-qemu\"><a href=\"#启动-qemu\" class=\"headerlink\" title=\"启动 qemu\"></a>启动 qemu</h3><blockquote>\n<p><code>make qemu</code><br><img src=\"./boot.png\" alt=\"make qemu\"><br>现在JOS内核只有两条命令来监视内核。help和kerninfo<br><img src=\"./kerninfo.png\" alt=\"kerninfo\"></p>\n</blockquote>\n<a id=\"more\"></a>\n<h3 id=\"PC物理地址空间\"><a href=\"#PC物理地址空间\" class=\"headerlink\" title=\"PC物理地址空间\"></a>PC物理地址空间</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">+------------------+  &lt;- 0xFFFFFFFF (4GB)</div><div class=\"line\">|      32-bit      |</div><div class=\"line\">|  memory mapped   |</div><div class=\"line\">|     devices      |</div><div class=\"line\">|                  |</div><div class=\"line\">/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\</div><div class=\"line\"></div><div class=\"line\">/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\</div><div class=\"line\">|                  |</div><div class=\"line\">|      Unused      |</div><div class=\"line\">|                  |</div><div class=\"line\">+------------------+  &lt;- depends on amount of RAM</div><div class=\"line\">|                  |</div><div class=\"line\">|                  |</div><div class=\"line\">| Extended Memory  |</div><div class=\"line\">|                  |</div><div class=\"line\">|                  |</div><div class=\"line\">+------------------+  &lt;- 0x00100000 (1MB)</div><div class=\"line\">|     BIOS ROM     |</div><div class=\"line\">+------------------+  &lt;- 0x000F0000 (960KB)</div><div class=\"line\">|  16-bit devices, |</div><div class=\"line\">|  expansion ROMs  |</div><div class=\"line\">+------------------+  &lt;- 0x000C0000 (768KB)</div><div class=\"line\">|   VGA Display    |</div><div class=\"line\">+------------------+  &lt;- 0x000A0000 (640KB)</div><div class=\"line\">|                  |</div><div class=\"line\">|    Low Memory    |</div><div class=\"line\">|                  |</div><div class=\"line\">+------------------+  &lt;- 0x00000000</div></pre></td></tr></table></figure>\n<blockquote>\n<p>　　早期基于16位Intel 8088处理器只能操作1MB物理内存，因此物理地址空间起始于0x00000000到0x000FFFFF，其中640KB为 Low memory，这只能被随机存储器(RAM)使用。<br>　　从 0x000A0000 到 0x000FFFFF的384KB留着给特殊使用，例如作为视频显示缓存或者储存在非易失存储器的硬件。从 0x000F0000 到 0x000FFFFF 占据64KB区域的部分是最重要的BIOS.<br>　　现在的x86处理器支持超过4GB的物理RAM，所以RAM扩展到了0xFFFFFFFF。当然，BIOS也流出了开始的32位寻址空间为了让32位的设备映射。JOS这里只用开始的256MB，所以假设PC只有32位地址空间。</p>\n</blockquote>\n<h3 id=\"BIOS\"><a href=\"#BIOS\" class=\"headerlink\" title=\"BIOS\"></a><strong>BIOS</strong></h3><blockquote>\n<p>在一个终端中输入 make qemu-gdb, 另一个终端输入 make gdb.开始调试程序。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[f000:fff0] 0xffff0: ljmp 0xf000, 0xe05b</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure></p>\n<p>上面是GDB反汇编出的第一条执行指令，这条指令表面了：<br>IBM PC 执行的起始物理地址为 0x000ffff0,PC 的偏移方式为 CS = 0xf000，IP = 0xfff0.第一条指令执行的是 jmp指令，跳转到段地址 CS = 0xf000，IP = 0xe05b<br>QEMU模拟了8088处理器的启动，当启动电源，BIOS最先控制机器，这时还没有其他程序执行，之后处理器进入实模式也就是设置 CS 为 0xf000，IP 为 0xfff0。在启动电源也就是实模式时，地址转译根据这个公式工作：物理地址 = 16 <em> 段地址 + 偏移量。所以 PC 中 CS 为 0xf000 IP 为 0xfff0 的物理地址为：<br>   16 </em> 0xf000 + 0xfff0   # 十六进制中乘16,左移4位<br>   = 0xf0000 + 0xfff0<br>   = 0xffff0<br>0xffff0 在 BIOS (0x100000) 的结束地址之前。<br>当BIOS启动，它设置了一个中断描述符表并初始化多个设备比如VGA显示器。在初始化PCI总线和所有重要的设备之后，它寻找可引导的设备，之后读取boot loader 并转移控制。</p>\n</blockquote>\n<h2 id=\"Part-2-The-Boot-Loader\"><a href=\"#Part-2-The-Boot-Loader\" class=\"headerlink\" title=\"Part 2: The Boot Loader\"></a>Part 2: The Boot Loader</h2><blockquote>\n<p>512 byte是区域的扇区是硬盘最小调度单位，每次读或写操作都至少是一个扇区，并且还会进行对齐。BIOS加载引导扇区到内存中是从物理地址0x7c00到0x7dff，然后使用jmp指令设置 CS:IP 为 0000:7c00。因此 boot loader 不能超过512字节，它执行两个功能：</p>\n<blockquote>\n<ol>\n<li>boot loader 切换处理器从实模式到保护模式，这样能访问大于1MB的物理地址空间。</li>\n<li>boot loader 从硬盘中读取内核。</li>\n</ol>\n</blockquote>\n</blockquote>\n<h3 id=\"Boot\"><a href=\"#Boot\" class=\"headerlink\" title=\"Boot\"></a>Boot</h3><blockquote>\n<p>通过 <code>b *0x7c00</code>设置断点，接着<code>c</code>运行到断点处，使用<code>x/i</code> 来查看当前的指令。</p>\n<p>在哪执行了32位代码？</p>\n<blockquote>\n<p><code>[0:7c2d] =&gt; 0x7c2d: ljmp $0x8,$0x7c32</code>这条指令之后，即boot.S 中的 <code>ljmp $PROT_MODE_CSEG, $protcseg</code> ，地址符号就变成<code>0x7c32</code>了。</p>\n</blockquote>\n<p>最后一条 boot loader 指令后, 执行第一条内核指令在哪里？</p>\n<blockquote>\n<p>boot loader 最后一步是加载kernel，所以在 boot/main.c 中可以找到<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">\\* call the entry point from the ELF header</div><div class=\"line\">((void (*)(void)) (ELFHDR-&gt;e_entry))()</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>表明这是准备读取ELF头。<br>通过 <code>objdump -x obj/kern/kernel</code>可以查看kernel的信息，开头为<code>start address 0x0010000c</code>，通过 <code>b *0x10000c</code>然后在<code>c</code> 能得到执行的指令是 <code>movw $0x1234,0x472</code>.</p>\n<p>第一条kernel指令在哪里</p>\n<blockquote>\n<p>同上一条的问题，存在kern/entry.S中。</p>\n</blockquote>\n<p>设置一个断点在地址0x7c00处，这是boot sector被加载的位置。然后让程序继续运行直到这个断点。跟踪/boot/boot.S文件的每一条指令，同时使用boot.S文件和系统为你反汇编出来的文件obj/boot/boot.asm.也可以使用GDB的x/i指令来获取去任意一个机器指令的反汇编指令，把源文件boot.S文件和boot.asm文件以及在GDB反汇编出来的指令进行比较。<br>追踪到bootmain函数中，而且还要具体追踪到readsect()子函数里面。找出和readsect()c语言程序的每一条语句所对应的汇编指令，回到bootmain()，然后找出把内核文件从磁盘读取到内存的那个for循环所对应的汇编语句。找出当循环结束后会执行哪条语句，在那里设置断点，继续运行到断点，然后运行完所有的剩下的语句。</p>\n<p>boot.S<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">start:</div><div class=\"line\">  .code16                     # 16位汇编模式</div><div class=\"line\">  cli                         # 关中断</div><div class=\"line\">  cld                         # 操作方向标志位DF，使DF=0。</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">  lgdt    gdtdesc</div><div class=\"line\">  movl    %cr0, %eax</div><div class=\"line\">  orl     $CR0_PE_ON, %eax</div><div class=\"line\">  movl    %eax, %cr0</div><div class=\"line\"># 切换到保护模式后，加载GDT(Global Descriptor Table)，接着修改了cr0寄存器的值，$CR0_PE_ON值为0x1，代表启动保护模式的flag标志。</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">movl    $start, %esp</div><div class=\"line\">call bootmain</div><div class=\"line\"># 设置栈指针，接着开始调用bootmain函数。</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">7d15:    55                       push   %ebp</div><div class=\"line\">7d16:    89 e5                    mov    %esp,%ebp</div><div class=\"line\">7d18:    56                       push   %esi</div><div class=\"line\">7d19:    53                       push   %ebx</div><div class=\"line\"># 参数压栈, 准备进入函数</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">// read 1st page off disk</div><div class=\"line\">readseg((uint32_t) ELFHDR, SECTSIZE*8, 0);</div><div class=\"line\">7d1a:    6a 00                    push   $0x0</div><div class=\"line\">7d1c:    68 00 10 00 00           push   $0x1000</div><div class=\"line\">7d21:    68 00 00 01 00           push   $0x10000</div><div class=\"line\">7d26:    e8 b1 ff ff ff           call   7cdc &lt;readseg&gt;</div><div class=\"line\"># 调用readseg函数，对应3个参数(物理地址，页的大小，偏移量)</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">0x7ceb: shr $0x9,%edi </div><div class=\"line\"># 执行 offset = (offset / SECTSIZE) + 1, 除法求出扇区号。</div><div class=\"line\">0x7cee: add %ebx,%esi </div><div class=\"line\"># 执行 end_pa = pa + count, 计算这个扇区结束的物理地址。</div><div class=\"line\">0x7cf0: inc %edi </div><div class=\"line\"># 执行了 offset = (offset / SECTSIZE) + 1中的加1。</div><div class=\"line\">0x7cf1: and $0xfffffe00,%ebx </div><div class=\"line\"># 执行了 pa &amp;= ~(SECTSIZE - 1);。</div><div class=\"line\">0x7cf7:    cmp    %esi,%ebx</div><div class=\"line\">0x7cf9:    jae    0x7d0d</div><div class=\"line\"># 执行 while (pa &lt; end_pa) 循环判断语句。</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 加载程序段</div><div class=\"line\">7d3a:    a1 1c 00 01 00           mov    0x1001c,%eax</div><div class=\"line\">7d3f:    0f b7 35 2c 00 01 00     movzwl 0x1002c,%esi</div><div class=\"line\">7d46:    8d 98 00 00 01 00        lea    0x10000(%eax),%ebx</div><div class=\"line\">7d4c:    c1 e6 05                 shl    $0x5,%esi</div><div class=\"line\">7d4f:    01 de                    add    %ebx,%esi</div><div class=\"line\"># 接着循环调用readseg函数，将Program Header Table中表项读入内存。</div><div class=\"line\"># 最后加载内核</div><div class=\"line\">((void (*)(void)) (ELFHDR-&gt;e_entry))();</div></pre></td></tr></table></figure>\n</blockquote>\n<h3 id=\"加载内核\"><a href=\"#加载内核\" class=\"headerlink\" title=\"加载内核\"></a>加载内核</h3><blockquote>\n<p>　　为了理解 boot/main.c，需要了解ELF二进制文件。编译并链接比如JOS内核这样的C程序，编译器会将源文件(.c)转为包含汇编指令的目标文件(.o)。接着链接器把所有的目标文件组合成一个单独的二进制镜像（binary image），比如 obj/kern/kernel，这种文件就是ELF(是可执行可链接形式的缩写)。<br>　　当前只需要知道，可执行的ELF文件由带有加载信息的头，多个程序段表组成。每个程序段表是一个连续代码块或者数据，它们要被加载到内存具体地址中。boot loader 不修改源码和数据，直接加载到内存中并运行。<br>　　ELF开头是固定长度的ELF头，之后是一个可变长度的程序头，它列出了需要加载的程序段。ELF头的定义在 inc/elf.h 中。主要学习以下3个程序段：</p>\n<blockquote>\n<p>.text: 程序执行指令<br>.rodata:只读数据，比如ASCII字符串<br>.data: 存放程序初始化的数据段，比如有初始值的全局变量。</p>\n</blockquote>\n<p>　　当链接器计算程序内存布局时，会在内存里紧挨着.data段的.bss段中保留空间给未初始化的全局变量。C规定未初始化的全局变量为0。因此没必要在ELF的.bss段储存内容，链接器只储存了.bss段的地址和大小。<br>使用 <code>objdump -h obj/kern/kernel</code>可以查看ELF头的相关信息。<br>　　重点关注 .text段 的VMA(链接地址)和LMA(加载地址)，段的加载地址即加载进内存的地址。段的链接地址就是这个段预计在内存中执行的地址。<br>　　回到 boot/main.c， ph-&gt;p_pa是每个程序头包含的段目的物理地址。BIOS把引导扇区加载到内存地址0x7c00，这也就是引导扇区的加载地址和链接地址。在 boot/Makefrag 中，是通过传 -Ttext 0x7C00 这个参数给链接程序设置了链接地址，因此链接程序在生成的代码中产生正确的内存地址。</p>\n</blockquote>\n<h2 id=\"Part-3-The-Kernel\"><a href=\"#Part-3-The-Kernel\" class=\"headerlink\" title=\"Part 3: The Kernel\"></a>Part 3: The Kernel</h2><h3 id=\"使用虚拟内存\"><a href=\"#使用虚拟内存\" class=\"headerlink\" title=\"使用虚拟内存\"></a>使用虚拟内存</h3><blockquote>\n<p>　　boot loader 的链接地址和加载地址是一样的，然而 kernel 的链接地址和加载地址有些差异。查看 kern/kernel.ld 可以发现内核地址在 0xF0100000。<br>　　操作系统内核通常被链接并且运行在非常高的虚拟地址，比如文件里看到的 0xf0100000，为了让处理器虚拟地址空间的低地址部分给用户程序使用。<br>许多机器没有地址为 0xf0100000的物理内存，所以内核不能放在那儿。因此使用处理器内存管理硬件将虚拟地址 0xf0100000 (内核希望运行的链接地址)映射到物理地址 0x00100000 (boot loader加载内核后所放的物理地址)。尽管内核虚拟地址很高，但加载进物理地址位于1MB的地方仅仅高于BIOS的ROM。这需要PC至少有1MB的物理内存。<br>在下一个lab，会映射物理地址空间底部256MB，也就是 0x00000000 到 0x0fffffff，到虚拟地址0xf0000000~0xffffffff。所以JOS只使用物理内存开始的256MB。<br>　　目前，只是映射了物理内存开始的4MB， 使用手写的静态初始化页目录和也表在 kern/entrypgdir.c。当 kern/entry.S 设置 CR0_PG 标记，存储器引用就变为虚拟地址，即存储器引用是由虚拟存储器硬件转换为物理地址的虚拟地址。entry_pgdir 将虚拟地址 0xf0000000 ~ 0xf0400000 转换为物理地址 0x00000000 ~ 0x00400000，虚拟地址 0x00000000 ~ 0x00400000 也转换为物理地址 0x00000000 ~ 0x00400000。任何不在这两个范围内的虚拟地址会导致硬件异常。</p>\n</blockquote>\n<h3 id=\"堆栈\"><a href=\"#堆栈\" class=\"headerlink\" title=\"堆栈\"></a>堆栈</h3><blockquote>\n<p>C语言是如何在x86框架上使用堆栈的?需要查看指令寄存器(IP)的值的变化。<br>研究内核是在哪初始化堆栈，找出堆栈存放在内存的位置。内核是如何保存一块空间给堆栈的？堆栈指针指向这块区域的哪儿？<br>看了几个文件以后，发现在 kern/entry.S 中提到了设置堆指针和栈指针。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Clear the frame pointer register (EBP)</div><div class=\"line\"># so that once we get into debugging C code,</div><div class=\"line\"># stack backtraces will be terminated properly.</div><div class=\"line\">movl    $0x0,%ebp            # nuke frame pointer</div><div class=\"line\"></div><div class=\"line\"># Set the stack pointer</div><div class=\"line\">movl    $(bootstacktop),%esp</div></pre></td></tr></table></figure></p>\n<p>为了查看堆的位置，所以要使用gdb，同样还是<code>b *0x10000c</code>打断点进入 entry。 si 一步步执行，在 <code>0x10002d: jmp *%eax</code>之后，下一条指令变为 <code>0xf010002f &lt;relocated&gt;: mov $0x0,%ebp</code>。其实地址应该还是 <code>0x10002f</code>，所以这里的 <code>0xf010002f</code>是因为开启的虚拟地址。<br>通过 gdb 发现 <code>0xf0100034 &lt;relocated+5&gt;: mov $0xf0110000,%esp</code>， 也就是说%esp也就是bootstacktop的值为0xf0110000。其中 kern/entry.S 的 KSTKSIZE 应该就是堆栈的大小，通过跳转，发现在 inc/memlayout.h 里提到了堆栈。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Kernel stack.</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> KSTACKTOP    KERNBASE</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> KSTKSIZE    (8*PGSIZE)           <span class=\"comment\">// size of a kernel stack</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> KSTKGAP        (8*PGSIZE)           <span class=\"comment\">// size of a kernel stack guard</span></span></div><div class=\"line\"># PGSIZE 定义在 inc/mmu.h 中，值为 <span class=\"number\">4096</span>，所以 KSTKSIZE 为 <span class=\"number\">32</span>KB。 使用 info registers可以查出esp和ebp的值。最高地址为bootstacktop的值，也就是<span class=\"number\">0xf0110000</span>。</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><blockquote>\n<ul>\n<li><a href=\"https://pdos.csail.mit.edu/6.828/2016/labs/lab1/\" target=\"_blank\" rel=\"external\">boot pc</a></li>\n</ul>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h1 id=\"Lab1-启动pc\"><a href=\"#Lab1-启动pc\" class=\"headerlink\" title=\"Lab1 启动pc\"></a>Lab1 启动pc</h1><h2 id=\"lab1分为三部分\"><a href=\"#lab1分为三部分\" class=\"headerlink\" title=\"lab1分为三部分\"></a>lab1分为三部分</h2><blockquote>\n<p>1.熟悉x86汇编语言，qemu x86模拟器，启动pc<br>2.分学习6.828内核的boot loader部分。<br>3.深入研究6.828内核JOS的初始化部分，该部分代码在kernel目录下</p>\n</blockquote>\n<h2 id=\"1-实验代码下载\"><a href=\"#1-实验代码下载\" class=\"headerlink\" title=\"1. 实验代码下载\"></a>1. 实验代码下载</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">git <span class=\"built_in\">clone</span> https://pdos.csail.mit.edu/6.828/2016/jos.git lab</div><div class=\"line\"><span class=\"built_in\">cd</span> lab</div></pre></td></tr></table></figure>\n<h2 id=\"2-part1-启动pc\"><a href=\"#2-part1-启动pc\" class=\"headerlink\" title=\"2. part1 启动pc\"></a>2. part1 启动pc</h2><h3 id=\"启动-qemu\"><a href=\"#启动-qemu\" class=\"headerlink\" title=\"启动 qemu\"></a>启动 qemu</h3><blockquote>\n<p><code>make qemu</code><br><img src=\"./boot.png\" alt=\"make qemu\"><br>现在JOS内核只有两条命令来监视内核。help和kerninfo<br><img src=\"./kerninfo.png\" alt=\"kerninfo\"></p>\n</blockquote>","more":"<h3 id=\"PC物理地址空间\"><a href=\"#PC物理地址空间\" class=\"headerlink\" title=\"PC物理地址空间\"></a>PC物理地址空间</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\">+------------------+  &lt;- 0xFFFFFFFF (4GB)</div><div class=\"line\">|      32-bit      |</div><div class=\"line\">|  memory mapped   |</div><div class=\"line\">|     devices      |</div><div class=\"line\">|                  |</div><div class=\"line\">/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\</div><div class=\"line\"></div><div class=\"line\">/\\/\\/\\/\\/\\/\\/\\/\\/\\/\\</div><div class=\"line\">|                  |</div><div class=\"line\">|      Unused      |</div><div class=\"line\">|                  |</div><div class=\"line\">+------------------+  &lt;- depends on amount of RAM</div><div class=\"line\">|                  |</div><div class=\"line\">|                  |</div><div class=\"line\">| Extended Memory  |</div><div class=\"line\">|                  |</div><div class=\"line\">|                  |</div><div class=\"line\">+------------------+  &lt;- 0x00100000 (1MB)</div><div class=\"line\">|     BIOS ROM     |</div><div class=\"line\">+------------------+  &lt;- 0x000F0000 (960KB)</div><div class=\"line\">|  16-bit devices, |</div><div class=\"line\">|  expansion ROMs  |</div><div class=\"line\">+------------------+  &lt;- 0x000C0000 (768KB)</div><div class=\"line\">|   VGA Display    |</div><div class=\"line\">+------------------+  &lt;- 0x000A0000 (640KB)</div><div class=\"line\">|                  |</div><div class=\"line\">|    Low Memory    |</div><div class=\"line\">|                  |</div><div class=\"line\">+------------------+  &lt;- 0x00000000</div></pre></td></tr></table></figure>\n<blockquote>\n<p>　　早期基于16位Intel 8088处理器只能操作1MB物理内存，因此物理地址空间起始于0x00000000到0x000FFFFF，其中640KB为 Low memory，这只能被随机存储器(RAM)使用。<br>　　从 0x000A0000 到 0x000FFFFF的384KB留着给特殊使用，例如作为视频显示缓存或者储存在非易失存储器的硬件。从 0x000F0000 到 0x000FFFFF 占据64KB区域的部分是最重要的BIOS.<br>　　现在的x86处理器支持超过4GB的物理RAM，所以RAM扩展到了0xFFFFFFFF。当然，BIOS也流出了开始的32位寻址空间为了让32位的设备映射。JOS这里只用开始的256MB，所以假设PC只有32位地址空间。</p>\n</blockquote>\n<h3 id=\"BIOS\"><a href=\"#BIOS\" class=\"headerlink\" title=\"BIOS\"></a><strong>BIOS</strong></h3><blockquote>\n<p>在一个终端中输入 make qemu-gdb, 另一个终端输入 make gdb.开始调试程序。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[f000:fff0] 0xffff0: ljmp 0xf000, 0xe05b</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure></p>\n<p>上面是GDB反汇编出的第一条执行指令，这条指令表面了：<br>IBM PC 执行的起始物理地址为 0x000ffff0,PC 的偏移方式为 CS = 0xf000，IP = 0xfff0.第一条指令执行的是 jmp指令，跳转到段地址 CS = 0xf000，IP = 0xe05b<br>QEMU模拟了8088处理器的启动，当启动电源，BIOS最先控制机器，这时还没有其他程序执行，之后处理器进入实模式也就是设置 CS 为 0xf000，IP 为 0xfff0。在启动电源也就是实模式时，地址转译根据这个公式工作：物理地址 = 16 <em> 段地址 + 偏移量。所以 PC 中 CS 为 0xf000 IP 为 0xfff0 的物理地址为：<br>   16 </em> 0xf000 + 0xfff0   # 十六进制中乘16,左移4位<br>   = 0xf0000 + 0xfff0<br>   = 0xffff0<br>0xffff0 在 BIOS (0x100000) 的结束地址之前。<br>当BIOS启动，它设置了一个中断描述符表并初始化多个设备比如VGA显示器。在初始化PCI总线和所有重要的设备之后，它寻找可引导的设备，之后读取boot loader 并转移控制。</p>\n</blockquote>\n<h2 id=\"Part-2-The-Boot-Loader\"><a href=\"#Part-2-The-Boot-Loader\" class=\"headerlink\" title=\"Part 2: The Boot Loader\"></a>Part 2: The Boot Loader</h2><blockquote>\n<p>512 byte是区域的扇区是硬盘最小调度单位，每次读或写操作都至少是一个扇区，并且还会进行对齐。BIOS加载引导扇区到内存中是从物理地址0x7c00到0x7dff，然后使用jmp指令设置 CS:IP 为 0000:7c00。因此 boot loader 不能超过512字节，它执行两个功能：</p>\n<blockquote>\n<ol>\n<li>boot loader 切换处理器从实模式到保护模式，这样能访问大于1MB的物理地址空间。</li>\n<li>boot loader 从硬盘中读取内核。</li>\n</ol>\n</blockquote>\n</blockquote>\n<h3 id=\"Boot\"><a href=\"#Boot\" class=\"headerlink\" title=\"Boot\"></a>Boot</h3><blockquote>\n<p>通过 <code>b *0x7c00</code>设置断点，接着<code>c</code>运行到断点处，使用<code>x/i</code> 来查看当前的指令。</p>\n<p>在哪执行了32位代码？</p>\n<blockquote>\n<p><code>[0:7c2d] =&gt; 0x7c2d: ljmp $0x8,$0x7c32</code>这条指令之后，即boot.S 中的 <code>ljmp $PROT_MODE_CSEG, $protcseg</code> ，地址符号就变成<code>0x7c32</code>了。</p>\n</blockquote>\n<p>最后一条 boot loader 指令后, 执行第一条内核指令在哪里？</p>\n<blockquote>\n<p>boot loader 最后一步是加载kernel，所以在 boot/main.c 中可以找到<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">\\* call the entry point from the ELF header</div><div class=\"line\">((void (*)(void)) (ELFHDR-&gt;e_entry))()</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>表明这是准备读取ELF头。<br>通过 <code>objdump -x obj/kern/kernel</code>可以查看kernel的信息，开头为<code>start address 0x0010000c</code>，通过 <code>b *0x10000c</code>然后在<code>c</code> 能得到执行的指令是 <code>movw $0x1234,0x472</code>.</p>\n<p>第一条kernel指令在哪里</p>\n<blockquote>\n<p>同上一条的问题，存在kern/entry.S中。</p>\n</blockquote>\n<p>设置一个断点在地址0x7c00处，这是boot sector被加载的位置。然后让程序继续运行直到这个断点。跟踪/boot/boot.S文件的每一条指令，同时使用boot.S文件和系统为你反汇编出来的文件obj/boot/boot.asm.也可以使用GDB的x/i指令来获取去任意一个机器指令的反汇编指令，把源文件boot.S文件和boot.asm文件以及在GDB反汇编出来的指令进行比较。<br>追踪到bootmain函数中，而且还要具体追踪到readsect()子函数里面。找出和readsect()c语言程序的每一条语句所对应的汇编指令，回到bootmain()，然后找出把内核文件从磁盘读取到内存的那个for循环所对应的汇编语句。找出当循环结束后会执行哪条语句，在那里设置断点，继续运行到断点，然后运行完所有的剩下的语句。</p>\n<p>boot.S<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">start:</div><div class=\"line\">  .code16                     # 16位汇编模式</div><div class=\"line\">  cli                         # 关中断</div><div class=\"line\">  cld                         # 操作方向标志位DF，使DF=0。</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">  lgdt    gdtdesc</div><div class=\"line\">  movl    %cr0, %eax</div><div class=\"line\">  orl     $CR0_PE_ON, %eax</div><div class=\"line\">  movl    %eax, %cr0</div><div class=\"line\"># 切换到保护模式后，加载GDT(Global Descriptor Table)，接着修改了cr0寄存器的值，$CR0_PE_ON值为0x1，代表启动保护模式的flag标志。</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">movl    $start, %esp</div><div class=\"line\">call bootmain</div><div class=\"line\"># 设置栈指针，接着开始调用bootmain函数。</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">7d15:    55                       push   %ebp</div><div class=\"line\">7d16:    89 e5                    mov    %esp,%ebp</div><div class=\"line\">7d18:    56                       push   %esi</div><div class=\"line\">7d19:    53                       push   %ebx</div><div class=\"line\"># 参数压栈, 准备进入函数</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">// read 1st page off disk</div><div class=\"line\">readseg((uint32_t) ELFHDR, SECTSIZE*8, 0);</div><div class=\"line\">7d1a:    6a 00                    push   $0x0</div><div class=\"line\">7d1c:    68 00 10 00 00           push   $0x1000</div><div class=\"line\">7d21:    68 00 00 01 00           push   $0x10000</div><div class=\"line\">7d26:    e8 b1 ff ff ff           call   7cdc &lt;readseg&gt;</div><div class=\"line\"># 调用readseg函数，对应3个参数(物理地址，页的大小，偏移量)</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">0x7ceb: shr $0x9,%edi </div><div class=\"line\"># 执行 offset = (offset / SECTSIZE) + 1, 除法求出扇区号。</div><div class=\"line\">0x7cee: add %ebx,%esi </div><div class=\"line\"># 执行 end_pa = pa + count, 计算这个扇区结束的物理地址。</div><div class=\"line\">0x7cf0: inc %edi </div><div class=\"line\"># 执行了 offset = (offset / SECTSIZE) + 1中的加1。</div><div class=\"line\">0x7cf1: and $0xfffffe00,%ebx </div><div class=\"line\"># 执行了 pa &amp;= ~(SECTSIZE - 1);。</div><div class=\"line\">0x7cf7:    cmp    %esi,%ebx</div><div class=\"line\">0x7cf9:    jae    0x7d0d</div><div class=\"line\"># 执行 while (pa &lt; end_pa) 循环判断语句。</div></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 加载程序段</div><div class=\"line\">7d3a:    a1 1c 00 01 00           mov    0x1001c,%eax</div><div class=\"line\">7d3f:    0f b7 35 2c 00 01 00     movzwl 0x1002c,%esi</div><div class=\"line\">7d46:    8d 98 00 00 01 00        lea    0x10000(%eax),%ebx</div><div class=\"line\">7d4c:    c1 e6 05                 shl    $0x5,%esi</div><div class=\"line\">7d4f:    01 de                    add    %ebx,%esi</div><div class=\"line\"># 接着循环调用readseg函数，将Program Header Table中表项读入内存。</div><div class=\"line\"># 最后加载内核</div><div class=\"line\">((void (*)(void)) (ELFHDR-&gt;e_entry))();</div></pre></td></tr></table></figure>\n</blockquote>\n<h3 id=\"加载内核\"><a href=\"#加载内核\" class=\"headerlink\" title=\"加载内核\"></a>加载内核</h3><blockquote>\n<p>　　为了理解 boot/main.c，需要了解ELF二进制文件。编译并链接比如JOS内核这样的C程序，编译器会将源文件(.c)转为包含汇编指令的目标文件(.o)。接着链接器把所有的目标文件组合成一个单独的二进制镜像（binary image），比如 obj/kern/kernel，这种文件就是ELF(是可执行可链接形式的缩写)。<br>　　当前只需要知道，可执行的ELF文件由带有加载信息的头，多个程序段表组成。每个程序段表是一个连续代码块或者数据，它们要被加载到内存具体地址中。boot loader 不修改源码和数据，直接加载到内存中并运行。<br>　　ELF开头是固定长度的ELF头，之后是一个可变长度的程序头，它列出了需要加载的程序段。ELF头的定义在 inc/elf.h 中。主要学习以下3个程序段：</p>\n<blockquote>\n<p>.text: 程序执行指令<br>.rodata:只读数据，比如ASCII字符串<br>.data: 存放程序初始化的数据段，比如有初始值的全局变量。</p>\n</blockquote>\n<p>　　当链接器计算程序内存布局时，会在内存里紧挨着.data段的.bss段中保留空间给未初始化的全局变量。C规定未初始化的全局变量为0。因此没必要在ELF的.bss段储存内容，链接器只储存了.bss段的地址和大小。<br>使用 <code>objdump -h obj/kern/kernel</code>可以查看ELF头的相关信息。<br>　　重点关注 .text段 的VMA(链接地址)和LMA(加载地址)，段的加载地址即加载进内存的地址。段的链接地址就是这个段预计在内存中执行的地址。<br>　　回到 boot/main.c， ph-&gt;p_pa是每个程序头包含的段目的物理地址。BIOS把引导扇区加载到内存地址0x7c00，这也就是引导扇区的加载地址和链接地址。在 boot/Makefrag 中，是通过传 -Ttext 0x7C00 这个参数给链接程序设置了链接地址，因此链接程序在生成的代码中产生正确的内存地址。</p>\n</blockquote>\n<h2 id=\"Part-3-The-Kernel\"><a href=\"#Part-3-The-Kernel\" class=\"headerlink\" title=\"Part 3: The Kernel\"></a>Part 3: The Kernel</h2><h3 id=\"使用虚拟内存\"><a href=\"#使用虚拟内存\" class=\"headerlink\" title=\"使用虚拟内存\"></a>使用虚拟内存</h3><blockquote>\n<p>　　boot loader 的链接地址和加载地址是一样的，然而 kernel 的链接地址和加载地址有些差异。查看 kern/kernel.ld 可以发现内核地址在 0xF0100000。<br>　　操作系统内核通常被链接并且运行在非常高的虚拟地址，比如文件里看到的 0xf0100000，为了让处理器虚拟地址空间的低地址部分给用户程序使用。<br>许多机器没有地址为 0xf0100000的物理内存，所以内核不能放在那儿。因此使用处理器内存管理硬件将虚拟地址 0xf0100000 (内核希望运行的链接地址)映射到物理地址 0x00100000 (boot loader加载内核后所放的物理地址)。尽管内核虚拟地址很高，但加载进物理地址位于1MB的地方仅仅高于BIOS的ROM。这需要PC至少有1MB的物理内存。<br>在下一个lab，会映射物理地址空间底部256MB，也就是 0x00000000 到 0x0fffffff，到虚拟地址0xf0000000~0xffffffff。所以JOS只使用物理内存开始的256MB。<br>　　目前，只是映射了物理内存开始的4MB， 使用手写的静态初始化页目录和也表在 kern/entrypgdir.c。当 kern/entry.S 设置 CR0_PG 标记，存储器引用就变为虚拟地址，即存储器引用是由虚拟存储器硬件转换为物理地址的虚拟地址。entry_pgdir 将虚拟地址 0xf0000000 ~ 0xf0400000 转换为物理地址 0x00000000 ~ 0x00400000，虚拟地址 0x00000000 ~ 0x00400000 也转换为物理地址 0x00000000 ~ 0x00400000。任何不在这两个范围内的虚拟地址会导致硬件异常。</p>\n</blockquote>\n<h3 id=\"堆栈\"><a href=\"#堆栈\" class=\"headerlink\" title=\"堆栈\"></a>堆栈</h3><blockquote>\n<p>C语言是如何在x86框架上使用堆栈的?需要查看指令寄存器(IP)的值的变化。<br>研究内核是在哪初始化堆栈，找出堆栈存放在内存的位置。内核是如何保存一块空间给堆栈的？堆栈指针指向这块区域的哪儿？<br>看了几个文件以后，发现在 kern/entry.S 中提到了设置堆指针和栈指针。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"># Clear the frame pointer register (EBP)</div><div class=\"line\"># so that once we get into debugging C code,</div><div class=\"line\"># stack backtraces will be terminated properly.</div><div class=\"line\">movl    $0x0,%ebp            # nuke frame pointer</div><div class=\"line\"></div><div class=\"line\"># Set the stack pointer</div><div class=\"line\">movl    $(bootstacktop),%esp</div></pre></td></tr></table></figure></p>\n<p>为了查看堆的位置，所以要使用gdb，同样还是<code>b *0x10000c</code>打断点进入 entry。 si 一步步执行，在 <code>0x10002d: jmp *%eax</code>之后，下一条指令变为 <code>0xf010002f &lt;relocated&gt;: mov $0x0,%ebp</code>。其实地址应该还是 <code>0x10002f</code>，所以这里的 <code>0xf010002f</code>是因为开启的虚拟地址。<br>通过 gdb 发现 <code>0xf0100034 &lt;relocated+5&gt;: mov $0xf0110000,%esp</code>， 也就是说%esp也就是bootstacktop的值为0xf0110000。其中 kern/entry.S 的 KSTKSIZE 应该就是堆栈的大小，通过跳转，发现在 inc/memlayout.h 里提到了堆栈。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Kernel stack.</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> KSTACKTOP    KERNBASE</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> KSTKSIZE    (8*PGSIZE)           <span class=\"comment\">// size of a kernel stack</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> KSTKGAP        (8*PGSIZE)           <span class=\"comment\">// size of a kernel stack guard</span></span></div><div class=\"line\"># PGSIZE 定义在 inc/mmu.h 中，值为 <span class=\"number\">4096</span>，所以 KSTKSIZE 为 <span class=\"number\">32</span>KB。 使用 info registers可以查出esp和ebp的值。最高地址为bootstacktop的值，也就是<span class=\"number\">0xf0110000</span>。</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><blockquote>\n<ul>\n<li><a href=\"https://pdos.csail.mit.edu/6.828/2016/labs/lab1/\" target=\"_blank\" rel=\"external\">boot pc</a></li>\n</ul>\n</blockquote>"},{"title":"lab2-memeory-management","date":"2017-04-17T16:00:00.000Z","_content":"\n# Lab2 内存管理\n## 摘要\n> * 内存管理有两个组件:\n> 1.  第一个组件是内核的物理内存分配器，因此内核可以分配内存并稍后释放它。.分配器将以4096个字节为单位进行操作，称为页面。代码要实现维护记录哪些物理页面是空闲的，哪些被分配的数据结构以及共享每个分配的页面的进程数量,另外还将编写例程以分配和释放内存页面。\n> 2. 第二个组件是虚拟内存，它将内核和用户软件使用的虚拟地址映射到物理内存中的地址。 当指令使用内存，咨询一组页表时，x86硬件的内存管理单元（MMU）执行映射。 lab2根据提供的规范修改JOS以设置MMU的页表。\n\n> - lab1分为三部分\n> 1. part1: 物理页面管理 physical page management\n> 2. part2: 虚拟内存 virtual memory\n> 3. part3: 内核地址空间 kernel address space\n\n<!-- more -->\n\n## 实验代码\n> ```bash\n cd ~/6.828/lab\n git checkout -b lab2 origin/lab2\n git merge lab1\n```\n> Lab 2 添加了以下文件:\n```bash\ninc/memlayout.h\nkern/pmap.c\nkern/pmap.h\nkern/kclock.h\nkern/kclock.c\n```\n> `memlayout.h` 描述了虚拟地址空间的结构，通过修改`pmap.c/memlayout.h` 和`pmap.h`来实现`PageInfo`结构，这个是为了记录哪些物理内存的page是空闲的。`kclock.c` 和 `kclock.h` 管理PC的时钟和CMOS RAM硬件，这个设备记录了物理内存的数量。`pmap.c`需要读这个设备来确定内存大小。\n\n## Part 1：Physical Page Management\n> 操作系统必须要追踪记录哪些内存区域是空闲的，哪些是被占用的。JOS内核是以页(page)为最小粒度来管理内存的，它使用MMU来映射，保护每一块被分配出去的内存。这里要具体实现一下物理内存页的分配子函数。它利用一个结构体`PageInfo`的链表来记录哪些页是空闲的，链表中每一个结点对应一个物理页。\n\n### Exercise 1.\n> 在文件 kern/pmap.c 中，完成以下几个子函数:\n> * boot_alloc()\n> * mem_init()\n> * page_init()\n> * page_alloc()\n> * page_free()\n> * check_page_free_list()和check_page_alloc()两个函数将会检测页分配器代码的正确性.\n\n\n> 查看`pmap.c`中的代码，其中最重要的函数就是`mem_init`了，在内核刚开始运行时就会调用这个子函数，对整个操作系统的内存管理系统进行一些初始化的设置，比如设定页表等等操作。下面进入这个函数，首先这个函数调用 `i386_detect_memory` 子函数，这个子函数的功能就是检测现在系统中有多少可用的内存空间。\n  之前有讲，jos把整个物理内存空间划分成三个部分：\n>> 1. 从0x00000~0xA0000，这部分也叫basemem，是可用的。\n>> 2. 紧接着是0xA0000~0x100000，这部分叫做IO hole，是不可用的，主要被用来分配给外部设备了。\n>> 3. 再紧接着就是0x100000~0x，这部分叫做extmem，是可用的，这是最重要的内存区域。\n\n> 这个子函数中包括三个变量，其中`npages`记录整个内存的页,`npages_basemem`记录basemem的页数，`npages_extmem`记录extmem的页数。\n下一条指令为：\n> ```c\nkern_pgdir = (pde_t *) boot_alloc(PGSIZE);\nmemset(kern_pgdir, 0, PGSIZE);\n```\n> 其中`kern_pgdir`是一个指针，`pde_t *kern_pgdir`，它是指向操作系统的页目录表的指针，操作系统之后工作在虚拟内存模式下时，就需要这个页目录表进行地址转换。我们为这个页目录表分配的内存大小空间为`PGSIZE`，即一个页的大小。并且首先把这部分内存清0。\n\n> 通过查看 `mem_init` 函数可以知道，`boot_alloc` 是用来初始化页目录(page directory)。在 `boot_alloc` 中，`nextfree` 为下一个空闲内存的虚拟内存地址，当 `nextfree` 为空时会先初始化。用到了`ROUNDUP`，这个`ROUNDUP`在 ``/inc/types.h` 中，因为内存区块是对齐的，所以每块都是固定的大小。npages 是页数量，可使用的内存大小是 `npages × PGSIZE` ，根据lab1提到的，KERNBASE是分配内存的起始地址，若`nextfree` 大于 `KERNBASE + npages × PGSIZE` 的值，就是指针地址溢出了。\n所以只需要添加上这部分代码:\n> ```c\nresult = nextfree;\nnextfree = ROUNDUP(nextfree+n, PGSIZE);\nif((uint32_t)nextfree > KERNBASE + (npages * PGSIZE)) {\n    panic(\"Out of memory!\\n\");\n}\n```\n> `mem_init()`在执行完上面的函数以后，会给`kern_pgdir`加上权限位。之后就是要初始化所有的`struct PageInfo`为 0。首先确定`PageInfo`的大小，然后用`boot_alloc()`分配内存，接着用`memset()`初始化。\n> ```c\nsize_t PageInfo_size = sizeof(struct PageInfo);\npages = (struct PageInfo *)boot_alloc(npages * PageInfo_size);\nmemset(pages, 0, npages * PageInfo_size);\n```\n\n> 接着调用`page_init()`来初始化`page`结构和内存空闲链表。\n`page_init()`，这个子函数的功能包括：\n>> 1. 初始化pages数组\n>> 2. 初始化pages_free_list链表，这个数组中存放着所有空闲页的信息\n\n> 可以到这个函数的定义处具体查看，整个函数是由一个for循环构成，它会遍历所有内存页所对应的在`npages`数组中的`PageInfo`结构体，并且根据这个页当前的状态来修改这个结构体的状态，如果页已被占用，那么要把`PageInfo`结构体中的`pp_ref`属性置一；如果是空闲页，则要把这个页送入`pages_free_list`链表中。根据注释中的提示，第0页已被占用，`io hole`部分已被占用，还有在extmem区域还有一部分已经被占用，代码如下：\n> ```c\nsize_t i;\npage_free_list = NULL;\n\n//num_alloc：在extmem区域已经被占用的页的个数\nint num_alloc = ((uint32_t)boot_alloc(0) - KERNBASE) / PGSIZE;\n//num_iohole：在io hole区域占用的页数\nint num_iohole = 96;\n\nfor(i=0; i<npages; i++)\n{\n    if(i==0)\n    {\n        pages[i].pp_ref = 1;\n    }    \n    else if(i >= npages_basemem && i < npages_basemem + num_iohole + num_alloc)\n    {\n        pages[i].pp_ref = 1;\n    }\n    else\n    {\n        pages[i].pp_ref = 0;\n        pages[i].pp_link = page_free_list;\n        page_free_list = &pages[i];\n    }\n}\n```\n\n> 先实现`page_alloc()`函数，通过注释我们可以知道这个函数的功能就是分配一个物理页。而函数的返回值就是这个物理页所对应的`PageInfo`结构体。\n所以这个函数的大致步骤应该是：\n>> 1. 从free_page_list中取出一个空闲页的PageInfo结构体\n>> 2. 修改free_page_list相关信息，比如修改链表表头\n>> 3. 修改取出的空闲页的PageInfo结构体信息，初始化该页的内存\n\n> 代码如下：\n> ```c\nstruct PageInfo *\npage_alloc(int alloc_flags)\n{\n    struct PageInfo *result;\n    if (page_free_list == NULL)\n        return NULL;\n\n      result= page_free_list;\n      page_free_list = result->pp_link;\n      result->pp_link = NULL;\n\n    if (alloc_flags & ALLOC_ZERO)\n        memset(page2kva(result), 0, PGSIZE);\n\n      return result;\n}\n```\n> `实现page_free()`方法，根据注释可知，这个方法的功能就是把一个页的`PageInfo`结构体再返回给`page_free_list`空闲页链表，代表回收了这个页。\n主要完成以下几个操作：\n>> 1. 修改被回收的页的PageInfo结构体的相应信息。\n>> 2. 把该结构体插入回page_free_list空闲页链表。\n\n> 代码如下：\n> ```c\nvoid page_free(struct PageInfo *pp)\n{\n    // Fill this function in\n    // Hint: You may want to panic if pp->pp_ref is nonzero or\n    // pp->pp_link is not NULL.\n      assert(pp->pp_ref == 0);\n      assert(pp->pp_link == NULL);\n\n      pp->pp_link = page_free_list;\n      page_free_list = pp;\n}\n```\n\n## Part 2: Virtual Memory\n> 在x86体系中，一个虚拟地址(Virtual Address)是由两部分组成，一个是段选择子(segment selector)，另一个是段内偏移(segment offset)。一个线性地址(Linear Address)指的是通过段地址转换机构把虚拟地址进行转换之后得到的地址。一个物理地址(Physical Addresses)是分页地址转换机构把线性地址进行转换之后得到的真实的内存地址，这个地址将会最终送到你的内存芯片的地址总线上。\n我们所编写的C语言程序中的指针的值是虚拟地址中段内偏移部分的值。在boot/boot.S文件中，我们引入了一个全局描述符表，这个表通过把所有的段的基址设置为0，界限设置为0xffffffff的方式，关闭了分段管理的功能。因此虚拟地址中的段选择子字段的内容已经没有任何意义，线性地址的值总是等于虚拟地址中段内偏移的值。\n回顾一下lab1中的part 3，我们引入了一个简单的页表，使得内核可以运行与0xf0100000的虚拟地址空间，尽管它所在的真实位置是物理地址0x00100000处，刚刚好在ROM BIOS之上。这个页表仅仅映射了4MB的内存空间。在我们这个JOS操作系统中，我们希望把这种映射扩展到物理内存的头256MB空间上，并且把这部分物理空间映射到从0xf0000000开始的虚拟空间中，以及一些其他的虚拟地址空间中。\n### Exercise 2\n> 熟悉关于分页地址转换(page translation)和基于页的保护(page-based protection)。\n首先介绍一下80386将逻辑地址转为物理地址的方法。\n>> * 分段地址转换，由段选择子和段偏移量构成的逻辑地址转为线性地址。\n>> * 分页地址转换，线性地址转为物理地址。\n\n#### 区别虚拟地址，线性地址，物理地址\n虚拟地址是有段选择子和段偏移构成。线性地址是经过分段地址转换单没进行分页地址转换。物理地址是两种转换之后最终通过硬件总线到RAM的地址。C 指针是虚拟地址的偏移部分。在 `boot/boot.S`中，引入全局描述符表(GDT)将所有段基址设为0到 0xffffffff。因此线性地址等于虚拟地址的偏移量。\n```\n           Selector  +--------------+         +-----------+\n          ---------->|              |         |           |\n                     | Segmentation |         |  Paging   |\nSoftware             |              |-------->|           |---------->  RAM\n            Offset   |  Mechanism   |         | Mechanism |\n          ---------->|              |         |           |\n                     +--------------+         +-----------+\n            Virtual                   Linear                Physical\n```\n\n### Exercise 3`\n> 在QEMU中使用 `xp 可以查看物理内存，PD虚拟机对于lab手册上调出QEMU monitor的方法没用，查看\n指令为\n```bash\nqemu-system-i386 -hda obj/kern/kernel.img -monitor stdio -gdb tcp::26000 -D qemu.log。\n```\n\n> 在QEMU monitor中使用 `info pg` 查看当前页表， `info mem` 查看虚拟内存的范围。\n进入保护模式以后，所有地址引用都是虚拟地址，由MMU转换，也就是说 C 指针都是虚拟地址。JOS内核经常需要操作地址通过整数而不解引用。JOS为了区分两种情况：类型 `uintptr_t` 代表虚拟地址，`physaddr_t` 代表物理地址。虽然都是32位整数，但是不能直接解引用，需要先转换类型。JOS需要读取或修改内存，尽管只知道物理地址。给页表添加映射需要分配无力内存去储存一个页目录，然后才能初始化内存。然而内核不能绕过虚拟地址转换，因此不能直接加载和储存物理地址。为了将物理地址转为虚拟地址，内核需要在物理地址加上`0xf0000000`从而找到相关的虚拟地址，可以使用`KADDR(pa)`完成这个操作。\n同样，如果内核需要通过虚拟地址去找物理地址，就需要减去`0xf0000000`，可以使用`PADDR(va)`完成这个操作。\n\n> 引用计数\n之后实验经常需要将多个虚拟地址同时映射到同一块物理页上，因此需要给每一个物理页计数引用次数，这个值位于物理页 `struct PageInfo` 中的 `pp_ref` 字段中。\n\n### Exercise 4\n> 实现`kern/pmap.c`里的`pgdir_walk()，boot_map_region()，page_lookup()，page_remove()，page_insert()`这几个函数。`check_page()`会测试是否写的正确。\n\n> 首先是 `pgdir_walk()`，参考注释可以得知，这个函数获得指向线性地址页表项的指针，传入的参数是页目录指针，线性地址和另外一个参数。\n![page](http://xinqiu.me/2016/12/09/MIT-6.828-2/2.png)\n> 由上面的图可以知道二级分页模式下线性地址到物理地址的转换。所以首先要获得页目录地址，判断是否指向的页表项存在，不存在则新建一个页表。这里有两个注意点。\n>> * 第一个地方是要注意判断页表是否存在，根据下图页目录/表的结构，可以知道这里的P位代表Present，用来判断对应的物理页是否存在，存在则为1，所以通过与运算来判断。\n>> * 另外一个注意点是新建页。为新建的物理页设置页目录时，需要添加上权限位\n\n> 代码如下:\n> ```c\npte_t *\npgdir_walk(pde_t *pgdir, const void *va, int create)\n{\n    // Fill this function in\n    pde_t *pt = pgdir + PDX(va);\n    pde_t *pt_addr_v;\n\n    if (*pt & PTE_P) {\n        pt_addr_v = (pte_t *)KADDR(PTE_ADDR(*pt));\n        return pt_addr_v + PTX(va);\n    } else {\n        struct PageInfo *newpt;\n        if (create == 1 && (newpt = page_alloc(ALLOC_ZERO)) != 0) {\n            memset(page2kva(newpt), 0, PGSIZE);\n            newpt->pp_ref ++;\n            *pt = PADDR(page2kva(newpt))|PTE_U|PTE_W|PTE_P;\n            pt_addr_v = (pte_t *)KADDR(PTE_ADDR(*pt));\n            return pt_addr_v + PTX(va);\n        }\n    }\n    return NULL;\n}\n```\n\n> 接着是`boot_map_region`函数，这个函数将虚拟地址`[va, va+size)`映射到物理地址`[pa, pa+size)`，注释中提到可以使用上面写的`pgdir_walk`，获取页表地址，接着将物理地址的值与上权限位赋给页表地址。\n```c\nstatic void\nboot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)\n{\n    // Fill this function in\n    int offset;\n    pte_t *pt;\n    for (offset = 0; offset < size; offset += PGSIZE) {\n        pt = pgdir_walk(pgdir, (void *)va, 1);\n        *pt = pa|perm|PTE_P;\n        pa += PGSIZE;\n        va += PGSIZE;\n    }\n}\n```\n\n> 之后是`page_lookup`函数，查找线性地址va对应的物理页面，找到就返回这个物理页，否则返回`NULL`。首先如果`pte_store`非0，则储存这个页的页表地址，这一步是为了之后的`page_remove`用的。\n> ```c\nstruct PageInfo *\npage_lookup(pde_t *pgdir, void *va, pte_t **pte_store)\n{\n    // Fill this function in\n    pte_t *pte = pgdir_walk(pgdir, va, 0);\n    if (pte_store != 0) {\n        *pte_store = pte;\n    }\n    if (pte != NULL && (*pte & PTE_P)) {\n        return pa2page(PTE_ADDR(*pte));\n    }\n    return NULL;\n}\n```\n\n> `page_remove`实现参考注释里的提示，先通过`page_lookup`获得物理页，如果存在则执行删除工作`page_decref`，同时也要将`va`地址的页表项设为0，最后就是验证有效性。\n> ```c\nvoid\npage_remove(pde_t *pgdir, void *va)\n{\n    // Fill this function in\n    pte_t *pte;\n    struct PageInfo *page = page_lookup(pgdir, va, &pte);\n    if (page) {\n        page_decref(page);\n        *pte = 0;\n        tlb_invalidate(pgdir, va);\n    }\n}\n```\n> 最后一步就是`page_insert`函数，将页面管理结构 `pp` 所对应的物理页面分配给线性地址 `va`。同时,将对应的页表项的 `permission` 设置成 `PTE_P&perm`。 注意:一定要考虑到线性地址 `va` 已经指向了另外一个物理页面或者干脆就是这个函数要指向的物理页面的情况。如果线性地址 `va` 已经指向了另外一个物理页面,则先要调用 `page_remove` 将该物理页从线性地址 `va` 处删除,再将 `va` 对应的页表项的地址赋值为 `pp` 对应 的物理页面。如果 `va` 指向的本来就是参数 `pp` 所对应的物理页面,则将 `va` 对应的页表项中 的物理地址赋值重新赋值为 `pp` 所对应的物理页面的首地址即可。\n> ```c\nint\npage_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)\n{\n    // Fill this function in\n    pte_t *pte = pgdir_walk(pgdir, va, 1);\n    if (!pte) {\n        return -E_NO_MEM;\n    }  \n    if (*pte & PTE_P) {\n        if (PTE_ADDR(*pte) == page2pa(pp)) {\n            tlb_invalidate(pgdir, va);\n            pp->pp_ref--;\n        }\n        else {\n            page_remove(pgdir, va);\n        }\n    }\n    *pte = page2pa(pp) | perm | PTE_P;\n    pp->pp_ref++;\n    pgdir[PDX(va)] |= perm;\n    return 0;\n}\n```\n\n## Part 3: 内核地址空间\n\n#### 线性地址的两部分\n> JOS将处理器32位线性地址划分为占低地址的用户环境(进程)和占高地址的内核。 分界线是`inc/memlayout.h`中的变量 `ULIM`。内核保留了大约256MB的虚拟地址空间，lab1中内核设在那么高的地址就是因为要留一部分空间给用户环境。\n\n#### 访问权限和故障隔离\n> 内核和用户内存都在各自的环境地址空间中，必须在x86页表中使用访问权限位(`Permissions bits`)来使用户代码只访问用户的地址空间，否则用户的代码bug会覆盖内核数据，造成系统崩溃。值得注意的是可写权限位(`PTE_W`)可以同时影响用户和内核代码。\n高于`ULIM`的内存内核可以读写，而用户环境没有权限。内核和用户在地址`[UTOP,ULIM)`有同样的权限：可读但不可写，这部分地址空间通常是一些特定的内核数据，让用户环境可以读取。最后，地址`UTOP`之下的是用户环境。\n\n#### 初始化内核地址空间\n> 设置`UTOP`之上的地址空间。在`inc/memlayout.h`中显示了布局。\n\n#### Exercise 5\n> 完成`mem_init()`中缺少的部分。\n> 因为`mem_init`开头创建了初始化页目录`kern_pgdir`，首先是将`pages`数组映射到线性地址`UPAGES`，权限是内核只读。\n> ```c\nboot_map_region(kern_pgdir, UPAGES, PTSIZE, PADDR(pages),PTE_U);`\n```\n> 接着是映射物理地址到内核栈，也就是从地址范围`[KSTACKTOP-KSTKSIZE, KSTACKTOP)`映射到`bootstack`开始的物理地址页上，注释中提到了，只要映射`[KSTACKTOP-KSTKSIZE, KSTACKTOP)`， `[KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE)`不映射，权限位是内核读写。\n> ```c\nboot_map_region(kern_pgdir, KSTACKTOP-KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W);\n```\n> 最后是映射虚拟地址`[KERNBASE, 2^32)`到物理地址`[0, 2^32 - KERNBASE)`，权限位是内核读写。\n> ```c\nboot_map_region(kern_pgdir, KERNBASE, (0xffffffff-KERNBASE), 0, PTE_W);\n```\n\n## 参考链接\n[memory management](https://pdos.csail.mit.edu/6.828/2016/labs/lab2/)\n","source":"_posts/lab2.md","raw":"title: lab2-memeory-management\ndate: 2017/04/18\ntags:\n- xv6\n- os\n\n---\n\n# Lab2 内存管理\n## 摘要\n> * 内存管理有两个组件:\n> 1.  第一个组件是内核的物理内存分配器，因此内核可以分配内存并稍后释放它。.分配器将以4096个字节为单位进行操作，称为页面。代码要实现维护记录哪些物理页面是空闲的，哪些被分配的数据结构以及共享每个分配的页面的进程数量,另外还将编写例程以分配和释放内存页面。\n> 2. 第二个组件是虚拟内存，它将内核和用户软件使用的虚拟地址映射到物理内存中的地址。 当指令使用内存，咨询一组页表时，x86硬件的内存管理单元（MMU）执行映射。 lab2根据提供的规范修改JOS以设置MMU的页表。\n\n> - lab1分为三部分\n> 1. part1: 物理页面管理 physical page management\n> 2. part2: 虚拟内存 virtual memory\n> 3. part3: 内核地址空间 kernel address space\n\n<!-- more -->\n\n## 实验代码\n> ```bash\n cd ~/6.828/lab\n git checkout -b lab2 origin/lab2\n git merge lab1\n```\n> Lab 2 添加了以下文件:\n```bash\ninc/memlayout.h\nkern/pmap.c\nkern/pmap.h\nkern/kclock.h\nkern/kclock.c\n```\n> `memlayout.h` 描述了虚拟地址空间的结构，通过修改`pmap.c/memlayout.h` 和`pmap.h`来实现`PageInfo`结构，这个是为了记录哪些物理内存的page是空闲的。`kclock.c` 和 `kclock.h` 管理PC的时钟和CMOS RAM硬件，这个设备记录了物理内存的数量。`pmap.c`需要读这个设备来确定内存大小。\n\n## Part 1：Physical Page Management\n> 操作系统必须要追踪记录哪些内存区域是空闲的，哪些是被占用的。JOS内核是以页(page)为最小粒度来管理内存的，它使用MMU来映射，保护每一块被分配出去的内存。这里要具体实现一下物理内存页的分配子函数。它利用一个结构体`PageInfo`的链表来记录哪些页是空闲的，链表中每一个结点对应一个物理页。\n\n### Exercise 1.\n> 在文件 kern/pmap.c 中，完成以下几个子函数:\n> * boot_alloc()\n> * mem_init()\n> * page_init()\n> * page_alloc()\n> * page_free()\n> * check_page_free_list()和check_page_alloc()两个函数将会检测页分配器代码的正确性.\n\n\n> 查看`pmap.c`中的代码，其中最重要的函数就是`mem_init`了，在内核刚开始运行时就会调用这个子函数，对整个操作系统的内存管理系统进行一些初始化的设置，比如设定页表等等操作。下面进入这个函数，首先这个函数调用 `i386_detect_memory` 子函数，这个子函数的功能就是检测现在系统中有多少可用的内存空间。\n  之前有讲，jos把整个物理内存空间划分成三个部分：\n>> 1. 从0x00000~0xA0000，这部分也叫basemem，是可用的。\n>> 2. 紧接着是0xA0000~0x100000，这部分叫做IO hole，是不可用的，主要被用来分配给外部设备了。\n>> 3. 再紧接着就是0x100000~0x，这部分叫做extmem，是可用的，这是最重要的内存区域。\n\n> 这个子函数中包括三个变量，其中`npages`记录整个内存的页,`npages_basemem`记录basemem的页数，`npages_extmem`记录extmem的页数。\n下一条指令为：\n> ```c\nkern_pgdir = (pde_t *) boot_alloc(PGSIZE);\nmemset(kern_pgdir, 0, PGSIZE);\n```\n> 其中`kern_pgdir`是一个指针，`pde_t *kern_pgdir`，它是指向操作系统的页目录表的指针，操作系统之后工作在虚拟内存模式下时，就需要这个页目录表进行地址转换。我们为这个页目录表分配的内存大小空间为`PGSIZE`，即一个页的大小。并且首先把这部分内存清0。\n\n> 通过查看 `mem_init` 函数可以知道，`boot_alloc` 是用来初始化页目录(page directory)。在 `boot_alloc` 中，`nextfree` 为下一个空闲内存的虚拟内存地址，当 `nextfree` 为空时会先初始化。用到了`ROUNDUP`，这个`ROUNDUP`在 ``/inc/types.h` 中，因为内存区块是对齐的，所以每块都是固定的大小。npages 是页数量，可使用的内存大小是 `npages × PGSIZE` ，根据lab1提到的，KERNBASE是分配内存的起始地址，若`nextfree` 大于 `KERNBASE + npages × PGSIZE` 的值，就是指针地址溢出了。\n所以只需要添加上这部分代码:\n> ```c\nresult = nextfree;\nnextfree = ROUNDUP(nextfree+n, PGSIZE);\nif((uint32_t)nextfree > KERNBASE + (npages * PGSIZE)) {\n    panic(\"Out of memory!\\n\");\n}\n```\n> `mem_init()`在执行完上面的函数以后，会给`kern_pgdir`加上权限位。之后就是要初始化所有的`struct PageInfo`为 0。首先确定`PageInfo`的大小，然后用`boot_alloc()`分配内存，接着用`memset()`初始化。\n> ```c\nsize_t PageInfo_size = sizeof(struct PageInfo);\npages = (struct PageInfo *)boot_alloc(npages * PageInfo_size);\nmemset(pages, 0, npages * PageInfo_size);\n```\n\n> 接着调用`page_init()`来初始化`page`结构和内存空闲链表。\n`page_init()`，这个子函数的功能包括：\n>> 1. 初始化pages数组\n>> 2. 初始化pages_free_list链表，这个数组中存放着所有空闲页的信息\n\n> 可以到这个函数的定义处具体查看，整个函数是由一个for循环构成，它会遍历所有内存页所对应的在`npages`数组中的`PageInfo`结构体，并且根据这个页当前的状态来修改这个结构体的状态，如果页已被占用，那么要把`PageInfo`结构体中的`pp_ref`属性置一；如果是空闲页，则要把这个页送入`pages_free_list`链表中。根据注释中的提示，第0页已被占用，`io hole`部分已被占用，还有在extmem区域还有一部分已经被占用，代码如下：\n> ```c\nsize_t i;\npage_free_list = NULL;\n\n//num_alloc：在extmem区域已经被占用的页的个数\nint num_alloc = ((uint32_t)boot_alloc(0) - KERNBASE) / PGSIZE;\n//num_iohole：在io hole区域占用的页数\nint num_iohole = 96;\n\nfor(i=0; i<npages; i++)\n{\n    if(i==0)\n    {\n        pages[i].pp_ref = 1;\n    }    \n    else if(i >= npages_basemem && i < npages_basemem + num_iohole + num_alloc)\n    {\n        pages[i].pp_ref = 1;\n    }\n    else\n    {\n        pages[i].pp_ref = 0;\n        pages[i].pp_link = page_free_list;\n        page_free_list = &pages[i];\n    }\n}\n```\n\n> 先实现`page_alloc()`函数，通过注释我们可以知道这个函数的功能就是分配一个物理页。而函数的返回值就是这个物理页所对应的`PageInfo`结构体。\n所以这个函数的大致步骤应该是：\n>> 1. 从free_page_list中取出一个空闲页的PageInfo结构体\n>> 2. 修改free_page_list相关信息，比如修改链表表头\n>> 3. 修改取出的空闲页的PageInfo结构体信息，初始化该页的内存\n\n> 代码如下：\n> ```c\nstruct PageInfo *\npage_alloc(int alloc_flags)\n{\n    struct PageInfo *result;\n    if (page_free_list == NULL)\n        return NULL;\n\n      result= page_free_list;\n      page_free_list = result->pp_link;\n      result->pp_link = NULL;\n\n    if (alloc_flags & ALLOC_ZERO)\n        memset(page2kva(result), 0, PGSIZE);\n\n      return result;\n}\n```\n> `实现page_free()`方法，根据注释可知，这个方法的功能就是把一个页的`PageInfo`结构体再返回给`page_free_list`空闲页链表，代表回收了这个页。\n主要完成以下几个操作：\n>> 1. 修改被回收的页的PageInfo结构体的相应信息。\n>> 2. 把该结构体插入回page_free_list空闲页链表。\n\n> 代码如下：\n> ```c\nvoid page_free(struct PageInfo *pp)\n{\n    // Fill this function in\n    // Hint: You may want to panic if pp->pp_ref is nonzero or\n    // pp->pp_link is not NULL.\n      assert(pp->pp_ref == 0);\n      assert(pp->pp_link == NULL);\n\n      pp->pp_link = page_free_list;\n      page_free_list = pp;\n}\n```\n\n## Part 2: Virtual Memory\n> 在x86体系中，一个虚拟地址(Virtual Address)是由两部分组成，一个是段选择子(segment selector)，另一个是段内偏移(segment offset)。一个线性地址(Linear Address)指的是通过段地址转换机构把虚拟地址进行转换之后得到的地址。一个物理地址(Physical Addresses)是分页地址转换机构把线性地址进行转换之后得到的真实的内存地址，这个地址将会最终送到你的内存芯片的地址总线上。\n我们所编写的C语言程序中的指针的值是虚拟地址中段内偏移部分的值。在boot/boot.S文件中，我们引入了一个全局描述符表，这个表通过把所有的段的基址设置为0，界限设置为0xffffffff的方式，关闭了分段管理的功能。因此虚拟地址中的段选择子字段的内容已经没有任何意义，线性地址的值总是等于虚拟地址中段内偏移的值。\n回顾一下lab1中的part 3，我们引入了一个简单的页表，使得内核可以运行与0xf0100000的虚拟地址空间，尽管它所在的真实位置是物理地址0x00100000处，刚刚好在ROM BIOS之上。这个页表仅仅映射了4MB的内存空间。在我们这个JOS操作系统中，我们希望把这种映射扩展到物理内存的头256MB空间上，并且把这部分物理空间映射到从0xf0000000开始的虚拟空间中，以及一些其他的虚拟地址空间中。\n### Exercise 2\n> 熟悉关于分页地址转换(page translation)和基于页的保护(page-based protection)。\n首先介绍一下80386将逻辑地址转为物理地址的方法。\n>> * 分段地址转换，由段选择子和段偏移量构成的逻辑地址转为线性地址。\n>> * 分页地址转换，线性地址转为物理地址。\n\n#### 区别虚拟地址，线性地址，物理地址\n虚拟地址是有段选择子和段偏移构成。线性地址是经过分段地址转换单没进行分页地址转换。物理地址是两种转换之后最终通过硬件总线到RAM的地址。C 指针是虚拟地址的偏移部分。在 `boot/boot.S`中，引入全局描述符表(GDT)将所有段基址设为0到 0xffffffff。因此线性地址等于虚拟地址的偏移量。\n```\n           Selector  +--------------+         +-----------+\n          ---------->|              |         |           |\n                     | Segmentation |         |  Paging   |\nSoftware             |              |-------->|           |---------->  RAM\n            Offset   |  Mechanism   |         | Mechanism |\n          ---------->|              |         |           |\n                     +--------------+         +-----------+\n            Virtual                   Linear                Physical\n```\n\n### Exercise 3`\n> 在QEMU中使用 `xp 可以查看物理内存，PD虚拟机对于lab手册上调出QEMU monitor的方法没用，查看\n指令为\n```bash\nqemu-system-i386 -hda obj/kern/kernel.img -monitor stdio -gdb tcp::26000 -D qemu.log。\n```\n\n> 在QEMU monitor中使用 `info pg` 查看当前页表， `info mem` 查看虚拟内存的范围。\n进入保护模式以后，所有地址引用都是虚拟地址，由MMU转换，也就是说 C 指针都是虚拟地址。JOS内核经常需要操作地址通过整数而不解引用。JOS为了区分两种情况：类型 `uintptr_t` 代表虚拟地址，`physaddr_t` 代表物理地址。虽然都是32位整数，但是不能直接解引用，需要先转换类型。JOS需要读取或修改内存，尽管只知道物理地址。给页表添加映射需要分配无力内存去储存一个页目录，然后才能初始化内存。然而内核不能绕过虚拟地址转换，因此不能直接加载和储存物理地址。为了将物理地址转为虚拟地址，内核需要在物理地址加上`0xf0000000`从而找到相关的虚拟地址，可以使用`KADDR(pa)`完成这个操作。\n同样，如果内核需要通过虚拟地址去找物理地址，就需要减去`0xf0000000`，可以使用`PADDR(va)`完成这个操作。\n\n> 引用计数\n之后实验经常需要将多个虚拟地址同时映射到同一块物理页上，因此需要给每一个物理页计数引用次数，这个值位于物理页 `struct PageInfo` 中的 `pp_ref` 字段中。\n\n### Exercise 4\n> 实现`kern/pmap.c`里的`pgdir_walk()，boot_map_region()，page_lookup()，page_remove()，page_insert()`这几个函数。`check_page()`会测试是否写的正确。\n\n> 首先是 `pgdir_walk()`，参考注释可以得知，这个函数获得指向线性地址页表项的指针，传入的参数是页目录指针，线性地址和另外一个参数。\n![page](http://xinqiu.me/2016/12/09/MIT-6.828-2/2.png)\n> 由上面的图可以知道二级分页模式下线性地址到物理地址的转换。所以首先要获得页目录地址，判断是否指向的页表项存在，不存在则新建一个页表。这里有两个注意点。\n>> * 第一个地方是要注意判断页表是否存在，根据下图页目录/表的结构，可以知道这里的P位代表Present，用来判断对应的物理页是否存在，存在则为1，所以通过与运算来判断。\n>> * 另外一个注意点是新建页。为新建的物理页设置页目录时，需要添加上权限位\n\n> 代码如下:\n> ```c\npte_t *\npgdir_walk(pde_t *pgdir, const void *va, int create)\n{\n    // Fill this function in\n    pde_t *pt = pgdir + PDX(va);\n    pde_t *pt_addr_v;\n\n    if (*pt & PTE_P) {\n        pt_addr_v = (pte_t *)KADDR(PTE_ADDR(*pt));\n        return pt_addr_v + PTX(va);\n    } else {\n        struct PageInfo *newpt;\n        if (create == 1 && (newpt = page_alloc(ALLOC_ZERO)) != 0) {\n            memset(page2kva(newpt), 0, PGSIZE);\n            newpt->pp_ref ++;\n            *pt = PADDR(page2kva(newpt))|PTE_U|PTE_W|PTE_P;\n            pt_addr_v = (pte_t *)KADDR(PTE_ADDR(*pt));\n            return pt_addr_v + PTX(va);\n        }\n    }\n    return NULL;\n}\n```\n\n> 接着是`boot_map_region`函数，这个函数将虚拟地址`[va, va+size)`映射到物理地址`[pa, pa+size)`，注释中提到可以使用上面写的`pgdir_walk`，获取页表地址，接着将物理地址的值与上权限位赋给页表地址。\n```c\nstatic void\nboot_map_region(pde_t *pgdir, uintptr_t va, size_t size, physaddr_t pa, int perm)\n{\n    // Fill this function in\n    int offset;\n    pte_t *pt;\n    for (offset = 0; offset < size; offset += PGSIZE) {\n        pt = pgdir_walk(pgdir, (void *)va, 1);\n        *pt = pa|perm|PTE_P;\n        pa += PGSIZE;\n        va += PGSIZE;\n    }\n}\n```\n\n> 之后是`page_lookup`函数，查找线性地址va对应的物理页面，找到就返回这个物理页，否则返回`NULL`。首先如果`pte_store`非0，则储存这个页的页表地址，这一步是为了之后的`page_remove`用的。\n> ```c\nstruct PageInfo *\npage_lookup(pde_t *pgdir, void *va, pte_t **pte_store)\n{\n    // Fill this function in\n    pte_t *pte = pgdir_walk(pgdir, va, 0);\n    if (pte_store != 0) {\n        *pte_store = pte;\n    }\n    if (pte != NULL && (*pte & PTE_P)) {\n        return pa2page(PTE_ADDR(*pte));\n    }\n    return NULL;\n}\n```\n\n> `page_remove`实现参考注释里的提示，先通过`page_lookup`获得物理页，如果存在则执行删除工作`page_decref`，同时也要将`va`地址的页表项设为0，最后就是验证有效性。\n> ```c\nvoid\npage_remove(pde_t *pgdir, void *va)\n{\n    // Fill this function in\n    pte_t *pte;\n    struct PageInfo *page = page_lookup(pgdir, va, &pte);\n    if (page) {\n        page_decref(page);\n        *pte = 0;\n        tlb_invalidate(pgdir, va);\n    }\n}\n```\n> 最后一步就是`page_insert`函数，将页面管理结构 `pp` 所对应的物理页面分配给线性地址 `va`。同时,将对应的页表项的 `permission` 设置成 `PTE_P&perm`。 注意:一定要考虑到线性地址 `va` 已经指向了另外一个物理页面或者干脆就是这个函数要指向的物理页面的情况。如果线性地址 `va` 已经指向了另外一个物理页面,则先要调用 `page_remove` 将该物理页从线性地址 `va` 处删除,再将 `va` 对应的页表项的地址赋值为 `pp` 对应 的物理页面。如果 `va` 指向的本来就是参数 `pp` 所对应的物理页面,则将 `va` 对应的页表项中 的物理地址赋值重新赋值为 `pp` 所对应的物理页面的首地址即可。\n> ```c\nint\npage_insert(pde_t *pgdir, struct PageInfo *pp, void *va, int perm)\n{\n    // Fill this function in\n    pte_t *pte = pgdir_walk(pgdir, va, 1);\n    if (!pte) {\n        return -E_NO_MEM;\n    }  \n    if (*pte & PTE_P) {\n        if (PTE_ADDR(*pte) == page2pa(pp)) {\n            tlb_invalidate(pgdir, va);\n            pp->pp_ref--;\n        }\n        else {\n            page_remove(pgdir, va);\n        }\n    }\n    *pte = page2pa(pp) | perm | PTE_P;\n    pp->pp_ref++;\n    pgdir[PDX(va)] |= perm;\n    return 0;\n}\n```\n\n## Part 3: 内核地址空间\n\n#### 线性地址的两部分\n> JOS将处理器32位线性地址划分为占低地址的用户环境(进程)和占高地址的内核。 分界线是`inc/memlayout.h`中的变量 `ULIM`。内核保留了大约256MB的虚拟地址空间，lab1中内核设在那么高的地址就是因为要留一部分空间给用户环境。\n\n#### 访问权限和故障隔离\n> 内核和用户内存都在各自的环境地址空间中，必须在x86页表中使用访问权限位(`Permissions bits`)来使用户代码只访问用户的地址空间，否则用户的代码bug会覆盖内核数据，造成系统崩溃。值得注意的是可写权限位(`PTE_W`)可以同时影响用户和内核代码。\n高于`ULIM`的内存内核可以读写，而用户环境没有权限。内核和用户在地址`[UTOP,ULIM)`有同样的权限：可读但不可写，这部分地址空间通常是一些特定的内核数据，让用户环境可以读取。最后，地址`UTOP`之下的是用户环境。\n\n#### 初始化内核地址空间\n> 设置`UTOP`之上的地址空间。在`inc/memlayout.h`中显示了布局。\n\n#### Exercise 5\n> 完成`mem_init()`中缺少的部分。\n> 因为`mem_init`开头创建了初始化页目录`kern_pgdir`，首先是将`pages`数组映射到线性地址`UPAGES`，权限是内核只读。\n> ```c\nboot_map_region(kern_pgdir, UPAGES, PTSIZE, PADDR(pages),PTE_U);`\n```\n> 接着是映射物理地址到内核栈，也就是从地址范围`[KSTACKTOP-KSTKSIZE, KSTACKTOP)`映射到`bootstack`开始的物理地址页上，注释中提到了，只要映射`[KSTACKTOP-KSTKSIZE, KSTACKTOP)`， `[KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE)`不映射，权限位是内核读写。\n> ```c\nboot_map_region(kern_pgdir, KSTACKTOP-KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W);\n```\n> 最后是映射虚拟地址`[KERNBASE, 2^32)`到物理地址`[0, 2^32 - KERNBASE)`，权限位是内核读写。\n> ```c\nboot_map_region(kern_pgdir, KERNBASE, (0xffffffff-KERNBASE), 0, PTE_W);\n```\n\n## 参考链接\n[memory management](https://pdos.csail.mit.edu/6.828/2016/labs/lab2/)\n","slug":"lab2","published":1,"updated":"2017-08-26T03:38:21.622Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6sslhb900103gamxtf877ft","content":"<h1 id=\"Lab2-内存管理\"><a href=\"#Lab2-内存管理\" class=\"headerlink\" title=\"Lab2 内存管理\"></a>Lab2 内存管理</h1><h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><blockquote>\n<ul>\n<li>内存管理有两个组件:</li>\n</ul>\n<ol>\n<li>第一个组件是内核的物理内存分配器，因此内核可以分配内存并稍后释放它。.分配器将以4096个字节为单位进行操作，称为页面。代码要实现维护记录哪些物理页面是空闲的，哪些被分配的数据结构以及共享每个分配的页面的进程数量,另外还将编写例程以分配和释放内存页面。</li>\n<li>第二个组件是虚拟内存，它将内核和用户软件使用的虚拟地址映射到物理内存中的地址。 当指令使用内存，咨询一组页表时，x86硬件的内存管理单元（MMU）执行映射。 lab2根据提供的规范修改JOS以设置MMU的页表。</li>\n</ol>\n<ul>\n<li>lab1分为三部分</li>\n</ul>\n<ol>\n<li>part1: 物理页面管理 physical page management</li>\n<li>part2: 虚拟内存 virtual memory</li>\n<li>part3: 内核地址空间 kernel address space</li>\n</ol>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"实验代码\"><a href=\"#实验代码\" class=\"headerlink\" title=\"实验代码\"></a>实验代码</h2><blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">cd</span> ~/6.828/lab</div><div class=\"line\">git checkout -b lab2 origin/lab2</div><div class=\"line\">git merge lab1</div></pre></td></tr></table></figure>\n<p>Lab 2 添加了以下文件:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">inc/memlayout.h</div><div class=\"line\">kern/pmap.c</div><div class=\"line\">kern/pmap.h</div><div class=\"line\">kern/kclock.h</div><div class=\"line\">kern/kclock.c</div></pre></td></tr></table></figure></p>\n<p><code>memlayout.h</code> 描述了虚拟地址空间的结构，通过修改<code>pmap.c/memlayout.h</code> 和<code>pmap.h</code>来实现<code>PageInfo</code>结构，这个是为了记录哪些物理内存的page是空闲的。<code>kclock.c</code> 和 <code>kclock.h</code> 管理PC的时钟和CMOS RAM硬件，这个设备记录了物理内存的数量。<code>pmap.c</code>需要读这个设备来确定内存大小。</p>\n</blockquote>\n<h2 id=\"Part-1：Physical-Page-Management\"><a href=\"#Part-1：Physical-Page-Management\" class=\"headerlink\" title=\"Part 1：Physical Page Management\"></a>Part 1：Physical Page Management</h2><blockquote>\n<p>操作系统必须要追踪记录哪些内存区域是空闲的，哪些是被占用的。JOS内核是以页(page)为最小粒度来管理内存的，它使用MMU来映射，保护每一块被分配出去的内存。这里要具体实现一下物理内存页的分配子函数。它利用一个结构体<code>PageInfo</code>的链表来记录哪些页是空闲的，链表中每一个结点对应一个物理页。</p>\n</blockquote>\n<h3 id=\"Exercise-1\"><a href=\"#Exercise-1\" class=\"headerlink\" title=\"Exercise 1.\"></a>Exercise 1.</h3><blockquote>\n<p>在文件 kern/pmap.c 中，完成以下几个子函数:</p>\n<ul>\n<li>boot_alloc()</li>\n<li>mem_init()</li>\n<li>page_init()</li>\n<li>page_alloc()</li>\n<li>page_free()</li>\n<li>check_page_free_list()和check_page_alloc()两个函数将会检测页分配器代码的正确性.</li>\n</ul>\n<p>查看<code>pmap.c</code>中的代码，其中最重要的函数就是<code>mem_init</code>了，在内核刚开始运行时就会调用这个子函数，对整个操作系统的内存管理系统进行一些初始化的设置，比如设定页表等等操作。下面进入这个函数，首先这个函数调用 <code>i386_detect_memory</code> 子函数，这个子函数的功能就是检测现在系统中有多少可用的内存空间。<br>  之前有讲，jos把整个物理内存空间划分成三个部分：</p>\n<blockquote>\n<ol>\n<li>从0x00000~0xA0000，这部分也叫basemem，是可用的。</li>\n<li>紧接着是0xA0000~0x100000，这部分叫做IO hole，是不可用的，主要被用来分配给外部设备了。</li>\n<li>再紧接着就是0x100000~0x，这部分叫做extmem，是可用的，这是最重要的内存区域。</li>\n</ol>\n</blockquote>\n<p>这个子函数中包括三个变量，其中<code>npages</code>记录整个内存的页,<code>npages_basemem</code>记录basemem的页数，<code>npages_extmem</code>记录extmem的页数。<br>下一条指令为：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">kern_pgdir = (<span class=\"keyword\">pde_t</span> *) boot_alloc(PGSIZE);</div><div class=\"line\"><span class=\"built_in\">memset</span>(kern_pgdir, <span class=\"number\">0</span>, PGSIZE);</div></pre></td></tr></table></figure></p>\n<p>其中<code>kern_pgdir</code>是一个指针，<code>pde_t *kern_pgdir</code>，它是指向操作系统的页目录表的指针，操作系统之后工作在虚拟内存模式下时，就需要这个页目录表进行地址转换。我们为这个页目录表分配的内存大小空间为<code>PGSIZE</code>，即一个页的大小。并且首先把这部分内存清0。</p>\n<p>通过查看 <code>mem_init</code> 函数可以知道，<code>boot_alloc</code> 是用来初始化页目录(page directory)。在 <code>boot_alloc</code> 中，<code>nextfree</code> 为下一个空闲内存的虚拟内存地址，当 <code>nextfree</code> 为空时会先初始化。用到了<code>ROUNDUP</code>，这个<code>ROUNDUP</code>在 <code>`/inc/types.h</code> 中，因为内存区块是对齐的，所以每块都是固定的大小。npages 是页数量，可使用的内存大小是 <code>npages × PGSIZE</code> ，根据lab1提到的，KERNBASE是分配内存的起始地址，若<code>nextfree</code> 大于 <code>KERNBASE + npages × PGSIZE</code> 的值，就是指针地址溢出了。<br>所以只需要添加上这部分代码:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">result = nextfree;</div><div class=\"line\">nextfree = ROUNDUP(nextfree+n, PGSIZE);</div><div class=\"line\"><span class=\"keyword\">if</span>((<span class=\"keyword\">uint32_t</span>)nextfree &gt; KERNBASE + (npages * PGSIZE)) &#123;</div><div class=\"line\">    panic(<span class=\"string\">\"Out of memory!\\n\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>mem_init()</code>在执行完上面的函数以后，会给<code>kern_pgdir</code>加上权限位。之后就是要初始化所有的<code>struct PageInfo</code>为 0。首先确定<code>PageInfo</code>的大小，然后用<code>boot_alloc()</code>分配内存，接着用<code>memset()</code>初始化。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">size_t</span> PageInfo_size = <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> PageInfo);</div><div class=\"line\">pages = (<span class=\"keyword\">struct</span> PageInfo *)boot_alloc(npages * PageInfo_size);</div><div class=\"line\"><span class=\"built_in\">memset</span>(pages, <span class=\"number\">0</span>, npages * PageInfo_size);</div></pre></td></tr></table></figure></p>\n<p>接着调用<code>page_init()</code>来初始化<code>page</code>结构和内存空闲链表。<br><code>page_init()</code>，这个子函数的功能包括：</p>\n<blockquote>\n<ol>\n<li>初始化pages数组</li>\n<li>初始化pages_free_list链表，这个数组中存放着所有空闲页的信息</li>\n</ol>\n</blockquote>\n<p>可以到这个函数的定义处具体查看，整个函数是由一个for循环构成，它会遍历所有内存页所对应的在<code>npages</code>数组中的<code>PageInfo</code>结构体，并且根据这个页当前的状态来修改这个结构体的状态，如果页已被占用，那么要把<code>PageInfo</code>结构体中的<code>pp_ref</code>属性置一；如果是空闲页，则要把这个页送入<code>pages_free_list</code>链表中。根据注释中的提示，第0页已被占用，<code>io hole</code>部分已被占用，还有在extmem区域还有一部分已经被占用，代码如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">size_t</span> i;</div><div class=\"line\">page_free_list = <span class=\"literal\">NULL</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//num_alloc：在extmem区域已经被占用的页的个数</span></div><div class=\"line\"><span class=\"keyword\">int</span> num_alloc = ((<span class=\"keyword\">uint32_t</span>)boot_alloc(<span class=\"number\">0</span>) - KERNBASE) / PGSIZE;</div><div class=\"line\"><span class=\"comment\">//num_iohole：在io hole区域占用的页数</span></div><div class=\"line\"><span class=\"keyword\">int</span> num_iohole = <span class=\"number\">96</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i&lt;npages; i++)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(i==<span class=\"number\">0</span>)</div><div class=\"line\">    &#123;</div><div class=\"line\">        pages[i].pp_ref = <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;    </div><div class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(i &gt;= npages_basemem &amp;&amp; i &lt; npages_basemem + num_iohole + num_alloc)</div><div class=\"line\">    &#123;</div><div class=\"line\">        pages[i].pp_ref = <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span></div><div class=\"line\">    &#123;</div><div class=\"line\">        pages[i].pp_ref = <span class=\"number\">0</span>;</div><div class=\"line\">        pages[i].pp_link = page_free_list;</div><div class=\"line\">        page_free_list = &amp;pages[i];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>先实现<code>page_alloc()</code>函数，通过注释我们可以知道这个函数的功能就是分配一个物理页。而函数的返回值就是这个物理页所对应的<code>PageInfo</code>结构体。<br>所以这个函数的大致步骤应该是：</p>\n<blockquote>\n<ol>\n<li>从free_page_list中取出一个空闲页的PageInfo结构体</li>\n<li>修改free_page_list相关信息，比如修改链表表头</li>\n<li>修改取出的空闲页的PageInfo结构体信息，初始化该页的内存</li>\n</ol>\n</blockquote>\n<p>代码如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">struct</span> PageInfo *</span></div><div class=\"line\"><span class=\"title\">page_alloc</span><span class=\"params\">(<span class=\"keyword\">int</span> alloc_flags)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">struct</span> PageInfo *result;</div><div class=\"line\">    <span class=\"keyword\">if</span> (page_free_list == <span class=\"literal\">NULL</span>)</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</div><div class=\"line\"></div><div class=\"line\">      result= page_free_list;</div><div class=\"line\">      page_free_list = result-&gt;pp_link;</div><div class=\"line\">      result-&gt;pp_link = <span class=\"literal\">NULL</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (alloc_flags &amp; ALLOC_ZERO)</div><div class=\"line\">        <span class=\"built_in\">memset</span>(page2kva(result), <span class=\"number\">0</span>, PGSIZE);</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>实现page_free()</code>方法，根据注释可知，这个方法的功能就是把一个页的<code>PageInfo</code>结构体再返回给<code>page_free_list</code>空闲页链表，代表回收了这个页。<br>主要完成以下几个操作：</p>\n<blockquote>\n<ol>\n<li>修改被回收的页的PageInfo结构体的相应信息。</li>\n<li>把该结构体插入回page_free_list空闲页链表。</li>\n</ol>\n</blockquote>\n<p>代码如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">page_free</span><span class=\"params\">(<span class=\"keyword\">struct</span> PageInfo *pp)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">// Fill this function in</span></div><div class=\"line\">    <span class=\"comment\">// Hint: You may want to panic if pp-&gt;pp_ref is nonzero or</span></div><div class=\"line\">    <span class=\"comment\">// pp-&gt;pp_link is not NULL.</span></div><div class=\"line\">      assert(pp-&gt;pp_ref == <span class=\"number\">0</span>);</div><div class=\"line\">      assert(pp-&gt;pp_link == <span class=\"literal\">NULL</span>);</div><div class=\"line\"></div><div class=\"line\">      pp-&gt;pp_link = page_free_list;</div><div class=\"line\">      page_free_list = pp;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h2 id=\"Part-2-Virtual-Memory\"><a href=\"#Part-2-Virtual-Memory\" class=\"headerlink\" title=\"Part 2: Virtual Memory\"></a>Part 2: Virtual Memory</h2><blockquote>\n<p>在x86体系中，一个虚拟地址(Virtual Address)是由两部分组成，一个是段选择子(segment selector)，另一个是段内偏移(segment offset)。一个线性地址(Linear Address)指的是通过段地址转换机构把虚拟地址进行转换之后得到的地址。一个物理地址(Physical Addresses)是分页地址转换机构把线性地址进行转换之后得到的真实的内存地址，这个地址将会最终送到你的内存芯片的地址总线上。<br>我们所编写的C语言程序中的指针的值是虚拟地址中段内偏移部分的值。在boot/boot.S文件中，我们引入了一个全局描述符表，这个表通过把所有的段的基址设置为0，界限设置为0xffffffff的方式，关闭了分段管理的功能。因此虚拟地址中的段选择子字段的内容已经没有任何意义，线性地址的值总是等于虚拟地址中段内偏移的值。<br>回顾一下lab1中的part 3，我们引入了一个简单的页表，使得内核可以运行与0xf0100000的虚拟地址空间，尽管它所在的真实位置是物理地址0x00100000处，刚刚好在ROM BIOS之上。这个页表仅仅映射了4MB的内存空间。在我们这个JOS操作系统中，我们希望把这种映射扩展到物理内存的头256MB空间上，并且把这部分物理空间映射到从0xf0000000开始的虚拟空间中，以及一些其他的虚拟地址空间中。</p>\n<h3 id=\"Exercise-2\"><a href=\"#Exercise-2\" class=\"headerlink\" title=\"Exercise 2\"></a>Exercise 2</h3><p>熟悉关于分页地址转换(page translation)和基于页的保护(page-based protection)。<br>首先介绍一下80386将逻辑地址转为物理地址的方法。</p>\n<blockquote>\n<ul>\n<li>分段地址转换，由段选择子和段偏移量构成的逻辑地址转为线性地址。</li>\n<li>分页地址转换，线性地址转为物理地址。</li>\n</ul>\n</blockquote>\n</blockquote>\n<h4 id=\"区别虚拟地址，线性地址，物理地址\"><a href=\"#区别虚拟地址，线性地址，物理地址\" class=\"headerlink\" title=\"区别虚拟地址，线性地址，物理地址\"></a>区别虚拟地址，线性地址，物理地址</h4><p>虚拟地址是有段选择子和段偏移构成。线性地址是经过分段地址转换单没进行分页地址转换。物理地址是两种转换之后最终通过硬件总线到RAM的地址。C 指针是虚拟地址的偏移部分。在 <code>boot/boot.S</code>中，引入全局描述符表(GDT)将所有段基址设为0到 0xffffffff。因此线性地址等于虚拟地址的偏移量。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">           Selector  +--------------+         +-----------+</div><div class=\"line\">          ----------&gt;|              |         |           |</div><div class=\"line\">                     | Segmentation |         |  Paging   |</div><div class=\"line\">Software             |              |--------&gt;|           |----------&gt;  RAM</div><div class=\"line\">            Offset   |  Mechanism   |         | Mechanism |</div><div class=\"line\">          ----------&gt;|              |         |           |</div><div class=\"line\">                     +--------------+         +-----------+</div><div class=\"line\">            Virtual                   Linear                Physical</div></pre></td></tr></table></figure></p>\n<h3 id=\"Exercise-3\"><a href=\"#Exercise-3\" class=\"headerlink\" title=\"Exercise 3`\"></a>Exercise 3`</h3><blockquote>\n<p>在QEMU中使用 `xp 可以查看物理内存，PD虚拟机对于lab手册上调出QEMU monitor的方法没用，查看<br>指令为<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">qemu-system-i386 -hda obj/kern/kernel.img -monitor stdio -gdb tcp::26000 -D qemu.log。</div></pre></td></tr></table></figure></p>\n<p>在QEMU monitor中使用 <code>info pg</code> 查看当前页表， <code>info mem</code> 查看虚拟内存的范围。<br>进入保护模式以后，所有地址引用都是虚拟地址，由MMU转换，也就是说 C 指针都是虚拟地址。JOS内核经常需要操作地址通过整数而不解引用。JOS为了区分两种情况：类型 <code>uintptr_t</code> 代表虚拟地址，<code>physaddr_t</code> 代表物理地址。虽然都是32位整数，但是不能直接解引用，需要先转换类型。JOS需要读取或修改内存，尽管只知道物理地址。给页表添加映射需要分配无力内存去储存一个页目录，然后才能初始化内存。然而内核不能绕过虚拟地址转换，因此不能直接加载和储存物理地址。为了将物理地址转为虚拟地址，内核需要在物理地址加上<code>0xf0000000</code>从而找到相关的虚拟地址，可以使用<code>KADDR(pa)</code>完成这个操作。<br>同样，如果内核需要通过虚拟地址去找物理地址，就需要减去<code>0xf0000000</code>，可以使用<code>PADDR(va)</code>完成这个操作。</p>\n<p>引用计数<br>之后实验经常需要将多个虚拟地址同时映射到同一块物理页上，因此需要给每一个物理页计数引用次数，这个值位于物理页 <code>struct PageInfo</code> 中的 <code>pp_ref</code> 字段中。</p>\n</blockquote>\n<h3 id=\"Exercise-4\"><a href=\"#Exercise-4\" class=\"headerlink\" title=\"Exercise 4\"></a>Exercise 4</h3><blockquote>\n<p>实现<code>kern/pmap.c</code>里的<code>pgdir_walk()，boot_map_region()，page_lookup()，page_remove()，page_insert()</code>这几个函数。<code>check_page()</code>会测试是否写的正确。</p>\n<p>首先是 <code>pgdir_walk()</code>，参考注释可以得知，这个函数获得指向线性地址页表项的指针，传入的参数是页目录指针，线性地址和另外一个参数。<br><img src=\"http://xinqiu.me/2016/12/09/MIT-6.828-2/2.png\" alt=\"page\"><br>由上面的图可以知道二级分页模式下线性地址到物理地址的转换。所以首先要获得页目录地址，判断是否指向的页表项存在，不存在则新建一个页表。这里有两个注意点。</p>\n<blockquote>\n<ul>\n<li>第一个地方是要注意判断页表是否存在，根据下图页目录/表的结构，可以知道这里的P位代表Present，用来判断对应的物理页是否存在，存在则为1，所以通过与运算来判断。</li>\n<li>另外一个注意点是新建页。为新建的物理页设置页目录时，需要添加上权限位</li>\n</ul>\n</blockquote>\n<p>代码如下:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">pte_t</span> *</div><div class=\"line\">pgdir_walk(<span class=\"keyword\">pde_t</span> *pgdir, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *va, <span class=\"keyword\">int</span> create)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">// Fill this function in</span></div><div class=\"line\">    <span class=\"keyword\">pde_t</span> *pt = pgdir + PDX(va);</div><div class=\"line\">    <span class=\"keyword\">pde_t</span> *pt_addr_v;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (*pt &amp; PTE_P) &#123;</div><div class=\"line\">        pt_addr_v = (<span class=\"keyword\">pte_t</span> *)KADDR(PTE_ADDR(*pt));</div><div class=\"line\">        <span class=\"keyword\">return</span> pt_addr_v + PTX(va);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">struct</span> PageInfo *newpt;</div><div class=\"line\">        <span class=\"keyword\">if</span> (create == <span class=\"number\">1</span> &amp;&amp; (newpt = page_alloc(ALLOC_ZERO)) != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"built_in\">memset</span>(page2kva(newpt), <span class=\"number\">0</span>, PGSIZE);</div><div class=\"line\">            newpt-&gt;pp_ref ++;</div><div class=\"line\">            *pt = PADDR(page2kva(newpt))|PTE_U|PTE_W|PTE_P;</div><div class=\"line\">            pt_addr_v = (<span class=\"keyword\">pte_t</span> *)KADDR(PTE_ADDR(*pt));</div><div class=\"line\">            <span class=\"keyword\">return</span> pt_addr_v + PTX(va);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>接着是<code>boot_map_region</code>函数，这个函数将虚拟地址<code>[va, va+size)</code>映射到物理地址<code>[pa, pa+size)</code>，注释中提到可以使用上面写的<code>pgdir_walk</code>，获取页表地址，接着将物理地址的值与上权限位赋给页表地址。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">boot_map_region</span><span class=\"params\">(<span class=\"keyword\">pde_t</span> *pgdir, <span class=\"keyword\">uintptr_t</span> va, <span class=\"keyword\">size_t</span> size, <span class=\"keyword\">physaddr_t</span> pa, <span class=\"keyword\">int</span> perm)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">// Fill this function in</span></div><div class=\"line\">    <span class=\"keyword\">int</span> offset;</div><div class=\"line\">    <span class=\"keyword\">pte_t</span> *pt;</div><div class=\"line\">    <span class=\"keyword\">for</span> (offset = <span class=\"number\">0</span>; offset &lt; size; offset += PGSIZE) &#123;</div><div class=\"line\">        pt = pgdir_walk(pgdir, (<span class=\"keyword\">void</span> *)va, <span class=\"number\">1</span>);</div><div class=\"line\">        *pt = pa|perm|PTE_P;</div><div class=\"line\">        pa += PGSIZE;</div><div class=\"line\">        va += PGSIZE;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>之后是<code>page_lookup</code>函数，查找线性地址va对应的物理页面，找到就返回这个物理页，否则返回<code>NULL</code>。首先如果<code>pte_store</code>非0，则储存这个页的页表地址，这一步是为了之后的<code>page_remove</code>用的。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">struct</span> PageInfo *</span></div><div class=\"line\"><span class=\"title\">page_lookup</span><span class=\"params\">(<span class=\"keyword\">pde_t</span> *pgdir, <span class=\"keyword\">void</span> *va, <span class=\"keyword\">pte_t</span> **pte_store)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">// Fill this function in</span></div><div class=\"line\">    <span class=\"keyword\">pte_t</span> *pte = pgdir_walk(pgdir, va, <span class=\"number\">0</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span> (pte_store != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        *pte_store = pte;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (pte != <span class=\"literal\">NULL</span> &amp;&amp; (*pte &amp; PTE_P)) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> pa2page(PTE_ADDR(*pte));</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>page_remove</code>实现参考注释里的提示，先通过<code>page_lookup</code>获得物理页，如果存在则执行删除工作<code>page_decref</code>，同时也要将<code>va</code>地址的页表项设为0，最后就是验证有效性。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">page_remove</span><span class=\"params\">(<span class=\"keyword\">pde_t</span> *pgdir, <span class=\"keyword\">void</span> *va)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">// Fill this function in</span></div><div class=\"line\">    <span class=\"keyword\">pte_t</span> *pte;</div><div class=\"line\">    <span class=\"keyword\">struct</span> PageInfo *page = page_lookup(pgdir, va, &amp;pte);</div><div class=\"line\">    <span class=\"keyword\">if</span> (page) &#123;</div><div class=\"line\">        page_decref(page);</div><div class=\"line\">        *pte = <span class=\"number\">0</span>;</div><div class=\"line\">        tlb_invalidate(pgdir, va);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>最后一步就是<code>page_insert</code>函数，将页面管理结构 <code>pp</code> 所对应的物理页面分配给线性地址 <code>va</code>。同时,将对应的页表项的 <code>permission</code> 设置成 <code>PTE_P&amp;perm</code>。 注意:一定要考虑到线性地址 <code>va</code> 已经指向了另外一个物理页面或者干脆就是这个函数要指向的物理页面的情况。如果线性地址 <code>va</code> 已经指向了另外一个物理页面,则先要调用 <code>page_remove</code> 将该物理页从线性地址 <code>va</code> 处删除,再将 <code>va</code> 对应的页表项的地址赋值为 <code>pp</code> 对应 的物理页面。如果 <code>va</code> 指向的本来就是参数 <code>pp</code> 所对应的物理页面,则将 <code>va</code> 对应的页表项中 的物理地址赋值重新赋值为 <code>pp</code> 所对应的物理页面的首地址即可。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span></span></div><div class=\"line\"><span class=\"title\">page_insert</span><span class=\"params\">(<span class=\"keyword\">pde_t</span> *pgdir, <span class=\"keyword\">struct</span> PageInfo *pp, <span class=\"keyword\">void</span> *va, <span class=\"keyword\">int</span> perm)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">// Fill this function in</span></div><div class=\"line\">    <span class=\"keyword\">pte_t</span> *pte = pgdir_walk(pgdir, va, <span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span> (!pte) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> -E_NO_MEM;</div><div class=\"line\">    &#125;  </div><div class=\"line\">    <span class=\"keyword\">if</span> (*pte &amp; PTE_P) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (PTE_ADDR(*pte) == page2pa(pp)) &#123;</div><div class=\"line\">            tlb_invalidate(pgdir, va);</div><div class=\"line\">            pp-&gt;pp_ref--;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            page_remove(pgdir, va);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    *pte = page2pa(pp) | perm | PTE_P;</div><div class=\"line\">    pp-&gt;pp_ref++;</div><div class=\"line\">    pgdir[PDX(va)] |= perm;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h2 id=\"Part-3-内核地址空间\"><a href=\"#Part-3-内核地址空间\" class=\"headerlink\" title=\"Part 3: 内核地址空间\"></a>Part 3: 内核地址空间</h2><h4 id=\"线性地址的两部分\"><a href=\"#线性地址的两部分\" class=\"headerlink\" title=\"线性地址的两部分\"></a>线性地址的两部分</h4><blockquote>\n<p>JOS将处理器32位线性地址划分为占低地址的用户环境(进程)和占高地址的内核。 分界线是<code>inc/memlayout.h</code>中的变量 <code>ULIM</code>。内核保留了大约256MB的虚拟地址空间，lab1中内核设在那么高的地址就是因为要留一部分空间给用户环境。</p>\n</blockquote>\n<h4 id=\"访问权限和故障隔离\"><a href=\"#访问权限和故障隔离\" class=\"headerlink\" title=\"访问权限和故障隔离\"></a>访问权限和故障隔离</h4><blockquote>\n<p>内核和用户内存都在各自的环境地址空间中，必须在x86页表中使用访问权限位(<code>Permissions bits</code>)来使用户代码只访问用户的地址空间，否则用户的代码bug会覆盖内核数据，造成系统崩溃。值得注意的是可写权限位(<code>PTE_W</code>)可以同时影响用户和内核代码。<br>高于<code>ULIM</code>的内存内核可以读写，而用户环境没有权限。内核和用户在地址<code>[UTOP,ULIM)</code>有同样的权限：可读但不可写，这部分地址空间通常是一些特定的内核数据，让用户环境可以读取。最后，地址<code>UTOP</code>之下的是用户环境。</p>\n</blockquote>\n<h4 id=\"初始化内核地址空间\"><a href=\"#初始化内核地址空间\" class=\"headerlink\" title=\"初始化内核地址空间\"></a>初始化内核地址空间</h4><blockquote>\n<p>设置<code>UTOP</code>之上的地址空间。在<code>inc/memlayout.h</code>中显示了布局。</p>\n</blockquote>\n<h4 id=\"Exercise-5\"><a href=\"#Exercise-5\" class=\"headerlink\" title=\"Exercise 5\"></a>Exercise 5</h4><blockquote>\n<p>完成<code>mem_init()</code>中缺少的部分。<br>因为<code>mem_init</code>开头创建了初始化页目录<code>kern_pgdir</code>，首先是将<code>pages</code>数组映射到线性地址<code>UPAGES</code>，权限是内核只读。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">boot_map_region(kern_pgdir, UPAGES, PTSIZE, PADDR(pages),PTE_U);`</div></pre></td></tr></table></figure></p>\n<p>接着是映射物理地址到内核栈，也就是从地址范围<code>[KSTACKTOP-KSTKSIZE, KSTACKTOP)</code>映射到<code>bootstack</code>开始的物理地址页上，注释中提到了，只要映射<code>[KSTACKTOP-KSTKSIZE, KSTACKTOP)</code>， <code>[KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE)</code>不映射，权限位是内核读写。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">boot_map_region(kern_pgdir, KSTACKTOP-KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W);</div></pre></td></tr></table></figure></p>\n<p>最后是映射虚拟地址<code>[KERNBASE, 2^32)</code>到物理地址<code>[0, 2^32 - KERNBASE)</code>，权限位是内核读写。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">boot_map_region(kern_pgdir, KERNBASE, (<span class=\"number\">0xffffffff</span>-KERNBASE), <span class=\"number\">0</span>, PTE_W);</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://pdos.csail.mit.edu/6.828/2016/labs/lab2/\" target=\"_blank\" rel=\"external\">memory management</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Lab2-内存管理\"><a href=\"#Lab2-内存管理\" class=\"headerlink\" title=\"Lab2 内存管理\"></a>Lab2 内存管理</h1><h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><blockquote>\n<ul>\n<li>内存管理有两个组件:</li>\n</ul>\n<ol>\n<li>第一个组件是内核的物理内存分配器，因此内核可以分配内存并稍后释放它。.分配器将以4096个字节为单位进行操作，称为页面。代码要实现维护记录哪些物理页面是空闲的，哪些被分配的数据结构以及共享每个分配的页面的进程数量,另外还将编写例程以分配和释放内存页面。</li>\n<li>第二个组件是虚拟内存，它将内核和用户软件使用的虚拟地址映射到物理内存中的地址。 当指令使用内存，咨询一组页表时，x86硬件的内存管理单元（MMU）执行映射。 lab2根据提供的规范修改JOS以设置MMU的页表。</li>\n</ol>\n<ul>\n<li>lab1分为三部分</li>\n</ul>\n<ol>\n<li>part1: 物理页面管理 physical page management</li>\n<li>part2: 虚拟内存 virtual memory</li>\n<li>part3: 内核地址空间 kernel address space</li>\n</ol>\n</blockquote>","more":"<h2 id=\"实验代码\"><a href=\"#实验代码\" class=\"headerlink\" title=\"实验代码\"></a>实验代码</h2><blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">cd</span> ~/6.828/lab</div><div class=\"line\">git checkout -b lab2 origin/lab2</div><div class=\"line\">git merge lab1</div></pre></td></tr></table></figure>\n<p>Lab 2 添加了以下文件:<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">inc/memlayout.h</div><div class=\"line\">kern/pmap.c</div><div class=\"line\">kern/pmap.h</div><div class=\"line\">kern/kclock.h</div><div class=\"line\">kern/kclock.c</div></pre></td></tr></table></figure></p>\n<p><code>memlayout.h</code> 描述了虚拟地址空间的结构，通过修改<code>pmap.c/memlayout.h</code> 和<code>pmap.h</code>来实现<code>PageInfo</code>结构，这个是为了记录哪些物理内存的page是空闲的。<code>kclock.c</code> 和 <code>kclock.h</code> 管理PC的时钟和CMOS RAM硬件，这个设备记录了物理内存的数量。<code>pmap.c</code>需要读这个设备来确定内存大小。</p>\n</blockquote>\n<h2 id=\"Part-1：Physical-Page-Management\"><a href=\"#Part-1：Physical-Page-Management\" class=\"headerlink\" title=\"Part 1：Physical Page Management\"></a>Part 1：Physical Page Management</h2><blockquote>\n<p>操作系统必须要追踪记录哪些内存区域是空闲的，哪些是被占用的。JOS内核是以页(page)为最小粒度来管理内存的，它使用MMU来映射，保护每一块被分配出去的内存。这里要具体实现一下物理内存页的分配子函数。它利用一个结构体<code>PageInfo</code>的链表来记录哪些页是空闲的，链表中每一个结点对应一个物理页。</p>\n</blockquote>\n<h3 id=\"Exercise-1\"><a href=\"#Exercise-1\" class=\"headerlink\" title=\"Exercise 1.\"></a>Exercise 1.</h3><blockquote>\n<p>在文件 kern/pmap.c 中，完成以下几个子函数:</p>\n<ul>\n<li>boot_alloc()</li>\n<li>mem_init()</li>\n<li>page_init()</li>\n<li>page_alloc()</li>\n<li>page_free()</li>\n<li>check_page_free_list()和check_page_alloc()两个函数将会检测页分配器代码的正确性.</li>\n</ul>\n<p>查看<code>pmap.c</code>中的代码，其中最重要的函数就是<code>mem_init</code>了，在内核刚开始运行时就会调用这个子函数，对整个操作系统的内存管理系统进行一些初始化的设置，比如设定页表等等操作。下面进入这个函数，首先这个函数调用 <code>i386_detect_memory</code> 子函数，这个子函数的功能就是检测现在系统中有多少可用的内存空间。<br>  之前有讲，jos把整个物理内存空间划分成三个部分：</p>\n<blockquote>\n<ol>\n<li>从0x00000~0xA0000，这部分也叫basemem，是可用的。</li>\n<li>紧接着是0xA0000~0x100000，这部分叫做IO hole，是不可用的，主要被用来分配给外部设备了。</li>\n<li>再紧接着就是0x100000~0x，这部分叫做extmem，是可用的，这是最重要的内存区域。</li>\n</ol>\n</blockquote>\n<p>这个子函数中包括三个变量，其中<code>npages</code>记录整个内存的页,<code>npages_basemem</code>记录basemem的页数，<code>npages_extmem</code>记录extmem的页数。<br>下一条指令为：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">kern_pgdir = (<span class=\"keyword\">pde_t</span> *) boot_alloc(PGSIZE);</div><div class=\"line\"><span class=\"built_in\">memset</span>(kern_pgdir, <span class=\"number\">0</span>, PGSIZE);</div></pre></td></tr></table></figure></p>\n<p>其中<code>kern_pgdir</code>是一个指针，<code>pde_t *kern_pgdir</code>，它是指向操作系统的页目录表的指针，操作系统之后工作在虚拟内存模式下时，就需要这个页目录表进行地址转换。我们为这个页目录表分配的内存大小空间为<code>PGSIZE</code>，即一个页的大小。并且首先把这部分内存清0。</p>\n<p>通过查看 <code>mem_init</code> 函数可以知道，<code>boot_alloc</code> 是用来初始化页目录(page directory)。在 <code>boot_alloc</code> 中，<code>nextfree</code> 为下一个空闲内存的虚拟内存地址，当 <code>nextfree</code> 为空时会先初始化。用到了<code>ROUNDUP</code>，这个<code>ROUNDUP</code>在 <code>`/inc/types.h</code> 中，因为内存区块是对齐的，所以每块都是固定的大小。npages 是页数量，可使用的内存大小是 <code>npages × PGSIZE</code> ，根据lab1提到的，KERNBASE是分配内存的起始地址，若<code>nextfree</code> 大于 <code>KERNBASE + npages × PGSIZE</code> 的值，就是指针地址溢出了。<br>所以只需要添加上这部分代码:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">result = nextfree;</div><div class=\"line\">nextfree = ROUNDUP(nextfree+n, PGSIZE);</div><div class=\"line\"><span class=\"keyword\">if</span>((<span class=\"keyword\">uint32_t</span>)nextfree &gt; KERNBASE + (npages * PGSIZE)) &#123;</div><div class=\"line\">    panic(<span class=\"string\">\"Out of memory!\\n\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>mem_init()</code>在执行完上面的函数以后，会给<code>kern_pgdir</code>加上权限位。之后就是要初始化所有的<code>struct PageInfo</code>为 0。首先确定<code>PageInfo</code>的大小，然后用<code>boot_alloc()</code>分配内存，接着用<code>memset()</code>初始化。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">size_t</span> PageInfo_size = <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> PageInfo);</div><div class=\"line\">pages = (<span class=\"keyword\">struct</span> PageInfo *)boot_alloc(npages * PageInfo_size);</div><div class=\"line\"><span class=\"built_in\">memset</span>(pages, <span class=\"number\">0</span>, npages * PageInfo_size);</div></pre></td></tr></table></figure></p>\n<p>接着调用<code>page_init()</code>来初始化<code>page</code>结构和内存空闲链表。<br><code>page_init()</code>，这个子函数的功能包括：</p>\n<blockquote>\n<ol>\n<li>初始化pages数组</li>\n<li>初始化pages_free_list链表，这个数组中存放着所有空闲页的信息</li>\n</ol>\n</blockquote>\n<p>可以到这个函数的定义处具体查看，整个函数是由一个for循环构成，它会遍历所有内存页所对应的在<code>npages</code>数组中的<code>PageInfo</code>结构体，并且根据这个页当前的状态来修改这个结构体的状态，如果页已被占用，那么要把<code>PageInfo</code>结构体中的<code>pp_ref</code>属性置一；如果是空闲页，则要把这个页送入<code>pages_free_list</code>链表中。根据注释中的提示，第0页已被占用，<code>io hole</code>部分已被占用，还有在extmem区域还有一部分已经被占用，代码如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">size_t</span> i;</div><div class=\"line\">page_free_list = <span class=\"literal\">NULL</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//num_alloc：在extmem区域已经被占用的页的个数</span></div><div class=\"line\"><span class=\"keyword\">int</span> num_alloc = ((<span class=\"keyword\">uint32_t</span>)boot_alloc(<span class=\"number\">0</span>) - KERNBASE) / PGSIZE;</div><div class=\"line\"><span class=\"comment\">//num_iohole：在io hole区域占用的页数</span></div><div class=\"line\"><span class=\"keyword\">int</span> num_iohole = <span class=\"number\">96</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>; i&lt;npages; i++)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>(i==<span class=\"number\">0</span>)</div><div class=\"line\">    &#123;</div><div class=\"line\">        pages[i].pp_ref = <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;    </div><div class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(i &gt;= npages_basemem &amp;&amp; i &lt; npages_basemem + num_iohole + num_alloc)</div><div class=\"line\">    &#123;</div><div class=\"line\">        pages[i].pp_ref = <span class=\"number\">1</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">else</span></div><div class=\"line\">    &#123;</div><div class=\"line\">        pages[i].pp_ref = <span class=\"number\">0</span>;</div><div class=\"line\">        pages[i].pp_link = page_free_list;</div><div class=\"line\">        page_free_list = &amp;pages[i];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>先实现<code>page_alloc()</code>函数，通过注释我们可以知道这个函数的功能就是分配一个物理页。而函数的返回值就是这个物理页所对应的<code>PageInfo</code>结构体。<br>所以这个函数的大致步骤应该是：</p>\n<blockquote>\n<ol>\n<li>从free_page_list中取出一个空闲页的PageInfo结构体</li>\n<li>修改free_page_list相关信息，比如修改链表表头</li>\n<li>修改取出的空闲页的PageInfo结构体信息，初始化该页的内存</li>\n</ol>\n</blockquote>\n<p>代码如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">struct</span> PageInfo *</span></div><div class=\"line\"><span class=\"title\">page_alloc</span><span class=\"params\">(<span class=\"keyword\">int</span> alloc_flags)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">struct</span> PageInfo *result;</div><div class=\"line\">    <span class=\"keyword\">if</span> (page_free_list == <span class=\"literal\">NULL</span>)</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</div><div class=\"line\"></div><div class=\"line\">      result= page_free_list;</div><div class=\"line\">      page_free_list = result-&gt;pp_link;</div><div class=\"line\">      result-&gt;pp_link = <span class=\"literal\">NULL</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (alloc_flags &amp; ALLOC_ZERO)</div><div class=\"line\">        <span class=\"built_in\">memset</span>(page2kva(result), <span class=\"number\">0</span>, PGSIZE);</div><div class=\"line\"></div><div class=\"line\">      <span class=\"keyword\">return</span> result;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>实现page_free()</code>方法，根据注释可知，这个方法的功能就是把一个页的<code>PageInfo</code>结构体再返回给<code>page_free_list</code>空闲页链表，代表回收了这个页。<br>主要完成以下几个操作：</p>\n<blockquote>\n<ol>\n<li>修改被回收的页的PageInfo结构体的相应信息。</li>\n<li>把该结构体插入回page_free_list空闲页链表。</li>\n</ol>\n</blockquote>\n<p>代码如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">page_free</span><span class=\"params\">(<span class=\"keyword\">struct</span> PageInfo *pp)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">// Fill this function in</span></div><div class=\"line\">    <span class=\"comment\">// Hint: You may want to panic if pp-&gt;pp_ref is nonzero or</span></div><div class=\"line\">    <span class=\"comment\">// pp-&gt;pp_link is not NULL.</span></div><div class=\"line\">      assert(pp-&gt;pp_ref == <span class=\"number\">0</span>);</div><div class=\"line\">      assert(pp-&gt;pp_link == <span class=\"literal\">NULL</span>);</div><div class=\"line\"></div><div class=\"line\">      pp-&gt;pp_link = page_free_list;</div><div class=\"line\">      page_free_list = pp;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h2 id=\"Part-2-Virtual-Memory\"><a href=\"#Part-2-Virtual-Memory\" class=\"headerlink\" title=\"Part 2: Virtual Memory\"></a>Part 2: Virtual Memory</h2><blockquote>\n<p>在x86体系中，一个虚拟地址(Virtual Address)是由两部分组成，一个是段选择子(segment selector)，另一个是段内偏移(segment offset)。一个线性地址(Linear Address)指的是通过段地址转换机构把虚拟地址进行转换之后得到的地址。一个物理地址(Physical Addresses)是分页地址转换机构把线性地址进行转换之后得到的真实的内存地址，这个地址将会最终送到你的内存芯片的地址总线上。<br>我们所编写的C语言程序中的指针的值是虚拟地址中段内偏移部分的值。在boot/boot.S文件中，我们引入了一个全局描述符表，这个表通过把所有的段的基址设置为0，界限设置为0xffffffff的方式，关闭了分段管理的功能。因此虚拟地址中的段选择子字段的内容已经没有任何意义，线性地址的值总是等于虚拟地址中段内偏移的值。<br>回顾一下lab1中的part 3，我们引入了一个简单的页表，使得内核可以运行与0xf0100000的虚拟地址空间，尽管它所在的真实位置是物理地址0x00100000处，刚刚好在ROM BIOS之上。这个页表仅仅映射了4MB的内存空间。在我们这个JOS操作系统中，我们希望把这种映射扩展到物理内存的头256MB空间上，并且把这部分物理空间映射到从0xf0000000开始的虚拟空间中，以及一些其他的虚拟地址空间中。</p>\n<h3 id=\"Exercise-2\"><a href=\"#Exercise-2\" class=\"headerlink\" title=\"Exercise 2\"></a>Exercise 2</h3><p>熟悉关于分页地址转换(page translation)和基于页的保护(page-based protection)。<br>首先介绍一下80386将逻辑地址转为物理地址的方法。</p>\n<blockquote>\n<ul>\n<li>分段地址转换，由段选择子和段偏移量构成的逻辑地址转为线性地址。</li>\n<li>分页地址转换，线性地址转为物理地址。</li>\n</ul>\n</blockquote>\n</blockquote>\n<h4 id=\"区别虚拟地址，线性地址，物理地址\"><a href=\"#区别虚拟地址，线性地址，物理地址\" class=\"headerlink\" title=\"区别虚拟地址，线性地址，物理地址\"></a>区别虚拟地址，线性地址，物理地址</h4><p>虚拟地址是有段选择子和段偏移构成。线性地址是经过分段地址转换单没进行分页地址转换。物理地址是两种转换之后最终通过硬件总线到RAM的地址。C 指针是虚拟地址的偏移部分。在 <code>boot/boot.S</code>中，引入全局描述符表(GDT)将所有段基址设为0到 0xffffffff。因此线性地址等于虚拟地址的偏移量。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">           Selector  +--------------+         +-----------+</div><div class=\"line\">          ----------&gt;|              |         |           |</div><div class=\"line\">                     | Segmentation |         |  Paging   |</div><div class=\"line\">Software             |              |--------&gt;|           |----------&gt;  RAM</div><div class=\"line\">            Offset   |  Mechanism   |         | Mechanism |</div><div class=\"line\">          ----------&gt;|              |         |           |</div><div class=\"line\">                     +--------------+         +-----------+</div><div class=\"line\">            Virtual                   Linear                Physical</div></pre></td></tr></table></figure></p>\n<h3 id=\"Exercise-3\"><a href=\"#Exercise-3\" class=\"headerlink\" title=\"Exercise 3`\"></a>Exercise 3`</h3><blockquote>\n<p>在QEMU中使用 `xp 可以查看物理内存，PD虚拟机对于lab手册上调出QEMU monitor的方法没用，查看<br>指令为<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">qemu-system-i386 -hda obj/kern/kernel.img -monitor stdio -gdb tcp::26000 -D qemu.log。</div></pre></td></tr></table></figure></p>\n<p>在QEMU monitor中使用 <code>info pg</code> 查看当前页表， <code>info mem</code> 查看虚拟内存的范围。<br>进入保护模式以后，所有地址引用都是虚拟地址，由MMU转换，也就是说 C 指针都是虚拟地址。JOS内核经常需要操作地址通过整数而不解引用。JOS为了区分两种情况：类型 <code>uintptr_t</code> 代表虚拟地址，<code>physaddr_t</code> 代表物理地址。虽然都是32位整数，但是不能直接解引用，需要先转换类型。JOS需要读取或修改内存，尽管只知道物理地址。给页表添加映射需要分配无力内存去储存一个页目录，然后才能初始化内存。然而内核不能绕过虚拟地址转换，因此不能直接加载和储存物理地址。为了将物理地址转为虚拟地址，内核需要在物理地址加上<code>0xf0000000</code>从而找到相关的虚拟地址，可以使用<code>KADDR(pa)</code>完成这个操作。<br>同样，如果内核需要通过虚拟地址去找物理地址，就需要减去<code>0xf0000000</code>，可以使用<code>PADDR(va)</code>完成这个操作。</p>\n<p>引用计数<br>之后实验经常需要将多个虚拟地址同时映射到同一块物理页上，因此需要给每一个物理页计数引用次数，这个值位于物理页 <code>struct PageInfo</code> 中的 <code>pp_ref</code> 字段中。</p>\n</blockquote>\n<h3 id=\"Exercise-4\"><a href=\"#Exercise-4\" class=\"headerlink\" title=\"Exercise 4\"></a>Exercise 4</h3><blockquote>\n<p>实现<code>kern/pmap.c</code>里的<code>pgdir_walk()，boot_map_region()，page_lookup()，page_remove()，page_insert()</code>这几个函数。<code>check_page()</code>会测试是否写的正确。</p>\n<p>首先是 <code>pgdir_walk()</code>，参考注释可以得知，这个函数获得指向线性地址页表项的指针，传入的参数是页目录指针，线性地址和另外一个参数。<br><img src=\"http://xinqiu.me/2016/12/09/MIT-6.828-2/2.png\" alt=\"page\"><br>由上面的图可以知道二级分页模式下线性地址到物理地址的转换。所以首先要获得页目录地址，判断是否指向的页表项存在，不存在则新建一个页表。这里有两个注意点。</p>\n<blockquote>\n<ul>\n<li>第一个地方是要注意判断页表是否存在，根据下图页目录/表的结构，可以知道这里的P位代表Present，用来判断对应的物理页是否存在，存在则为1，所以通过与运算来判断。</li>\n<li>另外一个注意点是新建页。为新建的物理页设置页目录时，需要添加上权限位</li>\n</ul>\n</blockquote>\n<p>代码如下:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">pte_t</span> *</div><div class=\"line\">pgdir_walk(<span class=\"keyword\">pde_t</span> *pgdir, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *va, <span class=\"keyword\">int</span> create)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">// Fill this function in</span></div><div class=\"line\">    <span class=\"keyword\">pde_t</span> *pt = pgdir + PDX(va);</div><div class=\"line\">    <span class=\"keyword\">pde_t</span> *pt_addr_v;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (*pt &amp; PTE_P) &#123;</div><div class=\"line\">        pt_addr_v = (<span class=\"keyword\">pte_t</span> *)KADDR(PTE_ADDR(*pt));</div><div class=\"line\">        <span class=\"keyword\">return</span> pt_addr_v + PTX(va);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        <span class=\"keyword\">struct</span> PageInfo *newpt;</div><div class=\"line\">        <span class=\"keyword\">if</span> (create == <span class=\"number\">1</span> &amp;&amp; (newpt = page_alloc(ALLOC_ZERO)) != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            <span class=\"built_in\">memset</span>(page2kva(newpt), <span class=\"number\">0</span>, PGSIZE);</div><div class=\"line\">            newpt-&gt;pp_ref ++;</div><div class=\"line\">            *pt = PADDR(page2kva(newpt))|PTE_U|PTE_W|PTE_P;</div><div class=\"line\">            pt_addr_v = (<span class=\"keyword\">pte_t</span> *)KADDR(PTE_ADDR(*pt));</div><div class=\"line\">            <span class=\"keyword\">return</span> pt_addr_v + PTX(va);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>接着是<code>boot_map_region</code>函数，这个函数将虚拟地址<code>[va, va+size)</code>映射到物理地址<code>[pa, pa+size)</code>，注释中提到可以使用上面写的<code>pgdir_walk</code>，获取页表地址，接着将物理地址的值与上权限位赋给页表地址。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">boot_map_region</span><span class=\"params\">(<span class=\"keyword\">pde_t</span> *pgdir, <span class=\"keyword\">uintptr_t</span> va, <span class=\"keyword\">size_t</span> size, <span class=\"keyword\">physaddr_t</span> pa, <span class=\"keyword\">int</span> perm)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">// Fill this function in</span></div><div class=\"line\">    <span class=\"keyword\">int</span> offset;</div><div class=\"line\">    <span class=\"keyword\">pte_t</span> *pt;</div><div class=\"line\">    <span class=\"keyword\">for</span> (offset = <span class=\"number\">0</span>; offset &lt; size; offset += PGSIZE) &#123;</div><div class=\"line\">        pt = pgdir_walk(pgdir, (<span class=\"keyword\">void</span> *)va, <span class=\"number\">1</span>);</div><div class=\"line\">        *pt = pa|perm|PTE_P;</div><div class=\"line\">        pa += PGSIZE;</div><div class=\"line\">        va += PGSIZE;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>之后是<code>page_lookup</code>函数，查找线性地址va对应的物理页面，找到就返回这个物理页，否则返回<code>NULL</code>。首先如果<code>pte_store</code>非0，则储存这个页的页表地址，这一步是为了之后的<code>page_remove</code>用的。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">struct</span> PageInfo *</span></div><div class=\"line\"><span class=\"title\">page_lookup</span><span class=\"params\">(<span class=\"keyword\">pde_t</span> *pgdir, <span class=\"keyword\">void</span> *va, <span class=\"keyword\">pte_t</span> **pte_store)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">// Fill this function in</span></div><div class=\"line\">    <span class=\"keyword\">pte_t</span> *pte = pgdir_walk(pgdir, va, <span class=\"number\">0</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span> (pte_store != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        *pte_store = pte;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (pte != <span class=\"literal\">NULL</span> &amp;&amp; (*pte &amp; PTE_P)) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> pa2page(PTE_ADDR(*pte));</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>page_remove</code>实现参考注释里的提示，先通过<code>page_lookup</code>获得物理页，如果存在则执行删除工作<code>page_decref</code>，同时也要将<code>va</code>地址的页表项设为0，最后就是验证有效性。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">page_remove</span><span class=\"params\">(<span class=\"keyword\">pde_t</span> *pgdir, <span class=\"keyword\">void</span> *va)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">// Fill this function in</span></div><div class=\"line\">    <span class=\"keyword\">pte_t</span> *pte;</div><div class=\"line\">    <span class=\"keyword\">struct</span> PageInfo *page = page_lookup(pgdir, va, &amp;pte);</div><div class=\"line\">    <span class=\"keyword\">if</span> (page) &#123;</div><div class=\"line\">        page_decref(page);</div><div class=\"line\">        *pte = <span class=\"number\">0</span>;</div><div class=\"line\">        tlb_invalidate(pgdir, va);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>最后一步就是<code>page_insert</code>函数，将页面管理结构 <code>pp</code> 所对应的物理页面分配给线性地址 <code>va</code>。同时,将对应的页表项的 <code>permission</code> 设置成 <code>PTE_P&amp;perm</code>。 注意:一定要考虑到线性地址 <code>va</code> 已经指向了另外一个物理页面或者干脆就是这个函数要指向的物理页面的情况。如果线性地址 <code>va</code> 已经指向了另外一个物理页面,则先要调用 <code>page_remove</code> 将该物理页从线性地址 <code>va</code> 处删除,再将 <code>va</code> 对应的页表项的地址赋值为 <code>pp</code> 对应 的物理页面。如果 <code>va</code> 指向的本来就是参数 <code>pp</code> 所对应的物理页面,则将 <code>va</code> 对应的页表项中 的物理地址赋值重新赋值为 <code>pp</code> 所对应的物理页面的首地址即可。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span></span></div><div class=\"line\"><span class=\"title\">page_insert</span><span class=\"params\">(<span class=\"keyword\">pde_t</span> *pgdir, <span class=\"keyword\">struct</span> PageInfo *pp, <span class=\"keyword\">void</span> *va, <span class=\"keyword\">int</span> perm)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">// Fill this function in</span></div><div class=\"line\">    <span class=\"keyword\">pte_t</span> *pte = pgdir_walk(pgdir, va, <span class=\"number\">1</span>);</div><div class=\"line\">    <span class=\"keyword\">if</span> (!pte) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> -E_NO_MEM;</div><div class=\"line\">    &#125;  </div><div class=\"line\">    <span class=\"keyword\">if</span> (*pte &amp; PTE_P) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (PTE_ADDR(*pte) == page2pa(pp)) &#123;</div><div class=\"line\">            tlb_invalidate(pgdir, va);</div><div class=\"line\">            pp-&gt;pp_ref--;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            page_remove(pgdir, va);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    *pte = page2pa(pp) | perm | PTE_P;</div><div class=\"line\">    pp-&gt;pp_ref++;</div><div class=\"line\">    pgdir[PDX(va)] |= perm;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h2 id=\"Part-3-内核地址空间\"><a href=\"#Part-3-内核地址空间\" class=\"headerlink\" title=\"Part 3: 内核地址空间\"></a>Part 3: 内核地址空间</h2><h4 id=\"线性地址的两部分\"><a href=\"#线性地址的两部分\" class=\"headerlink\" title=\"线性地址的两部分\"></a>线性地址的两部分</h4><blockquote>\n<p>JOS将处理器32位线性地址划分为占低地址的用户环境(进程)和占高地址的内核。 分界线是<code>inc/memlayout.h</code>中的变量 <code>ULIM</code>。内核保留了大约256MB的虚拟地址空间，lab1中内核设在那么高的地址就是因为要留一部分空间给用户环境。</p>\n</blockquote>\n<h4 id=\"访问权限和故障隔离\"><a href=\"#访问权限和故障隔离\" class=\"headerlink\" title=\"访问权限和故障隔离\"></a>访问权限和故障隔离</h4><blockquote>\n<p>内核和用户内存都在各自的环境地址空间中，必须在x86页表中使用访问权限位(<code>Permissions bits</code>)来使用户代码只访问用户的地址空间，否则用户的代码bug会覆盖内核数据，造成系统崩溃。值得注意的是可写权限位(<code>PTE_W</code>)可以同时影响用户和内核代码。<br>高于<code>ULIM</code>的内存内核可以读写，而用户环境没有权限。内核和用户在地址<code>[UTOP,ULIM)</code>有同样的权限：可读但不可写，这部分地址空间通常是一些特定的内核数据，让用户环境可以读取。最后，地址<code>UTOP</code>之下的是用户环境。</p>\n</blockquote>\n<h4 id=\"初始化内核地址空间\"><a href=\"#初始化内核地址空间\" class=\"headerlink\" title=\"初始化内核地址空间\"></a>初始化内核地址空间</h4><blockquote>\n<p>设置<code>UTOP</code>之上的地址空间。在<code>inc/memlayout.h</code>中显示了布局。</p>\n</blockquote>\n<h4 id=\"Exercise-5\"><a href=\"#Exercise-5\" class=\"headerlink\" title=\"Exercise 5\"></a>Exercise 5</h4><blockquote>\n<p>完成<code>mem_init()</code>中缺少的部分。<br>因为<code>mem_init</code>开头创建了初始化页目录<code>kern_pgdir</code>，首先是将<code>pages</code>数组映射到线性地址<code>UPAGES</code>，权限是内核只读。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">boot_map_region(kern_pgdir, UPAGES, PTSIZE, PADDR(pages),PTE_U);`</div></pre></td></tr></table></figure></p>\n<p>接着是映射物理地址到内核栈，也就是从地址范围<code>[KSTACKTOP-KSTKSIZE, KSTACKTOP)</code>映射到<code>bootstack</code>开始的物理地址页上，注释中提到了，只要映射<code>[KSTACKTOP-KSTKSIZE, KSTACKTOP)</code>， <code>[KSTACKTOP-PTSIZE, KSTACKTOP-KSTKSIZE)</code>不映射，权限位是内核读写。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">boot_map_region(kern_pgdir, KSTACKTOP-KSTKSIZE, KSTKSIZE, PADDR(bootstack), PTE_W);</div></pre></td></tr></table></figure></p>\n<p>最后是映射虚拟地址<code>[KERNBASE, 2^32)</code>到物理地址<code>[0, 2^32 - KERNBASE)</code>，权限位是内核读写。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">boot_map_region(kern_pgdir, KERNBASE, (<span class=\"number\">0xffffffff</span>-KERNBASE), <span class=\"number\">0</span>, PTE_W);</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://pdos.csail.mit.edu/6.828/2016/labs/lab2/\" target=\"_blank\" rel=\"external\">memory management</a></p>"},{"title":"lab3-user-environment-part2","date":"2017-04-28T16:00:00.000Z","_content":"\n# Lab3 用户环境 Part2\n\n## Part2 缺页中断, 断点异常和系统调用\npart1完成后,JOSkernel已经具备一定的异常处理能力了,part2将进一步完善它,使它能够处理不同类型的中断/异常.\n\n### 处理缺页中断\n　　缺页中断（中断向量14（`T_PGFLT`））是一个非常重要的中断,因为后续的实验中,非常依赖kernel能够处理缺页中断的能力.当缺页中断发生时,系统会把引起中断的线性地址存放到控制寄存器`CR2`中.在`trap.c`中,已经提供了一个能够处理这种缺页异常的函数`page_fault_handler()`.\n\n<!-- more -->\n\n#### 练习5\n问\n> 修改`trap_dispatch`函数,使系统能够把缺页异常引导到 `page_fault_handler()`上执行.在修改完成后,JOS可以成功运行测试程序`faultread,faultreadkernel,faultwrite,faultwritekernel`\n\n解:\n> 根据 `trapentry.S`文件中的`TRAPHANDLER`函数可知,这个函数会把当前中断的中断向量压入堆栈中,再根据`inc/trap.h`文件中的`Trapframe`结构体可以知道,`Trapframe`中的`tf_trapno`成员代表这个中断的中断向量.所以在 `trap_dispatch`函数中需要根据输入的`Trapframe`指针`tf`中的 `tf_trapno`成员来判断捕捉是什么中断.如果是是缺页中断,则执行 `page_fault_handler`函数,修改代码如下：\n``` c\nstatic void\ntrap_dispatch(struct Trapframe *tf)\n{\n    int32_t ret_code;\n    // Handle processor exceptions.\n    switch(tf->tf_trapno) {\n        case (T_PGFLT):\n            page_fault_handler(tf);\n            break;\n         default:\n            // Unexpected trap: The user process or the kernel has a bug.\n            print_trapframe(tf);\n            if (tf->tf_cs == GD_KT)\n                panic(\"unhandled trap in kernel\");\n            else {\n                env_destroy(curenv);\n                return;\n            }\n    }\n}\n```\n\n### 断点异常\n断点异常,中断向量3（`T_BRKPT`）.这个异常可以让调试器能够给程序加上断点.加断点的基本原理就是把要加断点的语句用一个`INT3`指令替换:执行到`INT3`时,会触发软中断.在JOS中通过把这个异常转换成一个伪系统调用,这样的话任何用户环境都可以使用这个伪系统调用来触发JOSkernel监视器`kernel monitor`.\n\n### 练习6\n问\n> 修改`trap_dispatch()`使断点异常发生时,能够触发kernel监视器.要求修改后的 JOS 能够正确运行`breakpoint`测试程序.\n\n解\n> 这个练习其实和上一个练习是类似的,只不过是在这里需要处理断点异常 (`T_BRKPT`),kernel monitor 就是定义在`kern/monitor.c`文件中的`monitor` 函数,修改程序如下\n``` c\nstatic void\ntrap_dispatch(struct Trapframe *tf)\n{\n    int32_t ret_code;\n    // Handle processor exceptions.\n    switch(tf->tf_trapno) {\n        case (T_PGFLT):\n            page_fault_handler(tf);\n            break;\n        case (T_BRKPT):\n            monitor(tf);        \n            break;\n         default:\n            // Unexpected trap: The user process or the kernel has a bug.\n            print_trapframe(tf);\n            if (tf->tf_cs == GD_KT)\n                panic(\"unhandled trap in kernel\");\n            else {\n                env_destroy(curenv);\n                return;\n            }\n    }\n}\n```\n\n#### 问题\n> 3. 在上面的断点异常(`break point exception`)测试程序中,如果在设置`IDT`时,对断点异常采用不同的方式进行设置,可能会产生触发不同的异常,有可能是断点异常,有可能是一般保护异常(`general protection exception`).这是为什么？应该怎么做才能得到一个想要的断点异常,而不是一般保护异常？\n解:\n　　通过实验发现出现这个现象的问题就是在设置`IDT`表中的断点异常的表项时,如果把表项中的`DPL`字段设置为3,则会触发断点异常,如果设置为0,则会触发一般保护异常.`DPL`字段代表的含义是段描述符优先级（`Descriptor Privileged Level`）,如果想要当前执行的程序能够跳转到这个描述符所指向的程序继续执行的话,要求当前运行程序的`CPL,RPL`的最大值需要小于等于`DPL`,否则就会出现优先级低的代码试图去访问优先级高的代码的情况,就会触发一般保护异常.那么的测试程序首先运行于用户态,它的`CPL`为3,当异常发生时,它希望去执行`int 3`指令,这是一个系统级别的指令,用户态命令的`CPL`一定大于`int 3`的`DPL`,所以就会触发一般保护异常,但是如果把`IDT`这个表项的`DPL`字段设置为3时,就不会出现这样的现象了,这时如果再出现异常,肯定是因为还没有编写处理断点异常的程序所引起的,所以是断点异常.\n\n### 系统调用\n用户程序会要求kernel帮助它完成系统调用.当用户程序触发系统调用,系统进入kernel态.CPU和操作系统将保存该用户程序当前的上下文状态,然后由kernel执行正确的代码完成系统调用,然后回到用户程序继续执行.而用户程序到底是如何得到操作系统的服务,以及它如何说明它希望操作系统如何服务的方法,有很多不同的实现方式.\n在JOS中,采用`int`指令,这个指令会触发一个CPU的中断.特别的,用`int $0x30`来代表系统调用中断.注意,`int 0x30`不是通过硬件产生的.\n应用程序会把系统调用号以及系统调用的参数放到寄存器中.通过这种方法,kernel就不需要去查询用户程序的堆栈了.系统调用号存放到`%eax`中,参数则存放在`%edx, %ecx, %ebx, %edi, 和 %esi`中.kernel会把返回值送到`%eax`中.在`lib/syscall.c`中已经写好触发一个系统调用的代码.　　\n\n#### 练习7\n问:\n> 给中断向量`T_SYSCALL`编写一个中断处理函数.需要编辑`kern/trapentry.S`和`kern/trap.c`中的`trap_init()`函数,也需要修改`trap_dispatch()`函数,使其能够通过调用`syscall()`（在``kern/syscall.c``中定义的）函数处理系统调用中断.最后需要实现`kern/syscall.c`中的`syscall()`函数, 确保这个函数会在系统调用号为非法值时返回`-E_INVAL`.要求充分理解`lib/syscall.c`文件,处理在`inc/syscall.h`文件中定义的所有系统调用.\n　　通过`make run-hello`指令来运行`user/hello`程序,它应该在控制台上输出 “hello, world”,然后引发一个缺页中断.\n\n解:\n> 需要了解一下系统调用的整个流程:如果现在运行的是kernel态的程序的话,此时调用了一个系统调用,比如`sys_cputs`函数时,此时不会触发中断,那么系统会直接执行定义在`lib/syscall.c`文件中的`sys_cputs`这个文件中定义了几个比较常用的系统调用,包括`sys_cputs`, `sys_cgetc`等等.还会发现他们都是统一调用一个 `syscall()`函数,通过这个函数的代码发现其实它是执行了一个汇编指令.所以最终是这个函数完成了系统调用.\n以上是运行在kernel态下的程序,调用系统调用时的流程.但是如果是用户态程序呢？这个练习就是让编写程序使的用户程序在调用系统调用时,最终也能经过一系列的处理最终去执行`lib/syscall.c`中的`syscall`指令.\n让看一下这个过程,当用户程序中要调用系统调用时,依然比如`sys_cputs`,从它的汇编代码中会发现,它会执行一个`int $0x30`指令,这个指令就是软件中断指令,这个中断的中断号就是`0x3`,即`T_SYSCALL`,所以题目要求首先为这个中断号编写一个中断处理函数,首先就要在`kern/trapentry.S`文件中为它声明它的中断处理函数,即`TRAPHANDLER_NOEC`,与其他中断号的声明一样.\n``` c\n//kern/trapentry.S\n....\nTRAPHANDLER_NOEC(t_fperr, T_FPERR)\nTRAPHANDLER(t_align, T_ALIGN)\nTRAPHANDLER_NOEC(t_mchk, T_MCHK)\nTRAPHANDLER_NOEC(t_simderr, T_SIMDERR)\n....\nTRAPHANDLER_NOEC(t_syscall, T_SYSCALL)\n....\n```\n\n> 然后在`trap.c`文件中声明`t_syscall()``函数.并且在`trap_init()`函数中为它注册\n``` c\n//kern/trap.c\n....\nvoid t_fperr();\nvoid t_align();\nvoid t_mchk();\nvoid t_simderr();\n\nvoid t_syscall();\n.....\nvoid\ntrap_init(void)\n{\n    extern struct Segdesc gdt[];\n\n        .....\n    SETGATE(idt[T_ALIGN], 0, GD_KT, t_align, 0);\n    SETGATE(idt[T_MCHK], 0, GD_KT, t_mchk, 0);\n    SETGATE(idt[T_SIMDERR], 0, GD_KT, t_simderr, 0);\n\n    SETGATE(idt[T_SYSCALL], 0, GD_KT, t_syscall, 3);\n    // Per-CPU setup\n    trap_init_percpu();\n}    \n```\n\n> 此时当系统调用中断发生时,系统就可以捕捉到这个中断了,中断发生时,系统会调用 `_alltraps`代码块,并且运行到`trap()`函数处,进入`trap()`函数后,经过一系列处理进入`trap_dispatch()`函数.题目中要求此时需要去调用`kern/syscall.c`中的`syscall`函数,注意到这个函数不是`lib/syscall.c1`中的`syscall`函数,但是通过阅读`kern/syscall.c`中的`syscall`程序发现,它的输入和 `lib/syscall.c`中的`syscall`很像,对比如下\n\n>`kern/syscall.c`中的`syscall`：\n``` c\nsyscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)\n```\n>  `lib/syscall.c`中的`syscall`：\n``` c\nsyscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)\n```\n> 可以假设,`kern/syscall.c`中的`syscall`就是一个外壳函数,它的存在就是为了能够调用`lib/syscall`.所以按照这个思路继续进行下去,再继续观察 `kern/syscall.c`中的其他函数,会发现`kern/syscall.c`中的所有函数和 `lib/syscall.c`中的所有函数都是一样的.比如 在这两个文件中都有`sys_cputs` 函数,但仔细观察可以发现这两个同名的函数,发现实现方式却不一样.以`sys_cputs`函数为例：\n> `kern/syscall.c`中的`sys_cputs`：\n``` c\nstatic void\nsys_cputs(const char *s, size_t len)\n{\n    // Check that the user has permission to read memory [s, s+len).\n    // Destroy the environment if not:.\n\n    user_mem_assert(curenv, s, len, 0);\n    // Print the string supplied by the user.\n    cprintf(\"%.*s\", len, s);\n}\n```\n> `lib/syscall.c`中的`sys_cputs`:\n``` c\nvoid\nsys_cputs(const char *s, size_t len)\n{\n    syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);\n}\n```\n> 可见在`lib/syscall.c`中,直接调用`syscall`,但是注意观察 `kern/syscall.c`中的`sys_cputs`,它调用了`cprintf`,这个调用其实就是为了完成输出的功能.但要注意,当程序运行到这里时,系统已经工作在kernel态了,而`cprintf`函数其实就是通过调用`lib/syscall.c`中的`sys_cputs`来实现的,由于此时系统已经处于kernel态了,所以这个`sys_cputs`可以被执行了.所以 `kern/syscall.c`中的`sys_cputs`函数通过调用`cprintf`实现了调用 `lib/syscall.c`中的`syscall`.\n所以剩下的部分是如何在`kern/syscall.c`中的`syscall()`函数中正确的调用`sys_cputs`函数了,当然 `kern/syscall.c` 中其他的函数也能完成这个功能.所以必须根据触发这个系统调用的指令到底想调用哪个系统调用来确定该调用哪个函数.\n\n> 如何确定这个指令是要调用哪个系统调用呢？答案是根据`syscall`函数中的第一个参数`syscallno`.这个值要手动传递进去的,它存储在哪里？通过阅读 `lib/syscall.c` 中的`syscall`函数,可以知道它存放在`%eax`寄存器中,所以最后完成`trap_dispatch`和`kern/syscall.c`中的`syscall`函数的代码.\n``` c\nstatic void\ntrap_dispatch(struct Trapframe *tf)\n{\n    int32_t ret_code;\n    // Handle processor exceptions.\n    switch(tf->tf_trapno) {\n        case (T_PGFLT):\n            page_fault_handler(tf);\n            break;\n        case (T_BRKPT):\n            monitor(tf);        \n            break;\n        case (T_SYSCALL):\n    //        print_trapframe(tf);\n            ret_code = syscall(\n                    tf->tf_regs.reg_eax,\n                    tf->tf_regs.reg_edx,\n                    tf->tf_regs.reg_ecx,\n                    tf->tf_regs.reg_ebx,\n                    tf->tf_regs.reg_edi,\n                    tf->tf_regs.reg_esi);\n            tf->tf_regs.reg_eax = ret_code;\n            break;\n         default:\n            // Unexpected trap: The user process or the kernel has a bug.\n            print_trapframe(tf);\n            if (tf->tf_cs == GD_KT)\n                panic(\"unhandled trap in kernel\");\n            else {\n                env_destroy(curenv);\n                return;\n            }\n    }\n}\n```\n> `kern/syscall.c` 中的 `syscall`():\n``` c\nint32_t\nsyscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)\n{\n    // Call the function corresponding to the 'syscallno' parameter.\n    // Return any appropriate return value.\n\n    // panic(\"syscall not implemented\");\n\n    switch (syscallno) {\n        case (SYS_cputs):\n            sys_cputs((const char *)a1, a2);\n            return 0;\n        case (SYS_cgetc):\n            return sys_cgetc();\n        case (SYS_getenvid):\n            return sys_getenvid();\n        case (SYS_env_destroy):\n            return sys_env_destroy(a1);\n        default:\n            return -E_INVAL;\n    }\n}\n```\n　\n### 启动用户模式\n用户程序真正开始运行的地方是在`lib/entry.S`文件中.该文件中,首先会进行一些设置,然后就会调用`lib/libmain.c`文件中的`libmain()`函数.要求修改一`libmain()`函数,使它能够初始化全局指针`thisenv` ,让它指向当前用户环境的 `Env`结构体.\n然后`libmain()`函数就会调用`umain()`.`umain()`函数恰好是`user/hello.c`中被调用的函数.在之前的实验中发现,`hello.c`程序只会打印 “hello, world”,然后就会报出`page fault`(缺页异常),原因是`thisenv->env_id`语句没有被成功初始化..现在已经正确初始化了`thisenv`的值,再次运行就应该不会报错了.\n\n### 练习8\n问：\n> 把上述的要求补全的代码补全,然后重新启动kernel,此时应该看到`user/hello`程序会打印 “hello, world”, 然后再打印出来 “i am environment 00001000”.然后`user/hello`通过调用`sys_env_destroy()（lib/libmain.c lib/exit.c）`尝试退出.由于kernel目前仅仅支持一个用户运行环境,所以它应该报告唯一的用户环境已被销毁的消息,然后退回kernel监控器.\n\n解：\n> 这个练习是通过程序获得当前正在运行的用户环境的`env_id`, 以及这个用户环境所对应的`Env`结构体的指针.`env_id`可以通过调用`sys_getenvid()`函数来获得.那么如何获得它对应的`Env`结构体指针呢？\n　　通过阅读`lib/env.h`文件知道,`env_id`的值类型为`int32_t`,按位模式分为三部分\n> * 第31位被固定为0\n> * 第10~30这21位是标识符,标示这个用户环境\n> * 第0~9位代表这个用户环境所采用的`Env`结构体,在`envs`数组中的索引.\n所以只需知道`env_id`的低 0~9 位,就可以获得这个用户环境对应的`Env`结构体了.代码如下：\n``` c\nvoid\nlibmain(int argc, char **argv)\n{\n    // set thisenv to point at our Env structure in envs[].\n    thisenv = &envs[ENVX(sys_getenvid())];\n\n    // save the name of the program so that panic() can use it\n    if (argc > 0)\n        binaryname = argv[0];\n\n    // call user main routine\n    umain(argc, argv);\n\n    // exit gracefully\n    exit();\n}\n```\n\n### 页错误和内存保护\n内存保护是操作系统的非常重要的一项功能,它可以防止由于用户程序崩溃对操作系统带来的破坏与影响.\n操作系统通常依赖于硬件的支持来实现内存保护.操作系统可以让硬件能够始终知晓哪些虚拟地址是有效的,哪些是无效的.当程序尝试去访问一个无效地址,或者尝试去访问一个超出它访问权限的地址时,处理器会在这个指令处终止,并且触发异常,陷入内核态,与此同时把错误的信息报告给内核.如果这个异常是可以被修复的,那么内核会修复这个异常,然后程序继续运行.如果异常无法被修复,则程序永远不会继续运行.\n> 一个可修复异常的典型是可自动扩展的堆栈.在许多系统中,内核在初始情况下只会分配一个内核堆栈页,如果程序想要访问这个内核堆栈页之外的堆栈空间的话,就会触发异常,此时内核会自动再分配一些页给这个程序,程序就可以继续运行了.\n\n系统调用也为内存保护带来了问题.大部分系统调用接口让用户程序传递一个指针参数给内核.这些指针指向的是用户缓冲区.通过这种方式,系统调用在执行时就可以解引用这些指针.但是这里有两个问题：\n1. 在内核中的页错误（page fault)要比在用户程序中的页错误更严重.如果内核在操作自己的数据结构时出现页错误,这是一个内核的bug,而且异常处理程序会中断整个内核.但是当内核在解引用由用户程序传递来的指针时,它需要一种方法去记录此时出现的页错误都是由用户程序带来的.\n2. 内核通常比用户程序有着更高的内存访问权限.用户程序很有可能要传递一个指针给系统调用,这个指针指向的内存区域是内核可以进行读写的,但是用户程序不能.此时内核必须小心不要去解析这个指针,否则的话内核的重要信息很有可能被泄露.\n\n现在需要通过仔细检查所有由用户传递来指针所指向的空间来解决上述两个问题.当一个程序传递给内核一个指针时,内核会检查这个地址是否在整个地址空间的用户地址空间部分,如果是将允许页表进行内存操作.\n\n#### 练习9\n问：\n> 修改`kern/trap.c`文件,使其能够实现当在内核模式下发现页错误,`trap.c`将转到`panic`.阅读`user_mem_assert`（在`kern/pmap.c`）,并且实现`user_mem_check`；修改`kern/syscall.c`，检查输入参数.\n启动内核后,运行`user/buggyhello`程序,用户环境可以被销毁,内核不可以`panic`,输出应该是：\n```\n[00001000] user_mem_check assertion failure for va 00000001\n[00001000] free env 00001000\nDestroyed the only environment - nothing more to do!\n```\n\n解：\n> 首先确定应该根据什么来判断当前运行的程序时处在内核态下还是用户态下？根据`CS`段寄存器的低2位,这两位的名称叫做`CPL`位,表示当前运行的代码的访问权限级别,0代表是内核态,3代表是用户态.\n题目要求在检测到页错误是出现在内核态时,通过`panic`跳出来,所以我们把`page_fault_handler`文件修改如下：\n``` c\nvoid\npage_fault_handler(struct Trapframe *tf)\n{\n    uint32_t fault_va;\n\n    // Read processor's CR2 register to find the faulting address\n    fault_va = rcr2();\n\n    // Handle kernel-mode 页错误s.\n    if(tf->tf_cs && 0x01 == 0) {\n        panic(\"page_fault in kernel mode, fault address %d\\n\", fault_va);\n    }\n\n    // We've already handled kernel-mode exceptions, so if we get here,\n    // the page fault happened in user mode.\n\n    // Destroy the environment that caused the fault.\n    cprintf(\"[%08x] user fault va %08x ip %08x\\n\",\n        curenv->env_id, fault_va, tf->tf_eip);\n    print_trapframe(tf);\n    env_destroy(curenv);\n}\n```\n> 然后根据题目的要求,继续完善`kern/pmap.c`文件中的`user_mem_assert()`, `user_mem_check` 函数,通过观察 `user_mem_assert()`函数发现,它调用了 `user_mem_check()`函数.而 `user_mem_check`函数的功能是检查一下当前用户态程序是否有对虚拟地址空间`[va, va+len]`的`perm| PTE_P`访问权限.\n然后要做的事情是,先找到这个虚拟地址范围对应于当前用户态程序的页表中的页表项,然后再去看一下这个页表项中有关访问权限的字段,是否包含`perm|PTE_P`,只要有一个页表项是不包含的,就代表程序对这个范围的虚拟地址没有`perm|PTE_P`的访问权限.代码实现如下：\n``` c\nint\nuser_mem_check(struct Env *env, const void *va, size_t len, int perm)\n{\n    char * end = NULL;\n    char * start = NULL;\n    start = ROUNDDOWN((char *)va, PGSIZE);\n    end = ROUNDUP((char *)(va + len), PGSIZE);\n    pte_t * cur = NULL;\n\n    for(; start < end; start += PGSIZE) {\n        cur = pgdir_walk(env->env_pgdir, (void *)start, 0);\n        if((int)start > ULIM || cur == NULL || ((uint32_t)(*cur) & perm) != perm) {\n              if(start == ROUNDDOWN((char *)va, PGSIZE)) {\n                    user_mem_check_addr = (uintptr_t)va;\n              }\n              else {\n                      user_mem_check_addr = (uintptr_t)start;\n              }\n              return -E_FAULT;\n        }\n    }\n\n    return 0;\n}\n```\n\n> 最后按照题目要求，补全`kern/syscall.c`文件中的一部分内容,即`sys_cputs` 函数,这个函数要求检查用户程序对虚拟地指空间`[s, s+len]`是否有访问权限,所以可以使用刚刚写好的函数`user_mem_assert`来实现.\n``` c\nstatic void\nsys_cputs(const char *s, size_t len)\n{\n    // Check that the user has permission to read memory [s, s+len).\n    // Destroy the environment if not:.\n\n    user_mem_assert(curenv, s, len, 0);\n    // Print the string supplied by the user.\n    cprintf(\"%.*s\", len, s);\n}\n```\n> 最后在`kern/kdebug`中修改`debuginfo_eip`函数,对用户空间的数据使用`user_mem_check`函数检查当前用户空间是否对其有`PTE_U`权限.\n``` c\n...\n    const struct UserStabData *usd = (const struct UserStabData *) USTABDATA;\n    // Make sure this memory is valid.\n    // Return -1 if it is not.  Hint: Call user_mem_check.\n    // LAB 3: Your code here.\n    if (user_mem_check(curenv, usd, sizeof(*usd),PTE_U) <0 )\n            return -1;\n    stabs = usd->stabs;\n    stab_end = usd->stab_end;\n    stabstr = usd->stabstr;\n    stabstr_end = usd->stabstr_end;\n    // Make sure the STABS and string table memory is valid.\n    // LAB 3: Your code here.a\n    if (user_mem_check(curenv, stabs, stab_end-stabs,PTE_U) <0 || `user_mem_check`(curenv, stabstr, stabstr_end-stabstr,PTE_U) <0)\n            return -1;\n```\n\n## 参考链接\n[lab3:user environment](https://pdos.csail.mit.edu/6.828/2016/labs/lab3/)\n","source":"_posts/lab3_part2.md","raw":"title: lab3-user-environment-part2\ndate: 2017/04/29\ntags:\n- xv6\n- os\n\n---\n\n# Lab3 用户环境 Part2\n\n## Part2 缺页中断, 断点异常和系统调用\npart1完成后,JOSkernel已经具备一定的异常处理能力了,part2将进一步完善它,使它能够处理不同类型的中断/异常.\n\n### 处理缺页中断\n　　缺页中断（中断向量14（`T_PGFLT`））是一个非常重要的中断,因为后续的实验中,非常依赖kernel能够处理缺页中断的能力.当缺页中断发生时,系统会把引起中断的线性地址存放到控制寄存器`CR2`中.在`trap.c`中,已经提供了一个能够处理这种缺页异常的函数`page_fault_handler()`.\n\n<!-- more -->\n\n#### 练习5\n问\n> 修改`trap_dispatch`函数,使系统能够把缺页异常引导到 `page_fault_handler()`上执行.在修改完成后,JOS可以成功运行测试程序`faultread,faultreadkernel,faultwrite,faultwritekernel`\n\n解:\n> 根据 `trapentry.S`文件中的`TRAPHANDLER`函数可知,这个函数会把当前中断的中断向量压入堆栈中,再根据`inc/trap.h`文件中的`Trapframe`结构体可以知道,`Trapframe`中的`tf_trapno`成员代表这个中断的中断向量.所以在 `trap_dispatch`函数中需要根据输入的`Trapframe`指针`tf`中的 `tf_trapno`成员来判断捕捉是什么中断.如果是是缺页中断,则执行 `page_fault_handler`函数,修改代码如下：\n``` c\nstatic void\ntrap_dispatch(struct Trapframe *tf)\n{\n    int32_t ret_code;\n    // Handle processor exceptions.\n    switch(tf->tf_trapno) {\n        case (T_PGFLT):\n            page_fault_handler(tf);\n            break;\n         default:\n            // Unexpected trap: The user process or the kernel has a bug.\n            print_trapframe(tf);\n            if (tf->tf_cs == GD_KT)\n                panic(\"unhandled trap in kernel\");\n            else {\n                env_destroy(curenv);\n                return;\n            }\n    }\n}\n```\n\n### 断点异常\n断点异常,中断向量3（`T_BRKPT`）.这个异常可以让调试器能够给程序加上断点.加断点的基本原理就是把要加断点的语句用一个`INT3`指令替换:执行到`INT3`时,会触发软中断.在JOS中通过把这个异常转换成一个伪系统调用,这样的话任何用户环境都可以使用这个伪系统调用来触发JOSkernel监视器`kernel monitor`.\n\n### 练习6\n问\n> 修改`trap_dispatch()`使断点异常发生时,能够触发kernel监视器.要求修改后的 JOS 能够正确运行`breakpoint`测试程序.\n\n解\n> 这个练习其实和上一个练习是类似的,只不过是在这里需要处理断点异常 (`T_BRKPT`),kernel monitor 就是定义在`kern/monitor.c`文件中的`monitor` 函数,修改程序如下\n``` c\nstatic void\ntrap_dispatch(struct Trapframe *tf)\n{\n    int32_t ret_code;\n    // Handle processor exceptions.\n    switch(tf->tf_trapno) {\n        case (T_PGFLT):\n            page_fault_handler(tf);\n            break;\n        case (T_BRKPT):\n            monitor(tf);        \n            break;\n         default:\n            // Unexpected trap: The user process or the kernel has a bug.\n            print_trapframe(tf);\n            if (tf->tf_cs == GD_KT)\n                panic(\"unhandled trap in kernel\");\n            else {\n                env_destroy(curenv);\n                return;\n            }\n    }\n}\n```\n\n#### 问题\n> 3. 在上面的断点异常(`break point exception`)测试程序中,如果在设置`IDT`时,对断点异常采用不同的方式进行设置,可能会产生触发不同的异常,有可能是断点异常,有可能是一般保护异常(`general protection exception`).这是为什么？应该怎么做才能得到一个想要的断点异常,而不是一般保护异常？\n解:\n　　通过实验发现出现这个现象的问题就是在设置`IDT`表中的断点异常的表项时,如果把表项中的`DPL`字段设置为3,则会触发断点异常,如果设置为0,则会触发一般保护异常.`DPL`字段代表的含义是段描述符优先级（`Descriptor Privileged Level`）,如果想要当前执行的程序能够跳转到这个描述符所指向的程序继续执行的话,要求当前运行程序的`CPL,RPL`的最大值需要小于等于`DPL`,否则就会出现优先级低的代码试图去访问优先级高的代码的情况,就会触发一般保护异常.那么的测试程序首先运行于用户态,它的`CPL`为3,当异常发生时,它希望去执行`int 3`指令,这是一个系统级别的指令,用户态命令的`CPL`一定大于`int 3`的`DPL`,所以就会触发一般保护异常,但是如果把`IDT`这个表项的`DPL`字段设置为3时,就不会出现这样的现象了,这时如果再出现异常,肯定是因为还没有编写处理断点异常的程序所引起的,所以是断点异常.\n\n### 系统调用\n用户程序会要求kernel帮助它完成系统调用.当用户程序触发系统调用,系统进入kernel态.CPU和操作系统将保存该用户程序当前的上下文状态,然后由kernel执行正确的代码完成系统调用,然后回到用户程序继续执行.而用户程序到底是如何得到操作系统的服务,以及它如何说明它希望操作系统如何服务的方法,有很多不同的实现方式.\n在JOS中,采用`int`指令,这个指令会触发一个CPU的中断.特别的,用`int $0x30`来代表系统调用中断.注意,`int 0x30`不是通过硬件产生的.\n应用程序会把系统调用号以及系统调用的参数放到寄存器中.通过这种方法,kernel就不需要去查询用户程序的堆栈了.系统调用号存放到`%eax`中,参数则存放在`%edx, %ecx, %ebx, %edi, 和 %esi`中.kernel会把返回值送到`%eax`中.在`lib/syscall.c`中已经写好触发一个系统调用的代码.　　\n\n#### 练习7\n问:\n> 给中断向量`T_SYSCALL`编写一个中断处理函数.需要编辑`kern/trapentry.S`和`kern/trap.c`中的`trap_init()`函数,也需要修改`trap_dispatch()`函数,使其能够通过调用`syscall()`（在``kern/syscall.c``中定义的）函数处理系统调用中断.最后需要实现`kern/syscall.c`中的`syscall()`函数, 确保这个函数会在系统调用号为非法值时返回`-E_INVAL`.要求充分理解`lib/syscall.c`文件,处理在`inc/syscall.h`文件中定义的所有系统调用.\n　　通过`make run-hello`指令来运行`user/hello`程序,它应该在控制台上输出 “hello, world”,然后引发一个缺页中断.\n\n解:\n> 需要了解一下系统调用的整个流程:如果现在运行的是kernel态的程序的话,此时调用了一个系统调用,比如`sys_cputs`函数时,此时不会触发中断,那么系统会直接执行定义在`lib/syscall.c`文件中的`sys_cputs`这个文件中定义了几个比较常用的系统调用,包括`sys_cputs`, `sys_cgetc`等等.还会发现他们都是统一调用一个 `syscall()`函数,通过这个函数的代码发现其实它是执行了一个汇编指令.所以最终是这个函数完成了系统调用.\n以上是运行在kernel态下的程序,调用系统调用时的流程.但是如果是用户态程序呢？这个练习就是让编写程序使的用户程序在调用系统调用时,最终也能经过一系列的处理最终去执行`lib/syscall.c`中的`syscall`指令.\n让看一下这个过程,当用户程序中要调用系统调用时,依然比如`sys_cputs`,从它的汇编代码中会发现,它会执行一个`int $0x30`指令,这个指令就是软件中断指令,这个中断的中断号就是`0x3`,即`T_SYSCALL`,所以题目要求首先为这个中断号编写一个中断处理函数,首先就要在`kern/trapentry.S`文件中为它声明它的中断处理函数,即`TRAPHANDLER_NOEC`,与其他中断号的声明一样.\n``` c\n//kern/trapentry.S\n....\nTRAPHANDLER_NOEC(t_fperr, T_FPERR)\nTRAPHANDLER(t_align, T_ALIGN)\nTRAPHANDLER_NOEC(t_mchk, T_MCHK)\nTRAPHANDLER_NOEC(t_simderr, T_SIMDERR)\n....\nTRAPHANDLER_NOEC(t_syscall, T_SYSCALL)\n....\n```\n\n> 然后在`trap.c`文件中声明`t_syscall()``函数.并且在`trap_init()`函数中为它注册\n``` c\n//kern/trap.c\n....\nvoid t_fperr();\nvoid t_align();\nvoid t_mchk();\nvoid t_simderr();\n\nvoid t_syscall();\n.....\nvoid\ntrap_init(void)\n{\n    extern struct Segdesc gdt[];\n\n        .....\n    SETGATE(idt[T_ALIGN], 0, GD_KT, t_align, 0);\n    SETGATE(idt[T_MCHK], 0, GD_KT, t_mchk, 0);\n    SETGATE(idt[T_SIMDERR], 0, GD_KT, t_simderr, 0);\n\n    SETGATE(idt[T_SYSCALL], 0, GD_KT, t_syscall, 3);\n    // Per-CPU setup\n    trap_init_percpu();\n}    \n```\n\n> 此时当系统调用中断发生时,系统就可以捕捉到这个中断了,中断发生时,系统会调用 `_alltraps`代码块,并且运行到`trap()`函数处,进入`trap()`函数后,经过一系列处理进入`trap_dispatch()`函数.题目中要求此时需要去调用`kern/syscall.c`中的`syscall`函数,注意到这个函数不是`lib/syscall.c1`中的`syscall`函数,但是通过阅读`kern/syscall.c`中的`syscall`程序发现,它的输入和 `lib/syscall.c`中的`syscall`很像,对比如下\n\n>`kern/syscall.c`中的`syscall`：\n``` c\nsyscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)\n```\n>  `lib/syscall.c`中的`syscall`：\n``` c\nsyscall(int num, int check, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)\n```\n> 可以假设,`kern/syscall.c`中的`syscall`就是一个外壳函数,它的存在就是为了能够调用`lib/syscall`.所以按照这个思路继续进行下去,再继续观察 `kern/syscall.c`中的其他函数,会发现`kern/syscall.c`中的所有函数和 `lib/syscall.c`中的所有函数都是一样的.比如 在这两个文件中都有`sys_cputs` 函数,但仔细观察可以发现这两个同名的函数,发现实现方式却不一样.以`sys_cputs`函数为例：\n> `kern/syscall.c`中的`sys_cputs`：\n``` c\nstatic void\nsys_cputs(const char *s, size_t len)\n{\n    // Check that the user has permission to read memory [s, s+len).\n    // Destroy the environment if not:.\n\n    user_mem_assert(curenv, s, len, 0);\n    // Print the string supplied by the user.\n    cprintf(\"%.*s\", len, s);\n}\n```\n> `lib/syscall.c`中的`sys_cputs`:\n``` c\nvoid\nsys_cputs(const char *s, size_t len)\n{\n    syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);\n}\n```\n> 可见在`lib/syscall.c`中,直接调用`syscall`,但是注意观察 `kern/syscall.c`中的`sys_cputs`,它调用了`cprintf`,这个调用其实就是为了完成输出的功能.但要注意,当程序运行到这里时,系统已经工作在kernel态了,而`cprintf`函数其实就是通过调用`lib/syscall.c`中的`sys_cputs`来实现的,由于此时系统已经处于kernel态了,所以这个`sys_cputs`可以被执行了.所以 `kern/syscall.c`中的`sys_cputs`函数通过调用`cprintf`实现了调用 `lib/syscall.c`中的`syscall`.\n所以剩下的部分是如何在`kern/syscall.c`中的`syscall()`函数中正确的调用`sys_cputs`函数了,当然 `kern/syscall.c` 中其他的函数也能完成这个功能.所以必须根据触发这个系统调用的指令到底想调用哪个系统调用来确定该调用哪个函数.\n\n> 如何确定这个指令是要调用哪个系统调用呢？答案是根据`syscall`函数中的第一个参数`syscallno`.这个值要手动传递进去的,它存储在哪里？通过阅读 `lib/syscall.c` 中的`syscall`函数,可以知道它存放在`%eax`寄存器中,所以最后完成`trap_dispatch`和`kern/syscall.c`中的`syscall`函数的代码.\n``` c\nstatic void\ntrap_dispatch(struct Trapframe *tf)\n{\n    int32_t ret_code;\n    // Handle processor exceptions.\n    switch(tf->tf_trapno) {\n        case (T_PGFLT):\n            page_fault_handler(tf);\n            break;\n        case (T_BRKPT):\n            monitor(tf);        \n            break;\n        case (T_SYSCALL):\n    //        print_trapframe(tf);\n            ret_code = syscall(\n                    tf->tf_regs.reg_eax,\n                    tf->tf_regs.reg_edx,\n                    tf->tf_regs.reg_ecx,\n                    tf->tf_regs.reg_ebx,\n                    tf->tf_regs.reg_edi,\n                    tf->tf_regs.reg_esi);\n            tf->tf_regs.reg_eax = ret_code;\n            break;\n         default:\n            // Unexpected trap: The user process or the kernel has a bug.\n            print_trapframe(tf);\n            if (tf->tf_cs == GD_KT)\n                panic(\"unhandled trap in kernel\");\n            else {\n                env_destroy(curenv);\n                return;\n            }\n    }\n}\n```\n> `kern/syscall.c` 中的 `syscall`():\n``` c\nint32_t\nsyscall(uint32_t syscallno, uint32_t a1, uint32_t a2, uint32_t a3, uint32_t a4, uint32_t a5)\n{\n    // Call the function corresponding to the 'syscallno' parameter.\n    // Return any appropriate return value.\n\n    // panic(\"syscall not implemented\");\n\n    switch (syscallno) {\n        case (SYS_cputs):\n            sys_cputs((const char *)a1, a2);\n            return 0;\n        case (SYS_cgetc):\n            return sys_cgetc();\n        case (SYS_getenvid):\n            return sys_getenvid();\n        case (SYS_env_destroy):\n            return sys_env_destroy(a1);\n        default:\n            return -E_INVAL;\n    }\n}\n```\n　\n### 启动用户模式\n用户程序真正开始运行的地方是在`lib/entry.S`文件中.该文件中,首先会进行一些设置,然后就会调用`lib/libmain.c`文件中的`libmain()`函数.要求修改一`libmain()`函数,使它能够初始化全局指针`thisenv` ,让它指向当前用户环境的 `Env`结构体.\n然后`libmain()`函数就会调用`umain()`.`umain()`函数恰好是`user/hello.c`中被调用的函数.在之前的实验中发现,`hello.c`程序只会打印 “hello, world”,然后就会报出`page fault`(缺页异常),原因是`thisenv->env_id`语句没有被成功初始化..现在已经正确初始化了`thisenv`的值,再次运行就应该不会报错了.\n\n### 练习8\n问：\n> 把上述的要求补全的代码补全,然后重新启动kernel,此时应该看到`user/hello`程序会打印 “hello, world”, 然后再打印出来 “i am environment 00001000”.然后`user/hello`通过调用`sys_env_destroy()（lib/libmain.c lib/exit.c）`尝试退出.由于kernel目前仅仅支持一个用户运行环境,所以它应该报告唯一的用户环境已被销毁的消息,然后退回kernel监控器.\n\n解：\n> 这个练习是通过程序获得当前正在运行的用户环境的`env_id`, 以及这个用户环境所对应的`Env`结构体的指针.`env_id`可以通过调用`sys_getenvid()`函数来获得.那么如何获得它对应的`Env`结构体指针呢？\n　　通过阅读`lib/env.h`文件知道,`env_id`的值类型为`int32_t`,按位模式分为三部分\n> * 第31位被固定为0\n> * 第10~30这21位是标识符,标示这个用户环境\n> * 第0~9位代表这个用户环境所采用的`Env`结构体,在`envs`数组中的索引.\n所以只需知道`env_id`的低 0~9 位,就可以获得这个用户环境对应的`Env`结构体了.代码如下：\n``` c\nvoid\nlibmain(int argc, char **argv)\n{\n    // set thisenv to point at our Env structure in envs[].\n    thisenv = &envs[ENVX(sys_getenvid())];\n\n    // save the name of the program so that panic() can use it\n    if (argc > 0)\n        binaryname = argv[0];\n\n    // call user main routine\n    umain(argc, argv);\n\n    // exit gracefully\n    exit();\n}\n```\n\n### 页错误和内存保护\n内存保护是操作系统的非常重要的一项功能,它可以防止由于用户程序崩溃对操作系统带来的破坏与影响.\n操作系统通常依赖于硬件的支持来实现内存保护.操作系统可以让硬件能够始终知晓哪些虚拟地址是有效的,哪些是无效的.当程序尝试去访问一个无效地址,或者尝试去访问一个超出它访问权限的地址时,处理器会在这个指令处终止,并且触发异常,陷入内核态,与此同时把错误的信息报告给内核.如果这个异常是可以被修复的,那么内核会修复这个异常,然后程序继续运行.如果异常无法被修复,则程序永远不会继续运行.\n> 一个可修复异常的典型是可自动扩展的堆栈.在许多系统中,内核在初始情况下只会分配一个内核堆栈页,如果程序想要访问这个内核堆栈页之外的堆栈空间的话,就会触发异常,此时内核会自动再分配一些页给这个程序,程序就可以继续运行了.\n\n系统调用也为内存保护带来了问题.大部分系统调用接口让用户程序传递一个指针参数给内核.这些指针指向的是用户缓冲区.通过这种方式,系统调用在执行时就可以解引用这些指针.但是这里有两个问题：\n1. 在内核中的页错误（page fault)要比在用户程序中的页错误更严重.如果内核在操作自己的数据结构时出现页错误,这是一个内核的bug,而且异常处理程序会中断整个内核.但是当内核在解引用由用户程序传递来的指针时,它需要一种方法去记录此时出现的页错误都是由用户程序带来的.\n2. 内核通常比用户程序有着更高的内存访问权限.用户程序很有可能要传递一个指针给系统调用,这个指针指向的内存区域是内核可以进行读写的,但是用户程序不能.此时内核必须小心不要去解析这个指针,否则的话内核的重要信息很有可能被泄露.\n\n现在需要通过仔细检查所有由用户传递来指针所指向的空间来解决上述两个问题.当一个程序传递给内核一个指针时,内核会检查这个地址是否在整个地址空间的用户地址空间部分,如果是将允许页表进行内存操作.\n\n#### 练习9\n问：\n> 修改`kern/trap.c`文件,使其能够实现当在内核模式下发现页错误,`trap.c`将转到`panic`.阅读`user_mem_assert`（在`kern/pmap.c`）,并且实现`user_mem_check`；修改`kern/syscall.c`，检查输入参数.\n启动内核后,运行`user/buggyhello`程序,用户环境可以被销毁,内核不可以`panic`,输出应该是：\n```\n[00001000] user_mem_check assertion failure for va 00000001\n[00001000] free env 00001000\nDestroyed the only environment - nothing more to do!\n```\n\n解：\n> 首先确定应该根据什么来判断当前运行的程序时处在内核态下还是用户态下？根据`CS`段寄存器的低2位,这两位的名称叫做`CPL`位,表示当前运行的代码的访问权限级别,0代表是内核态,3代表是用户态.\n题目要求在检测到页错误是出现在内核态时,通过`panic`跳出来,所以我们把`page_fault_handler`文件修改如下：\n``` c\nvoid\npage_fault_handler(struct Trapframe *tf)\n{\n    uint32_t fault_va;\n\n    // Read processor's CR2 register to find the faulting address\n    fault_va = rcr2();\n\n    // Handle kernel-mode 页错误s.\n    if(tf->tf_cs && 0x01 == 0) {\n        panic(\"page_fault in kernel mode, fault address %d\\n\", fault_va);\n    }\n\n    // We've already handled kernel-mode exceptions, so if we get here,\n    // the page fault happened in user mode.\n\n    // Destroy the environment that caused the fault.\n    cprintf(\"[%08x] user fault va %08x ip %08x\\n\",\n        curenv->env_id, fault_va, tf->tf_eip);\n    print_trapframe(tf);\n    env_destroy(curenv);\n}\n```\n> 然后根据题目的要求,继续完善`kern/pmap.c`文件中的`user_mem_assert()`, `user_mem_check` 函数,通过观察 `user_mem_assert()`函数发现,它调用了 `user_mem_check()`函数.而 `user_mem_check`函数的功能是检查一下当前用户态程序是否有对虚拟地址空间`[va, va+len]`的`perm| PTE_P`访问权限.\n然后要做的事情是,先找到这个虚拟地址范围对应于当前用户态程序的页表中的页表项,然后再去看一下这个页表项中有关访问权限的字段,是否包含`perm|PTE_P`,只要有一个页表项是不包含的,就代表程序对这个范围的虚拟地址没有`perm|PTE_P`的访问权限.代码实现如下：\n``` c\nint\nuser_mem_check(struct Env *env, const void *va, size_t len, int perm)\n{\n    char * end = NULL;\n    char * start = NULL;\n    start = ROUNDDOWN((char *)va, PGSIZE);\n    end = ROUNDUP((char *)(va + len), PGSIZE);\n    pte_t * cur = NULL;\n\n    for(; start < end; start += PGSIZE) {\n        cur = pgdir_walk(env->env_pgdir, (void *)start, 0);\n        if((int)start > ULIM || cur == NULL || ((uint32_t)(*cur) & perm) != perm) {\n              if(start == ROUNDDOWN((char *)va, PGSIZE)) {\n                    user_mem_check_addr = (uintptr_t)va;\n              }\n              else {\n                      user_mem_check_addr = (uintptr_t)start;\n              }\n              return -E_FAULT;\n        }\n    }\n\n    return 0;\n}\n```\n\n> 最后按照题目要求，补全`kern/syscall.c`文件中的一部分内容,即`sys_cputs` 函数,这个函数要求检查用户程序对虚拟地指空间`[s, s+len]`是否有访问权限,所以可以使用刚刚写好的函数`user_mem_assert`来实现.\n``` c\nstatic void\nsys_cputs(const char *s, size_t len)\n{\n    // Check that the user has permission to read memory [s, s+len).\n    // Destroy the environment if not:.\n\n    user_mem_assert(curenv, s, len, 0);\n    // Print the string supplied by the user.\n    cprintf(\"%.*s\", len, s);\n}\n```\n> 最后在`kern/kdebug`中修改`debuginfo_eip`函数,对用户空间的数据使用`user_mem_check`函数检查当前用户空间是否对其有`PTE_U`权限.\n``` c\n...\n    const struct UserStabData *usd = (const struct UserStabData *) USTABDATA;\n    // Make sure this memory is valid.\n    // Return -1 if it is not.  Hint: Call user_mem_check.\n    // LAB 3: Your code here.\n    if (user_mem_check(curenv, usd, sizeof(*usd),PTE_U) <0 )\n            return -1;\n    stabs = usd->stabs;\n    stab_end = usd->stab_end;\n    stabstr = usd->stabstr;\n    stabstr_end = usd->stabstr_end;\n    // Make sure the STABS and string table memory is valid.\n    // LAB 3: Your code here.a\n    if (user_mem_check(curenv, stabs, stab_end-stabs,PTE_U) <0 || `user_mem_check`(curenv, stabstr, stabstr_end-stabstr,PTE_U) <0)\n            return -1;\n```\n\n## 参考链接\n[lab3:user environment](https://pdos.csail.mit.edu/6.828/2016/labs/lab3/)\n","slug":"lab3_part2","published":1,"updated":"2017-08-26T03:38:21.614Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6sslhba00133gamnwjkhun9","content":"<h1 id=\"Lab3-用户环境-Part2\"><a href=\"#Lab3-用户环境-Part2\" class=\"headerlink\" title=\"Lab3 用户环境 Part2\"></a>Lab3 用户环境 Part2</h1><h2 id=\"Part2-缺页中断-断点异常和系统调用\"><a href=\"#Part2-缺页中断-断点异常和系统调用\" class=\"headerlink\" title=\"Part2 缺页中断, 断点异常和系统调用\"></a>Part2 缺页中断, 断点异常和系统调用</h2><p>part1完成后,JOSkernel已经具备一定的异常处理能力了,part2将进一步完善它,使它能够处理不同类型的中断/异常.</p>\n<h3 id=\"处理缺页中断\"><a href=\"#处理缺页中断\" class=\"headerlink\" title=\"处理缺页中断\"></a>处理缺页中断</h3><p>　　缺页中断（中断向量14（<code>T_PGFLT</code>））是一个非常重要的中断,因为后续的实验中,非常依赖kernel能够处理缺页中断的能力.当缺页中断发生时,系统会把引起中断的线性地址存放到控制寄存器<code>CR2</code>中.在<code>trap.c</code>中,已经提供了一个能够处理这种缺页异常的函数<code>page_fault_handler()</code>.</p>\n<a id=\"more\"></a>\n<h4 id=\"练习5\"><a href=\"#练习5\" class=\"headerlink\" title=\"练习5\"></a>练习5</h4><p>问</p>\n<blockquote>\n<p>修改<code>trap_dispatch</code>函数,使系统能够把缺页异常引导到 <code>page_fault_handler()</code>上执行.在修改完成后,JOS可以成功运行测试程序<code>faultread,faultreadkernel,faultwrite,faultwritekernel</code></p>\n</blockquote>\n<p>解:</p>\n<blockquote>\n<p>根据 <code>trapentry.S</code>文件中的<code>TRAPHANDLER</code>函数可知,这个函数会把当前中断的中断向量压入堆栈中,再根据<code>inc/trap.h</code>文件中的<code>Trapframe</code>结构体可以知道,<code>Trapframe</code>中的<code>tf_trapno</code>成员代表这个中断的中断向量.所以在 <code>trap_dispatch</code>函数中需要根据输入的<code>Trapframe</code>指针<code>tf</code>中的 <code>tf_trapno</code>成员来判断捕捉是什么中断.如果是是缺页中断,则执行 <code>page_fault_handler</code>函数,修改代码如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">trap_dispatch</span><span class=\"params\">(<span class=\"keyword\">struct</span> Trapframe *tf)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">int32_t</span> ret_code;</div><div class=\"line\">    <span class=\"comment\">// Handle processor exceptions.</span></div><div class=\"line\">    <span class=\"keyword\">switch</span>(tf-&gt;tf_trapno) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> (T_PGFLT):</div><div class=\"line\">            page_fault_handler(tf);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">         <span class=\"keyword\">default</span>:</div><div class=\"line\">            <span class=\"comment\">// Unexpected trap: The user process or the kernel has a bug.</span></div><div class=\"line\">            print_trapframe(tf);</div><div class=\"line\">            <span class=\"keyword\">if</span> (tf-&gt;tf_cs == GD_KT)</div><div class=\"line\">                panic(<span class=\"string\">\"unhandled trap in kernel\"</span>);</div><div class=\"line\">            <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                env_destroy(curenv);</div><div class=\"line\">                <span class=\"keyword\">return</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"断点异常\"><a href=\"#断点异常\" class=\"headerlink\" title=\"断点异常\"></a>断点异常</h3><p>断点异常,中断向量3（<code>T_BRKPT</code>）.这个异常可以让调试器能够给程序加上断点.加断点的基本原理就是把要加断点的语句用一个<code>INT3</code>指令替换:执行到<code>INT3</code>时,会触发软中断.在JOS中通过把这个异常转换成一个伪系统调用,这样的话任何用户环境都可以使用这个伪系统调用来触发JOSkernel监视器<code>kernel monitor</code>.</p>\n<h3 id=\"练习6\"><a href=\"#练习6\" class=\"headerlink\" title=\"练习6\"></a>练习6</h3><p>问</p>\n<blockquote>\n<p>修改<code>trap_dispatch()</code>使断点异常发生时,能够触发kernel监视器.要求修改后的 JOS 能够正确运行<code>breakpoint</code>测试程序.</p>\n</blockquote>\n<p>解</p>\n<blockquote>\n<p>这个练习其实和上一个练习是类似的,只不过是在这里需要处理断点异常 (<code>T_BRKPT</code>),kernel monitor 就是定义在<code>kern/monitor.c</code>文件中的<code>monitor</code> 函数,修改程序如下<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">trap_dispatch</span><span class=\"params\">(<span class=\"keyword\">struct</span> Trapframe *tf)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">int32_t</span> ret_code;</div><div class=\"line\">    <span class=\"comment\">// Handle processor exceptions.</span></div><div class=\"line\">    <span class=\"keyword\">switch</span>(tf-&gt;tf_trapno) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> (T_PGFLT):</div><div class=\"line\">            page_fault_handler(tf);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> (T_BRKPT):</div><div class=\"line\">            monitor(tf);        </div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">         <span class=\"keyword\">default</span>:</div><div class=\"line\">            <span class=\"comment\">// Unexpected trap: The user process or the kernel has a bug.</span></div><div class=\"line\">            print_trapframe(tf);</div><div class=\"line\">            <span class=\"keyword\">if</span> (tf-&gt;tf_cs == GD_KT)</div><div class=\"line\">                panic(<span class=\"string\">\"unhandled trap in kernel\"</span>);</div><div class=\"line\">            <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                env_destroy(curenv);</div><div class=\"line\">                <span class=\"keyword\">return</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h4 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h4><blockquote>\n<ol>\n<li>在上面的断点异常(<code>break point exception</code>)测试程序中,如果在设置<code>IDT</code>时,对断点异常采用不同的方式进行设置,可能会产生触发不同的异常,有可能是断点异常,有可能是一般保护异常(<code>general protection exception</code>).这是为什么？应该怎么做才能得到一个想要的断点异常,而不是一般保护异常？<br>解:<br>　　通过实验发现出现这个现象的问题就是在设置<code>IDT</code>表中的断点异常的表项时,如果把表项中的<code>DPL</code>字段设置为3,则会触发断点异常,如果设置为0,则会触发一般保护异常.<code>DPL</code>字段代表的含义是段描述符优先级（<code>Descriptor Privileged Level</code>）,如果想要当前执行的程序能够跳转到这个描述符所指向的程序继续执行的话,要求当前运行程序的<code>CPL,RPL</code>的最大值需要小于等于<code>DPL</code>,否则就会出现优先级低的代码试图去访问优先级高的代码的情况,就会触发一般保护异常.那么的测试程序首先运行于用户态,它的<code>CPL</code>为3,当异常发生时,它希望去执行<code>int 3</code>指令,这是一个系统级别的指令,用户态命令的<code>CPL</code>一定大于<code>int 3</code>的<code>DPL</code>,所以就会触发一般保护异常,但是如果把<code>IDT</code>这个表项的<code>DPL</code>字段设置为3时,就不会出现这样的现象了,这时如果再出现异常,肯定是因为还没有编写处理断点异常的程序所引起的,所以是断点异常.</li>\n</ol>\n</blockquote>\n<h3 id=\"系统调用\"><a href=\"#系统调用\" class=\"headerlink\" title=\"系统调用\"></a>系统调用</h3><p>用户程序会要求kernel帮助它完成系统调用.当用户程序触发系统调用,系统进入kernel态.CPU和操作系统将保存该用户程序当前的上下文状态,然后由kernel执行正确的代码完成系统调用,然后回到用户程序继续执行.而用户程序到底是如何得到操作系统的服务,以及它如何说明它希望操作系统如何服务的方法,有很多不同的实现方式.<br>在JOS中,采用<code>int</code>指令,这个指令会触发一个CPU的中断.特别的,用<code>int $0x30</code>来代表系统调用中断.注意,<code>int 0x30</code>不是通过硬件产生的.<br>应用程序会把系统调用号以及系统调用的参数放到寄存器中.通过这种方法,kernel就不需要去查询用户程序的堆栈了.系统调用号存放到<code>%eax</code>中,参数则存放在<code>%edx, %ecx, %ebx, %edi, 和 %esi</code>中.kernel会把返回值送到<code>%eax</code>中.在<code>lib/syscall.c</code>中已经写好触发一个系统调用的代码.　　</p>\n<h4 id=\"练习7\"><a href=\"#练习7\" class=\"headerlink\" title=\"练习7\"></a>练习7</h4><p>问:</p>\n<blockquote>\n<p>给中断向量<code>T_SYSCALL</code>编写一个中断处理函数.需要编辑<code>kern/trapentry.S</code>和<code>kern/trap.c</code>中的<code>trap_init()</code>函数,也需要修改<code>trap_dispatch()</code>函数,使其能够通过调用<code>syscall()</code>（在<code>kern/syscall.c</code>中定义的）函数处理系统调用中断.最后需要实现<code>kern/syscall.c</code>中的<code>syscall()</code>函数, 确保这个函数会在系统调用号为非法值时返回<code>-E_INVAL</code>.要求充分理解<code>lib/syscall.c</code>文件,处理在<code>inc/syscall.h</code>文件中定义的所有系统调用.<br>　　通过<code>make run-hello</code>指令来运行<code>user/hello</code>程序,它应该在控制台上输出 “hello, world”,然后引发一个缺页中断.</p>\n</blockquote>\n<p>解:</p>\n<blockquote>\n<p>需要了解一下系统调用的整个流程:如果现在运行的是kernel态的程序的话,此时调用了一个系统调用,比如<code>sys_cputs</code>函数时,此时不会触发中断,那么系统会直接执行定义在<code>lib/syscall.c</code>文件中的<code>sys_cputs</code>这个文件中定义了几个比较常用的系统调用,包括<code>sys_cputs</code>, <code>sys_cgetc</code>等等.还会发现他们都是统一调用一个 <code>syscall()</code>函数,通过这个函数的代码发现其实它是执行了一个汇编指令.所以最终是这个函数完成了系统调用.<br>以上是运行在kernel态下的程序,调用系统调用时的流程.但是如果是用户态程序呢？这个练习就是让编写程序使的用户程序在调用系统调用时,最终也能经过一系列的处理最终去执行<code>lib/syscall.c</code>中的<code>syscall</code>指令.<br>让看一下这个过程,当用户程序中要调用系统调用时,依然比如<code>sys_cputs</code>,从它的汇编代码中会发现,它会执行一个<code>int $0x30</code>指令,这个指令就是软件中断指令,这个中断的中断号就是<code>0x3</code>,即<code>T_SYSCALL</code>,所以题目要求首先为这个中断号编写一个中断处理函数,首先就要在<code>kern/trapentry.S</code>文件中为它声明它的中断处理函数,即<code>TRAPHANDLER_NOEC</code>,与其他中断号的声明一样.<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//kern/trapentry.S</span></div><div class=\"line\">....</div><div class=\"line\">TRAPHANDLER_NOEC(t_fperr, T_FPERR)</div><div class=\"line\">TRAPHANDLER(t_align, T_ALIGN)</div><div class=\"line\">TRAPHANDLER_NOEC(t_mchk, T_MCHK)</div><div class=\"line\">TRAPHANDLER_NOEC(t_simderr, T_SIMDERR)</div><div class=\"line\">....</div><div class=\"line\">TRAPHANDLER_NOEC(t_syscall, T_SYSCALL)</div><div class=\"line\">....</div></pre></td></tr></table></figure></p>\n<p>然后在<code>trap.c</code>文件中声明<code>t_syscall()``函数.并且在</code>trap_init()`函数中为它注册<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//kern/trap.c</span></div><div class=\"line\">....</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">t_fperr</span><span class=\"params\">()</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">t_align</span><span class=\"params\">()</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">t_mchk</span><span class=\"params\">()</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">t_simderr</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">t_syscall</span><span class=\"params\">()</span></span>;</div><div class=\"line\">.....</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">trap_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">extern</span> <span class=\"keyword\">struct</span> Segdesc gdt[];</div><div class=\"line\"></div><div class=\"line\">        .....</div><div class=\"line\">    SETGATE(idt[T_ALIGN], <span class=\"number\">0</span>, GD_KT, t_align, <span class=\"number\">0</span>);</div><div class=\"line\">    SETGATE(idt[T_MCHK], <span class=\"number\">0</span>, GD_KT, t_mchk, <span class=\"number\">0</span>);</div><div class=\"line\">    SETGATE(idt[T_SIMDERR], <span class=\"number\">0</span>, GD_KT, t_simderr, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">    SETGATE(idt[T_SYSCALL], <span class=\"number\">0</span>, GD_KT, t_syscall, <span class=\"number\">3</span>);</div><div class=\"line\">    <span class=\"comment\">// Per-CPU setup</span></div><div class=\"line\">    trap_init_percpu();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>此时当系统调用中断发生时,系统就可以捕捉到这个中断了,中断发生时,系统会调用 <code>_alltraps</code>代码块,并且运行到<code>trap()</code>函数处,进入<code>trap()</code>函数后,经过一系列处理进入<code>trap_dispatch()</code>函数.题目中要求此时需要去调用<code>kern/syscall.c</code>中的<code>syscall</code>函数,注意到这个函数不是<code>lib/syscall.c1</code>中的<code>syscall</code>函数,但是通过阅读<code>kern/syscall.c</code>中的<code>syscall</code>程序发现,它的输入和 <code>lib/syscall.c</code>中的<code>syscall</code>很像,对比如下</p>\n<p><code>kern/syscall.c</code>中的<code>syscall</code>：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">syscall(<span class=\"keyword\">uint32_t</span> syscallno, <span class=\"keyword\">uint32_t</span> a1, <span class=\"keyword\">uint32_t</span> a2, <span class=\"keyword\">uint32_t</span> a3, <span class=\"keyword\">uint32_t</span> a4, <span class=\"keyword\">uint32_t</span> a5)</div></pre></td></tr></table></figure></p>\n<p> <code>lib/syscall.c</code>中的<code>syscall</code>：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">syscall(<span class=\"keyword\">int</span> num, <span class=\"keyword\">int</span> check, <span class=\"keyword\">uint32_t</span> a1, <span class=\"keyword\">uint32_t</span> a2, <span class=\"keyword\">uint32_t</span> a3, <span class=\"keyword\">uint32_t</span> a4, <span class=\"keyword\">uint32_t</span> a5)</div></pre></td></tr></table></figure></p>\n<p>可以假设,<code>kern/syscall.c</code>中的<code>syscall</code>就是一个外壳函数,它的存在就是为了能够调用<code>lib/syscall</code>.所以按照这个思路继续进行下去,再继续观察 <code>kern/syscall.c</code>中的其他函数,会发现<code>kern/syscall.c</code>中的所有函数和 <code>lib/syscall.c</code>中的所有函数都是一样的.比如 在这两个文件中都有<code>sys_cputs</code> 函数,但仔细观察可以发现这两个同名的函数,发现实现方式却不一样.以<code>sys_cputs</code>函数为例：<br><code>kern/syscall.c</code>中的<code>sys_cputs</code>：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">sys_cputs</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *s, <span class=\"keyword\">size_t</span> len)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">// Check that the user has permission to read memory [s, s+len).</span></div><div class=\"line\">    <span class=\"comment\">// Destroy the environment if not:.</span></div><div class=\"line\"></div><div class=\"line\">    user_mem_assert(curenv, s, len, <span class=\"number\">0</span>);</div><div class=\"line\">    <span class=\"comment\">// Print the string supplied by the user.</span></div><div class=\"line\">    cprintf(<span class=\"string\">\"%.*s\"</span>, len, s);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>lib/syscall.c</code>中的<code>sys_cputs</code>:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">sys_cputs</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *s, <span class=\"keyword\">size_t</span> len)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    syscall(SYS_cputs, <span class=\"number\">0</span>, (<span class=\"keyword\">uint32_t</span>)s, len, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可见在<code>lib/syscall.c</code>中,直接调用<code>syscall</code>,但是注意观察 <code>kern/syscall.c</code>中的<code>sys_cputs</code>,它调用了<code>cprintf</code>,这个调用其实就是为了完成输出的功能.但要注意,当程序运行到这里时,系统已经工作在kernel态了,而<code>cprintf</code>函数其实就是通过调用<code>lib/syscall.c</code>中的<code>sys_cputs</code>来实现的,由于此时系统已经处于kernel态了,所以这个<code>sys_cputs</code>可以被执行了.所以 <code>kern/syscall.c</code>中的<code>sys_cputs</code>函数通过调用<code>cprintf</code>实现了调用 <code>lib/syscall.c</code>中的<code>syscall</code>.<br>所以剩下的部分是如何在<code>kern/syscall.c</code>中的<code>syscall()</code>函数中正确的调用<code>sys_cputs</code>函数了,当然 <code>kern/syscall.c</code> 中其他的函数也能完成这个功能.所以必须根据触发这个系统调用的指令到底想调用哪个系统调用来确定该调用哪个函数.</p>\n<p>如何确定这个指令是要调用哪个系统调用呢？答案是根据<code>syscall</code>函数中的第一个参数<code>syscallno</code>.这个值要手动传递进去的,它存储在哪里？通过阅读 <code>lib/syscall.c</code> 中的<code>syscall</code>函数,可以知道它存放在<code>%eax</code>寄存器中,所以最后完成<code>trap_dispatch</code>和<code>kern/syscall.c</code>中的<code>syscall</code>函数的代码.<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">trap_dispatch</span><span class=\"params\">(<span class=\"keyword\">struct</span> Trapframe *tf)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">int32_t</span> ret_code;</div><div class=\"line\">    <span class=\"comment\">// Handle processor exceptions.</span></div><div class=\"line\">    <span class=\"keyword\">switch</span>(tf-&gt;tf_trapno) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> (T_PGFLT):</div><div class=\"line\">            page_fault_handler(tf);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> (T_BRKPT):</div><div class=\"line\">            monitor(tf);        </div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> (T_SYSCALL):</div><div class=\"line\">    <span class=\"comment\">//        print_trapframe(tf);</span></div><div class=\"line\">            ret_code = syscall(</div><div class=\"line\">                    tf-&gt;tf_regs.reg_eax,</div><div class=\"line\">                    tf-&gt;tf_regs.reg_edx,</div><div class=\"line\">                    tf-&gt;tf_regs.reg_ecx,</div><div class=\"line\">                    tf-&gt;tf_regs.reg_ebx,</div><div class=\"line\">                    tf-&gt;tf_regs.reg_edi,</div><div class=\"line\">                    tf-&gt;tf_regs.reg_esi);</div><div class=\"line\">            tf-&gt;tf_regs.reg_eax = ret_code;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">         <span class=\"keyword\">default</span>:</div><div class=\"line\">            <span class=\"comment\">// Unexpected trap: The user process or the kernel has a bug.</span></div><div class=\"line\">            print_trapframe(tf);</div><div class=\"line\">            <span class=\"keyword\">if</span> (tf-&gt;tf_cs == GD_KT)</div><div class=\"line\">                panic(<span class=\"string\">\"unhandled trap in kernel\"</span>);</div><div class=\"line\">            <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                env_destroy(curenv);</div><div class=\"line\">                <span class=\"keyword\">return</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>kern/syscall.c</code> 中的 <code>syscall</code>():<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int32_t</span></div><div class=\"line\">syscall(<span class=\"keyword\">uint32_t</span> syscallno, <span class=\"keyword\">uint32_t</span> a1, <span class=\"keyword\">uint32_t</span> a2, <span class=\"keyword\">uint32_t</span> a3, <span class=\"keyword\">uint32_t</span> a4, <span class=\"keyword\">uint32_t</span> a5)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">// Call the function corresponding to the 'syscallno' parameter.</span></div><div class=\"line\">    <span class=\"comment\">// Return any appropriate return value.</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// panic(\"syscall not implemented\");</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">switch</span> (syscallno) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> (SYS_cputs):</div><div class=\"line\">            sys_cputs((<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *)a1, a2);</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> (SYS_cgetc):</div><div class=\"line\">            <span class=\"keyword\">return</span> sys_cgetc();</div><div class=\"line\">        <span class=\"keyword\">case</span> (SYS_getenvid):</div><div class=\"line\">            <span class=\"keyword\">return</span> sys_getenvid();</div><div class=\"line\">        <span class=\"keyword\">case</span> (SYS_env_destroy):</div><div class=\"line\">            <span class=\"keyword\">return</span> sys_env_destroy(a1);</div><div class=\"line\">        <span class=\"keyword\">default</span>:</div><div class=\"line\">            <span class=\"keyword\">return</span> -E_INVAL;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>　</p>\n<h3 id=\"启动用户模式\"><a href=\"#启动用户模式\" class=\"headerlink\" title=\"启动用户模式\"></a>启动用户模式</h3><p>用户程序真正开始运行的地方是在<code>lib/entry.S</code>文件中.该文件中,首先会进行一些设置,然后就会调用<code>lib/libmain.c</code>文件中的<code>libmain()</code>函数.要求修改一<code>libmain()</code>函数,使它能够初始化全局指针<code>thisenv</code> ,让它指向当前用户环境的 <code>Env</code>结构体.<br>然后<code>libmain()</code>函数就会调用<code>umain()</code>.<code>umain()</code>函数恰好是<code>user/hello.c</code>中被调用的函数.在之前的实验中发现,<code>hello.c</code>程序只会打印 “hello, world”,然后就会报出<code>page fault</code>(缺页异常),原因是<code>thisenv-&gt;env_id</code>语句没有被成功初始化..现在已经正确初始化了<code>thisenv</code>的值,再次运行就应该不会报错了.</p>\n<h3 id=\"练习8\"><a href=\"#练习8\" class=\"headerlink\" title=\"练习8\"></a>练习8</h3><p>问：</p>\n<blockquote>\n<p>把上述的要求补全的代码补全,然后重新启动kernel,此时应该看到<code>user/hello</code>程序会打印 “hello, world”, 然后再打印出来 “i am environment 00001000”.然后<code>user/hello</code>通过调用<code>sys_env_destroy()（lib/libmain.c lib/exit.c）</code>尝试退出.由于kernel目前仅仅支持一个用户运行环境,所以它应该报告唯一的用户环境已被销毁的消息,然后退回kernel监控器.</p>\n</blockquote>\n<p>解：</p>\n<blockquote>\n<p>这个练习是通过程序获得当前正在运行的用户环境的<code>env_id</code>, 以及这个用户环境所对应的<code>Env</code>结构体的指针.<code>env_id</code>可以通过调用<code>sys_getenvid()</code>函数来获得.那么如何获得它对应的<code>Env</code>结构体指针呢？<br>　　通过阅读<code>lib/env.h</code>文件知道,<code>env_id</code>的值类型为<code>int32_t</code>,按位模式分为三部分</p>\n<ul>\n<li>第31位被固定为0</li>\n<li>第10~30这21位是标识符,标示这个用户环境</li>\n<li>第0~9位代表这个用户环境所采用的<code>Env</code>结构体,在<code>envs</code>数组中的索引.<br>所以只需知道<code>env_id</code>的低 0~9 位,就可以获得这个用户环境对应的<code>Env</code>结构体了.代码如下：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">libmain</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> **argv)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">// set thisenv to point at our Env structure in envs[].</span></div><div class=\"line\">    thisenv = &amp;envs[ENVX(sys_getenvid())];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// save the name of the program so that panic() can use it</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (argc &gt; <span class=\"number\">0</span>)</div><div class=\"line\">        binaryname = argv[<span class=\"number\">0</span>];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// call user main routine</span></div><div class=\"line\">    umain(argc, argv);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// exit gracefully</span></div><div class=\"line\">    <span class=\"built_in\">exit</span>();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"页错误和内存保护\"><a href=\"#页错误和内存保护\" class=\"headerlink\" title=\"页错误和内存保护\"></a>页错误和内存保护</h3><p>内存保护是操作系统的非常重要的一项功能,它可以防止由于用户程序崩溃对操作系统带来的破坏与影响.<br>操作系统通常依赖于硬件的支持来实现内存保护.操作系统可以让硬件能够始终知晓哪些虚拟地址是有效的,哪些是无效的.当程序尝试去访问一个无效地址,或者尝试去访问一个超出它访问权限的地址时,处理器会在这个指令处终止,并且触发异常,陷入内核态,与此同时把错误的信息报告给内核.如果这个异常是可以被修复的,那么内核会修复这个异常,然后程序继续运行.如果异常无法被修复,则程序永远不会继续运行.</p>\n<blockquote>\n<p>一个可修复异常的典型是可自动扩展的堆栈.在许多系统中,内核在初始情况下只会分配一个内核堆栈页,如果程序想要访问这个内核堆栈页之外的堆栈空间的话,就会触发异常,此时内核会自动再分配一些页给这个程序,程序就可以继续运行了.</p>\n</blockquote>\n<p>系统调用也为内存保护带来了问题.大部分系统调用接口让用户程序传递一个指针参数给内核.这些指针指向的是用户缓冲区.通过这种方式,系统调用在执行时就可以解引用这些指针.但是这里有两个问题：</p>\n<ol>\n<li>在内核中的页错误（page fault)要比在用户程序中的页错误更严重.如果内核在操作自己的数据结构时出现页错误,这是一个内核的bug,而且异常处理程序会中断整个内核.但是当内核在解引用由用户程序传递来的指针时,它需要一种方法去记录此时出现的页错误都是由用户程序带来的.</li>\n<li>内核通常比用户程序有着更高的内存访问权限.用户程序很有可能要传递一个指针给系统调用,这个指针指向的内存区域是内核可以进行读写的,但是用户程序不能.此时内核必须小心不要去解析这个指针,否则的话内核的重要信息很有可能被泄露.</li>\n</ol>\n<p>现在需要通过仔细检查所有由用户传递来指针所指向的空间来解决上述两个问题.当一个程序传递给内核一个指针时,内核会检查这个地址是否在整个地址空间的用户地址空间部分,如果是将允许页表进行内存操作.</p>\n<h4 id=\"练习9\"><a href=\"#练习9\" class=\"headerlink\" title=\"练习9\"></a>练习9</h4><p>问：</p>\n<blockquote>\n<p>修改<code>kern/trap.c</code>文件,使其能够实现当在内核模式下发现页错误,<code>trap.c</code>将转到<code>panic</code>.阅读<code>user_mem_assert</code>（在<code>kern/pmap.c</code>）,并且实现<code>user_mem_check</code>；修改<code>kern/syscall.c</code>，检查输入参数.<br>启动内核后,运行<code>user/buggyhello</code>程序,用户环境可以被销毁,内核不可以<code>panic</code>,输出应该是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[00001000] user_mem_check assertion failure for va 00000001</div><div class=\"line\">[00001000] free env 00001000</div><div class=\"line\">Destroyed the only environment - nothing more to do!</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>解：</p>\n<blockquote>\n<p>首先确定应该根据什么来判断当前运行的程序时处在内核态下还是用户态下？根据<code>CS</code>段寄存器的低2位,这两位的名称叫做<code>CPL</code>位,表示当前运行的代码的访问权限级别,0代表是内核态,3代表是用户态.<br>题目要求在检测到页错误是出现在内核态时,通过<code>panic</code>跳出来,所以我们把<code>page_fault_handler</code>文件修改如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">page_fault_handler</span><span class=\"params\">(<span class=\"keyword\">struct</span> Trapframe *tf)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">uint32_t</span> fault_va;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Read processor's CR2 register to find the faulting address</span></div><div class=\"line\">    fault_va = rcr2();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Handle kernel-mode 页错误s.</span></div><div class=\"line\">    <span class=\"keyword\">if</span>(tf-&gt;tf_cs &amp;&amp; <span class=\"number\">0x01</span> == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        panic(<span class=\"string\">\"page_fault in kernel mode, fault address %d\\n\"</span>, fault_va);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// We've already handled kernel-mode exceptions, so if we get here,</span></div><div class=\"line\">    <span class=\"comment\">// the page fault happened in user mode.</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Destroy the environment that caused the fault.</span></div><div class=\"line\">    cprintf(<span class=\"string\">\"[%08x] user fault va %08x ip %08x\\n\"</span>,</div><div class=\"line\">        curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);</div><div class=\"line\">    print_trapframe(tf);</div><div class=\"line\">    env_destroy(curenv);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>然后根据题目的要求,继续完善<code>kern/pmap.c</code>文件中的<code>user_mem_assert()</code>, <code>user_mem_check</code> 函数,通过观察 <code>user_mem_assert()</code>函数发现,它调用了 <code>user_mem_check()</code>函数.而 <code>user_mem_check</code>函数的功能是检查一下当前用户态程序是否有对虚拟地址空间<code>[va, va+len]</code>的<code>perm| PTE_P</code>访问权限.<br>然后要做的事情是,先找到这个虚拟地址范围对应于当前用户态程序的页表中的页表项,然后再去看一下这个页表项中有关访问权限的字段,是否包含<code>perm|PTE_P</code>,只要有一个页表项是不包含的,就代表程序对这个范围的虚拟地址没有<code>perm|PTE_P</code>的访问权限.代码实现如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span></span></div><div class=\"line\"><span class=\"title\">user_mem_check</span><span class=\"params\">(<span class=\"keyword\">struct</span> Env *env, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *va, <span class=\"keyword\">size_t</span> len, <span class=\"keyword\">int</span> perm)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">char</span> * end = <span class=\"literal\">NULL</span>;</div><div class=\"line\">    <span class=\"keyword\">char</span> * start = <span class=\"literal\">NULL</span>;</div><div class=\"line\">    start = ROUNDDOWN((<span class=\"keyword\">char</span> *)va, PGSIZE);</div><div class=\"line\">    end = ROUNDUP((<span class=\"keyword\">char</span> *)(va + len), PGSIZE);</div><div class=\"line\">    <span class=\"keyword\">pte_t</span> * cur = <span class=\"literal\">NULL</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span>(; start &lt; end; start += PGSIZE) &#123;</div><div class=\"line\">        cur = pgdir_walk(env-&gt;env_pgdir, (<span class=\"keyword\">void</span> *)start, <span class=\"number\">0</span>);</div><div class=\"line\">        <span class=\"keyword\">if</span>((<span class=\"keyword\">int</span>)start &gt; ULIM || cur == <span class=\"literal\">NULL</span> || ((<span class=\"keyword\">uint32_t</span>)(*cur) &amp; perm) != perm) &#123;</div><div class=\"line\">              <span class=\"keyword\">if</span>(start == ROUNDDOWN((<span class=\"keyword\">char</span> *)va, PGSIZE)) &#123;</div><div class=\"line\">                    user_mem_check_addr = (<span class=\"keyword\">uintptr_t</span>)va;</div><div class=\"line\">              &#125;</div><div class=\"line\">              <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                      user_mem_check_addr = (<span class=\"keyword\">uintptr_t</span>)start;</div><div class=\"line\">              &#125;</div><div class=\"line\">              <span class=\"keyword\">return</span> -E_FAULT;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>最后按照题目要求，补全<code>kern/syscall.c</code>文件中的一部分内容,即<code>sys_cputs</code> 函数,这个函数要求检查用户程序对虚拟地指空间<code>[s, s+len]</code>是否有访问权限,所以可以使用刚刚写好的函数<code>user_mem_assert</code>来实现.<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">sys_cputs</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *s, <span class=\"keyword\">size_t</span> len)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">// Check that the user has permission to read memory [s, s+len).</span></div><div class=\"line\">    <span class=\"comment\">// Destroy the environment if not:.</span></div><div class=\"line\"></div><div class=\"line\">    user_mem_assert(curenv, s, len, <span class=\"number\">0</span>);</div><div class=\"line\">    <span class=\"comment\">// Print the string supplied by the user.</span></div><div class=\"line\">    cprintf(<span class=\"string\">\"%.*s\"</span>, len, s);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>最后在<code>kern/kdebug</code>中修改<code>debuginfo_eip</code>函数,对用户空间的数据使用<code>user_mem_check</code>函数检查当前用户空间是否对其有<code>PTE_U</code>权限.<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">struct</span> UserStabData *usd = (<span class=\"keyword\">const</span> <span class=\"keyword\">struct</span> UserStabData *) USTABDATA;</div><div class=\"line\">    <span class=\"comment\">// Make sure this memory is valid.</span></div><div class=\"line\">    <span class=\"comment\">// Return -1 if it is not.  Hint: Call user_mem_check.</span></div><div class=\"line\">    <span class=\"comment\">// LAB 3: Your code here.</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (user_mem_check(curenv, usd, <span class=\"keyword\">sizeof</span>(*usd),PTE_U) &lt;<span class=\"number\">0</span> )</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">    stabs = usd-&gt;stabs;</div><div class=\"line\">    stab_end = usd-&gt;stab_end;</div><div class=\"line\">    stabstr = usd-&gt;stabstr;</div><div class=\"line\">    stabstr_end = usd-&gt;stabstr_end;</div><div class=\"line\">    <span class=\"comment\">// Make sure the STABS and string table memory is valid.</span></div><div class=\"line\">    <span class=\"comment\">// LAB 3: Your code here.a</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (user_mem_check(curenv, stabs, stab_end-stabs,PTE_U) &lt;<span class=\"number\">0</span> || `user_mem_check`(curenv, stabstr, stabstr_end-stabstr,PTE_U) &lt;<span class=\"number\">0</span>)</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://pdos.csail.mit.edu/6.828/2016/labs/lab3/\" target=\"_blank\" rel=\"external\">lab3:user environment</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Lab3-用户环境-Part2\"><a href=\"#Lab3-用户环境-Part2\" class=\"headerlink\" title=\"Lab3 用户环境 Part2\"></a>Lab3 用户环境 Part2</h1><h2 id=\"Part2-缺页中断-断点异常和系统调用\"><a href=\"#Part2-缺页中断-断点异常和系统调用\" class=\"headerlink\" title=\"Part2 缺页中断, 断点异常和系统调用\"></a>Part2 缺页中断, 断点异常和系统调用</h2><p>part1完成后,JOSkernel已经具备一定的异常处理能力了,part2将进一步完善它,使它能够处理不同类型的中断/异常.</p>\n<h3 id=\"处理缺页中断\"><a href=\"#处理缺页中断\" class=\"headerlink\" title=\"处理缺页中断\"></a>处理缺页中断</h3><p>　　缺页中断（中断向量14（<code>T_PGFLT</code>））是一个非常重要的中断,因为后续的实验中,非常依赖kernel能够处理缺页中断的能力.当缺页中断发生时,系统会把引起中断的线性地址存放到控制寄存器<code>CR2</code>中.在<code>trap.c</code>中,已经提供了一个能够处理这种缺页异常的函数<code>page_fault_handler()</code>.</p>","more":"<h4 id=\"练习5\"><a href=\"#练习5\" class=\"headerlink\" title=\"练习5\"></a>练习5</h4><p>问</p>\n<blockquote>\n<p>修改<code>trap_dispatch</code>函数,使系统能够把缺页异常引导到 <code>page_fault_handler()</code>上执行.在修改完成后,JOS可以成功运行测试程序<code>faultread,faultreadkernel,faultwrite,faultwritekernel</code></p>\n</blockquote>\n<p>解:</p>\n<blockquote>\n<p>根据 <code>trapentry.S</code>文件中的<code>TRAPHANDLER</code>函数可知,这个函数会把当前中断的中断向量压入堆栈中,再根据<code>inc/trap.h</code>文件中的<code>Trapframe</code>结构体可以知道,<code>Trapframe</code>中的<code>tf_trapno</code>成员代表这个中断的中断向量.所以在 <code>trap_dispatch</code>函数中需要根据输入的<code>Trapframe</code>指针<code>tf</code>中的 <code>tf_trapno</code>成员来判断捕捉是什么中断.如果是是缺页中断,则执行 <code>page_fault_handler</code>函数,修改代码如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">trap_dispatch</span><span class=\"params\">(<span class=\"keyword\">struct</span> Trapframe *tf)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">int32_t</span> ret_code;</div><div class=\"line\">    <span class=\"comment\">// Handle processor exceptions.</span></div><div class=\"line\">    <span class=\"keyword\">switch</span>(tf-&gt;tf_trapno) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> (T_PGFLT):</div><div class=\"line\">            page_fault_handler(tf);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">         <span class=\"keyword\">default</span>:</div><div class=\"line\">            <span class=\"comment\">// Unexpected trap: The user process or the kernel has a bug.</span></div><div class=\"line\">            print_trapframe(tf);</div><div class=\"line\">            <span class=\"keyword\">if</span> (tf-&gt;tf_cs == GD_KT)</div><div class=\"line\">                panic(<span class=\"string\">\"unhandled trap in kernel\"</span>);</div><div class=\"line\">            <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                env_destroy(curenv);</div><div class=\"line\">                <span class=\"keyword\">return</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"断点异常\"><a href=\"#断点异常\" class=\"headerlink\" title=\"断点异常\"></a>断点异常</h3><p>断点异常,中断向量3（<code>T_BRKPT</code>）.这个异常可以让调试器能够给程序加上断点.加断点的基本原理就是把要加断点的语句用一个<code>INT3</code>指令替换:执行到<code>INT3</code>时,会触发软中断.在JOS中通过把这个异常转换成一个伪系统调用,这样的话任何用户环境都可以使用这个伪系统调用来触发JOSkernel监视器<code>kernel monitor</code>.</p>\n<h3 id=\"练习6\"><a href=\"#练习6\" class=\"headerlink\" title=\"练习6\"></a>练习6</h3><p>问</p>\n<blockquote>\n<p>修改<code>trap_dispatch()</code>使断点异常发生时,能够触发kernel监视器.要求修改后的 JOS 能够正确运行<code>breakpoint</code>测试程序.</p>\n</blockquote>\n<p>解</p>\n<blockquote>\n<p>这个练习其实和上一个练习是类似的,只不过是在这里需要处理断点异常 (<code>T_BRKPT</code>),kernel monitor 就是定义在<code>kern/monitor.c</code>文件中的<code>monitor</code> 函数,修改程序如下<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">trap_dispatch</span><span class=\"params\">(<span class=\"keyword\">struct</span> Trapframe *tf)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">int32_t</span> ret_code;</div><div class=\"line\">    <span class=\"comment\">// Handle processor exceptions.</span></div><div class=\"line\">    <span class=\"keyword\">switch</span>(tf-&gt;tf_trapno) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> (T_PGFLT):</div><div class=\"line\">            page_fault_handler(tf);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> (T_BRKPT):</div><div class=\"line\">            monitor(tf);        </div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">         <span class=\"keyword\">default</span>:</div><div class=\"line\">            <span class=\"comment\">// Unexpected trap: The user process or the kernel has a bug.</span></div><div class=\"line\">            print_trapframe(tf);</div><div class=\"line\">            <span class=\"keyword\">if</span> (tf-&gt;tf_cs == GD_KT)</div><div class=\"line\">                panic(<span class=\"string\">\"unhandled trap in kernel\"</span>);</div><div class=\"line\">            <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                env_destroy(curenv);</div><div class=\"line\">                <span class=\"keyword\">return</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h4 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h4><blockquote>\n<ol>\n<li>在上面的断点异常(<code>break point exception</code>)测试程序中,如果在设置<code>IDT</code>时,对断点异常采用不同的方式进行设置,可能会产生触发不同的异常,有可能是断点异常,有可能是一般保护异常(<code>general protection exception</code>).这是为什么？应该怎么做才能得到一个想要的断点异常,而不是一般保护异常？<br>解:<br>　　通过实验发现出现这个现象的问题就是在设置<code>IDT</code>表中的断点异常的表项时,如果把表项中的<code>DPL</code>字段设置为3,则会触发断点异常,如果设置为0,则会触发一般保护异常.<code>DPL</code>字段代表的含义是段描述符优先级（<code>Descriptor Privileged Level</code>）,如果想要当前执行的程序能够跳转到这个描述符所指向的程序继续执行的话,要求当前运行程序的<code>CPL,RPL</code>的最大值需要小于等于<code>DPL</code>,否则就会出现优先级低的代码试图去访问优先级高的代码的情况,就会触发一般保护异常.那么的测试程序首先运行于用户态,它的<code>CPL</code>为3,当异常发生时,它希望去执行<code>int 3</code>指令,这是一个系统级别的指令,用户态命令的<code>CPL</code>一定大于<code>int 3</code>的<code>DPL</code>,所以就会触发一般保护异常,但是如果把<code>IDT</code>这个表项的<code>DPL</code>字段设置为3时,就不会出现这样的现象了,这时如果再出现异常,肯定是因为还没有编写处理断点异常的程序所引起的,所以是断点异常.</li>\n</ol>\n</blockquote>\n<h3 id=\"系统调用\"><a href=\"#系统调用\" class=\"headerlink\" title=\"系统调用\"></a>系统调用</h3><p>用户程序会要求kernel帮助它完成系统调用.当用户程序触发系统调用,系统进入kernel态.CPU和操作系统将保存该用户程序当前的上下文状态,然后由kernel执行正确的代码完成系统调用,然后回到用户程序继续执行.而用户程序到底是如何得到操作系统的服务,以及它如何说明它希望操作系统如何服务的方法,有很多不同的实现方式.<br>在JOS中,采用<code>int</code>指令,这个指令会触发一个CPU的中断.特别的,用<code>int $0x30</code>来代表系统调用中断.注意,<code>int 0x30</code>不是通过硬件产生的.<br>应用程序会把系统调用号以及系统调用的参数放到寄存器中.通过这种方法,kernel就不需要去查询用户程序的堆栈了.系统调用号存放到<code>%eax</code>中,参数则存放在<code>%edx, %ecx, %ebx, %edi, 和 %esi</code>中.kernel会把返回值送到<code>%eax</code>中.在<code>lib/syscall.c</code>中已经写好触发一个系统调用的代码.　　</p>\n<h4 id=\"练习7\"><a href=\"#练习7\" class=\"headerlink\" title=\"练习7\"></a>练习7</h4><p>问:</p>\n<blockquote>\n<p>给中断向量<code>T_SYSCALL</code>编写一个中断处理函数.需要编辑<code>kern/trapentry.S</code>和<code>kern/trap.c</code>中的<code>trap_init()</code>函数,也需要修改<code>trap_dispatch()</code>函数,使其能够通过调用<code>syscall()</code>（在<code>kern/syscall.c</code>中定义的）函数处理系统调用中断.最后需要实现<code>kern/syscall.c</code>中的<code>syscall()</code>函数, 确保这个函数会在系统调用号为非法值时返回<code>-E_INVAL</code>.要求充分理解<code>lib/syscall.c</code>文件,处理在<code>inc/syscall.h</code>文件中定义的所有系统调用.<br>　　通过<code>make run-hello</code>指令来运行<code>user/hello</code>程序,它应该在控制台上输出 “hello, world”,然后引发一个缺页中断.</p>\n</blockquote>\n<p>解:</p>\n<blockquote>\n<p>需要了解一下系统调用的整个流程:如果现在运行的是kernel态的程序的话,此时调用了一个系统调用,比如<code>sys_cputs</code>函数时,此时不会触发中断,那么系统会直接执行定义在<code>lib/syscall.c</code>文件中的<code>sys_cputs</code>这个文件中定义了几个比较常用的系统调用,包括<code>sys_cputs</code>, <code>sys_cgetc</code>等等.还会发现他们都是统一调用一个 <code>syscall()</code>函数,通过这个函数的代码发现其实它是执行了一个汇编指令.所以最终是这个函数完成了系统调用.<br>以上是运行在kernel态下的程序,调用系统调用时的流程.但是如果是用户态程序呢？这个练习就是让编写程序使的用户程序在调用系统调用时,最终也能经过一系列的处理最终去执行<code>lib/syscall.c</code>中的<code>syscall</code>指令.<br>让看一下这个过程,当用户程序中要调用系统调用时,依然比如<code>sys_cputs</code>,从它的汇编代码中会发现,它会执行一个<code>int $0x30</code>指令,这个指令就是软件中断指令,这个中断的中断号就是<code>0x3</code>,即<code>T_SYSCALL</code>,所以题目要求首先为这个中断号编写一个中断处理函数,首先就要在<code>kern/trapentry.S</code>文件中为它声明它的中断处理函数,即<code>TRAPHANDLER_NOEC</code>,与其他中断号的声明一样.<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//kern/trapentry.S</span></div><div class=\"line\">....</div><div class=\"line\">TRAPHANDLER_NOEC(t_fperr, T_FPERR)</div><div class=\"line\">TRAPHANDLER(t_align, T_ALIGN)</div><div class=\"line\">TRAPHANDLER_NOEC(t_mchk, T_MCHK)</div><div class=\"line\">TRAPHANDLER_NOEC(t_simderr, T_SIMDERR)</div><div class=\"line\">....</div><div class=\"line\">TRAPHANDLER_NOEC(t_syscall, T_SYSCALL)</div><div class=\"line\">....</div></pre></td></tr></table></figure></p>\n<p>然后在<code>trap.c</code>文件中声明<code>t_syscall()``函数.并且在</code>trap_init()`函数中为它注册<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//kern/trap.c</span></div><div class=\"line\">....</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">t_fperr</span><span class=\"params\">()</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">t_align</span><span class=\"params\">()</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">t_mchk</span><span class=\"params\">()</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">t_simderr</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">t_syscall</span><span class=\"params\">()</span></span>;</div><div class=\"line\">.....</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">trap_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">extern</span> <span class=\"keyword\">struct</span> Segdesc gdt[];</div><div class=\"line\"></div><div class=\"line\">        .....</div><div class=\"line\">    SETGATE(idt[T_ALIGN], <span class=\"number\">0</span>, GD_KT, t_align, <span class=\"number\">0</span>);</div><div class=\"line\">    SETGATE(idt[T_MCHK], <span class=\"number\">0</span>, GD_KT, t_mchk, <span class=\"number\">0</span>);</div><div class=\"line\">    SETGATE(idt[T_SIMDERR], <span class=\"number\">0</span>, GD_KT, t_simderr, <span class=\"number\">0</span>);</div><div class=\"line\"></div><div class=\"line\">    SETGATE(idt[T_SYSCALL], <span class=\"number\">0</span>, GD_KT, t_syscall, <span class=\"number\">3</span>);</div><div class=\"line\">    <span class=\"comment\">// Per-CPU setup</span></div><div class=\"line\">    trap_init_percpu();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>此时当系统调用中断发生时,系统就可以捕捉到这个中断了,中断发生时,系统会调用 <code>_alltraps</code>代码块,并且运行到<code>trap()</code>函数处,进入<code>trap()</code>函数后,经过一系列处理进入<code>trap_dispatch()</code>函数.题目中要求此时需要去调用<code>kern/syscall.c</code>中的<code>syscall</code>函数,注意到这个函数不是<code>lib/syscall.c1</code>中的<code>syscall</code>函数,但是通过阅读<code>kern/syscall.c</code>中的<code>syscall</code>程序发现,它的输入和 <code>lib/syscall.c</code>中的<code>syscall</code>很像,对比如下</p>\n<p><code>kern/syscall.c</code>中的<code>syscall</code>：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">syscall(<span class=\"keyword\">uint32_t</span> syscallno, <span class=\"keyword\">uint32_t</span> a1, <span class=\"keyword\">uint32_t</span> a2, <span class=\"keyword\">uint32_t</span> a3, <span class=\"keyword\">uint32_t</span> a4, <span class=\"keyword\">uint32_t</span> a5)</div></pre></td></tr></table></figure></p>\n<p> <code>lib/syscall.c</code>中的<code>syscall</code>：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">syscall(<span class=\"keyword\">int</span> num, <span class=\"keyword\">int</span> check, <span class=\"keyword\">uint32_t</span> a1, <span class=\"keyword\">uint32_t</span> a2, <span class=\"keyword\">uint32_t</span> a3, <span class=\"keyword\">uint32_t</span> a4, <span class=\"keyword\">uint32_t</span> a5)</div></pre></td></tr></table></figure></p>\n<p>可以假设,<code>kern/syscall.c</code>中的<code>syscall</code>就是一个外壳函数,它的存在就是为了能够调用<code>lib/syscall</code>.所以按照这个思路继续进行下去,再继续观察 <code>kern/syscall.c</code>中的其他函数,会发现<code>kern/syscall.c</code>中的所有函数和 <code>lib/syscall.c</code>中的所有函数都是一样的.比如 在这两个文件中都有<code>sys_cputs</code> 函数,但仔细观察可以发现这两个同名的函数,发现实现方式却不一样.以<code>sys_cputs</code>函数为例：<br><code>kern/syscall.c</code>中的<code>sys_cputs</code>：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">sys_cputs</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *s, <span class=\"keyword\">size_t</span> len)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">// Check that the user has permission to read memory [s, s+len).</span></div><div class=\"line\">    <span class=\"comment\">// Destroy the environment if not:.</span></div><div class=\"line\"></div><div class=\"line\">    user_mem_assert(curenv, s, len, <span class=\"number\">0</span>);</div><div class=\"line\">    <span class=\"comment\">// Print the string supplied by the user.</span></div><div class=\"line\">    cprintf(<span class=\"string\">\"%.*s\"</span>, len, s);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>lib/syscall.c</code>中的<code>sys_cputs</code>:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">sys_cputs</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *s, <span class=\"keyword\">size_t</span> len)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    syscall(SYS_cputs, <span class=\"number\">0</span>, (<span class=\"keyword\">uint32_t</span>)s, len, <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>可见在<code>lib/syscall.c</code>中,直接调用<code>syscall</code>,但是注意观察 <code>kern/syscall.c</code>中的<code>sys_cputs</code>,它调用了<code>cprintf</code>,这个调用其实就是为了完成输出的功能.但要注意,当程序运行到这里时,系统已经工作在kernel态了,而<code>cprintf</code>函数其实就是通过调用<code>lib/syscall.c</code>中的<code>sys_cputs</code>来实现的,由于此时系统已经处于kernel态了,所以这个<code>sys_cputs</code>可以被执行了.所以 <code>kern/syscall.c</code>中的<code>sys_cputs</code>函数通过调用<code>cprintf</code>实现了调用 <code>lib/syscall.c</code>中的<code>syscall</code>.<br>所以剩下的部分是如何在<code>kern/syscall.c</code>中的<code>syscall()</code>函数中正确的调用<code>sys_cputs</code>函数了,当然 <code>kern/syscall.c</code> 中其他的函数也能完成这个功能.所以必须根据触发这个系统调用的指令到底想调用哪个系统调用来确定该调用哪个函数.</p>\n<p>如何确定这个指令是要调用哪个系统调用呢？答案是根据<code>syscall</code>函数中的第一个参数<code>syscallno</code>.这个值要手动传递进去的,它存储在哪里？通过阅读 <code>lib/syscall.c</code> 中的<code>syscall</code>函数,可以知道它存放在<code>%eax</code>寄存器中,所以最后完成<code>trap_dispatch</code>和<code>kern/syscall.c</code>中的<code>syscall</code>函数的代码.<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">trap_dispatch</span><span class=\"params\">(<span class=\"keyword\">struct</span> Trapframe *tf)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">int32_t</span> ret_code;</div><div class=\"line\">    <span class=\"comment\">// Handle processor exceptions.</span></div><div class=\"line\">    <span class=\"keyword\">switch</span>(tf-&gt;tf_trapno) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> (T_PGFLT):</div><div class=\"line\">            page_fault_handler(tf);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> (T_BRKPT):</div><div class=\"line\">            monitor(tf);        </div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> (T_SYSCALL):</div><div class=\"line\">    <span class=\"comment\">//        print_trapframe(tf);</span></div><div class=\"line\">            ret_code = syscall(</div><div class=\"line\">                    tf-&gt;tf_regs.reg_eax,</div><div class=\"line\">                    tf-&gt;tf_regs.reg_edx,</div><div class=\"line\">                    tf-&gt;tf_regs.reg_ecx,</div><div class=\"line\">                    tf-&gt;tf_regs.reg_ebx,</div><div class=\"line\">                    tf-&gt;tf_regs.reg_edi,</div><div class=\"line\">                    tf-&gt;tf_regs.reg_esi);</div><div class=\"line\">            tf-&gt;tf_regs.reg_eax = ret_code;</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">         <span class=\"keyword\">default</span>:</div><div class=\"line\">            <span class=\"comment\">// Unexpected trap: The user process or the kernel has a bug.</span></div><div class=\"line\">            print_trapframe(tf);</div><div class=\"line\">            <span class=\"keyword\">if</span> (tf-&gt;tf_cs == GD_KT)</div><div class=\"line\">                panic(<span class=\"string\">\"unhandled trap in kernel\"</span>);</div><div class=\"line\">            <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                env_destroy(curenv);</div><div class=\"line\">                <span class=\"keyword\">return</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>kern/syscall.c</code> 中的 <code>syscall</code>():<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int32_t</span></div><div class=\"line\">syscall(<span class=\"keyword\">uint32_t</span> syscallno, <span class=\"keyword\">uint32_t</span> a1, <span class=\"keyword\">uint32_t</span> a2, <span class=\"keyword\">uint32_t</span> a3, <span class=\"keyword\">uint32_t</span> a4, <span class=\"keyword\">uint32_t</span> a5)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">// Call the function corresponding to the 'syscallno' parameter.</span></div><div class=\"line\">    <span class=\"comment\">// Return any appropriate return value.</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// panic(\"syscall not implemented\");</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">switch</span> (syscallno) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> (SYS_cputs):</div><div class=\"line\">            sys_cputs((<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *)a1, a2);</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> (SYS_cgetc):</div><div class=\"line\">            <span class=\"keyword\">return</span> sys_cgetc();</div><div class=\"line\">        <span class=\"keyword\">case</span> (SYS_getenvid):</div><div class=\"line\">            <span class=\"keyword\">return</span> sys_getenvid();</div><div class=\"line\">        <span class=\"keyword\">case</span> (SYS_env_destroy):</div><div class=\"line\">            <span class=\"keyword\">return</span> sys_env_destroy(a1);</div><div class=\"line\">        <span class=\"keyword\">default</span>:</div><div class=\"line\">            <span class=\"keyword\">return</span> -E_INVAL;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>　</p>\n<h3 id=\"启动用户模式\"><a href=\"#启动用户模式\" class=\"headerlink\" title=\"启动用户模式\"></a>启动用户模式</h3><p>用户程序真正开始运行的地方是在<code>lib/entry.S</code>文件中.该文件中,首先会进行一些设置,然后就会调用<code>lib/libmain.c</code>文件中的<code>libmain()</code>函数.要求修改一<code>libmain()</code>函数,使它能够初始化全局指针<code>thisenv</code> ,让它指向当前用户环境的 <code>Env</code>结构体.<br>然后<code>libmain()</code>函数就会调用<code>umain()</code>.<code>umain()</code>函数恰好是<code>user/hello.c</code>中被调用的函数.在之前的实验中发现,<code>hello.c</code>程序只会打印 “hello, world”,然后就会报出<code>page fault</code>(缺页异常),原因是<code>thisenv-&gt;env_id</code>语句没有被成功初始化..现在已经正确初始化了<code>thisenv</code>的值,再次运行就应该不会报错了.</p>\n<h3 id=\"练习8\"><a href=\"#练习8\" class=\"headerlink\" title=\"练习8\"></a>练习8</h3><p>问：</p>\n<blockquote>\n<p>把上述的要求补全的代码补全,然后重新启动kernel,此时应该看到<code>user/hello</code>程序会打印 “hello, world”, 然后再打印出来 “i am environment 00001000”.然后<code>user/hello</code>通过调用<code>sys_env_destroy()（lib/libmain.c lib/exit.c）</code>尝试退出.由于kernel目前仅仅支持一个用户运行环境,所以它应该报告唯一的用户环境已被销毁的消息,然后退回kernel监控器.</p>\n</blockquote>\n<p>解：</p>\n<blockquote>\n<p>这个练习是通过程序获得当前正在运行的用户环境的<code>env_id</code>, 以及这个用户环境所对应的<code>Env</code>结构体的指针.<code>env_id</code>可以通过调用<code>sys_getenvid()</code>函数来获得.那么如何获得它对应的<code>Env</code>结构体指针呢？<br>　　通过阅读<code>lib/env.h</code>文件知道,<code>env_id</code>的值类型为<code>int32_t</code>,按位模式分为三部分</p>\n<ul>\n<li>第31位被固定为0</li>\n<li>第10~30这21位是标识符,标示这个用户环境</li>\n<li>第0~9位代表这个用户环境所采用的<code>Env</code>结构体,在<code>envs</code>数组中的索引.<br>所以只需知道<code>env_id</code>的低 0~9 位,就可以获得这个用户环境对应的<code>Env</code>结构体了.代码如下：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">libmain</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> **argv)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">// set thisenv to point at our Env structure in envs[].</span></div><div class=\"line\">    thisenv = &amp;envs[ENVX(sys_getenvid())];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// save the name of the program so that panic() can use it</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (argc &gt; <span class=\"number\">0</span>)</div><div class=\"line\">        binaryname = argv[<span class=\"number\">0</span>];</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// call user main routine</span></div><div class=\"line\">    umain(argc, argv);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// exit gracefully</span></div><div class=\"line\">    <span class=\"built_in\">exit</span>();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<h3 id=\"页错误和内存保护\"><a href=\"#页错误和内存保护\" class=\"headerlink\" title=\"页错误和内存保护\"></a>页错误和内存保护</h3><p>内存保护是操作系统的非常重要的一项功能,它可以防止由于用户程序崩溃对操作系统带来的破坏与影响.<br>操作系统通常依赖于硬件的支持来实现内存保护.操作系统可以让硬件能够始终知晓哪些虚拟地址是有效的,哪些是无效的.当程序尝试去访问一个无效地址,或者尝试去访问一个超出它访问权限的地址时,处理器会在这个指令处终止,并且触发异常,陷入内核态,与此同时把错误的信息报告给内核.如果这个异常是可以被修复的,那么内核会修复这个异常,然后程序继续运行.如果异常无法被修复,则程序永远不会继续运行.</p>\n<blockquote>\n<p>一个可修复异常的典型是可自动扩展的堆栈.在许多系统中,内核在初始情况下只会分配一个内核堆栈页,如果程序想要访问这个内核堆栈页之外的堆栈空间的话,就会触发异常,此时内核会自动再分配一些页给这个程序,程序就可以继续运行了.</p>\n</blockquote>\n<p>系统调用也为内存保护带来了问题.大部分系统调用接口让用户程序传递一个指针参数给内核.这些指针指向的是用户缓冲区.通过这种方式,系统调用在执行时就可以解引用这些指针.但是这里有两个问题：</p>\n<ol>\n<li>在内核中的页错误（page fault)要比在用户程序中的页错误更严重.如果内核在操作自己的数据结构时出现页错误,这是一个内核的bug,而且异常处理程序会中断整个内核.但是当内核在解引用由用户程序传递来的指针时,它需要一种方法去记录此时出现的页错误都是由用户程序带来的.</li>\n<li>内核通常比用户程序有着更高的内存访问权限.用户程序很有可能要传递一个指针给系统调用,这个指针指向的内存区域是内核可以进行读写的,但是用户程序不能.此时内核必须小心不要去解析这个指针,否则的话内核的重要信息很有可能被泄露.</li>\n</ol>\n<p>现在需要通过仔细检查所有由用户传递来指针所指向的空间来解决上述两个问题.当一个程序传递给内核一个指针时,内核会检查这个地址是否在整个地址空间的用户地址空间部分,如果是将允许页表进行内存操作.</p>\n<h4 id=\"练习9\"><a href=\"#练习9\" class=\"headerlink\" title=\"练习9\"></a>练习9</h4><p>问：</p>\n<blockquote>\n<p>修改<code>kern/trap.c</code>文件,使其能够实现当在内核模式下发现页错误,<code>trap.c</code>将转到<code>panic</code>.阅读<code>user_mem_assert</code>（在<code>kern/pmap.c</code>）,并且实现<code>user_mem_check</code>；修改<code>kern/syscall.c</code>，检查输入参数.<br>启动内核后,运行<code>user/buggyhello</code>程序,用户环境可以被销毁,内核不可以<code>panic</code>,输出应该是：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[00001000] user_mem_check assertion failure for va 00000001</div><div class=\"line\">[00001000] free env 00001000</div><div class=\"line\">Destroyed the only environment - nothing more to do!</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>解：</p>\n<blockquote>\n<p>首先确定应该根据什么来判断当前运行的程序时处在内核态下还是用户态下？根据<code>CS</code>段寄存器的低2位,这两位的名称叫做<code>CPL</code>位,表示当前运行的代码的访问权限级别,0代表是内核态,3代表是用户态.<br>题目要求在检测到页错误是出现在内核态时,通过<code>panic</code>跳出来,所以我们把<code>page_fault_handler</code>文件修改如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">page_fault_handler</span><span class=\"params\">(<span class=\"keyword\">struct</span> Trapframe *tf)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">uint32_t</span> fault_va;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Read processor's CR2 register to find the faulting address</span></div><div class=\"line\">    fault_va = rcr2();</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Handle kernel-mode 页错误s.</span></div><div class=\"line\">    <span class=\"keyword\">if</span>(tf-&gt;tf_cs &amp;&amp; <span class=\"number\">0x01</span> == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        panic(<span class=\"string\">\"page_fault in kernel mode, fault address %d\\n\"</span>, fault_va);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// We've already handled kernel-mode exceptions, so if we get here,</span></div><div class=\"line\">    <span class=\"comment\">// the page fault happened in user mode.</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Destroy the environment that caused the fault.</span></div><div class=\"line\">    cprintf(<span class=\"string\">\"[%08x] user fault va %08x ip %08x\\n\"</span>,</div><div class=\"line\">        curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);</div><div class=\"line\">    print_trapframe(tf);</div><div class=\"line\">    env_destroy(curenv);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>然后根据题目的要求,继续完善<code>kern/pmap.c</code>文件中的<code>user_mem_assert()</code>, <code>user_mem_check</code> 函数,通过观察 <code>user_mem_assert()</code>函数发现,它调用了 <code>user_mem_check()</code>函数.而 <code>user_mem_check</code>函数的功能是检查一下当前用户态程序是否有对虚拟地址空间<code>[va, va+len]</code>的<code>perm| PTE_P</code>访问权限.<br>然后要做的事情是,先找到这个虚拟地址范围对应于当前用户态程序的页表中的页表项,然后再去看一下这个页表项中有关访问权限的字段,是否包含<code>perm|PTE_P</code>,只要有一个页表项是不包含的,就代表程序对这个范围的虚拟地址没有<code>perm|PTE_P</code>的访问权限.代码实现如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span></span></div><div class=\"line\"><span class=\"title\">user_mem_check</span><span class=\"params\">(<span class=\"keyword\">struct</span> Env *env, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span> *va, <span class=\"keyword\">size_t</span> len, <span class=\"keyword\">int</span> perm)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">char</span> * end = <span class=\"literal\">NULL</span>;</div><div class=\"line\">    <span class=\"keyword\">char</span> * start = <span class=\"literal\">NULL</span>;</div><div class=\"line\">    start = ROUNDDOWN((<span class=\"keyword\">char</span> *)va, PGSIZE);</div><div class=\"line\">    end = ROUNDUP((<span class=\"keyword\">char</span> *)(va + len), PGSIZE);</div><div class=\"line\">    <span class=\"keyword\">pte_t</span> * cur = <span class=\"literal\">NULL</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span>(; start &lt; end; start += PGSIZE) &#123;</div><div class=\"line\">        cur = pgdir_walk(env-&gt;env_pgdir, (<span class=\"keyword\">void</span> *)start, <span class=\"number\">0</span>);</div><div class=\"line\">        <span class=\"keyword\">if</span>((<span class=\"keyword\">int</span>)start &gt; ULIM || cur == <span class=\"literal\">NULL</span> || ((<span class=\"keyword\">uint32_t</span>)(*cur) &amp; perm) != perm) &#123;</div><div class=\"line\">              <span class=\"keyword\">if</span>(start == ROUNDDOWN((<span class=\"keyword\">char</span> *)va, PGSIZE)) &#123;</div><div class=\"line\">                    user_mem_check_addr = (<span class=\"keyword\">uintptr_t</span>)va;</div><div class=\"line\">              &#125;</div><div class=\"line\">              <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                      user_mem_check_addr = (<span class=\"keyword\">uintptr_t</span>)start;</div><div class=\"line\">              &#125;</div><div class=\"line\">              <span class=\"keyword\">return</span> -E_FAULT;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>最后按照题目要求，补全<code>kern/syscall.c</code>文件中的一部分内容,即<code>sys_cputs</code> 函数,这个函数要求检查用户程序对虚拟地指空间<code>[s, s+len]</code>是否有访问权限,所以可以使用刚刚写好的函数<code>user_mem_assert</code>来实现.<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">sys_cputs</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *s, <span class=\"keyword\">size_t</span> len)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">// Check that the user has permission to read memory [s, s+len).</span></div><div class=\"line\">    <span class=\"comment\">// Destroy the environment if not:.</span></div><div class=\"line\"></div><div class=\"line\">    user_mem_assert(curenv, s, len, <span class=\"number\">0</span>);</div><div class=\"line\">    <span class=\"comment\">// Print the string supplied by the user.</span></div><div class=\"line\">    cprintf(<span class=\"string\">\"%.*s\"</span>, len, s);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>最后在<code>kern/kdebug</code>中修改<code>debuginfo_eip</code>函数,对用户空间的数据使用<code>user_mem_check</code>函数检查当前用户空间是否对其有<code>PTE_U</code>权限.<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">struct</span> UserStabData *usd = (<span class=\"keyword\">const</span> <span class=\"keyword\">struct</span> UserStabData *) USTABDATA;</div><div class=\"line\">    <span class=\"comment\">// Make sure this memory is valid.</span></div><div class=\"line\">    <span class=\"comment\">// Return -1 if it is not.  Hint: Call user_mem_check.</span></div><div class=\"line\">    <span class=\"comment\">// LAB 3: Your code here.</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (user_mem_check(curenv, usd, <span class=\"keyword\">sizeof</span>(*usd),PTE_U) &lt;<span class=\"number\">0</span> )</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div><div class=\"line\">    stabs = usd-&gt;stabs;</div><div class=\"line\">    stab_end = usd-&gt;stab_end;</div><div class=\"line\">    stabstr = usd-&gt;stabstr;</div><div class=\"line\">    stabstr_end = usd-&gt;stabstr_end;</div><div class=\"line\">    <span class=\"comment\">// Make sure the STABS and string table memory is valid.</span></div><div class=\"line\">    <span class=\"comment\">// LAB 3: Your code here.a</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (user_mem_check(curenv, stabs, stab_end-stabs,PTE_U) &lt;<span class=\"number\">0</span> || `user_mem_check`(curenv, stabstr, stabstr_end-stabstr,PTE_U) &lt;<span class=\"number\">0</span>)</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h2 id=\"参考链接\"><a href=\"#参考链接\" class=\"headerlink\" title=\"参考链接\"></a>参考链接</h2><p><a href=\"https://pdos.csail.mit.edu/6.828/2016/labs/lab3/\" target=\"_blank\" rel=\"external\">lab3:user environment</a></p>"},{"title":"lab3-user-environment-part1","date":"2017-04-25T16:00:00.000Z","_content":"\n# Lab3 用户环境 Part1\n## 摘要\nos运行分为两个基本状态: 内核态(kernel) 和 用户态(user).对应用进程而言, 运行在用户态下, 通过系统调用接口使用kernel提供的服务.\nLab3主要实现的功能是在用户环境下的进程的正常运行.包括三个方面:\n> 1. 实现获得受保护的用户模式环境（即“进程”）运行所需的基本内核功能.\n> 2. 创建数据结构以增强JOS内核,跟踪用户环境,创建单个用户环境,将程序映像加载到其中并运行.\n> 3. 使JOS内核能够处理用户环境所产生的任何系统调用,并处理其导致的任何其他异常.\n\nLab3分为两个部分:\n> part1. 用户环境和异常处理\n> part2. 缺页中断, 断点异常和系统调用\n\n<!-- more -->\n\n## 准备\n下载代码\n``` bash\ngit pull\ngit checkout -b lab3 origin/Lab3\ngit merge lab2\n```\nlab3新增的实验相关文件:\n``` c\ninc/\tenv.h\t      用户模式环境的公共定义\n      trap.h\t    陷阱处理的公共定义\n      syscall.h\t  从用户环境到内核的系统调用的公共定义\n      lib.h\t      用户模式支持库函数的公共定义\nkern/\tenv.h\t      用户模式环境的内核私有定义\n      env.c\t      实现用户模式环境的内核代码\n      trap.h\t    陷阱处理的内核私有定义\n      trap.c\t    陷阱处理代码\n      trapentry.S\t汇编陷阱处理程序入口\n      syscall.h\t  用于系统调用处理的内核私有定义\n      syscall.c\t  系统调用实现代码\nlib/\tMakefrag\t  构建用户模式的库文件的makefile,obj/lib/libJOS.a\n      entry.S\tA   用户环境的汇编入口\n      libmain.c\t  从entry.S调用的用户模式库文件的启动代码\n      syscall.c\t  用户模式下系统调用的存根函数\n      console.c\t  putchar和getchar在用户模式下实现 ,提供控制台I/O\n      exit.c\t    用户模式下实现退出的代码\nuser/\t*\t          各种测试程序\n```\n\n## Part1 User Environment\n新包含的文件`inc/env.h`里面包含了JOS内核的有关用户环境(User Environment)的基本定义.用户环境指的就是一个应用程序运行在系统中所需要的一个上下文环境,操作系统内核使用数据结构`Env`来记录每一个用户环境的信息.Lab3只会建一个用户环境,但是之后会把它拓展成能够支持多用户环境,即多个用户程序并发执行.\n\n在`kern/env.c`文件中,操作系统一共维护了三个重要的和用户环境相关的全局变量：\n``` c\nstruct Env *envs = NULL;    //所有的 Env 结构体l链表\nstruct Env *curenv = NULL;   //目前正在运行的用户环境\nstatic struct Env *env_free_list;  //还没有被使用的 Env 结构体链表\n```\n一旦JOS启动,`envs`指针便指向了一个`Env`结构体链表,表示系统中所有的用户环境的`env`.JOS内核将支持同一时刻最多`NENV`个活跃的用户环境,系统会为每一个活跃的用户环境在`envs`链表中维护一个`Env`结构体.JOS内核用`env_free_list`链接起来把所有不活跃的`Env`结构体,方便进行用户环境`env`的分配和回收.另外,内核也会把`curenv`指针指向在任意时刻正在执行的用户环境的`Env`结构体.在内核启动时,并且还没有任何用户环境运行时,`curenv`的值为`NULL`.\n\n### 环境状态 Environment Status\n`Env`结构体定义在 inc/env.h`:\n``` c\nstruct Env {\n　　　　struct Trapframe env_tf;      //saved registers\n　　　　struct Env * env_link;         //next free Env\n　　　　envid_t env_id;　　            //Unique environment identifier\n　　　　envid_t env_parent_id;        //envid of this env's parent\n　　　　enum EnvType env_type;　　//Indicates special system environment\n　　　　unsigned env_status;　　   //Status of the environment\n　　　　uint32_t env_runs;         //Number of the times environment has run\n　　　　pde_t \\*env_pgdir;　　　　//Kernel virtual address of page dir.\n};　　\n```\n具体含义如下:\n`env_tf`:\n　　定义在`inc/trap.h`文件中,里面存放着当用户环境暂停运行时,所有重要寄存器的值.内核也会在系统从用户态切换到内核态时保存这些值,这样的话用户环境可以在之后被恢复,继续执行.\n`env_link`:\n　　该指针指向在`env_free_list`中第一个空闲的`Env`结构体.前提是这个结构体还没有被分配给任意一个用户环境时.\n`env_id`:\n　　唯一的确定使用这个结构体的用户环境.当这个用户环境终止,内核会把这个结构体分配给另外一个不同的环境,这个新的环境会有不同的`env_id`值.\n`env_parent_id`:\n　　创建这个用户环境的父用户环境的`env_id`\n`env_type`:\n　　用于区别某个特定的用户环境.对于大多数环境来说,它的值都是 `ENV_TYPE_USER`.\n`env_status`:\n　　表示环境的状态,存放以下可能的值:\n　　`ENV_FREE`: 结构体是空闲的,应该在链表`env_free_list`中.\n　　`ENV_RUNNABLE`: 结构体对应的用户环境已经就绪,等待被分配处理机.\n　　`ENV_RUNNING`: 结构体对应的用户环境正在运行.\n　　`ENV_NOT_RUNNABLE`: 结构体所代表的是一个活跃的用户环境,但是它不能被调度运行,因为它在等待其他环境传递给它的消息.\n　　`ENV_DYING`: 代表这个结构体对应的是一个僵尸环境.一个僵尸环境在下一次陷入内核时会被释放回收.\n`env_pgdir`:\n　　存放这个环境的页目录的虚拟地址\n\n正如`Unix`中的进程一样,一个JOS环境中结合了“线程”和“地址空间”的概念.线程通常是由被保存的寄存器的值来定义的,而地址空间则是由`env_pgdir`所指向的页目录表还有页表来定义的.为了运行一个用户环境,内核必须设置合适的寄存器的值以及合适的地址空间.\n\n### 分配环境数组\nlab2中`mem_init()`函数中分配了`pages`数组的地址空间,用于记录内核中所有的页的信息.lab3需要进一步去修改`mem_init()`函数,分配`Env`结构体数组`envs`.\n\n#### 练习1:\n问:\n> 修改`mem_init()`的代码,让它能够分配`envs`数组.这个数组是由`NENV`个`Env`结构体组成的.`envs`数组所在的内存空间在用户模式下是只读的,被映射到虚拟地址`UENVS`处.\n\n解:\n> 如同Lab2里面分配pages数组,分配一个`Env`数组给指针`envs`即可\n``` c\n//kern/pmap.c\n//分配内存空间给envs\nenvs = (struct Env*)boot_alloc(NENV*sizeof(struct Env));\nmemset(envs, 0, NENV * sizeof(struct Env));\n//页表中设置envs的映射关系\nboot_map_region(kern_pgdir, UENVS, PTSIZE, PADDR(envs), PTE_U);\n```\n\n### 创建运行环境\n编写 `kern/env.c`文件来运行一个用户环境了.由于现在没有文件系统,所以必须把内核设置成能够加载内核中的静态二进制程序映像文件.在`i386_init()`函数中,编码完成运行用户环境的功能.\n\n#### 练习2:\n问:\n> 在文件`env.c`中,完成下列函数：\n`env_init()`:\n初始化所有的在`envs`数组中的`Env`结构体,并把它们加入到 `env_free_list`中. 还要调用`env_init_percpu`,这个函数要配置段式内存管理系统,让它所管理的段具有两种访问优先级的一种,一个是内核运行时的0优先级,以及用户运行时的3优先级.\n`env_setup_vm()`:\n为一个新的用户环境分配一个页目录表,并且初始化这个用户环境的地址空间中的和内核相关的部分.\n`region_alloc()`:\n为用户环境分配物理地址空间\n`load_icode()`:\n分析一个`ELF`文件,把它的内容加载到用户环境下.\n`env_create()`:\n利用`env_alloc`函数和`load_icode`函数,加载一个`ELF`文件到用户环境中\n`env_run()`:\n在用户模式下,开始运行一个用户环境.\n\n解:\n> `env_init`函数,通过遍历`envs`数组中的所有`Env`结构体,把每一个结构体的 `env_id`字段置0,因为要求所有的`Env`在`env_free_list`中的顺序,要和它在 `envs`中的顺序一致,采用头插法.　　\n``` c\n void\nenv_init(void)\n{\n    // Set up envs array\n    int i;\n    env_free_list = NULL;\n    for (i=NENV-1; i>=0; i--){\n        envs[i].env_id = 0;\n        envs[i].env_status = ENV_FREE;\n        envs[i].env_link = env_free_list;\n        env_free_list = &envs[i];\n     }\n     // Per-CPU part of the initialization\n     env_init_percpu();\n}\n```\n> `env_setup_vm()`初始化新的用户环境的页目录表,只设置页目录表中和操作系统内核跟内核相关的页目录项,用户环境的页目录项不要设置,因为所有用户环境的页目录表中和操作系统相关的页目录项都是一样的（除了虚拟地址`UVPT`,单独进行设置）,所以可以参照`kern_pgdir`中的内容来设置`env_pgdir`中的内容.\n``` c\nstatic int\nenv_setup_vm(struct Env *e)\n{\n    int i;\n    struct PageInfo* p = NULL;\n\n    // Allocate a page for the page directory\n    if (!(p = page_alloc(ALLOC_ZERO)))\n        return -E_NO_MEM;\n\n     e->env_pgdir = (pde_t *)page2kva(p);\n     p->pp_ref++;\n\n     //Map the directory below UTOP.\n     for (i = 0; i < PDX(UTOP); i++)\n         e->env_pgdir[i] = 0;        \n\n     //Map the directory above UTOP\n     for (i = PDX(UTOP); i < NPDENTRIES; i++) {\n         e->env_pgdir[i] = kern_pgdir[i];\n     }\n\n     // UVPT maps the env's own page table read-only.\n     // Permissions: kernel R, user R\n     e->env_pgdir[PDX(UVPT)] = PADDR(e->env_pgdir) | PTE_P | PTE_U;\n\n     return 0;\n }\n```\n> `region_alloc()`为用户环境分配物理空间,这里注意我们要先把起始地址和终止地址进行页对齐,对其之后我们就可以以页为单位,为其一个页一个页的分配内存,并且修改页目录表和页表.\n``` c\nstatic void\nregion_alloc(struct Env *e, void *va, size_t len)\n{\n    void* start = (void *)ROUNDDOWN((uint32_t)va, PGSIZE);\n    void* end = (void *)ROUNDUP((uint32_t)va+len, PGSIZE);\n    struct PageInfo *p = NULL;\n    void* i;\n    int r;\n\n    for(i = start; i < end; i += PGSIZE){\n        p = page_alloc(0);\n        if(p == NULL)\n           panic(\" region alloc failed: allocation failed.\\n\");\n\n        r = page_insert(e->env_pgdir, p, i, PTE_W | PTE_U);\n        if(r != 0)\n            panic(\"region alloc failed.\\n\");\n    }\n}\n```\n>　`load_icode()`为每一个用户进程设置它的初始代码区,堆栈以及CPU标识.用户程序是`ELF`文件,解析`ELF`文件.\n``` c\nstatic void\nload_icode(struct Env *e, uint8_t *binary)\n{\n\n    struct Elf* header = (struct Elf*)binary;\n\n    if (header->e_magic != ELF_MAGIC)\n        panic(\"load_icode failed: The binary we load is not elf.\\n\");\n\n    if (header->e_entry == 0)\n        panic(\"load_icode failed: The elf file can't be excuterd.\\n\");\n\n   e->env_tf.tf_eip = header->e_entry;\n\n   lcr3(PADDR(e->env_pgdir));   //load user pgdir\n\n   struct Proghdr *ph, *eph;\n   ph = (struct Proghdr* )((uint8_t *)header + header->e_phoff);\n   eph = ph + header->e_phnum;\n    for(; ph < eph; ph++) {\n        if(ph->p_type == ELF_PROG_LOAD) {\n            if(ph->p_memsz - ph->p_filesz < 0)\n                panic(\"load icode failed : p_memsz < p_filesz.\\n\");\n\n           region_alloc(e, (void *)ph->p_va, ph->p_memsz);\n            memmove((void *)ph->p_va, binary + ph->p_offset, ph->p_filesz);\n            memset((void *)(ph->p_va + ph->p_filesz), 0, ph->p_memsz - ph->p_filesz);\n        }\n     }\n}\n```\n> `env_create`是利用`env_alloc`函数和`load_icode`函数,加载一个`ELF`文件到用户环境中\n``` c\nvoid\nenv_create(uint8_t *binary, enum EnvType type)\n{\n    struct Env *e;\n    int rc;\n    if ((rc = env_alloc(&e, 0)) != 0)\n          panic(\"env_create failed: env_alloc failed.\\n\");\n\n     load_icode(e, binary);\n     e->env_type = type;\n }\n```\n> `env_run`开始运行一个用户环境\n``` c\nvoid\nenv_run(struct Env *e)\n{\n\n    if(curenv != NULL && curenv->env_status == ENV_RUNNING)\n        curenv->env_status = ENV_RUNNABLE;\n\n    curenv = e;\n    curenv->env_status = ENV_RUNNING;\n    curenv->env_runs++;\n    lcr3(PADDR(curenv->env_pgdir));\n\n    env_pop_tf(&curenv->env_tf);\n\n    panic(\"env_run not yet implemented\");\n}\n```\n\n用户环境的代码被调用前,操作系统一共按顺序执行了以下几个函数：\n``` c\n* start (kern/entry.S)\n* i386_init (kern/init.c)\ncons_init\nmem_init\nenv_init\ntrap_init （目前还未实现）\nenv_create\nenv_run\nenv_pop_tf\n```\n完成上述子函数的代码后,并且在`QEMU`下编译运行,系统会进入用户空间,并且开始执行`hello`程序,直到它做出一个系统调用指令`int`.但是这个系统调用指令不能成功运行,因为到目前为止,JOS还没有设置相关硬件来实现从用户态向内核态的转换功能.当CPU发现,它没有被设置成能够处理这种系统调用中断时,它会触发一个保护异常,然后发现这个保护异常也无法处理,从而又产生一个错误异常,然后又发现仍旧无法解决问题,所以最后放弃,这种异常被称为”triple fault”.通常来说,接下来CPU会复位,系统会重启.\n\n\n### 处理中断和异常\n到目前为止,当程序运行到第一个系统调用`int $0x30`时,就会进入错误的状态,因为现在系统无法从用户态切换到内核态.需要实现一个基本的异常处理机制,使得内核可以从用户态转换为内核态.学习X86的异常中断机制.\n\n### 受保护的控制转移\n异常(Exception)和中断(Interrupts)都是“受到保护的控制转移方法”,都会使CPU从用户态转移为内核态.在Intel的术语中,一个中断指的是由外部异步事件引起的CPU控制权转移,比如外部IO设备发送来的中断信号.一个异常则是由于当前正在运行的指令所带来的同步的CPU控制权的转移,比如除零异常.\n\n为了能够确保这些控制的转移能够真正被保护起来,CPU的中断/异常机制通常被设计为：用户态的代码无权选择内核中的代码从哪里开始执行.CPU可以确保只有在某些条件下,才能进入内核态.在X86上,有两种机制配合工作来提供这种保护：\n> 1. **中断向量表 The Interrupt Descriptor Table**：\nCPU保证中断和异常只能够引起内核进入到一些特定的,被事先定义好的程序入口,而不是由触发中断的程序来决定中断程序入口.\nX86有256个不同的中断和异常,对应特定的中断向量.一个向量指的就是0到255中的一个数.一个中断向量的值是根据中断源来决定的：不同设备/错误/对内核的请求,会产生出不同的中断和中断向量的组合.CPU将使用这个向量作为这个中断在中断向量表中的索引,这个表是由内核设置的,放在内核空间中.通过`IDT`中的任意一个表项,CPU得到以下信息:\n>> * 加载到`EIP`寄存器中的值,这个值指向了处理这个中断的中断处理程序的位置.\n>> * 加载到`CS`寄存器中的值,里面还包含了这个中断处理程序的运行特权级.\n\n> 2. **任务状态段 The Task State Segment**\nCPU还需要一个地方来存放异常/中断发生时CPU的状态,比如`EIP`和`CS`寄存器的值.这样的话,中断处理程序能够顺利重新返回到原来的程序中.这段内存自然也要保护起来,不能被用户态的程序所篡改.\n正因为如此,当一个x86CPU要处理一个中断,异常并且使运行特权级从用户态转为内核态时,它也会把它的堆栈切换到内核空间中.一个叫做 “任务状态段（TSS）”的数据结构将会详细记录这个堆栈所在的段的段描述符和地址.CPU把`SS,ESP,EFLAGS,CS,EIP`以及一个可选错误码等等这些值压入到这个堆栈上.然后加载中断处理程序的`CS,EIP`值,并且设置`ESP,SS`寄存器指向新的堆栈.由于JOS中的内核态指的就是特权级0,所以CPU用`TSS`中的`ESP0,SS0`字段来指明这个内核堆栈的位置,大小.\n\n### 中断/异常的类型\n所有的由X86CPU内部产生的异常的向量值是0到31之间的整数.比如,页表错误所对应的向量值是14.而大于31号的中断向量对应的是软件中断,由int指令生成；或者是外部中断,由外部设备生成.\n\npart1扩展JOS的功能,使它能够处理0~31号内部异常.part2让JOS能够处理48号软件中断,主要被用来做系统调用.在Lab4中会继续扩展JOS使它能够处理外部硬件中断,比如时钟中断.\n\n实例:\n> 假设CPU正在用户状态下运行代码,但是遇到了一个除法指令,并且除数为0.\n```\n         +--------------------+ KSTACKTOP             \n         | 0x00000 | old SS   |     \" - 4\n         |      old ESP       |     \" - 8\n         |     old EFLAGS     |     \" - 12\n         | 0x00000 | old CS   |     \" - 16\n         |      old EIP       |     \" - 20 <---- ESP\n         +--------------------+\n```\n> 发生除零异常后,CPU运行如下:\n> 1. CPU会首先切换自己的堆栈,切换到由`TSS`的`SS0,ESP0`字段所指定的内核堆栈区,这两个字段分别存放着`GD_KD`和`KSTACKTOP`的值.\n> 2. CPU把异常参数压入到内核堆栈中,起始于地址`KSTACKTOP`：\n> 3. 因为要处理的是除零异常,它的中断向量是0,CPU会读取`IDT`表中的0号表项,并且把`CS:EIP`的值设置为0号中断处理函数的地址值.\n> 4. 中断处理函数开始执行,处理中断.\n\n> 对于某些特定的异常,除了中要保存的五个值之外,还要再压入一个字,叫做错误码(error code).比如页表错误,就是其中一个实例.当压入错误码之后,内核堆栈的状态如下：\n```\n                     +--------------------+ KSTACKTOP             \n                     | 0x00000 | old SS   |     \" - 4\n                     |      old ESP       |     \" - 8\n                     |     old EFLAGS     |     \" - 12\n                     | 0x00000 | old CS   |     \" - 16\n                     |      old EIP       |     \" - 20\n                     |     error code     |     \" - 24 <---- ESP\n                     +--------------------+             \n```\n\n### 中断/异常的嵌套\n　　CPU在用户态下和内核态下都可以处理异常或中断.只有当CPU从用户态切换到内核态时,硬件才会自动地切换堆栈,并且把一些寄存器中的原来的值压入到堆栈上,并且触发相应的中断处理函数.但如果CPU已经由于正在处理中断而处在内核态下时,此时CPU会向内核堆栈压入更多的值.通过这种方式,内核就可处理嵌套中断.\n　　如果CPU已经在内核态下并且遇到嵌套中断,因为它不需要切换堆栈,所以它不需要存储`SS,ESP`寄存器的值.此时内核堆栈如下:\n```\n                     +--------------------+ <---- old ESP\n                     |     old EFLAGS     |     \" - 4\n                     | 0x00000 | old CS   |     \" - 8\n                     |      old EIP       |     \" - 12\n                     +--------------------+\n```\n但可能会发生一个问题: 如果CPU在内核态下捕捉一个异常,而且由于一些原因,比如堆栈空间不足,不能把当前的状态信息（寄存器的值）压入到内核堆栈中时,那么CPU是无法恢复到原来的状态,它会自动重启.\n\n### 设置IDT\n上文确定了基本信息, 可以设置IDT表,并在JOS处理异常了.Lab3只需要处理内部异常（中断向量号0~31）.在头文件`inc/trap.h和kern/trap.h`中包含了和中断异常相关的的定义.\n最后要实现的效果如下：\n```\nIDT                   trapentry.S         trap.c\n\n+----------------+                        \n|   &handler1    |---------> handler1:          trap (struct Trapframe *tf)\n|                |             // do stuff      {\n|                |             call trap          // handle the exception/interrupt\n|                |             // ...           }\n+----------------+\n|   &handler2    |--------> handler2:\n|                |            // do stuff\n|                |            call trap\n|                |            // ...\n+----------------+\n .\n .\n .\n+----------------+\n|   &handlerX    |--------> handlerX:\n|                |             // do stuff\n|                |             call trap\n|                |             // ...\n+----------------+\n```\n\n每一个中断/异常都有它自己的中断处理函数,定义在`trapentry.S`中.`trap_init()`将初始化`IDT`表.每一个处理函数都构建一个结构体 `Trapframe`在堆栈上,并且调用`trap()`函数指向这个结构体,`trap()`然后处理异常/中断,给它分配一个中断处理函数.\n所以操作系统的中断控制流程为：\n> 1. `trap_init()`先将所有中断处理函数的起始地址放到中断向量表`IDT`中.\n> 2. 当中断发生时,不管是外部中断还是内部中断,CPU捕捉到该中断,进入核心态,根据中断向量去查询中断向量表,找到对应的表项\n> 3. 保存被中断的程序的上下文到内核堆栈中,调用这个表项中指明的中断处理函数.\n> 4. 执行中断处理函数.\n> 5. 执行完成后,恢复被中断的进程的上下文,返回用户态,继续运行这个进程.\n\n#### 练习4\n问\n> 修改`trapentry.S`和`trap.c`文件,实现上述的功能.在`trapentry.S`文件中为在`inc/trap.h`文件中的每一个`trap`加入一个入口指针, 修改`trap_init()`函数来初始化`IDT`表,使表中每一项指向定义在`trapentry.S`中的入口指针.\n`_alltraps`要求:\n> 1. 把值压入堆栈,使堆栈结构类似一个结构体`Trapframe`\n> 2. 加载`GD_KD`的值到`%ds, %es`寄存器中\n> 3. 压栈`%esp`的值,并且传递一个指向`Trapframe`的指针到`trap()``函数中.\n> 4. 调用`trap`\n解\n> 在`trapentry.S`文件定义了两个宏,`TRAPHANDLER`,`TRAPHANDLER_NOEC`.其功能为：声明了一个全局符号name,并且这个符号是函数类型的,代表它是一个中断处理函数名.当系统检测到一个中断/异常时,首先需要完成的一部分操作,包括：中断异常码,中断错误码(error code).因为有些中断有中断错误码,有些没有,所以采用两个宏定义函数.\n``` c\n#define TRAPHANDLER(name, num)                        \\\n        .globl name;            /* define global symbol for 'name' */   \\\n        .type name, @function;  /* symbol type is function */           \\\n        .align 2;               /* align function definition */         \\\n        name:                   /* function starts here */              \\\n        pushl $(num);                                                   \\\n        jmp _alltraps\n/* Use TRAPHANDLER_NOEC for traps where the CPU doesn't push an error code.\n * It pushes a 0 in place of the error code, so the trap frame has the same\n * format in either case.\n */\n#define TRAPHANDLER_NOEC(name, num)                                     \\\n        .globl name;                                                    \\\n        .type name, @function;                                          \\\n        .align 2;                                                       \\\n        name:                                                           \\\n        pushl $0;                                                       \\\n        pushl $(num);                                                   \\\n        jmp _alltraps\n\n.text\n\n/*\n * Lab 3: Your code here for generating entry points for the different traps.\n */\nTRAPHANDLER_NOEC(divide_entry, T_DIVIDE);\nTRAPHANDLER_NOEC(debug_entry, T_DEBUG);\nTRAPHANDLER_NOEC(nmi_entry, T_NMI);\nTRAPHANDLER_NOEC(brkpt_entry, T_BRKPT);\nTRAPHANDLER_NOEC(oflow_entry, T_OFLOW);\nTRAPHANDLER_NOEC(bound_entry, T_BOUND);\nTRAPHANDLER_NOEC(illop_entry, T_ILLOP);\nTRAPHANDLER_NOEC(device_entry, T_DEVICE);\nTRAPHANDLER(dblflt_entry, T_DBLFLT);\nTRAPHANDLER(tss_entry, T_TSS);\nTRAPHANDLER(segnp_entry, T_SEGNP);\nTRAPHANDLER(stack_entry, T_STACK);\nTRAPHANDLER(gpflt_entry, T_GPFLT);\nTRAPHANDLER(pgflt_entry, T_PGFLT);\nTRAPHANDLER_NOEC(fperr_entry, T_FPERR);\nTRAPHANDLER(align_entry, T_ALIGN);\nTRAPHANDLER_NOEC(mchk_entry, T_MCHK);\nTRAPHANDLER_NOEC(simderr_entry, T_SIMDERR);\nTRAPHANDLER_NOEC(syscall_entry, T_SYSCALL);\n```\n> 然后调用`_alltraps`函数,使程序在之后调用`trap.`c中的`trap`函数时,能够正确的访问到输入的参数,即`Trapframe`指针类型的输入参数`tf`.\n``` c\n_alltraps:\n        pushl %ds\n        pushl %es\n        pushal\n\n        movl $GD_KD, %eax\n        movl %eax, %ds\n        movl %eax, %es\n\n        push %esp\n        call trap\n```\n> 最后在`trap.c`中实现`trap_init`函数,即在`IDT`表中插入中断向量描述符,可以使用`SETGATE`宏实现,其定义如下：\n``` c\n//gate:IDT表的index入口\n//istrap:判断是异常还是中断\n//sel:代码段选择符\n//off:对应的处理函数地址\n//dpl:触发该异常或中断的用户权限.\n#define SETGATE(gate, istrap, sel, off, dpl)\n```\n> `trap_init`实现：\n``` c\nvoid\ntrap_init(void)\n{\n        extern struct Segdesc gdt[];\n\n        SETGATE(idt[T_DIVIDE], 0, GD_KT, divide_entry, 0);\n        SETGATE(idt[T_DEBUG], 0, GD_KT, debug_entry, 0);\n        SETGATE(idt[T_NMI], 0, GD_KT, nmi_entry, 0);\n        SETGATE(idt[T_BRKPT], 0, GD_KT, brkpt_entry, 3);\n        SETGATE(idt[T_OFLOW], 0, GD_KT, oflow_entry, 0);\n        SETGATE(idt[T_BOUND], 0, GD_KT, bound_entry, 0);\n        SETGATE(idt[T_ILLOP], 0, GD_KT, illop_entry, 0);\n        SETGATE(idt[T_DEVICE], 0, GD_KT, device_entry, 0);\n        SETGATE(idt[T_DBLFLT], 0, GD_KT, dblflt_entry, 0);\n        SETGATE(idt[T_TSS], 0, GD_KT, tss_entry, 0);\n        SETGATE(idt[T_SEGNP], 0, GD_KT, segnp_entry, 0);\n        SETGATE(idt[T_STACK], 0, GD_KT, stack_entry, 0);\n        SETGATE(idt[T_GPFLT], 0, GD_KT, gpflt_entry, 0);\n        SETGATE(idt[T_PGFLT], 0, GD_KT, pgflt_entry, 0);\n        SETGATE(idt[T_FPERR], 0, GD_KT, fperr_entry, 0);\n        SETGATE(idt[T_ALIGN], 0, GD_KT, align_entry, 0);\n        SETGATE(idt[T_MCHK], 0, GD_KT, mchk_entry, 0);\n        SETGATE(idt[T_SIMDERR], 0, GD_KT, simderr_entry, 0);\n        SETGATE(idt[T_SYSCALL], 0, GD_KT, syscall_entry, 3);\n\n        trap_init_percpu();\n}\n```\n\n### 问题\n1. 每个异常/中断具有特定处理函数的目的是什么?（即如果所有异常/中断都传递给同一个处理程序,那么无法提供当前实现中存在的哪些功能?）\n解:\n　　不同的中断或者异常当然需要不同的中断处理函数,因为不同的异常/中断可能需要不同的处理方式,比如有些异常是代表指令有错误,则不会返回被中断的命令.而有些中断可能只是为了处理外部IO事件,此时执行完中断函数还要返回到被中断的程序中继续运行.\n\n2. 对软中断程序,测试程序预计会产生一般的保护错误（陷阱13）,但软中断的代码说`int $14`.为什么要产生中断向量13?如果内核允许软中断程序的`int $14`指令调用内核的页面错误处理程序（中断向量14）,会发生什么?\n解\n　　因为当前的系统正在运行在用户态下,特权级为3,而`INT`指令为系统指令,特权级为0.特权级为3的程序不能直接调用特权级为0的程序,会引发一个`General Protection Exception`,即`trap 13\n","source":"_posts/lab3_part1.md","raw":"title: lab3-user-environment-part1\ndate: 2017/04/26\ntags:\n- xv6\n- os\n\n---\n\n# Lab3 用户环境 Part1\n## 摘要\nos运行分为两个基本状态: 内核态(kernel) 和 用户态(user).对应用进程而言, 运行在用户态下, 通过系统调用接口使用kernel提供的服务.\nLab3主要实现的功能是在用户环境下的进程的正常运行.包括三个方面:\n> 1. 实现获得受保护的用户模式环境（即“进程”）运行所需的基本内核功能.\n> 2. 创建数据结构以增强JOS内核,跟踪用户环境,创建单个用户环境,将程序映像加载到其中并运行.\n> 3. 使JOS内核能够处理用户环境所产生的任何系统调用,并处理其导致的任何其他异常.\n\nLab3分为两个部分:\n> part1. 用户环境和异常处理\n> part2. 缺页中断, 断点异常和系统调用\n\n<!-- more -->\n\n## 准备\n下载代码\n``` bash\ngit pull\ngit checkout -b lab3 origin/Lab3\ngit merge lab2\n```\nlab3新增的实验相关文件:\n``` c\ninc/\tenv.h\t      用户模式环境的公共定义\n      trap.h\t    陷阱处理的公共定义\n      syscall.h\t  从用户环境到内核的系统调用的公共定义\n      lib.h\t      用户模式支持库函数的公共定义\nkern/\tenv.h\t      用户模式环境的内核私有定义\n      env.c\t      实现用户模式环境的内核代码\n      trap.h\t    陷阱处理的内核私有定义\n      trap.c\t    陷阱处理代码\n      trapentry.S\t汇编陷阱处理程序入口\n      syscall.h\t  用于系统调用处理的内核私有定义\n      syscall.c\t  系统调用实现代码\nlib/\tMakefrag\t  构建用户模式的库文件的makefile,obj/lib/libJOS.a\n      entry.S\tA   用户环境的汇编入口\n      libmain.c\t  从entry.S调用的用户模式库文件的启动代码\n      syscall.c\t  用户模式下系统调用的存根函数\n      console.c\t  putchar和getchar在用户模式下实现 ,提供控制台I/O\n      exit.c\t    用户模式下实现退出的代码\nuser/\t*\t          各种测试程序\n```\n\n## Part1 User Environment\n新包含的文件`inc/env.h`里面包含了JOS内核的有关用户环境(User Environment)的基本定义.用户环境指的就是一个应用程序运行在系统中所需要的一个上下文环境,操作系统内核使用数据结构`Env`来记录每一个用户环境的信息.Lab3只会建一个用户环境,但是之后会把它拓展成能够支持多用户环境,即多个用户程序并发执行.\n\n在`kern/env.c`文件中,操作系统一共维护了三个重要的和用户环境相关的全局变量：\n``` c\nstruct Env *envs = NULL;    //所有的 Env 结构体l链表\nstruct Env *curenv = NULL;   //目前正在运行的用户环境\nstatic struct Env *env_free_list;  //还没有被使用的 Env 结构体链表\n```\n一旦JOS启动,`envs`指针便指向了一个`Env`结构体链表,表示系统中所有的用户环境的`env`.JOS内核将支持同一时刻最多`NENV`个活跃的用户环境,系统会为每一个活跃的用户环境在`envs`链表中维护一个`Env`结构体.JOS内核用`env_free_list`链接起来把所有不活跃的`Env`结构体,方便进行用户环境`env`的分配和回收.另外,内核也会把`curenv`指针指向在任意时刻正在执行的用户环境的`Env`结构体.在内核启动时,并且还没有任何用户环境运行时,`curenv`的值为`NULL`.\n\n### 环境状态 Environment Status\n`Env`结构体定义在 inc/env.h`:\n``` c\nstruct Env {\n　　　　struct Trapframe env_tf;      //saved registers\n　　　　struct Env * env_link;         //next free Env\n　　　　envid_t env_id;　　            //Unique environment identifier\n　　　　envid_t env_parent_id;        //envid of this env's parent\n　　　　enum EnvType env_type;　　//Indicates special system environment\n　　　　unsigned env_status;　　   //Status of the environment\n　　　　uint32_t env_runs;         //Number of the times environment has run\n　　　　pde_t \\*env_pgdir;　　　　//Kernel virtual address of page dir.\n};　　\n```\n具体含义如下:\n`env_tf`:\n　　定义在`inc/trap.h`文件中,里面存放着当用户环境暂停运行时,所有重要寄存器的值.内核也会在系统从用户态切换到内核态时保存这些值,这样的话用户环境可以在之后被恢复,继续执行.\n`env_link`:\n　　该指针指向在`env_free_list`中第一个空闲的`Env`结构体.前提是这个结构体还没有被分配给任意一个用户环境时.\n`env_id`:\n　　唯一的确定使用这个结构体的用户环境.当这个用户环境终止,内核会把这个结构体分配给另外一个不同的环境,这个新的环境会有不同的`env_id`值.\n`env_parent_id`:\n　　创建这个用户环境的父用户环境的`env_id`\n`env_type`:\n　　用于区别某个特定的用户环境.对于大多数环境来说,它的值都是 `ENV_TYPE_USER`.\n`env_status`:\n　　表示环境的状态,存放以下可能的值:\n　　`ENV_FREE`: 结构体是空闲的,应该在链表`env_free_list`中.\n　　`ENV_RUNNABLE`: 结构体对应的用户环境已经就绪,等待被分配处理机.\n　　`ENV_RUNNING`: 结构体对应的用户环境正在运行.\n　　`ENV_NOT_RUNNABLE`: 结构体所代表的是一个活跃的用户环境,但是它不能被调度运行,因为它在等待其他环境传递给它的消息.\n　　`ENV_DYING`: 代表这个结构体对应的是一个僵尸环境.一个僵尸环境在下一次陷入内核时会被释放回收.\n`env_pgdir`:\n　　存放这个环境的页目录的虚拟地址\n\n正如`Unix`中的进程一样,一个JOS环境中结合了“线程”和“地址空间”的概念.线程通常是由被保存的寄存器的值来定义的,而地址空间则是由`env_pgdir`所指向的页目录表还有页表来定义的.为了运行一个用户环境,内核必须设置合适的寄存器的值以及合适的地址空间.\n\n### 分配环境数组\nlab2中`mem_init()`函数中分配了`pages`数组的地址空间,用于记录内核中所有的页的信息.lab3需要进一步去修改`mem_init()`函数,分配`Env`结构体数组`envs`.\n\n#### 练习1:\n问:\n> 修改`mem_init()`的代码,让它能够分配`envs`数组.这个数组是由`NENV`个`Env`结构体组成的.`envs`数组所在的内存空间在用户模式下是只读的,被映射到虚拟地址`UENVS`处.\n\n解:\n> 如同Lab2里面分配pages数组,分配一个`Env`数组给指针`envs`即可\n``` c\n//kern/pmap.c\n//分配内存空间给envs\nenvs = (struct Env*)boot_alloc(NENV*sizeof(struct Env));\nmemset(envs, 0, NENV * sizeof(struct Env));\n//页表中设置envs的映射关系\nboot_map_region(kern_pgdir, UENVS, PTSIZE, PADDR(envs), PTE_U);\n```\n\n### 创建运行环境\n编写 `kern/env.c`文件来运行一个用户环境了.由于现在没有文件系统,所以必须把内核设置成能够加载内核中的静态二进制程序映像文件.在`i386_init()`函数中,编码完成运行用户环境的功能.\n\n#### 练习2:\n问:\n> 在文件`env.c`中,完成下列函数：\n`env_init()`:\n初始化所有的在`envs`数组中的`Env`结构体,并把它们加入到 `env_free_list`中. 还要调用`env_init_percpu`,这个函数要配置段式内存管理系统,让它所管理的段具有两种访问优先级的一种,一个是内核运行时的0优先级,以及用户运行时的3优先级.\n`env_setup_vm()`:\n为一个新的用户环境分配一个页目录表,并且初始化这个用户环境的地址空间中的和内核相关的部分.\n`region_alloc()`:\n为用户环境分配物理地址空间\n`load_icode()`:\n分析一个`ELF`文件,把它的内容加载到用户环境下.\n`env_create()`:\n利用`env_alloc`函数和`load_icode`函数,加载一个`ELF`文件到用户环境中\n`env_run()`:\n在用户模式下,开始运行一个用户环境.\n\n解:\n> `env_init`函数,通过遍历`envs`数组中的所有`Env`结构体,把每一个结构体的 `env_id`字段置0,因为要求所有的`Env`在`env_free_list`中的顺序,要和它在 `envs`中的顺序一致,采用头插法.　　\n``` c\n void\nenv_init(void)\n{\n    // Set up envs array\n    int i;\n    env_free_list = NULL;\n    for (i=NENV-1; i>=0; i--){\n        envs[i].env_id = 0;\n        envs[i].env_status = ENV_FREE;\n        envs[i].env_link = env_free_list;\n        env_free_list = &envs[i];\n     }\n     // Per-CPU part of the initialization\n     env_init_percpu();\n}\n```\n> `env_setup_vm()`初始化新的用户环境的页目录表,只设置页目录表中和操作系统内核跟内核相关的页目录项,用户环境的页目录项不要设置,因为所有用户环境的页目录表中和操作系统相关的页目录项都是一样的（除了虚拟地址`UVPT`,单独进行设置）,所以可以参照`kern_pgdir`中的内容来设置`env_pgdir`中的内容.\n``` c\nstatic int\nenv_setup_vm(struct Env *e)\n{\n    int i;\n    struct PageInfo* p = NULL;\n\n    // Allocate a page for the page directory\n    if (!(p = page_alloc(ALLOC_ZERO)))\n        return -E_NO_MEM;\n\n     e->env_pgdir = (pde_t *)page2kva(p);\n     p->pp_ref++;\n\n     //Map the directory below UTOP.\n     for (i = 0; i < PDX(UTOP); i++)\n         e->env_pgdir[i] = 0;        \n\n     //Map the directory above UTOP\n     for (i = PDX(UTOP); i < NPDENTRIES; i++) {\n         e->env_pgdir[i] = kern_pgdir[i];\n     }\n\n     // UVPT maps the env's own page table read-only.\n     // Permissions: kernel R, user R\n     e->env_pgdir[PDX(UVPT)] = PADDR(e->env_pgdir) | PTE_P | PTE_U;\n\n     return 0;\n }\n```\n> `region_alloc()`为用户环境分配物理空间,这里注意我们要先把起始地址和终止地址进行页对齐,对其之后我们就可以以页为单位,为其一个页一个页的分配内存,并且修改页目录表和页表.\n``` c\nstatic void\nregion_alloc(struct Env *e, void *va, size_t len)\n{\n    void* start = (void *)ROUNDDOWN((uint32_t)va, PGSIZE);\n    void* end = (void *)ROUNDUP((uint32_t)va+len, PGSIZE);\n    struct PageInfo *p = NULL;\n    void* i;\n    int r;\n\n    for(i = start; i < end; i += PGSIZE){\n        p = page_alloc(0);\n        if(p == NULL)\n           panic(\" region alloc failed: allocation failed.\\n\");\n\n        r = page_insert(e->env_pgdir, p, i, PTE_W | PTE_U);\n        if(r != 0)\n            panic(\"region alloc failed.\\n\");\n    }\n}\n```\n>　`load_icode()`为每一个用户进程设置它的初始代码区,堆栈以及CPU标识.用户程序是`ELF`文件,解析`ELF`文件.\n``` c\nstatic void\nload_icode(struct Env *e, uint8_t *binary)\n{\n\n    struct Elf* header = (struct Elf*)binary;\n\n    if (header->e_magic != ELF_MAGIC)\n        panic(\"load_icode failed: The binary we load is not elf.\\n\");\n\n    if (header->e_entry == 0)\n        panic(\"load_icode failed: The elf file can't be excuterd.\\n\");\n\n   e->env_tf.tf_eip = header->e_entry;\n\n   lcr3(PADDR(e->env_pgdir));   //load user pgdir\n\n   struct Proghdr *ph, *eph;\n   ph = (struct Proghdr* )((uint8_t *)header + header->e_phoff);\n   eph = ph + header->e_phnum;\n    for(; ph < eph; ph++) {\n        if(ph->p_type == ELF_PROG_LOAD) {\n            if(ph->p_memsz - ph->p_filesz < 0)\n                panic(\"load icode failed : p_memsz < p_filesz.\\n\");\n\n           region_alloc(e, (void *)ph->p_va, ph->p_memsz);\n            memmove((void *)ph->p_va, binary + ph->p_offset, ph->p_filesz);\n            memset((void *)(ph->p_va + ph->p_filesz), 0, ph->p_memsz - ph->p_filesz);\n        }\n     }\n}\n```\n> `env_create`是利用`env_alloc`函数和`load_icode`函数,加载一个`ELF`文件到用户环境中\n``` c\nvoid\nenv_create(uint8_t *binary, enum EnvType type)\n{\n    struct Env *e;\n    int rc;\n    if ((rc = env_alloc(&e, 0)) != 0)\n          panic(\"env_create failed: env_alloc failed.\\n\");\n\n     load_icode(e, binary);\n     e->env_type = type;\n }\n```\n> `env_run`开始运行一个用户环境\n``` c\nvoid\nenv_run(struct Env *e)\n{\n\n    if(curenv != NULL && curenv->env_status == ENV_RUNNING)\n        curenv->env_status = ENV_RUNNABLE;\n\n    curenv = e;\n    curenv->env_status = ENV_RUNNING;\n    curenv->env_runs++;\n    lcr3(PADDR(curenv->env_pgdir));\n\n    env_pop_tf(&curenv->env_tf);\n\n    panic(\"env_run not yet implemented\");\n}\n```\n\n用户环境的代码被调用前,操作系统一共按顺序执行了以下几个函数：\n``` c\n* start (kern/entry.S)\n* i386_init (kern/init.c)\ncons_init\nmem_init\nenv_init\ntrap_init （目前还未实现）\nenv_create\nenv_run\nenv_pop_tf\n```\n完成上述子函数的代码后,并且在`QEMU`下编译运行,系统会进入用户空间,并且开始执行`hello`程序,直到它做出一个系统调用指令`int`.但是这个系统调用指令不能成功运行,因为到目前为止,JOS还没有设置相关硬件来实现从用户态向内核态的转换功能.当CPU发现,它没有被设置成能够处理这种系统调用中断时,它会触发一个保护异常,然后发现这个保护异常也无法处理,从而又产生一个错误异常,然后又发现仍旧无法解决问题,所以最后放弃,这种异常被称为”triple fault”.通常来说,接下来CPU会复位,系统会重启.\n\n\n### 处理中断和异常\n到目前为止,当程序运行到第一个系统调用`int $0x30`时,就会进入错误的状态,因为现在系统无法从用户态切换到内核态.需要实现一个基本的异常处理机制,使得内核可以从用户态转换为内核态.学习X86的异常中断机制.\n\n### 受保护的控制转移\n异常(Exception)和中断(Interrupts)都是“受到保护的控制转移方法”,都会使CPU从用户态转移为内核态.在Intel的术语中,一个中断指的是由外部异步事件引起的CPU控制权转移,比如外部IO设备发送来的中断信号.一个异常则是由于当前正在运行的指令所带来的同步的CPU控制权的转移,比如除零异常.\n\n为了能够确保这些控制的转移能够真正被保护起来,CPU的中断/异常机制通常被设计为：用户态的代码无权选择内核中的代码从哪里开始执行.CPU可以确保只有在某些条件下,才能进入内核态.在X86上,有两种机制配合工作来提供这种保护：\n> 1. **中断向量表 The Interrupt Descriptor Table**：\nCPU保证中断和异常只能够引起内核进入到一些特定的,被事先定义好的程序入口,而不是由触发中断的程序来决定中断程序入口.\nX86有256个不同的中断和异常,对应特定的中断向量.一个向量指的就是0到255中的一个数.一个中断向量的值是根据中断源来决定的：不同设备/错误/对内核的请求,会产生出不同的中断和中断向量的组合.CPU将使用这个向量作为这个中断在中断向量表中的索引,这个表是由内核设置的,放在内核空间中.通过`IDT`中的任意一个表项,CPU得到以下信息:\n>> * 加载到`EIP`寄存器中的值,这个值指向了处理这个中断的中断处理程序的位置.\n>> * 加载到`CS`寄存器中的值,里面还包含了这个中断处理程序的运行特权级.\n\n> 2. **任务状态段 The Task State Segment**\nCPU还需要一个地方来存放异常/中断发生时CPU的状态,比如`EIP`和`CS`寄存器的值.这样的话,中断处理程序能够顺利重新返回到原来的程序中.这段内存自然也要保护起来,不能被用户态的程序所篡改.\n正因为如此,当一个x86CPU要处理一个中断,异常并且使运行特权级从用户态转为内核态时,它也会把它的堆栈切换到内核空间中.一个叫做 “任务状态段（TSS）”的数据结构将会详细记录这个堆栈所在的段的段描述符和地址.CPU把`SS,ESP,EFLAGS,CS,EIP`以及一个可选错误码等等这些值压入到这个堆栈上.然后加载中断处理程序的`CS,EIP`值,并且设置`ESP,SS`寄存器指向新的堆栈.由于JOS中的内核态指的就是特权级0,所以CPU用`TSS`中的`ESP0,SS0`字段来指明这个内核堆栈的位置,大小.\n\n### 中断/异常的类型\n所有的由X86CPU内部产生的异常的向量值是0到31之间的整数.比如,页表错误所对应的向量值是14.而大于31号的中断向量对应的是软件中断,由int指令生成；或者是外部中断,由外部设备生成.\n\npart1扩展JOS的功能,使它能够处理0~31号内部异常.part2让JOS能够处理48号软件中断,主要被用来做系统调用.在Lab4中会继续扩展JOS使它能够处理外部硬件中断,比如时钟中断.\n\n实例:\n> 假设CPU正在用户状态下运行代码,但是遇到了一个除法指令,并且除数为0.\n```\n         +--------------------+ KSTACKTOP             \n         | 0x00000 | old SS   |     \" - 4\n         |      old ESP       |     \" - 8\n         |     old EFLAGS     |     \" - 12\n         | 0x00000 | old CS   |     \" - 16\n         |      old EIP       |     \" - 20 <---- ESP\n         +--------------------+\n```\n> 发生除零异常后,CPU运行如下:\n> 1. CPU会首先切换自己的堆栈,切换到由`TSS`的`SS0,ESP0`字段所指定的内核堆栈区,这两个字段分别存放着`GD_KD`和`KSTACKTOP`的值.\n> 2. CPU把异常参数压入到内核堆栈中,起始于地址`KSTACKTOP`：\n> 3. 因为要处理的是除零异常,它的中断向量是0,CPU会读取`IDT`表中的0号表项,并且把`CS:EIP`的值设置为0号中断处理函数的地址值.\n> 4. 中断处理函数开始执行,处理中断.\n\n> 对于某些特定的异常,除了中要保存的五个值之外,还要再压入一个字,叫做错误码(error code).比如页表错误,就是其中一个实例.当压入错误码之后,内核堆栈的状态如下：\n```\n                     +--------------------+ KSTACKTOP             \n                     | 0x00000 | old SS   |     \" - 4\n                     |      old ESP       |     \" - 8\n                     |     old EFLAGS     |     \" - 12\n                     | 0x00000 | old CS   |     \" - 16\n                     |      old EIP       |     \" - 20\n                     |     error code     |     \" - 24 <---- ESP\n                     +--------------------+             \n```\n\n### 中断/异常的嵌套\n　　CPU在用户态下和内核态下都可以处理异常或中断.只有当CPU从用户态切换到内核态时,硬件才会自动地切换堆栈,并且把一些寄存器中的原来的值压入到堆栈上,并且触发相应的中断处理函数.但如果CPU已经由于正在处理中断而处在内核态下时,此时CPU会向内核堆栈压入更多的值.通过这种方式,内核就可处理嵌套中断.\n　　如果CPU已经在内核态下并且遇到嵌套中断,因为它不需要切换堆栈,所以它不需要存储`SS,ESP`寄存器的值.此时内核堆栈如下:\n```\n                     +--------------------+ <---- old ESP\n                     |     old EFLAGS     |     \" - 4\n                     | 0x00000 | old CS   |     \" - 8\n                     |      old EIP       |     \" - 12\n                     +--------------------+\n```\n但可能会发生一个问题: 如果CPU在内核态下捕捉一个异常,而且由于一些原因,比如堆栈空间不足,不能把当前的状态信息（寄存器的值）压入到内核堆栈中时,那么CPU是无法恢复到原来的状态,它会自动重启.\n\n### 设置IDT\n上文确定了基本信息, 可以设置IDT表,并在JOS处理异常了.Lab3只需要处理内部异常（中断向量号0~31）.在头文件`inc/trap.h和kern/trap.h`中包含了和中断异常相关的的定义.\n最后要实现的效果如下：\n```\nIDT                   trapentry.S         trap.c\n\n+----------------+                        \n|   &handler1    |---------> handler1:          trap (struct Trapframe *tf)\n|                |             // do stuff      {\n|                |             call trap          // handle the exception/interrupt\n|                |             // ...           }\n+----------------+\n|   &handler2    |--------> handler2:\n|                |            // do stuff\n|                |            call trap\n|                |            // ...\n+----------------+\n .\n .\n .\n+----------------+\n|   &handlerX    |--------> handlerX:\n|                |             // do stuff\n|                |             call trap\n|                |             // ...\n+----------------+\n```\n\n每一个中断/异常都有它自己的中断处理函数,定义在`trapentry.S`中.`trap_init()`将初始化`IDT`表.每一个处理函数都构建一个结构体 `Trapframe`在堆栈上,并且调用`trap()`函数指向这个结构体,`trap()`然后处理异常/中断,给它分配一个中断处理函数.\n所以操作系统的中断控制流程为：\n> 1. `trap_init()`先将所有中断处理函数的起始地址放到中断向量表`IDT`中.\n> 2. 当中断发生时,不管是外部中断还是内部中断,CPU捕捉到该中断,进入核心态,根据中断向量去查询中断向量表,找到对应的表项\n> 3. 保存被中断的程序的上下文到内核堆栈中,调用这个表项中指明的中断处理函数.\n> 4. 执行中断处理函数.\n> 5. 执行完成后,恢复被中断的进程的上下文,返回用户态,继续运行这个进程.\n\n#### 练习4\n问\n> 修改`trapentry.S`和`trap.c`文件,实现上述的功能.在`trapentry.S`文件中为在`inc/trap.h`文件中的每一个`trap`加入一个入口指针, 修改`trap_init()`函数来初始化`IDT`表,使表中每一项指向定义在`trapentry.S`中的入口指针.\n`_alltraps`要求:\n> 1. 把值压入堆栈,使堆栈结构类似一个结构体`Trapframe`\n> 2. 加载`GD_KD`的值到`%ds, %es`寄存器中\n> 3. 压栈`%esp`的值,并且传递一个指向`Trapframe`的指针到`trap()``函数中.\n> 4. 调用`trap`\n解\n> 在`trapentry.S`文件定义了两个宏,`TRAPHANDLER`,`TRAPHANDLER_NOEC`.其功能为：声明了一个全局符号name,并且这个符号是函数类型的,代表它是一个中断处理函数名.当系统检测到一个中断/异常时,首先需要完成的一部分操作,包括：中断异常码,中断错误码(error code).因为有些中断有中断错误码,有些没有,所以采用两个宏定义函数.\n``` c\n#define TRAPHANDLER(name, num)                        \\\n        .globl name;            /* define global symbol for 'name' */   \\\n        .type name, @function;  /* symbol type is function */           \\\n        .align 2;               /* align function definition */         \\\n        name:                   /* function starts here */              \\\n        pushl $(num);                                                   \\\n        jmp _alltraps\n/* Use TRAPHANDLER_NOEC for traps where the CPU doesn't push an error code.\n * It pushes a 0 in place of the error code, so the trap frame has the same\n * format in either case.\n */\n#define TRAPHANDLER_NOEC(name, num)                                     \\\n        .globl name;                                                    \\\n        .type name, @function;                                          \\\n        .align 2;                                                       \\\n        name:                                                           \\\n        pushl $0;                                                       \\\n        pushl $(num);                                                   \\\n        jmp _alltraps\n\n.text\n\n/*\n * Lab 3: Your code here for generating entry points for the different traps.\n */\nTRAPHANDLER_NOEC(divide_entry, T_DIVIDE);\nTRAPHANDLER_NOEC(debug_entry, T_DEBUG);\nTRAPHANDLER_NOEC(nmi_entry, T_NMI);\nTRAPHANDLER_NOEC(brkpt_entry, T_BRKPT);\nTRAPHANDLER_NOEC(oflow_entry, T_OFLOW);\nTRAPHANDLER_NOEC(bound_entry, T_BOUND);\nTRAPHANDLER_NOEC(illop_entry, T_ILLOP);\nTRAPHANDLER_NOEC(device_entry, T_DEVICE);\nTRAPHANDLER(dblflt_entry, T_DBLFLT);\nTRAPHANDLER(tss_entry, T_TSS);\nTRAPHANDLER(segnp_entry, T_SEGNP);\nTRAPHANDLER(stack_entry, T_STACK);\nTRAPHANDLER(gpflt_entry, T_GPFLT);\nTRAPHANDLER(pgflt_entry, T_PGFLT);\nTRAPHANDLER_NOEC(fperr_entry, T_FPERR);\nTRAPHANDLER(align_entry, T_ALIGN);\nTRAPHANDLER_NOEC(mchk_entry, T_MCHK);\nTRAPHANDLER_NOEC(simderr_entry, T_SIMDERR);\nTRAPHANDLER_NOEC(syscall_entry, T_SYSCALL);\n```\n> 然后调用`_alltraps`函数,使程序在之后调用`trap.`c中的`trap`函数时,能够正确的访问到输入的参数,即`Trapframe`指针类型的输入参数`tf`.\n``` c\n_alltraps:\n        pushl %ds\n        pushl %es\n        pushal\n\n        movl $GD_KD, %eax\n        movl %eax, %ds\n        movl %eax, %es\n\n        push %esp\n        call trap\n```\n> 最后在`trap.c`中实现`trap_init`函数,即在`IDT`表中插入中断向量描述符,可以使用`SETGATE`宏实现,其定义如下：\n``` c\n//gate:IDT表的index入口\n//istrap:判断是异常还是中断\n//sel:代码段选择符\n//off:对应的处理函数地址\n//dpl:触发该异常或中断的用户权限.\n#define SETGATE(gate, istrap, sel, off, dpl)\n```\n> `trap_init`实现：\n``` c\nvoid\ntrap_init(void)\n{\n        extern struct Segdesc gdt[];\n\n        SETGATE(idt[T_DIVIDE], 0, GD_KT, divide_entry, 0);\n        SETGATE(idt[T_DEBUG], 0, GD_KT, debug_entry, 0);\n        SETGATE(idt[T_NMI], 0, GD_KT, nmi_entry, 0);\n        SETGATE(idt[T_BRKPT], 0, GD_KT, brkpt_entry, 3);\n        SETGATE(idt[T_OFLOW], 0, GD_KT, oflow_entry, 0);\n        SETGATE(idt[T_BOUND], 0, GD_KT, bound_entry, 0);\n        SETGATE(idt[T_ILLOP], 0, GD_KT, illop_entry, 0);\n        SETGATE(idt[T_DEVICE], 0, GD_KT, device_entry, 0);\n        SETGATE(idt[T_DBLFLT], 0, GD_KT, dblflt_entry, 0);\n        SETGATE(idt[T_TSS], 0, GD_KT, tss_entry, 0);\n        SETGATE(idt[T_SEGNP], 0, GD_KT, segnp_entry, 0);\n        SETGATE(idt[T_STACK], 0, GD_KT, stack_entry, 0);\n        SETGATE(idt[T_GPFLT], 0, GD_KT, gpflt_entry, 0);\n        SETGATE(idt[T_PGFLT], 0, GD_KT, pgflt_entry, 0);\n        SETGATE(idt[T_FPERR], 0, GD_KT, fperr_entry, 0);\n        SETGATE(idt[T_ALIGN], 0, GD_KT, align_entry, 0);\n        SETGATE(idt[T_MCHK], 0, GD_KT, mchk_entry, 0);\n        SETGATE(idt[T_SIMDERR], 0, GD_KT, simderr_entry, 0);\n        SETGATE(idt[T_SYSCALL], 0, GD_KT, syscall_entry, 3);\n\n        trap_init_percpu();\n}\n```\n\n### 问题\n1. 每个异常/中断具有特定处理函数的目的是什么?（即如果所有异常/中断都传递给同一个处理程序,那么无法提供当前实现中存在的哪些功能?）\n解:\n　　不同的中断或者异常当然需要不同的中断处理函数,因为不同的异常/中断可能需要不同的处理方式,比如有些异常是代表指令有错误,则不会返回被中断的命令.而有些中断可能只是为了处理外部IO事件,此时执行完中断函数还要返回到被中断的程序中继续运行.\n\n2. 对软中断程序,测试程序预计会产生一般的保护错误（陷阱13）,但软中断的代码说`int $14`.为什么要产生中断向量13?如果内核允许软中断程序的`int $14`指令调用内核的页面错误处理程序（中断向量14）,会发生什么?\n解\n　　因为当前的系统正在运行在用户态下,特权级为3,而`INT`指令为系统指令,特权级为0.特权级为3的程序不能直接调用特权级为0的程序,会引发一个`General Protection Exception`,即`trap 13\n","slug":"lab3_part1","published":1,"updated":"2017-08-26T03:38:21.610Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6sslhbb00153gamxxuhxziu","content":"<h1 id=\"Lab3-用户环境-Part1\"><a href=\"#Lab3-用户环境-Part1\" class=\"headerlink\" title=\"Lab3 用户环境 Part1\"></a>Lab3 用户环境 Part1</h1><h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><p>os运行分为两个基本状态: 内核态(kernel) 和 用户态(user).对应用进程而言, 运行在用户态下, 通过系统调用接口使用kernel提供的服务.<br>Lab3主要实现的功能是在用户环境下的进程的正常运行.包括三个方面:</p>\n<blockquote>\n<ol>\n<li>实现获得受保护的用户模式环境（即“进程”）运行所需的基本内核功能.</li>\n<li>创建数据结构以增强JOS内核,跟踪用户环境,创建单个用户环境,将程序映像加载到其中并运行.</li>\n<li>使JOS内核能够处理用户环境所产生的任何系统调用,并处理其导致的任何其他异常.</li>\n</ol>\n</blockquote>\n<p>Lab3分为两个部分:</p>\n<blockquote>\n<p>part1. 用户环境和异常处理<br>part2. 缺页中断, 断点异常和系统调用</p>\n</blockquote>\n<a id=\"more\"></a>\n<h2 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h2><p>下载代码<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git pull</div><div class=\"line\">git checkout -b lab3 origin/Lab3</div><div class=\"line\">git merge lab2</div></pre></td></tr></table></figure></p>\n<p>lab3新增的实验相关文件:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">inc/\tenv.h\t      用户模式环境的公共定义</div><div class=\"line\">      trap.h\t    陷阱处理的公共定义</div><div class=\"line\">      syscall.h\t  从用户环境到内核的系统调用的公共定义</div><div class=\"line\">      lib.h\t      用户模式支持库函数的公共定义</div><div class=\"line\">kern/\tenv.h\t      用户模式环境的内核私有定义</div><div class=\"line\">      env.c\t      实现用户模式环境的内核代码</div><div class=\"line\">      trap.h\t    陷阱处理的内核私有定义</div><div class=\"line\">      trap.c\t    陷阱处理代码</div><div class=\"line\">      trapentry.S\t汇编陷阱处理程序入口</div><div class=\"line\">      syscall.h\t  用于系统调用处理的内核私有定义</div><div class=\"line\">      syscall.c\t  系统调用实现代码</div><div class=\"line\">lib/\tMakefrag\t  构建用户模式的库文件的makefile,obj/lib/libJOS.a</div><div class=\"line\">      entry.S\tA   用户环境的汇编入口</div><div class=\"line\">      libmain.c\t  从entry.S调用的用户模式库文件的启动代码</div><div class=\"line\">      syscall.c\t  用户模式下系统调用的存根函数</div><div class=\"line\">      console.c\t  <span class=\"built_in\">putchar</span>和getchar在用户模式下实现 ,提供控制台I/O</div><div class=\"line\">      <span class=\"built_in\">exit</span>.c\t    用户模式下实现退出的代码</div><div class=\"line\">user/\t*\t          各种测试程序</div></pre></td></tr></table></figure></p>\n<h2 id=\"Part1-User-Environment\"><a href=\"#Part1-User-Environment\" class=\"headerlink\" title=\"Part1 User Environment\"></a>Part1 User Environment</h2><p>新包含的文件<code>inc/env.h</code>里面包含了JOS内核的有关用户环境(User Environment)的基本定义.用户环境指的就是一个应用程序运行在系统中所需要的一个上下文环境,操作系统内核使用数据结构<code>Env</code>来记录每一个用户环境的信息.Lab3只会建一个用户环境,但是之后会把它拓展成能够支持多用户环境,即多个用户程序并发执行.</p>\n<p>在<code>kern/env.c</code>文件中,操作系统一共维护了三个重要的和用户环境相关的全局变量：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> Env *envs = <span class=\"literal\">NULL</span>;    <span class=\"comment\">//所有的 Env 结构体l链表</span></div><div class=\"line\"><span class=\"keyword\">struct</span> Env *curenv = <span class=\"literal\">NULL</span>;   <span class=\"comment\">//目前正在运行的用户环境</span></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">struct</span> Env *env_free_list;  <span class=\"comment\">//还没有被使用的 Env 结构体链表</span></div></pre></td></tr></table></figure></p>\n<p>一旦JOS启动,<code>envs</code>指针便指向了一个<code>Env</code>结构体链表,表示系统中所有的用户环境的<code>env</code>.JOS内核将支持同一时刻最多<code>NENV</code>个活跃的用户环境,系统会为每一个活跃的用户环境在<code>envs</code>链表中维护一个<code>Env</code>结构体.JOS内核用<code>env_free_list</code>链接起来把所有不活跃的<code>Env</code>结构体,方便进行用户环境<code>env</code>的分配和回收.另外,内核也会把<code>curenv</code>指针指向在任意时刻正在执行的用户环境的<code>Env</code>结构体.在内核启动时,并且还没有任何用户环境运行时,<code>curenv</code>的值为<code>NULL</code>.</p>\n<h3 id=\"环境状态-Environment-Status\"><a href=\"#环境状态-Environment-Status\" class=\"headerlink\" title=\"环境状态 Environment Status\"></a>环境状态 Environment Status</h3><p><code>Env</code>结构体定义在 inc/env.h`:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> Env &#123;</div><div class=\"line\">　　　　<span class=\"keyword\">struct</span> Trapframe env_tf;      <span class=\"comment\">//saved registers</span></div><div class=\"line\">　　　　<span class=\"keyword\">struct</span> Env * env_link;         <span class=\"comment\">//next free Env</span></div><div class=\"line\">　　　　<span class=\"keyword\">envid_t</span> env_id;　　            <span class=\"comment\">//Unique environment identifier</span></div><div class=\"line\">　　　　<span class=\"keyword\">envid_t</span> env_parent_id;        <span class=\"comment\">//envid of this env's parent</span></div><div class=\"line\">　　　　<span class=\"keyword\">enum</span> EnvType env_type;　　<span class=\"comment\">//Indicates special system environment</span></div><div class=\"line\">　　　　<span class=\"keyword\">unsigned</span> env_status;　　   <span class=\"comment\">//Status of the environment</span></div><div class=\"line\">　　　　<span class=\"keyword\">uint32_t</span> env_runs;         <span class=\"comment\">//Number of the times environment has run</span></div><div class=\"line\">　　　　<span class=\"keyword\">pde_t</span> \\*env_pgdir;　　　　<span class=\"comment\">//Kernel virtual address of page dir.</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>具体含义如下:<br><code>env_tf</code>:<br>　　定义在<code>inc/trap.h</code>文件中,里面存放着当用户环境暂停运行时,所有重要寄存器的值.内核也会在系统从用户态切换到内核态时保存这些值,这样的话用户环境可以在之后被恢复,继续执行.<br><code>env_link</code>:<br>　　该指针指向在<code>env_free_list</code>中第一个空闲的<code>Env</code>结构体.前提是这个结构体还没有被分配给任意一个用户环境时.<br><code>env_id</code>:<br>　　唯一的确定使用这个结构体的用户环境.当这个用户环境终止,内核会把这个结构体分配给另外一个不同的环境,这个新的环境会有不同的<code>env_id</code>值.<br><code>env_parent_id</code>:<br>　　创建这个用户环境的父用户环境的<code>env_id</code><br><code>env_type</code>:<br>　　用于区别某个特定的用户环境.对于大多数环境来说,它的值都是 <code>ENV_TYPE_USER</code>.<br><code>env_status</code>:<br>　　表示环境的状态,存放以下可能的值:<br>　　<code>ENV_FREE</code>: 结构体是空闲的,应该在链表<code>env_free_list</code>中.<br>　　<code>ENV_RUNNABLE</code>: 结构体对应的用户环境已经就绪,等待被分配处理机.<br>　　<code>ENV_RUNNING</code>: 结构体对应的用户环境正在运行.<br>　　<code>ENV_NOT_RUNNABLE</code>: 结构体所代表的是一个活跃的用户环境,但是它不能被调度运行,因为它在等待其他环境传递给它的消息.<br>　　<code>ENV_DYING</code>: 代表这个结构体对应的是一个僵尸环境.一个僵尸环境在下一次陷入内核时会被释放回收.<br><code>env_pgdir</code>:<br>　　存放这个环境的页目录的虚拟地址</p>\n<p>正如<code>Unix</code>中的进程一样,一个JOS环境中结合了“线程”和“地址空间”的概念.线程通常是由被保存的寄存器的值来定义的,而地址空间则是由<code>env_pgdir</code>所指向的页目录表还有页表来定义的.为了运行一个用户环境,内核必须设置合适的寄存器的值以及合适的地址空间.</p>\n<h3 id=\"分配环境数组\"><a href=\"#分配环境数组\" class=\"headerlink\" title=\"分配环境数组\"></a>分配环境数组</h3><p>lab2中<code>mem_init()</code>函数中分配了<code>pages</code>数组的地址空间,用于记录内核中所有的页的信息.lab3需要进一步去修改<code>mem_init()</code>函数,分配<code>Env</code>结构体数组<code>envs</code>.</p>\n<h4 id=\"练习1\"><a href=\"#练习1\" class=\"headerlink\" title=\"练习1:\"></a>练习1:</h4><p>问:</p>\n<blockquote>\n<p>修改<code>mem_init()</code>的代码,让它能够分配<code>envs</code>数组.这个数组是由<code>NENV</code>个<code>Env</code>结构体组成的.<code>envs</code>数组所在的内存空间在用户模式下是只读的,被映射到虚拟地址<code>UENVS</code>处.</p>\n</blockquote>\n<p>解:</p>\n<blockquote>\n<p>如同Lab2里面分配pages数组,分配一个<code>Env</code>数组给指针<code>envs</code>即可<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//kern/pmap.c</span></div><div class=\"line\"><span class=\"comment\">//分配内存空间给envs</span></div><div class=\"line\">envs = (<span class=\"keyword\">struct</span> Env*)boot_alloc(NENV*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> Env));</div><div class=\"line\"><span class=\"built_in\">memset</span>(envs, <span class=\"number\">0</span>, NENV * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> Env));</div><div class=\"line\"><span class=\"comment\">//页表中设置envs的映射关系</span></div><div class=\"line\">boot_map_region(kern_pgdir, UENVS, PTSIZE, PADDR(envs), PTE_U);</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"创建运行环境\"><a href=\"#创建运行环境\" class=\"headerlink\" title=\"创建运行环境\"></a>创建运行环境</h3><p>编写 <code>kern/env.c</code>文件来运行一个用户环境了.由于现在没有文件系统,所以必须把内核设置成能够加载内核中的静态二进制程序映像文件.在<code>i386_init()</code>函数中,编码完成运行用户环境的功能.</p>\n<h4 id=\"练习2\"><a href=\"#练习2\" class=\"headerlink\" title=\"练习2:\"></a>练习2:</h4><p>问:</p>\n<blockquote>\n<p>在文件<code>env.c</code>中,完成下列函数：<br><code>env_init()</code>:<br>初始化所有的在<code>envs</code>数组中的<code>Env</code>结构体,并把它们加入到 <code>env_free_list</code>中. 还要调用<code>env_init_percpu</code>,这个函数要配置段式内存管理系统,让它所管理的段具有两种访问优先级的一种,一个是内核运行时的0优先级,以及用户运行时的3优先级.<br><code>env_setup_vm()</code>:<br>为一个新的用户环境分配一个页目录表,并且初始化这个用户环境的地址空间中的和内核相关的部分.<br><code>region_alloc()</code>:<br>为用户环境分配物理地址空间<br><code>load_icode()</code>:<br>分析一个<code>ELF</code>文件,把它的内容加载到用户环境下.<br><code>env_create()</code>:<br>利用<code>env_alloc</code>函数和<code>load_icode</code>函数,加载一个<code>ELF</code>文件到用户环境中<br><code>env_run()</code>:<br>在用户模式下,开始运行一个用户环境.</p>\n</blockquote>\n<p>解:</p>\n<blockquote>\n<p><code>env_init</code>函数,通过遍历<code>envs</code>数组中的所有<code>Env</code>结构体,把每一个结构体的 <code>env_id</code>字段置0,因为要求所有的<code>Env</code>在<code>env_free_list</code>中的顺序,要和它在 <code>envs</code>中的顺序一致,采用头插法.　　<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">env_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">// Set up envs array</span></div><div class=\"line\">    <span class=\"keyword\">int</span> i;</div><div class=\"line\">    env_free_list = <span class=\"literal\">NULL</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (i=NENV<span class=\"number\">-1</span>; i&gt;=<span class=\"number\">0</span>; i--)&#123;</div><div class=\"line\">        envs[i].env_id = <span class=\"number\">0</span>;</div><div class=\"line\">        envs[i].env_status = ENV_FREE;</div><div class=\"line\">        envs[i].env_link = env_free_list;</div><div class=\"line\">        env_free_list = &amp;envs[i];</div><div class=\"line\">     &#125;</div><div class=\"line\">     <span class=\"comment\">// Per-CPU part of the initialization</span></div><div class=\"line\">     env_init_percpu();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>env_setup_vm()</code>初始化新的用户环境的页目录表,只设置页目录表中和操作系统内核跟内核相关的页目录项,用户环境的页目录项不要设置,因为所有用户环境的页目录表中和操作系统相关的页目录项都是一样的（除了虚拟地址<code>UVPT</code>,单独进行设置）,所以可以参照<code>kern_pgdir</code>中的内容来设置<code>env_pgdir</code>中的内容.<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span></span></div><div class=\"line\"><span class=\"title\">env_setup_vm</span><span class=\"params\">(<span class=\"keyword\">struct</span> Env *e)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> i;</div><div class=\"line\">    <span class=\"keyword\">struct</span> PageInfo* p = <span class=\"literal\">NULL</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Allocate a page for the page directory</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (!(p = page_alloc(ALLOC_ZERO)))</div><div class=\"line\">        <span class=\"keyword\">return</span> -E_NO_MEM;</div><div class=\"line\"></div><div class=\"line\">     e-&gt;env_pgdir = (<span class=\"keyword\">pde_t</span> *)page2kva(p);</div><div class=\"line\">     p-&gt;pp_ref++;</div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">//Map the directory below UTOP.</span></div><div class=\"line\">     <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; PDX(UTOP); i++)</div><div class=\"line\">         e-&gt;env_pgdir[i] = <span class=\"number\">0</span>;        </div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">//Map the directory above UTOP</span></div><div class=\"line\">     <span class=\"keyword\">for</span> (i = PDX(UTOP); i &lt; NPDENTRIES; i++) &#123;</div><div class=\"line\">         e-&gt;env_pgdir[i] = kern_pgdir[i];</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">// UVPT maps the env's own page table read-only.</span></div><div class=\"line\">     <span class=\"comment\">// Permissions: kernel R, user R</span></div><div class=\"line\">     e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;</div><div class=\"line\"></div><div class=\"line\">     <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<p><code>region_alloc()</code>为用户环境分配物理空间,这里注意我们要先把起始地址和终止地址进行页对齐,对其之后我们就可以以页为单位,为其一个页一个页的分配内存,并且修改页目录表和页表.<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">region_alloc</span><span class=\"params\">(<span class=\"keyword\">struct</span> Env *e, <span class=\"keyword\">void</span> *va, <span class=\"keyword\">size_t</span> len)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">void</span>* start = (<span class=\"keyword\">void</span> *)ROUNDDOWN((<span class=\"keyword\">uint32_t</span>)va, PGSIZE);</div><div class=\"line\">    <span class=\"keyword\">void</span>* end = (<span class=\"keyword\">void</span> *)ROUNDUP((<span class=\"keyword\">uint32_t</span>)va+len, PGSIZE);</div><div class=\"line\">    <span class=\"keyword\">struct</span> PageInfo *p = <span class=\"literal\">NULL</span>;</div><div class=\"line\">    <span class=\"keyword\">void</span>* i;</div><div class=\"line\">    <span class=\"keyword\">int</span> r;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span>(i = start; i &lt; end; i += PGSIZE)&#123;</div><div class=\"line\">        p = page_alloc(<span class=\"number\">0</span>);</div><div class=\"line\">        <span class=\"keyword\">if</span>(p == <span class=\"literal\">NULL</span>)</div><div class=\"line\">           panic(<span class=\"string\">\" region alloc failed: allocation failed.\\n\"</span>);</div><div class=\"line\"></div><div class=\"line\">        r = page_insert(e-&gt;env_pgdir, p, i, PTE_W | PTE_U);</div><div class=\"line\">        <span class=\"keyword\">if</span>(r != <span class=\"number\">0</span>)</div><div class=\"line\">            panic(<span class=\"string\">\"region alloc failed.\\n\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>　<code>load_icode()</code>为每一个用户进程设置它的初始代码区,堆栈以及CPU标识.用户程序是<code>ELF</code>文件,解析<code>ELF</code>文件.<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">load_icode</span><span class=\"params\">(<span class=\"keyword\">struct</span> Env *e, <span class=\"keyword\">uint8_t</span> *binary)</span></div><div class=\"line\">&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">struct</span> Elf* header = (<span class=\"keyword\">struct</span> Elf*)binary;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (header-&gt;e_magic != ELF_MAGIC)</div><div class=\"line\">        panic(<span class=\"string\">\"load_icode failed: The binary we load is not elf.\\n\"</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (header-&gt;e_entry == <span class=\"number\">0</span>)</div><div class=\"line\">        panic(<span class=\"string\">\"load_icode failed: The elf file can't be excuterd.\\n\"</span>);</div><div class=\"line\"></div><div class=\"line\">   e-&gt;env_tf.tf_eip = header-&gt;e_entry;</div><div class=\"line\"></div><div class=\"line\">   lcr3(PADDR(e-&gt;env_pgdir));   <span class=\"comment\">//load user pgdir</span></div><div class=\"line\"></div><div class=\"line\">   <span class=\"keyword\">struct</span> Proghdr *ph, *eph;</div><div class=\"line\">   ph = (<span class=\"keyword\">struct</span> Proghdr* )((<span class=\"keyword\">uint8_t</span> *)header + header-&gt;e_phoff);</div><div class=\"line\">   eph = ph + header-&gt;e_phnum;</div><div class=\"line\">    <span class=\"keyword\">for</span>(; ph &lt; eph; ph++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(ph-&gt;p_type == ELF_PROG_LOAD) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(ph-&gt;p_memsz - ph-&gt;p_filesz &lt; <span class=\"number\">0</span>)</div><div class=\"line\">                panic(<span class=\"string\">\"load icode failed : p_memsz &lt; p_filesz.\\n\"</span>);</div><div class=\"line\"></div><div class=\"line\">           region_alloc(e, (<span class=\"keyword\">void</span> *)ph-&gt;p_va, ph-&gt;p_memsz);</div><div class=\"line\">            memmove((<span class=\"keyword\">void</span> *)ph-&gt;p_va, binary + ph-&gt;p_offset, ph-&gt;p_filesz);</div><div class=\"line\">            <span class=\"built_in\">memset</span>((<span class=\"keyword\">void</span> *)(ph-&gt;p_va + ph-&gt;p_filesz), <span class=\"number\">0</span>, ph-&gt;p_memsz - ph-&gt;p_filesz);</div><div class=\"line\">        &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>env_create</code>是利用<code>env_alloc</code>函数和<code>load_icode</code>函数,加载一个<code>ELF</code>文件到用户环境中<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">env_create</span><span class=\"params\">(<span class=\"keyword\">uint8_t</span> *binary, <span class=\"keyword\">enum</span> EnvType type)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">struct</span> Env *e;</div><div class=\"line\">    <span class=\"keyword\">int</span> rc;</div><div class=\"line\">    <span class=\"keyword\">if</span> ((rc = env_alloc(&amp;e, <span class=\"number\">0</span>)) != <span class=\"number\">0</span>)</div><div class=\"line\">          panic(<span class=\"string\">\"env_create failed: env_alloc failed.\\n\"</span>);</div><div class=\"line\"></div><div class=\"line\">     load_icode(e, binary);</div><div class=\"line\">     e-&gt;env_type = type;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<p><code>env_run</code>开始运行一个用户环境<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">env_run</span><span class=\"params\">(<span class=\"keyword\">struct</span> Env *e)</span></div><div class=\"line\">&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(curenv != <span class=\"literal\">NULL</span> &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)</div><div class=\"line\">        curenv-&gt;env_status = ENV_RUNNABLE;</div><div class=\"line\"></div><div class=\"line\">    curenv = e;</div><div class=\"line\">    curenv-&gt;env_status = ENV_RUNNING;</div><div class=\"line\">    curenv-&gt;env_runs++;</div><div class=\"line\">    lcr3(PADDR(curenv-&gt;env_pgdir));</div><div class=\"line\"></div><div class=\"line\">    env_pop_tf(&amp;curenv-&gt;env_tf);</div><div class=\"line\"></div><div class=\"line\">    panic(<span class=\"string\">\"env_run not yet implemented\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>用户环境的代码被调用前,操作系统一共按顺序执行了以下几个函数：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">* start (kern/entry.S)</div><div class=\"line\">* i386_init (kern/init.c)</div><div class=\"line\">cons_init</div><div class=\"line\">mem_init</div><div class=\"line\">env_init</div><div class=\"line\">trap_init （目前还未实现）</div><div class=\"line\">env_create</div><div class=\"line\">env_run</div><div class=\"line\">env_pop_tf</div></pre></td></tr></table></figure></p>\n<p>完成上述子函数的代码后,并且在<code>QEMU</code>下编译运行,系统会进入用户空间,并且开始执行<code>hello</code>程序,直到它做出一个系统调用指令<code>int</code>.但是这个系统调用指令不能成功运行,因为到目前为止,JOS还没有设置相关硬件来实现从用户态向内核态的转换功能.当CPU发现,它没有被设置成能够处理这种系统调用中断时,它会触发一个保护异常,然后发现这个保护异常也无法处理,从而又产生一个错误异常,然后又发现仍旧无法解决问题,所以最后放弃,这种异常被称为”triple fault”.通常来说,接下来CPU会复位,系统会重启.</p>\n<h3 id=\"处理中断和异常\"><a href=\"#处理中断和异常\" class=\"headerlink\" title=\"处理中断和异常\"></a>处理中断和异常</h3><p>到目前为止,当程序运行到第一个系统调用<code>int $0x30</code>时,就会进入错误的状态,因为现在系统无法从用户态切换到内核态.需要实现一个基本的异常处理机制,使得内核可以从用户态转换为内核态.学习X86的异常中断机制.</p>\n<h3 id=\"受保护的控制转移\"><a href=\"#受保护的控制转移\" class=\"headerlink\" title=\"受保护的控制转移\"></a>受保护的控制转移</h3><p>异常(Exception)和中断(Interrupts)都是“受到保护的控制转移方法”,都会使CPU从用户态转移为内核态.在Intel的术语中,一个中断指的是由外部异步事件引起的CPU控制权转移,比如外部IO设备发送来的中断信号.一个异常则是由于当前正在运行的指令所带来的同步的CPU控制权的转移,比如除零异常.</p>\n<p>为了能够确保这些控制的转移能够真正被保护起来,CPU的中断/异常机制通常被设计为：用户态的代码无权选择内核中的代码从哪里开始执行.CPU可以确保只有在某些条件下,才能进入内核态.在X86上,有两种机制配合工作来提供这种保护：</p>\n<blockquote>\n<ol>\n<li><p><strong>中断向量表 The Interrupt Descriptor Table</strong>：<br>CPU保证中断和异常只能够引起内核进入到一些特定的,被事先定义好的程序入口,而不是由触发中断的程序来决定中断程序入口.<br>X86有256个不同的中断和异常,对应特定的中断向量.一个向量指的就是0到255中的一个数.一个中断向量的值是根据中断源来决定的：不同设备/错误/对内核的请求,会产生出不同的中断和中断向量的组合.CPU将使用这个向量作为这个中断在中断向量表中的索引,这个表是由内核设置的,放在内核空间中.通过<code>IDT</code>中的任意一个表项,CPU得到以下信息:</p>\n<blockquote>\n<ul>\n<li>加载到<code>EIP</code>寄存器中的值,这个值指向了处理这个中断的中断处理程序的位置.</li>\n<li>加载到<code>CS</code>寄存器中的值,里面还包含了这个中断处理程序的运行特权级.</li>\n</ul>\n</blockquote>\n</li>\n<li><p><strong>任务状态段 The Task State Segment</strong><br>CPU还需要一个地方来存放异常/中断发生时CPU的状态,比如<code>EIP</code>和<code>CS</code>寄存器的值.这样的话,中断处理程序能够顺利重新返回到原来的程序中.这段内存自然也要保护起来,不能被用户态的程序所篡改.<br>正因为如此,当一个x86CPU要处理一个中断,异常并且使运行特权级从用户态转为内核态时,它也会把它的堆栈切换到内核空间中.一个叫做 “任务状态段（TSS）”的数据结构将会详细记录这个堆栈所在的段的段描述符和地址.CPU把<code>SS,ESP,EFLAGS,CS,EIP</code>以及一个可选错误码等等这些值压入到这个堆栈上.然后加载中断处理程序的<code>CS,EIP</code>值,并且设置<code>ESP,SS</code>寄存器指向新的堆栈.由于JOS中的内核态指的就是特权级0,所以CPU用<code>TSS</code>中的<code>ESP0,SS0</code>字段来指明这个内核堆栈的位置,大小.</p>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"中断-异常的类型\"><a href=\"#中断-异常的类型\" class=\"headerlink\" title=\"中断/异常的类型\"></a>中断/异常的类型</h3><p>所有的由X86CPU内部产生的异常的向量值是0到31之间的整数.比如,页表错误所对应的向量值是14.而大于31号的中断向量对应的是软件中断,由int指令生成；或者是外部中断,由外部设备生成.</p>\n<p>part1扩展JOS的功能,使它能够处理0~31号内部异常.part2让JOS能够处理48号软件中断,主要被用来做系统调用.在Lab4中会继续扩展JOS使它能够处理外部硬件中断,比如时钟中断.</p>\n<p>实例:</p>\n<blockquote>\n<p>假设CPU正在用户状态下运行代码,但是遇到了一个除法指令,并且除数为0.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">+--------------------+ KSTACKTOP             </div><div class=\"line\">| 0x00000 | old SS   |     &quot; - 4</div><div class=\"line\">|      old ESP       |     &quot; - 8</div><div class=\"line\">|     old EFLAGS     |     &quot; - 12</div><div class=\"line\">| 0x00000 | old CS   |     &quot; - 16</div><div class=\"line\">|      old EIP       |     &quot; - 20 &lt;---- ESP</div><div class=\"line\">+--------------------+</div></pre></td></tr></table></figure></p>\n<p>发生除零异常后,CPU运行如下:</p>\n<ol>\n<li>CPU会首先切换自己的堆栈,切换到由<code>TSS</code>的<code>SS0,ESP0</code>字段所指定的内核堆栈区,这两个字段分别存放着<code>GD_KD</code>和<code>KSTACKTOP</code>的值.</li>\n<li>CPU把异常参数压入到内核堆栈中,起始于地址<code>KSTACKTOP</code>：</li>\n<li>因为要处理的是除零异常,它的中断向量是0,CPU会读取<code>IDT</code>表中的0号表项,并且把<code>CS:EIP</code>的值设置为0号中断处理函数的地址值.</li>\n<li>中断处理函数开始执行,处理中断.</li>\n</ol>\n<p>对于某些特定的异常,除了中要保存的五个值之外,还要再压入一个字,叫做错误码(error code).比如页表错误,就是其中一个实例.当压入错误码之后,内核堆栈的状态如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">+--------------------+ KSTACKTOP             </div><div class=\"line\">| 0x00000 | old SS   |     &quot; - 4</div><div class=\"line\">|      old ESP       |     &quot; - 8</div><div class=\"line\">|     old EFLAGS     |     &quot; - 12</div><div class=\"line\">| 0x00000 | old CS   |     &quot; - 16</div><div class=\"line\">|      old EIP       |     &quot; - 20</div><div class=\"line\">|     error code     |     &quot; - 24 &lt;---- ESP</div><div class=\"line\">+--------------------+</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"中断-异常的嵌套\"><a href=\"#中断-异常的嵌套\" class=\"headerlink\" title=\"中断/异常的嵌套\"></a>中断/异常的嵌套</h3><p>　　CPU在用户态下和内核态下都可以处理异常或中断.只有当CPU从用户态切换到内核态时,硬件才会自动地切换堆栈,并且把一些寄存器中的原来的值压入到堆栈上,并且触发相应的中断处理函数.但如果CPU已经由于正在处理中断而处在内核态下时,此时CPU会向内核堆栈压入更多的值.通过这种方式,内核就可处理嵌套中断.<br>　　如果CPU已经在内核态下并且遇到嵌套中断,因为它不需要切换堆栈,所以它不需要存储<code>SS,ESP</code>寄存器的值.此时内核堆栈如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">+--------------------+ &lt;---- old ESP</div><div class=\"line\">|     old EFLAGS     |     &quot; - 4</div><div class=\"line\">| 0x00000 | old CS   |     &quot; - 8</div><div class=\"line\">|      old EIP       |     &quot; - 12</div><div class=\"line\">+--------------------+</div></pre></td></tr></table></figure></p>\n<p>但可能会发生一个问题: 如果CPU在内核态下捕捉一个异常,而且由于一些原因,比如堆栈空间不足,不能把当前的状态信息（寄存器的值）压入到内核堆栈中时,那么CPU是无法恢复到原来的状态,它会自动重启.</p>\n<h3 id=\"设置IDT\"><a href=\"#设置IDT\" class=\"headerlink\" title=\"设置IDT\"></a>设置IDT</h3><p>上文确定了基本信息, 可以设置IDT表,并在JOS处理异常了.Lab3只需要处理内部异常（中断向量号0~31）.在头文件<code>inc/trap.h和kern/trap.h</code>中包含了和中断异常相关的的定义.<br>最后要实现的效果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">IDT                   trapentry.S         trap.c</div><div class=\"line\"></div><div class=\"line\">+----------------+                        </div><div class=\"line\">|   &amp;handler1    |---------&gt; handler1:          trap (struct Trapframe *tf)</div><div class=\"line\">|                |             // do stuff      &#123;</div><div class=\"line\">|                |             call trap          // handle the exception/interrupt</div><div class=\"line\">|                |             // ...           &#125;</div><div class=\"line\">+----------------+</div><div class=\"line\">|   &amp;handler2    |--------&gt; handler2:</div><div class=\"line\">|                |            // do stuff</div><div class=\"line\">|                |            call trap</div><div class=\"line\">|                |            // ...</div><div class=\"line\">+----------------+</div><div class=\"line\"> .</div><div class=\"line\"> .</div><div class=\"line\"> .</div><div class=\"line\">+----------------+</div><div class=\"line\">|   &amp;handlerX    |--------&gt; handlerX:</div><div class=\"line\">|                |             // do stuff</div><div class=\"line\">|                |             call trap</div><div class=\"line\">|                |             // ...</div><div class=\"line\">+----------------+</div></pre></td></tr></table></figure></p>\n<p>每一个中断/异常都有它自己的中断处理函数,定义在<code>trapentry.S</code>中.<code>trap_init()</code>将初始化<code>IDT</code>表.每一个处理函数都构建一个结构体 <code>Trapframe</code>在堆栈上,并且调用<code>trap()</code>函数指向这个结构体,<code>trap()</code>然后处理异常/中断,给它分配一个中断处理函数.<br>所以操作系统的中断控制流程为：</p>\n<blockquote>\n<ol>\n<li><code>trap_init()</code>先将所有中断处理函数的起始地址放到中断向量表<code>IDT</code>中.</li>\n<li>当中断发生时,不管是外部中断还是内部中断,CPU捕捉到该中断,进入核心态,根据中断向量去查询中断向量表,找到对应的表项</li>\n<li>保存被中断的程序的上下文到内核堆栈中,调用这个表项中指明的中断处理函数.</li>\n<li>执行中断处理函数.</li>\n<li>执行完成后,恢复被中断的进程的上下文,返回用户态,继续运行这个进程.</li>\n</ol>\n</blockquote>\n<h4 id=\"练习4\"><a href=\"#练习4\" class=\"headerlink\" title=\"练习4\"></a>练习4</h4><p>问</p>\n<blockquote>\n<p>修改<code>trapentry.S</code>和<code>trap.c</code>文件,实现上述的功能.在<code>trapentry.S</code>文件中为在<code>inc/trap.h</code>文件中的每一个<code>trap</code>加入一个入口指针, 修改<code>trap_init()</code>函数来初始化<code>IDT</code>表,使表中每一项指向定义在<code>trapentry.S</code>中的入口指针.<br><code>_alltraps</code>要求:</p>\n<ol>\n<li>把值压入堆栈,使堆栈结构类似一个结构体<code>Trapframe</code></li>\n<li>加载<code>GD_KD</code>的值到<code>%ds, %es</code>寄存器中</li>\n<li>压栈<code>%esp</code>的值,并且传递一个指向<code>Trapframe</code>的指针到`trap()``函数中.</li>\n<li>调用<code>trap</code><br>解<br>在<code>trapentry.S</code>文件定义了两个宏,<code>TRAPHANDLER</code>,<code>TRAPHANDLER_NOEC</code>.其功能为：声明了一个全局符号name,并且这个符号是函数类型的,代表它是一个中断处理函数名.当系统检测到一个中断/异常时,首先需要完成的一部分操作,包括：中断异常码,中断错误码(error code).因为有些中断有中断错误码,有些没有,所以采用两个宏定义函数.<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> TRAPHANDLER(name, num)                        \\</span></div><div class=\"line\">        .globl name;            <span class=\"comment\">/* define global symbol for 'name' */</span>   \\</div><div class=\"line\">        .type name, @function;  <span class=\"comment\">/* symbol type is function */</span>           \\</div><div class=\"line\">        .align 2;               <span class=\"comment\">/* align function definition */</span>         \\</div><div class=\"line\">        name:                   <span class=\"comment\">/* function starts here */</span>              \\</div><div class=\"line\">        pushl $(num);                                                   \\</div><div class=\"line\">        jmp _alltraps</div><div class=\"line\"><span class=\"comment\">/* Use TRAPHANDLER_NOEC for traps where the CPU doesn't push an error code.</span></div><div class=\"line\"> * It pushes a 0 in place of the error code, so the trap frame has the same</div><div class=\"line\"> * format in either case.</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> TRAPHANDLER_NOEC(name, num)                                     \\</span></div><div class=\"line\">        .globl name;                                                    \\</div><div class=\"line\">        .type name, @function;                                          \\</div><div class=\"line\">        .align 2;                                                       \\</div><div class=\"line\">        name:                                                           \\</div><div class=\"line\">        pushl $0;                                                       \\</div><div class=\"line\">        pushl $(num);                                                   \\</div><div class=\"line\">        jmp _alltraps</div><div class=\"line\"></div><div class=\"line\">.text</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\"> * Lab 3: Your code here for generating entry points for the different traps.</div><div class=\"line\"> */</div><div class=\"line\">TRAPHANDLER_NOEC(divide_entry, T_DIVIDE);</div><div class=\"line\">TRAPHANDLER_NOEC(debug_entry, T_DEBUG);</div><div class=\"line\">TRAPHANDLER_NOEC(nmi_entry, T_NMI);</div><div class=\"line\">TRAPHANDLER_NOEC(brkpt_entry, T_BRKPT);</div><div class=\"line\">TRAPHANDLER_NOEC(oflow_entry, T_OFLOW);</div><div class=\"line\">TRAPHANDLER_NOEC(bound_entry, T_BOUND);</div><div class=\"line\">TRAPHANDLER_NOEC(illop_entry, T_ILLOP);</div><div class=\"line\">TRAPHANDLER_NOEC(device_entry, T_DEVICE);</div><div class=\"line\">TRAPHANDLER(dblflt_entry, T_DBLFLT);</div><div class=\"line\">TRAPHANDLER(tss_entry, T_TSS);</div><div class=\"line\">TRAPHANDLER(segnp_entry, T_SEGNP);</div><div class=\"line\">TRAPHANDLER(stack_entry, T_STACK);</div><div class=\"line\">TRAPHANDLER(gpflt_entry, T_GPFLT);</div><div class=\"line\">TRAPHANDLER(pgflt_entry, T_PGFLT);</div><div class=\"line\">TRAPHANDLER_NOEC(fperr_entry, T_FPERR);</div><div class=\"line\">TRAPHANDLER(align_entry, T_ALIGN);</div><div class=\"line\">TRAPHANDLER_NOEC(mchk_entry, T_MCHK);</div><div class=\"line\">TRAPHANDLER_NOEC(simderr_entry, T_SIMDERR);</div><div class=\"line\">TRAPHANDLER_NOEC(syscall_entry, T_SYSCALL);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>然后调用<code>_alltraps</code>函数,使程序在之后调用<code>trap.</code>c中的<code>trap</code>函数时,能够正确的访问到输入的参数,即<code>Trapframe</code>指针类型的输入参数<code>tf</code>.<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">_alltraps:</div><div class=\"line\">        pushl %ds</div><div class=\"line\">        pushl %es</div><div class=\"line\">        pushal</div><div class=\"line\"></div><div class=\"line\">        movl $GD_KD, %eax</div><div class=\"line\">        movl %eax, %ds</div><div class=\"line\">        movl %eax, %es</div><div class=\"line\"></div><div class=\"line\">        push %esp</div><div class=\"line\">        call trap</div></pre></td></tr></table></figure></p>\n<p>最后在<code>trap.c</code>中实现<code>trap_init</code>函数,即在<code>IDT</code>表中插入中断向量描述符,可以使用<code>SETGATE</code>宏实现,其定义如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//gate:IDT表的index入口</span></div><div class=\"line\"><span class=\"comment\">//istrap:判断是异常还是中断</span></div><div class=\"line\"><span class=\"comment\">//sel:代码段选择符</span></div><div class=\"line\"><span class=\"comment\">//off:对应的处理函数地址</span></div><div class=\"line\"><span class=\"comment\">//dpl:触发该异常或中断的用户权限.</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SETGATE(gate, istrap, sel, off, dpl)</span></div></pre></td></tr></table></figure></p>\n<p><code>trap_init</code>实现：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">trap_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></div><div class=\"line\">&#123;</div><div class=\"line\">        <span class=\"keyword\">extern</span> <span class=\"keyword\">struct</span> Segdesc gdt[];</div><div class=\"line\"></div><div class=\"line\">        SETGATE(idt[T_DIVIDE], <span class=\"number\">0</span>, GD_KT, divide_entry, <span class=\"number\">0</span>);</div><div class=\"line\">        SETGATE(idt[T_DEBUG], <span class=\"number\">0</span>, GD_KT, debug_entry, <span class=\"number\">0</span>);</div><div class=\"line\">        SETGATE(idt[T_NMI], <span class=\"number\">0</span>, GD_KT, nmi_entry, <span class=\"number\">0</span>);</div><div class=\"line\">        SETGATE(idt[T_BRKPT], <span class=\"number\">0</span>, GD_KT, brkpt_entry, <span class=\"number\">3</span>);</div><div class=\"line\">        SETGATE(idt[T_OFLOW], <span class=\"number\">0</span>, GD_KT, oflow_entry, <span class=\"number\">0</span>);</div><div class=\"line\">        SETGATE(idt[T_BOUND], <span class=\"number\">0</span>, GD_KT, bound_entry, <span class=\"number\">0</span>);</div><div class=\"line\">        SETGATE(idt[T_ILLOP], <span class=\"number\">0</span>, GD_KT, illop_entry, <span class=\"number\">0</span>);</div><div class=\"line\">        SETGATE(idt[T_DEVICE], <span class=\"number\">0</span>, GD_KT, device_entry, <span class=\"number\">0</span>);</div><div class=\"line\">        SETGATE(idt[T_DBLFLT], <span class=\"number\">0</span>, GD_KT, dblflt_entry, <span class=\"number\">0</span>);</div><div class=\"line\">        SETGATE(idt[T_TSS], <span class=\"number\">0</span>, GD_KT, tss_entry, <span class=\"number\">0</span>);</div><div class=\"line\">        SETGATE(idt[T_SEGNP], <span class=\"number\">0</span>, GD_KT, segnp_entry, <span class=\"number\">0</span>);</div><div class=\"line\">        SETGATE(idt[T_STACK], <span class=\"number\">0</span>, GD_KT, stack_entry, <span class=\"number\">0</span>);</div><div class=\"line\">        SETGATE(idt[T_GPFLT], <span class=\"number\">0</span>, GD_KT, gpflt_entry, <span class=\"number\">0</span>);</div><div class=\"line\">        SETGATE(idt[T_PGFLT], <span class=\"number\">0</span>, GD_KT, pgflt_entry, <span class=\"number\">0</span>);</div><div class=\"line\">        SETGATE(idt[T_FPERR], <span class=\"number\">0</span>, GD_KT, fperr_entry, <span class=\"number\">0</span>);</div><div class=\"line\">        SETGATE(idt[T_ALIGN], <span class=\"number\">0</span>, GD_KT, align_entry, <span class=\"number\">0</span>);</div><div class=\"line\">        SETGATE(idt[T_MCHK], <span class=\"number\">0</span>, GD_KT, mchk_entry, <span class=\"number\">0</span>);</div><div class=\"line\">        SETGATE(idt[T_SIMDERR], <span class=\"number\">0</span>, GD_KT, simderr_entry, <span class=\"number\">0</span>);</div><div class=\"line\">        SETGATE(idt[T_SYSCALL], <span class=\"number\">0</span>, GD_KT, syscall_entry, <span class=\"number\">3</span>);</div><div class=\"line\"></div><div class=\"line\">        trap_init_percpu();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><ol>\n<li><p>每个异常/中断具有特定处理函数的目的是什么?（即如果所有异常/中断都传递给同一个处理程序,那么无法提供当前实现中存在的哪些功能?）<br>解:<br>　　不同的中断或者异常当然需要不同的中断处理函数,因为不同的异常/中断可能需要不同的处理方式,比如有些异常是代表指令有错误,则不会返回被中断的命令.而有些中断可能只是为了处理外部IO事件,此时执行完中断函数还要返回到被中断的程序中继续运行.</p>\n</li>\n<li><p>对软中断程序,测试程序预计会产生一般的保护错误（陷阱13）,但软中断的代码说<code>int $14</code>.为什么要产生中断向量13?如果内核允许软中断程序的<code>int $14</code>指令调用内核的页面错误处理程序（中断向量14）,会发生什么?<br>解<br>　　因为当前的系统正在运行在用户态下,特权级为3,而<code>INT</code>指令为系统指令,特权级为0.特权级为3的程序不能直接调用特权级为0的程序,会引发一个<code>General Protection Exception</code>,即`trap 13</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"Lab3-用户环境-Part1\"><a href=\"#Lab3-用户环境-Part1\" class=\"headerlink\" title=\"Lab3 用户环境 Part1\"></a>Lab3 用户环境 Part1</h1><h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><p>os运行分为两个基本状态: 内核态(kernel) 和 用户态(user).对应用进程而言, 运行在用户态下, 通过系统调用接口使用kernel提供的服务.<br>Lab3主要实现的功能是在用户环境下的进程的正常运行.包括三个方面:</p>\n<blockquote>\n<ol>\n<li>实现获得受保护的用户模式环境（即“进程”）运行所需的基本内核功能.</li>\n<li>创建数据结构以增强JOS内核,跟踪用户环境,创建单个用户环境,将程序映像加载到其中并运行.</li>\n<li>使JOS内核能够处理用户环境所产生的任何系统调用,并处理其导致的任何其他异常.</li>\n</ol>\n</blockquote>\n<p>Lab3分为两个部分:</p>\n<blockquote>\n<p>part1. 用户环境和异常处理<br>part2. 缺页中断, 断点异常和系统调用</p>\n</blockquote>","more":"<h2 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h2><p>下载代码<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git pull</div><div class=\"line\">git checkout -b lab3 origin/Lab3</div><div class=\"line\">git merge lab2</div></pre></td></tr></table></figure></p>\n<p>lab3新增的实验相关文件:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">inc/\tenv.h\t      用户模式环境的公共定义</div><div class=\"line\">      trap.h\t    陷阱处理的公共定义</div><div class=\"line\">      syscall.h\t  从用户环境到内核的系统调用的公共定义</div><div class=\"line\">      lib.h\t      用户模式支持库函数的公共定义</div><div class=\"line\">kern/\tenv.h\t      用户模式环境的内核私有定义</div><div class=\"line\">      env.c\t      实现用户模式环境的内核代码</div><div class=\"line\">      trap.h\t    陷阱处理的内核私有定义</div><div class=\"line\">      trap.c\t    陷阱处理代码</div><div class=\"line\">      trapentry.S\t汇编陷阱处理程序入口</div><div class=\"line\">      syscall.h\t  用于系统调用处理的内核私有定义</div><div class=\"line\">      syscall.c\t  系统调用实现代码</div><div class=\"line\">lib/\tMakefrag\t  构建用户模式的库文件的makefile,obj/lib/libJOS.a</div><div class=\"line\">      entry.S\tA   用户环境的汇编入口</div><div class=\"line\">      libmain.c\t  从entry.S调用的用户模式库文件的启动代码</div><div class=\"line\">      syscall.c\t  用户模式下系统调用的存根函数</div><div class=\"line\">      console.c\t  <span class=\"built_in\">putchar</span>和getchar在用户模式下实现 ,提供控制台I/O</div><div class=\"line\">      <span class=\"built_in\">exit</span>.c\t    用户模式下实现退出的代码</div><div class=\"line\">user/\t*\t          各种测试程序</div></pre></td></tr></table></figure></p>\n<h2 id=\"Part1-User-Environment\"><a href=\"#Part1-User-Environment\" class=\"headerlink\" title=\"Part1 User Environment\"></a>Part1 User Environment</h2><p>新包含的文件<code>inc/env.h</code>里面包含了JOS内核的有关用户环境(User Environment)的基本定义.用户环境指的就是一个应用程序运行在系统中所需要的一个上下文环境,操作系统内核使用数据结构<code>Env</code>来记录每一个用户环境的信息.Lab3只会建一个用户环境,但是之后会把它拓展成能够支持多用户环境,即多个用户程序并发执行.</p>\n<p>在<code>kern/env.c</code>文件中,操作系统一共维护了三个重要的和用户环境相关的全局变量：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> Env *envs = <span class=\"literal\">NULL</span>;    <span class=\"comment\">//所有的 Env 结构体l链表</span></div><div class=\"line\"><span class=\"keyword\">struct</span> Env *curenv = <span class=\"literal\">NULL</span>;   <span class=\"comment\">//目前正在运行的用户环境</span></div><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">struct</span> Env *env_free_list;  <span class=\"comment\">//还没有被使用的 Env 结构体链表</span></div></pre></td></tr></table></figure></p>\n<p>一旦JOS启动,<code>envs</code>指针便指向了一个<code>Env</code>结构体链表,表示系统中所有的用户环境的<code>env</code>.JOS内核将支持同一时刻最多<code>NENV</code>个活跃的用户环境,系统会为每一个活跃的用户环境在<code>envs</code>链表中维护一个<code>Env</code>结构体.JOS内核用<code>env_free_list</code>链接起来把所有不活跃的<code>Env</code>结构体,方便进行用户环境<code>env</code>的分配和回收.另外,内核也会把<code>curenv</code>指针指向在任意时刻正在执行的用户环境的<code>Env</code>结构体.在内核启动时,并且还没有任何用户环境运行时,<code>curenv</code>的值为<code>NULL</code>.</p>\n<h3 id=\"环境状态-Environment-Status\"><a href=\"#环境状态-Environment-Status\" class=\"headerlink\" title=\"环境状态 Environment Status\"></a>环境状态 Environment Status</h3><p><code>Env</code>结构体定义在 inc/env.h`:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> Env &#123;</div><div class=\"line\">　　　　<span class=\"keyword\">struct</span> Trapframe env_tf;      <span class=\"comment\">//saved registers</span></div><div class=\"line\">　　　　<span class=\"keyword\">struct</span> Env * env_link;         <span class=\"comment\">//next free Env</span></div><div class=\"line\">　　　　<span class=\"keyword\">envid_t</span> env_id;　　            <span class=\"comment\">//Unique environment identifier</span></div><div class=\"line\">　　　　<span class=\"keyword\">envid_t</span> env_parent_id;        <span class=\"comment\">//envid of this env's parent</span></div><div class=\"line\">　　　　<span class=\"keyword\">enum</span> EnvType env_type;　　<span class=\"comment\">//Indicates special system environment</span></div><div class=\"line\">　　　　<span class=\"keyword\">unsigned</span> env_status;　　   <span class=\"comment\">//Status of the environment</span></div><div class=\"line\">　　　　<span class=\"keyword\">uint32_t</span> env_runs;         <span class=\"comment\">//Number of the times environment has run</span></div><div class=\"line\">　　　　<span class=\"keyword\">pde_t</span> \\*env_pgdir;　　　　<span class=\"comment\">//Kernel virtual address of page dir.</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>具体含义如下:<br><code>env_tf</code>:<br>　　定义在<code>inc/trap.h</code>文件中,里面存放着当用户环境暂停运行时,所有重要寄存器的值.内核也会在系统从用户态切换到内核态时保存这些值,这样的话用户环境可以在之后被恢复,继续执行.<br><code>env_link</code>:<br>　　该指针指向在<code>env_free_list</code>中第一个空闲的<code>Env</code>结构体.前提是这个结构体还没有被分配给任意一个用户环境时.<br><code>env_id</code>:<br>　　唯一的确定使用这个结构体的用户环境.当这个用户环境终止,内核会把这个结构体分配给另外一个不同的环境,这个新的环境会有不同的<code>env_id</code>值.<br><code>env_parent_id</code>:<br>　　创建这个用户环境的父用户环境的<code>env_id</code><br><code>env_type</code>:<br>　　用于区别某个特定的用户环境.对于大多数环境来说,它的值都是 <code>ENV_TYPE_USER</code>.<br><code>env_status</code>:<br>　　表示环境的状态,存放以下可能的值:<br>　　<code>ENV_FREE</code>: 结构体是空闲的,应该在链表<code>env_free_list</code>中.<br>　　<code>ENV_RUNNABLE</code>: 结构体对应的用户环境已经就绪,等待被分配处理机.<br>　　<code>ENV_RUNNING</code>: 结构体对应的用户环境正在运行.<br>　　<code>ENV_NOT_RUNNABLE</code>: 结构体所代表的是一个活跃的用户环境,但是它不能被调度运行,因为它在等待其他环境传递给它的消息.<br>　　<code>ENV_DYING</code>: 代表这个结构体对应的是一个僵尸环境.一个僵尸环境在下一次陷入内核时会被释放回收.<br><code>env_pgdir</code>:<br>　　存放这个环境的页目录的虚拟地址</p>\n<p>正如<code>Unix</code>中的进程一样,一个JOS环境中结合了“线程”和“地址空间”的概念.线程通常是由被保存的寄存器的值来定义的,而地址空间则是由<code>env_pgdir</code>所指向的页目录表还有页表来定义的.为了运行一个用户环境,内核必须设置合适的寄存器的值以及合适的地址空间.</p>\n<h3 id=\"分配环境数组\"><a href=\"#分配环境数组\" class=\"headerlink\" title=\"分配环境数组\"></a>分配环境数组</h3><p>lab2中<code>mem_init()</code>函数中分配了<code>pages</code>数组的地址空间,用于记录内核中所有的页的信息.lab3需要进一步去修改<code>mem_init()</code>函数,分配<code>Env</code>结构体数组<code>envs</code>.</p>\n<h4 id=\"练习1\"><a href=\"#练习1\" class=\"headerlink\" title=\"练习1:\"></a>练习1:</h4><p>问:</p>\n<blockquote>\n<p>修改<code>mem_init()</code>的代码,让它能够分配<code>envs</code>数组.这个数组是由<code>NENV</code>个<code>Env</code>结构体组成的.<code>envs</code>数组所在的内存空间在用户模式下是只读的,被映射到虚拟地址<code>UENVS</code>处.</p>\n</blockquote>\n<p>解:</p>\n<blockquote>\n<p>如同Lab2里面分配pages数组,分配一个<code>Env</code>数组给指针<code>envs</code>即可<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//kern/pmap.c</span></div><div class=\"line\"><span class=\"comment\">//分配内存空间给envs</span></div><div class=\"line\">envs = (<span class=\"keyword\">struct</span> Env*)boot_alloc(NENV*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> Env));</div><div class=\"line\"><span class=\"built_in\">memset</span>(envs, <span class=\"number\">0</span>, NENV * <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> Env));</div><div class=\"line\"><span class=\"comment\">//页表中设置envs的映射关系</span></div><div class=\"line\">boot_map_region(kern_pgdir, UENVS, PTSIZE, PADDR(envs), PTE_U);</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"创建运行环境\"><a href=\"#创建运行环境\" class=\"headerlink\" title=\"创建运行环境\"></a>创建运行环境</h3><p>编写 <code>kern/env.c</code>文件来运行一个用户环境了.由于现在没有文件系统,所以必须把内核设置成能够加载内核中的静态二进制程序映像文件.在<code>i386_init()</code>函数中,编码完成运行用户环境的功能.</p>\n<h4 id=\"练习2\"><a href=\"#练习2\" class=\"headerlink\" title=\"练习2:\"></a>练习2:</h4><p>问:</p>\n<blockquote>\n<p>在文件<code>env.c</code>中,完成下列函数：<br><code>env_init()</code>:<br>初始化所有的在<code>envs</code>数组中的<code>Env</code>结构体,并把它们加入到 <code>env_free_list</code>中. 还要调用<code>env_init_percpu</code>,这个函数要配置段式内存管理系统,让它所管理的段具有两种访问优先级的一种,一个是内核运行时的0优先级,以及用户运行时的3优先级.<br><code>env_setup_vm()</code>:<br>为一个新的用户环境分配一个页目录表,并且初始化这个用户环境的地址空间中的和内核相关的部分.<br><code>region_alloc()</code>:<br>为用户环境分配物理地址空间<br><code>load_icode()</code>:<br>分析一个<code>ELF</code>文件,把它的内容加载到用户环境下.<br><code>env_create()</code>:<br>利用<code>env_alloc</code>函数和<code>load_icode</code>函数,加载一个<code>ELF</code>文件到用户环境中<br><code>env_run()</code>:<br>在用户模式下,开始运行一个用户环境.</p>\n</blockquote>\n<p>解:</p>\n<blockquote>\n<p><code>env_init</code>函数,通过遍历<code>envs</code>数组中的所有<code>Env</code>结构体,把每一个结构体的 <code>env_id</code>字段置0,因为要求所有的<code>Env</code>在<code>env_free_list</code>中的顺序,要和它在 <code>envs</code>中的顺序一致,采用头插法.　　<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">env_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">// Set up envs array</span></div><div class=\"line\">    <span class=\"keyword\">int</span> i;</div><div class=\"line\">    env_free_list = <span class=\"literal\">NULL</span>;</div><div class=\"line\">    <span class=\"keyword\">for</span> (i=NENV<span class=\"number\">-1</span>; i&gt;=<span class=\"number\">0</span>; i--)&#123;</div><div class=\"line\">        envs[i].env_id = <span class=\"number\">0</span>;</div><div class=\"line\">        envs[i].env_status = ENV_FREE;</div><div class=\"line\">        envs[i].env_link = env_free_list;</div><div class=\"line\">        env_free_list = &amp;envs[i];</div><div class=\"line\">     &#125;</div><div class=\"line\">     <span class=\"comment\">// Per-CPU part of the initialization</span></div><div class=\"line\">     env_init_percpu();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>env_setup_vm()</code>初始化新的用户环境的页目录表,只设置页目录表中和操作系统内核跟内核相关的页目录项,用户环境的页目录项不要设置,因为所有用户环境的页目录表中和操作系统相关的页目录项都是一样的（除了虚拟地址<code>UVPT</code>,单独进行设置）,所以可以参照<code>kern_pgdir</code>中的内容来设置<code>env_pgdir</code>中的内容.<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span></span></div><div class=\"line\"><span class=\"title\">env_setup_vm</span><span class=\"params\">(<span class=\"keyword\">struct</span> Env *e)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> i;</div><div class=\"line\">    <span class=\"keyword\">struct</span> PageInfo* p = <span class=\"literal\">NULL</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Allocate a page for the page directory</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (!(p = page_alloc(ALLOC_ZERO)))</div><div class=\"line\">        <span class=\"keyword\">return</span> -E_NO_MEM;</div><div class=\"line\"></div><div class=\"line\">     e-&gt;env_pgdir = (<span class=\"keyword\">pde_t</span> *)page2kva(p);</div><div class=\"line\">     p-&gt;pp_ref++;</div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">//Map the directory below UTOP.</span></div><div class=\"line\">     <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; PDX(UTOP); i++)</div><div class=\"line\">         e-&gt;env_pgdir[i] = <span class=\"number\">0</span>;        </div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">//Map the directory above UTOP</span></div><div class=\"line\">     <span class=\"keyword\">for</span> (i = PDX(UTOP); i &lt; NPDENTRIES; i++) &#123;</div><div class=\"line\">         e-&gt;env_pgdir[i] = kern_pgdir[i];</div><div class=\"line\">     &#125;</div><div class=\"line\"></div><div class=\"line\">     <span class=\"comment\">// UVPT maps the env's own page table read-only.</span></div><div class=\"line\">     <span class=\"comment\">// Permissions: kernel R, user R</span></div><div class=\"line\">     e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;</div><div class=\"line\"></div><div class=\"line\">     <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<p><code>region_alloc()</code>为用户环境分配物理空间,这里注意我们要先把起始地址和终止地址进行页对齐,对其之后我们就可以以页为单位,为其一个页一个页的分配内存,并且修改页目录表和页表.<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">region_alloc</span><span class=\"params\">(<span class=\"keyword\">struct</span> Env *e, <span class=\"keyword\">void</span> *va, <span class=\"keyword\">size_t</span> len)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">void</span>* start = (<span class=\"keyword\">void</span> *)ROUNDDOWN((<span class=\"keyword\">uint32_t</span>)va, PGSIZE);</div><div class=\"line\">    <span class=\"keyword\">void</span>* end = (<span class=\"keyword\">void</span> *)ROUNDUP((<span class=\"keyword\">uint32_t</span>)va+len, PGSIZE);</div><div class=\"line\">    <span class=\"keyword\">struct</span> PageInfo *p = <span class=\"literal\">NULL</span>;</div><div class=\"line\">    <span class=\"keyword\">void</span>* i;</div><div class=\"line\">    <span class=\"keyword\">int</span> r;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span>(i = start; i &lt; end; i += PGSIZE)&#123;</div><div class=\"line\">        p = page_alloc(<span class=\"number\">0</span>);</div><div class=\"line\">        <span class=\"keyword\">if</span>(p == <span class=\"literal\">NULL</span>)</div><div class=\"line\">           panic(<span class=\"string\">\" region alloc failed: allocation failed.\\n\"</span>);</div><div class=\"line\"></div><div class=\"line\">        r = page_insert(e-&gt;env_pgdir, p, i, PTE_W | PTE_U);</div><div class=\"line\">        <span class=\"keyword\">if</span>(r != <span class=\"number\">0</span>)</div><div class=\"line\">            panic(<span class=\"string\">\"region alloc failed.\\n\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>　<code>load_icode()</code>为每一个用户进程设置它的初始代码区,堆栈以及CPU标识.用户程序是<code>ELF</code>文件,解析<code>ELF</code>文件.<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">load_icode</span><span class=\"params\">(<span class=\"keyword\">struct</span> Env *e, <span class=\"keyword\">uint8_t</span> *binary)</span></div><div class=\"line\">&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">struct</span> Elf* header = (<span class=\"keyword\">struct</span> Elf*)binary;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (header-&gt;e_magic != ELF_MAGIC)</div><div class=\"line\">        panic(<span class=\"string\">\"load_icode failed: The binary we load is not elf.\\n\"</span>);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span> (header-&gt;e_entry == <span class=\"number\">0</span>)</div><div class=\"line\">        panic(<span class=\"string\">\"load_icode failed: The elf file can't be excuterd.\\n\"</span>);</div><div class=\"line\"></div><div class=\"line\">   e-&gt;env_tf.tf_eip = header-&gt;e_entry;</div><div class=\"line\"></div><div class=\"line\">   lcr3(PADDR(e-&gt;env_pgdir));   <span class=\"comment\">//load user pgdir</span></div><div class=\"line\"></div><div class=\"line\">   <span class=\"keyword\">struct</span> Proghdr *ph, *eph;</div><div class=\"line\">   ph = (<span class=\"keyword\">struct</span> Proghdr* )((<span class=\"keyword\">uint8_t</span> *)header + header-&gt;e_phoff);</div><div class=\"line\">   eph = ph + header-&gt;e_phnum;</div><div class=\"line\">    <span class=\"keyword\">for</span>(; ph &lt; eph; ph++) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span>(ph-&gt;p_type == ELF_PROG_LOAD) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span>(ph-&gt;p_memsz - ph-&gt;p_filesz &lt; <span class=\"number\">0</span>)</div><div class=\"line\">                panic(<span class=\"string\">\"load icode failed : p_memsz &lt; p_filesz.\\n\"</span>);</div><div class=\"line\"></div><div class=\"line\">           region_alloc(e, (<span class=\"keyword\">void</span> *)ph-&gt;p_va, ph-&gt;p_memsz);</div><div class=\"line\">            memmove((<span class=\"keyword\">void</span> *)ph-&gt;p_va, binary + ph-&gt;p_offset, ph-&gt;p_filesz);</div><div class=\"line\">            <span class=\"built_in\">memset</span>((<span class=\"keyword\">void</span> *)(ph-&gt;p_va + ph-&gt;p_filesz), <span class=\"number\">0</span>, ph-&gt;p_memsz - ph-&gt;p_filesz);</div><div class=\"line\">        &#125;</div><div class=\"line\">     &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><code>env_create</code>是利用<code>env_alloc</code>函数和<code>load_icode</code>函数,加载一个<code>ELF</code>文件到用户环境中<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">env_create</span><span class=\"params\">(<span class=\"keyword\">uint8_t</span> *binary, <span class=\"keyword\">enum</span> EnvType type)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">struct</span> Env *e;</div><div class=\"line\">    <span class=\"keyword\">int</span> rc;</div><div class=\"line\">    <span class=\"keyword\">if</span> ((rc = env_alloc(&amp;e, <span class=\"number\">0</span>)) != <span class=\"number\">0</span>)</div><div class=\"line\">          panic(<span class=\"string\">\"env_create failed: env_alloc failed.\\n\"</span>);</div><div class=\"line\"></div><div class=\"line\">     load_icode(e, binary);</div><div class=\"line\">     e-&gt;env_type = type;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n<p><code>env_run</code>开始运行一个用户环境<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">env_run</span><span class=\"params\">(<span class=\"keyword\">struct</span> Env *e)</span></div><div class=\"line\">&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">if</span>(curenv != <span class=\"literal\">NULL</span> &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)</div><div class=\"line\">        curenv-&gt;env_status = ENV_RUNNABLE;</div><div class=\"line\"></div><div class=\"line\">    curenv = e;</div><div class=\"line\">    curenv-&gt;env_status = ENV_RUNNING;</div><div class=\"line\">    curenv-&gt;env_runs++;</div><div class=\"line\">    lcr3(PADDR(curenv-&gt;env_pgdir));</div><div class=\"line\"></div><div class=\"line\">    env_pop_tf(&amp;curenv-&gt;env_tf);</div><div class=\"line\"></div><div class=\"line\">    panic(<span class=\"string\">\"env_run not yet implemented\"</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>用户环境的代码被调用前,操作系统一共按顺序执行了以下几个函数：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">* start (kern/entry.S)</div><div class=\"line\">* i386_init (kern/init.c)</div><div class=\"line\">cons_init</div><div class=\"line\">mem_init</div><div class=\"line\">env_init</div><div class=\"line\">trap_init （目前还未实现）</div><div class=\"line\">env_create</div><div class=\"line\">env_run</div><div class=\"line\">env_pop_tf</div></pre></td></tr></table></figure></p>\n<p>完成上述子函数的代码后,并且在<code>QEMU</code>下编译运行,系统会进入用户空间,并且开始执行<code>hello</code>程序,直到它做出一个系统调用指令<code>int</code>.但是这个系统调用指令不能成功运行,因为到目前为止,JOS还没有设置相关硬件来实现从用户态向内核态的转换功能.当CPU发现,它没有被设置成能够处理这种系统调用中断时,它会触发一个保护异常,然后发现这个保护异常也无法处理,从而又产生一个错误异常,然后又发现仍旧无法解决问题,所以最后放弃,这种异常被称为”triple fault”.通常来说,接下来CPU会复位,系统会重启.</p>\n<h3 id=\"处理中断和异常\"><a href=\"#处理中断和异常\" class=\"headerlink\" title=\"处理中断和异常\"></a>处理中断和异常</h3><p>到目前为止,当程序运行到第一个系统调用<code>int $0x30</code>时,就会进入错误的状态,因为现在系统无法从用户态切换到内核态.需要实现一个基本的异常处理机制,使得内核可以从用户态转换为内核态.学习X86的异常中断机制.</p>\n<h3 id=\"受保护的控制转移\"><a href=\"#受保护的控制转移\" class=\"headerlink\" title=\"受保护的控制转移\"></a>受保护的控制转移</h3><p>异常(Exception)和中断(Interrupts)都是“受到保护的控制转移方法”,都会使CPU从用户态转移为内核态.在Intel的术语中,一个中断指的是由外部异步事件引起的CPU控制权转移,比如外部IO设备发送来的中断信号.一个异常则是由于当前正在运行的指令所带来的同步的CPU控制权的转移,比如除零异常.</p>\n<p>为了能够确保这些控制的转移能够真正被保护起来,CPU的中断/异常机制通常被设计为：用户态的代码无权选择内核中的代码从哪里开始执行.CPU可以确保只有在某些条件下,才能进入内核态.在X86上,有两种机制配合工作来提供这种保护：</p>\n<blockquote>\n<ol>\n<li><p><strong>中断向量表 The Interrupt Descriptor Table</strong>：<br>CPU保证中断和异常只能够引起内核进入到一些特定的,被事先定义好的程序入口,而不是由触发中断的程序来决定中断程序入口.<br>X86有256个不同的中断和异常,对应特定的中断向量.一个向量指的就是0到255中的一个数.一个中断向量的值是根据中断源来决定的：不同设备/错误/对内核的请求,会产生出不同的中断和中断向量的组合.CPU将使用这个向量作为这个中断在中断向量表中的索引,这个表是由内核设置的,放在内核空间中.通过<code>IDT</code>中的任意一个表项,CPU得到以下信息:</p>\n<blockquote>\n<ul>\n<li>加载到<code>EIP</code>寄存器中的值,这个值指向了处理这个中断的中断处理程序的位置.</li>\n<li>加载到<code>CS</code>寄存器中的值,里面还包含了这个中断处理程序的运行特权级.</li>\n</ul>\n</blockquote>\n</li>\n<li><p><strong>任务状态段 The Task State Segment</strong><br>CPU还需要一个地方来存放异常/中断发生时CPU的状态,比如<code>EIP</code>和<code>CS</code>寄存器的值.这样的话,中断处理程序能够顺利重新返回到原来的程序中.这段内存自然也要保护起来,不能被用户态的程序所篡改.<br>正因为如此,当一个x86CPU要处理一个中断,异常并且使运行特权级从用户态转为内核态时,它也会把它的堆栈切换到内核空间中.一个叫做 “任务状态段（TSS）”的数据结构将会详细记录这个堆栈所在的段的段描述符和地址.CPU把<code>SS,ESP,EFLAGS,CS,EIP</code>以及一个可选错误码等等这些值压入到这个堆栈上.然后加载中断处理程序的<code>CS,EIP</code>值,并且设置<code>ESP,SS</code>寄存器指向新的堆栈.由于JOS中的内核态指的就是特权级0,所以CPU用<code>TSS</code>中的<code>ESP0,SS0</code>字段来指明这个内核堆栈的位置,大小.</p>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"中断-异常的类型\"><a href=\"#中断-异常的类型\" class=\"headerlink\" title=\"中断/异常的类型\"></a>中断/异常的类型</h3><p>所有的由X86CPU内部产生的异常的向量值是0到31之间的整数.比如,页表错误所对应的向量值是14.而大于31号的中断向量对应的是软件中断,由int指令生成；或者是外部中断,由外部设备生成.</p>\n<p>part1扩展JOS的功能,使它能够处理0~31号内部异常.part2让JOS能够处理48号软件中断,主要被用来做系统调用.在Lab4中会继续扩展JOS使它能够处理外部硬件中断,比如时钟中断.</p>\n<p>实例:</p>\n<blockquote>\n<p>假设CPU正在用户状态下运行代码,但是遇到了一个除法指令,并且除数为0.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">+--------------------+ KSTACKTOP             </div><div class=\"line\">| 0x00000 | old SS   |     &quot; - 4</div><div class=\"line\">|      old ESP       |     &quot; - 8</div><div class=\"line\">|     old EFLAGS     |     &quot; - 12</div><div class=\"line\">| 0x00000 | old CS   |     &quot; - 16</div><div class=\"line\">|      old EIP       |     &quot; - 20 &lt;---- ESP</div><div class=\"line\">+--------------------+</div></pre></td></tr></table></figure></p>\n<p>发生除零异常后,CPU运行如下:</p>\n<ol>\n<li>CPU会首先切换自己的堆栈,切换到由<code>TSS</code>的<code>SS0,ESP0</code>字段所指定的内核堆栈区,这两个字段分别存放着<code>GD_KD</code>和<code>KSTACKTOP</code>的值.</li>\n<li>CPU把异常参数压入到内核堆栈中,起始于地址<code>KSTACKTOP</code>：</li>\n<li>因为要处理的是除零异常,它的中断向量是0,CPU会读取<code>IDT</code>表中的0号表项,并且把<code>CS:EIP</code>的值设置为0号中断处理函数的地址值.</li>\n<li>中断处理函数开始执行,处理中断.</li>\n</ol>\n<p>对于某些特定的异常,除了中要保存的五个值之外,还要再压入一个字,叫做错误码(error code).比如页表错误,就是其中一个实例.当压入错误码之后,内核堆栈的状态如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">+--------------------+ KSTACKTOP             </div><div class=\"line\">| 0x00000 | old SS   |     &quot; - 4</div><div class=\"line\">|      old ESP       |     &quot; - 8</div><div class=\"line\">|     old EFLAGS     |     &quot; - 12</div><div class=\"line\">| 0x00000 | old CS   |     &quot; - 16</div><div class=\"line\">|      old EIP       |     &quot; - 20</div><div class=\"line\">|     error code     |     &quot; - 24 &lt;---- ESP</div><div class=\"line\">+--------------------+</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"中断-异常的嵌套\"><a href=\"#中断-异常的嵌套\" class=\"headerlink\" title=\"中断/异常的嵌套\"></a>中断/异常的嵌套</h3><p>　　CPU在用户态下和内核态下都可以处理异常或中断.只有当CPU从用户态切换到内核态时,硬件才会自动地切换堆栈,并且把一些寄存器中的原来的值压入到堆栈上,并且触发相应的中断处理函数.但如果CPU已经由于正在处理中断而处在内核态下时,此时CPU会向内核堆栈压入更多的值.通过这种方式,内核就可处理嵌套中断.<br>　　如果CPU已经在内核态下并且遇到嵌套中断,因为它不需要切换堆栈,所以它不需要存储<code>SS,ESP</code>寄存器的值.此时内核堆栈如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">+--------------------+ &lt;---- old ESP</div><div class=\"line\">|     old EFLAGS     |     &quot; - 4</div><div class=\"line\">| 0x00000 | old CS   |     &quot; - 8</div><div class=\"line\">|      old EIP       |     &quot; - 12</div><div class=\"line\">+--------------------+</div></pre></td></tr></table></figure></p>\n<p>但可能会发生一个问题: 如果CPU在内核态下捕捉一个异常,而且由于一些原因,比如堆栈空间不足,不能把当前的状态信息（寄存器的值）压入到内核堆栈中时,那么CPU是无法恢复到原来的状态,它会自动重启.</p>\n<h3 id=\"设置IDT\"><a href=\"#设置IDT\" class=\"headerlink\" title=\"设置IDT\"></a>设置IDT</h3><p>上文确定了基本信息, 可以设置IDT表,并在JOS处理异常了.Lab3只需要处理内部异常（中断向量号0~31）.在头文件<code>inc/trap.h和kern/trap.h</code>中包含了和中断异常相关的的定义.<br>最后要实现的效果如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\">IDT                   trapentry.S         trap.c</div><div class=\"line\"></div><div class=\"line\">+----------------+                        </div><div class=\"line\">|   &amp;handler1    |---------&gt; handler1:          trap (struct Trapframe *tf)</div><div class=\"line\">|                |             // do stuff      &#123;</div><div class=\"line\">|                |             call trap          // handle the exception/interrupt</div><div class=\"line\">|                |             // ...           &#125;</div><div class=\"line\">+----------------+</div><div class=\"line\">|   &amp;handler2    |--------&gt; handler2:</div><div class=\"line\">|                |            // do stuff</div><div class=\"line\">|                |            call trap</div><div class=\"line\">|                |            // ...</div><div class=\"line\">+----------------+</div><div class=\"line\"> .</div><div class=\"line\"> .</div><div class=\"line\"> .</div><div class=\"line\">+----------------+</div><div class=\"line\">|   &amp;handlerX    |--------&gt; handlerX:</div><div class=\"line\">|                |             // do stuff</div><div class=\"line\">|                |             call trap</div><div class=\"line\">|                |             // ...</div><div class=\"line\">+----------------+</div></pre></td></tr></table></figure></p>\n<p>每一个中断/异常都有它自己的中断处理函数,定义在<code>trapentry.S</code>中.<code>trap_init()</code>将初始化<code>IDT</code>表.每一个处理函数都构建一个结构体 <code>Trapframe</code>在堆栈上,并且调用<code>trap()</code>函数指向这个结构体,<code>trap()</code>然后处理异常/中断,给它分配一个中断处理函数.<br>所以操作系统的中断控制流程为：</p>\n<blockquote>\n<ol>\n<li><code>trap_init()</code>先将所有中断处理函数的起始地址放到中断向量表<code>IDT</code>中.</li>\n<li>当中断发生时,不管是外部中断还是内部中断,CPU捕捉到该中断,进入核心态,根据中断向量去查询中断向量表,找到对应的表项</li>\n<li>保存被中断的程序的上下文到内核堆栈中,调用这个表项中指明的中断处理函数.</li>\n<li>执行中断处理函数.</li>\n<li>执行完成后,恢复被中断的进程的上下文,返回用户态,继续运行这个进程.</li>\n</ol>\n</blockquote>\n<h4 id=\"练习4\"><a href=\"#练习4\" class=\"headerlink\" title=\"练习4\"></a>练习4</h4><p>问</p>\n<blockquote>\n<p>修改<code>trapentry.S</code>和<code>trap.c</code>文件,实现上述的功能.在<code>trapentry.S</code>文件中为在<code>inc/trap.h</code>文件中的每一个<code>trap</code>加入一个入口指针, 修改<code>trap_init()</code>函数来初始化<code>IDT</code>表,使表中每一项指向定义在<code>trapentry.S</code>中的入口指针.<br><code>_alltraps</code>要求:</p>\n<ol>\n<li>把值压入堆栈,使堆栈结构类似一个结构体<code>Trapframe</code></li>\n<li>加载<code>GD_KD</code>的值到<code>%ds, %es</code>寄存器中</li>\n<li>压栈<code>%esp</code>的值,并且传递一个指向<code>Trapframe</code>的指针到`trap()``函数中.</li>\n<li>调用<code>trap</code><br>解<br>在<code>trapentry.S</code>文件定义了两个宏,<code>TRAPHANDLER</code>,<code>TRAPHANDLER_NOEC</code>.其功能为：声明了一个全局符号name,并且这个符号是函数类型的,代表它是一个中断处理函数名.当系统检测到一个中断/异常时,首先需要完成的一部分操作,包括：中断异常码,中断错误码(error code).因为有些中断有中断错误码,有些没有,所以采用两个宏定义函数.<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> TRAPHANDLER(name, num)                        \\</span></div><div class=\"line\">        .globl name;            <span class=\"comment\">/* define global symbol for 'name' */</span>   \\</div><div class=\"line\">        .type name, @function;  <span class=\"comment\">/* symbol type is function */</span>           \\</div><div class=\"line\">        .align 2;               <span class=\"comment\">/* align function definition */</span>         \\</div><div class=\"line\">        name:                   <span class=\"comment\">/* function starts here */</span>              \\</div><div class=\"line\">        pushl $(num);                                                   \\</div><div class=\"line\">        jmp _alltraps</div><div class=\"line\"><span class=\"comment\">/* Use TRAPHANDLER_NOEC for traps where the CPU doesn't push an error code.</span></div><div class=\"line\"> * It pushes a 0 in place of the error code, so the trap frame has the same</div><div class=\"line\"> * format in either case.</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> TRAPHANDLER_NOEC(name, num)                                     \\</span></div><div class=\"line\">        .globl name;                                                    \\</div><div class=\"line\">        .type name, @function;                                          \\</div><div class=\"line\">        .align 2;                                                       \\</div><div class=\"line\">        name:                                                           \\</div><div class=\"line\">        pushl $0;                                                       \\</div><div class=\"line\">        pushl $(num);                                                   \\</div><div class=\"line\">        jmp _alltraps</div><div class=\"line\"></div><div class=\"line\">.text</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/*</span></div><div class=\"line\"> * Lab 3: Your code here for generating entry points for the different traps.</div><div class=\"line\"> */</div><div class=\"line\">TRAPHANDLER_NOEC(divide_entry, T_DIVIDE);</div><div class=\"line\">TRAPHANDLER_NOEC(debug_entry, T_DEBUG);</div><div class=\"line\">TRAPHANDLER_NOEC(nmi_entry, T_NMI);</div><div class=\"line\">TRAPHANDLER_NOEC(brkpt_entry, T_BRKPT);</div><div class=\"line\">TRAPHANDLER_NOEC(oflow_entry, T_OFLOW);</div><div class=\"line\">TRAPHANDLER_NOEC(bound_entry, T_BOUND);</div><div class=\"line\">TRAPHANDLER_NOEC(illop_entry, T_ILLOP);</div><div class=\"line\">TRAPHANDLER_NOEC(device_entry, T_DEVICE);</div><div class=\"line\">TRAPHANDLER(dblflt_entry, T_DBLFLT);</div><div class=\"line\">TRAPHANDLER(tss_entry, T_TSS);</div><div class=\"line\">TRAPHANDLER(segnp_entry, T_SEGNP);</div><div class=\"line\">TRAPHANDLER(stack_entry, T_STACK);</div><div class=\"line\">TRAPHANDLER(gpflt_entry, T_GPFLT);</div><div class=\"line\">TRAPHANDLER(pgflt_entry, T_PGFLT);</div><div class=\"line\">TRAPHANDLER_NOEC(fperr_entry, T_FPERR);</div><div class=\"line\">TRAPHANDLER(align_entry, T_ALIGN);</div><div class=\"line\">TRAPHANDLER_NOEC(mchk_entry, T_MCHK);</div><div class=\"line\">TRAPHANDLER_NOEC(simderr_entry, T_SIMDERR);</div><div class=\"line\">TRAPHANDLER_NOEC(syscall_entry, T_SYSCALL);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>然后调用<code>_alltraps</code>函数,使程序在之后调用<code>trap.</code>c中的<code>trap</code>函数时,能够正确的访问到输入的参数,即<code>Trapframe</code>指针类型的输入参数<code>tf</code>.<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">_alltraps:</div><div class=\"line\">        pushl %ds</div><div class=\"line\">        pushl %es</div><div class=\"line\">        pushal</div><div class=\"line\"></div><div class=\"line\">        movl $GD_KD, %eax</div><div class=\"line\">        movl %eax, %ds</div><div class=\"line\">        movl %eax, %es</div><div class=\"line\"></div><div class=\"line\">        push %esp</div><div class=\"line\">        call trap</div></pre></td></tr></table></figure></p>\n<p>最后在<code>trap.c</code>中实现<code>trap_init</code>函数,即在<code>IDT</code>表中插入中断向量描述符,可以使用<code>SETGATE</code>宏实现,其定义如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//gate:IDT表的index入口</span></div><div class=\"line\"><span class=\"comment\">//istrap:判断是异常还是中断</span></div><div class=\"line\"><span class=\"comment\">//sel:代码段选择符</span></div><div class=\"line\"><span class=\"comment\">//off:对应的处理函数地址</span></div><div class=\"line\"><span class=\"comment\">//dpl:触发该异常或中断的用户权限.</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SETGATE(gate, istrap, sel, off, dpl)</span></div></pre></td></tr></table></figure></p>\n<p><code>trap_init</code>实现：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">trap_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></div><div class=\"line\">&#123;</div><div class=\"line\">        <span class=\"keyword\">extern</span> <span class=\"keyword\">struct</span> Segdesc gdt[];</div><div class=\"line\"></div><div class=\"line\">        SETGATE(idt[T_DIVIDE], <span class=\"number\">0</span>, GD_KT, divide_entry, <span class=\"number\">0</span>);</div><div class=\"line\">        SETGATE(idt[T_DEBUG], <span class=\"number\">0</span>, GD_KT, debug_entry, <span class=\"number\">0</span>);</div><div class=\"line\">        SETGATE(idt[T_NMI], <span class=\"number\">0</span>, GD_KT, nmi_entry, <span class=\"number\">0</span>);</div><div class=\"line\">        SETGATE(idt[T_BRKPT], <span class=\"number\">0</span>, GD_KT, brkpt_entry, <span class=\"number\">3</span>);</div><div class=\"line\">        SETGATE(idt[T_OFLOW], <span class=\"number\">0</span>, GD_KT, oflow_entry, <span class=\"number\">0</span>);</div><div class=\"line\">        SETGATE(idt[T_BOUND], <span class=\"number\">0</span>, GD_KT, bound_entry, <span class=\"number\">0</span>);</div><div class=\"line\">        SETGATE(idt[T_ILLOP], <span class=\"number\">0</span>, GD_KT, illop_entry, <span class=\"number\">0</span>);</div><div class=\"line\">        SETGATE(idt[T_DEVICE], <span class=\"number\">0</span>, GD_KT, device_entry, <span class=\"number\">0</span>);</div><div class=\"line\">        SETGATE(idt[T_DBLFLT], <span class=\"number\">0</span>, GD_KT, dblflt_entry, <span class=\"number\">0</span>);</div><div class=\"line\">        SETGATE(idt[T_TSS], <span class=\"number\">0</span>, GD_KT, tss_entry, <span class=\"number\">0</span>);</div><div class=\"line\">        SETGATE(idt[T_SEGNP], <span class=\"number\">0</span>, GD_KT, segnp_entry, <span class=\"number\">0</span>);</div><div class=\"line\">        SETGATE(idt[T_STACK], <span class=\"number\">0</span>, GD_KT, stack_entry, <span class=\"number\">0</span>);</div><div class=\"line\">        SETGATE(idt[T_GPFLT], <span class=\"number\">0</span>, GD_KT, gpflt_entry, <span class=\"number\">0</span>);</div><div class=\"line\">        SETGATE(idt[T_PGFLT], <span class=\"number\">0</span>, GD_KT, pgflt_entry, <span class=\"number\">0</span>);</div><div class=\"line\">        SETGATE(idt[T_FPERR], <span class=\"number\">0</span>, GD_KT, fperr_entry, <span class=\"number\">0</span>);</div><div class=\"line\">        SETGATE(idt[T_ALIGN], <span class=\"number\">0</span>, GD_KT, align_entry, <span class=\"number\">0</span>);</div><div class=\"line\">        SETGATE(idt[T_MCHK], <span class=\"number\">0</span>, GD_KT, mchk_entry, <span class=\"number\">0</span>);</div><div class=\"line\">        SETGATE(idt[T_SIMDERR], <span class=\"number\">0</span>, GD_KT, simderr_entry, <span class=\"number\">0</span>);</div><div class=\"line\">        SETGATE(idt[T_SYSCALL], <span class=\"number\">0</span>, GD_KT, syscall_entry, <span class=\"number\">3</span>);</div><div class=\"line\"></div><div class=\"line\">        trap_init_percpu();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h3><ol>\n<li><p>每个异常/中断具有特定处理函数的目的是什么?（即如果所有异常/中断都传递给同一个处理程序,那么无法提供当前实现中存在的哪些功能?）<br>解:<br>　　不同的中断或者异常当然需要不同的中断处理函数,因为不同的异常/中断可能需要不同的处理方式,比如有些异常是代表指令有错误,则不会返回被中断的命令.而有些中断可能只是为了处理外部IO事件,此时执行完中断函数还要返回到被中断的程序中继续运行.</p>\n</li>\n<li><p>对软中断程序,测试程序预计会产生一般的保护错误（陷阱13）,但软中断的代码说<code>int $14</code>.为什么要产生中断向量13?如果内核允许软中断程序的<code>int $14</code>指令调用内核的页面错误处理程序（中断向量14）,会发生什么?<br>解<br>　　因为当前的系统正在运行在用户态下,特权级为3,而<code>INT</code>指令为系统指令,特权级为0.特权级为3的程序不能直接调用特权级为0的程序,会引发一个<code>General Protection Exception</code>,即`trap 13</p>\n</li>\n</ol>"},{"title":"lab4-Preemptive Multitasking","date":"2017-05-03T16:00:00.000Z","_content":"# Lab4 抢占式多进程\n## 摘要\nLab4目标是在多用户环境下实现抢占式多进程的支持，分解为三个部分：\n* part1: 在JOS中添加对多处理器的支持，实现循环调度算法，并添加基本的环境管理的系统调用（创建/销毁环境，分配/映射内存）\n* part2：实现类似Unix的`fork`机制，允许在用户模式下创建副本\n* part3：添加对进程间通信(IPC)的支持，允许不同的用户环境进行进程间的通信和同步。并添加对硬件时钟中断和进程抢占的支持。\n\n## 准备\n下载实验代码：\n``` bash\ngit pull\ngit chekout -b lab4 origin/lab4\ngit merge Lab3\n```\nLab4 新增的文件：\n```\nkern/cpu.h\t多处理器支持的内核私有定义\nkern/mpconfig.c\t读取多处理器配置的代码\nkern/lapic.c\t驱动处理器中的本地APIC单元的内核代码\nkern/mpentry.S\t非启动CPU的汇编代码入口\nkern/spinlock.h\t包括大内核锁在内的自旋锁的内和私有定义\nkern/spinlock.c\t自旋锁的内核代码实现\nkern/sched.c\t调度器的代码框架\n```\n\n<!-- more -->\n\n## part1 多处理器支持和多任务协同\nLab4 part1将首先扩展JOS以在多处理器系统上运行，然后实现新的JOS内核系统调用，以允许用户级环境创建其他新的环境。另外实现协同循环调度，当当前环境自动放弃CPU（或退出）时，允许内核从一个环境切换到另一个环境。之后在part3中，还会实现抢占式调度，即使在环境不允许的情况下，允许内核在一定时间内重新从环境中重新控制CPU。\n\n### 多处理器支持\n目标使JOS支持对称多处理器(SMP)。`SMP`是一种多处理器架构，所有的CPU对等地访问系统资源。在SMP中所有CPU的功能是相同的，但是在启动过程中会被分为2类：引导处理器(`BSP`)负责初始化系统来启动操作系统，当操作系统被启动后，应用处理器(`AP`)被引导处理器激活。引导处理器是由硬件和BIOS决定的，目前所有的代码都是运行在BSP上。\n在个SMP系统中，每个CPU有1个附属的`Local APIC（LAPIC）`单元。LAPIC单元负责处理系统中的中断，同时为它关联的CPU提供独一无二的标识符。在part1，将使用LAPIC单元以下基本功能(在`/kern/lapic.c`)：\n* 读取LAPIC的标识符(APIC ID)来告诉我们正在哪个CPU上运行代码(`cpunum()`).\n* 从BSP发送STARTUP的处理器间中断(`IPI`) 到APs来唤醒其它CPU(`lapic_startup()`).\n* 在part3部分，将编程LAPIC内置的计时器来触发时钟中断来支持多任务抢占(`apic_init()`).\n\n处理器访通过内存映射I/O(MMIO)的方式访问它的LAPIC。在MMIO中，一部分物理地址被硬连接到一些IO设备的寄存器上，导致操作内存的指令`load/store`可以直接操作设备的寄存器。我们已经看到过1个`IO hole`在物理地址`0xA0000`(用来写入VGA显示缓存)。LAPIC的hole开始于物理地址`0xFE000000`(4GB之下地32MB)，但是这地址过高，导致无法访问通过过去的直接映射(虚拟地址`0xF0000000`映射0x0，即只有256MB)。但是JOS虚拟地址映射预留了4MB空间在`MMIOBASE`处，需要分配空间一映射设备。\n\n#### 练习1\n问\n> 在`kern/pmap.c`中实现`mmio_map_region`。查看`lapic_init`函数(`kern/lapic.c`)来确定使用方式\n\n解：\n> 在`lapic_init`函数的开头就会调用`mmio_map_region`\n``` c\n// lapicaddr is the physical address of the LAPIC's 4K MMIO\n// region.  Map it in to virtual memory so we can access it.\nlapic = mmio_map_region(lapicaddr, 4096);\n```\n> 在`kern/pmap.c`中，有具体的提示，设置个静态变量记录每次变化后的虚拟基地址，使用`boot_map_region`函数将`[pa,pa+size)的`物理地址映射到`[base,base+size)`，把`size`向上进位到`PGSIZE`。由于这是设备内存并不是正常的DRAM，所以使用cache缓存访问是不安全的，可以用页的标志位来实现。\n``` c\n//kern/pmap.c\nvoid *\nmmio_map_region(physaddr_t pa, size_t size)\n{\n    static uintptr_t base = MMIOBASE;\n    void *ret = (void *)base;\n\n    size = ROUNDUP(size, PGSIZE);\n    if (base + size > MMIOLIM || base + size < base)\n                panic(\"mmio_map_region: reservation overflow\\n\");\n\n    boot_map_region(kern_pgdir, base, size, pa, PTE_P | PTE_PCD | PTE_PWT);\n    base += size;\n\n    return ret;\n}\n```\n\n### 引导应用处理器(Application Processor)\n在启动AP之前，BSP应该先收集关于多处理器系统的配置信息，比如CPU总数，CPUs的APIC ID和LAPIC单元的MMIO地址等。在`kern/mpconfig`文件中的`mp_init()`函数通过读BIOS设定的`MP配置表`获取这些信息。\n`boot_aps(kern/init.c)`函数驱动AP引导程序。AP开始于实模式，跟BSP的开始相同，故此`boot_aps`函数拷贝AP入口代码(`kern/mpentry.S`)到实模式下的内存寻址空间。但是跟BSP不一样的是，当AP开始执行时，需要有一些控制将拷贝入口代码到`0x7000(MPENTRY_PADDR)`。\n之后，`boot_aps`函数通过发送`STARTUP的IPI`(处理器间中断)信号到AP的LAPIC单元来一个个地激活AP。在`kern/mpentry.S`中的入口代码跟`boot/boot.S`中的代码类似。在一些简短的配置后，它使AP进入开启分页机制的保护模式，调用C语言的setup函数`mp_main`（`kern/init.c`)。`boot_aps()`等待AP `CPU_STARTED`在`cpu_status`其字段中设定出一个flag，设定`struct CpuInfo`然后继续唤醒下一个。\n\n结合前几个lab，在i386 `init`函数中进行BSP启动的一些配置，经由lab2的`mem_init`，lab3的`env_init`和`trap_init`，lab4的`mp_init`和`lapic_init`，然后`boot_aps`函数启动所有的CPU\n``` c\n// lab2 memory management initialization functions\nmem_init();\n\n// lab3 user environment initialization functions\nenv_init();\ntrap_init();\n\n// lab4 multiprocessor initialization functions\nmp_init();\nlapic_init();\n\n// lab4 multitasking initialization functions\npic_init();\n\n// Acquire the bit kernel lock before waiting AP\nlock_kernel();\n\n// starting non-boot APs\nboot_aps();\n```\n多核处理器的初始化都在mp_init函数中完成，首先是调用mpconfig函数，主要功能是寻找一个MP 配置条目，然后对所有的CPU进行配置，找到启动的处理器。\n``` c\nvoid\nmp_init(void)\n{\n    struct mp *mp;\n    struct mpconf *conf;\n    struct mpproc *proc;\n    uint8_t *p;\n    unsigned int i;\n\n    bootcpu = &cpus[0];\n    if ((conf = mpconfig(&mp)) == 0)\n        return;\n    ismp = 1;\n    lapicaddr = conf->lapicaddr;\n\n    for (p = conf->entries, i = 0; i < conf->entry; i++) {\n        switch (*p) {\n\t\t    case MPPROC:\n        proc = (struct mpproc *)p;\n\t\t\t  if (proc->flags & MPPROC_BOOT)\n\t\t\t\t    bootcpu = &cpus[ncpu];\n\t\t\t  if (ncpu < NCPU) {\n\t\t\t\t    cpus[ncpu].cpu_id = ncpu;\n\t\t\t\t    ncpu++;\n\t\t\t  } else {\n            cprintf(\"SMP: too many CPUs, CPU %d disabled\\n\",\n            proc->apicid);\n\t\t\t  }\n        p += sizeof(struct mpproc);\n        continue;\n        case MPBUS:\n        case MPIOAPIC:\n        case MPIOINTR:\n        case MPLINTR:\n        p += 8;\n        continue;\n        default:\n            cprintf(\"mpinit: unknown config type %x\\n\", *p);\n        ismp = 0;\n        i = conf->entry;\n\t      }\n\t }\n```\n在启动过程中，`mp_init`和`lapic_init`是和硬件以及体系架构紧密相关的，通过读取某个特殊内存地址（当然前提是能读取的到，所以在`mem_init`中需要修改进行相应映射），来获取CPU的信息，根据这些信息初始化CPU结构。\n在`boot_aps`函数中首先找到一段用于启动的汇编代码，该代码和lab3是嵌入在内核代码段之上的一部分，其中`mpentry_start`和`mpentry_end`是编译器导出符号，代表这段代码在内存（虚拟地址）中的起止位置，接着把代码复制到`MPENTRY_PADDR`处。随后调用`lapic_startap`来命令特定的AP去执行这段代码。\n``` c\n// Start the non-boot (AP) processors.\nstatic void\nboot_aps(void)\n{\n    extern unsigned char mpentry_start[], mpentry_end[];\n  \tvoid *code;\n  \tstruct CpuInfo *c;\n\n  \t// Write entry code to unused memory at MPENTRY_PADDR\n  \tcode = KADDR(MPENTRY_PADDR);\n  \tmemmove(code, mpentry_start, mpentry_end - mpentry_start);\n\n  \t// Boot each AP one at a time\n  \tfor (c = cpus; c < cpus + ncpu; c++) {\n  \t\tif (c == cpus + cpunum())  // We've started already.\n  \t\t\tcontinue;\n\n  \t\t// Tell mpentry.S what stack to use\n  \t\tmpentry_kstack = percpu_kstacks[c - cpus] + KSTKSIZE;\n  \t\t// Start the CPU at mpentry_start\n  \t\tlapic_startap(c->cpu_id, PADDR(code));\n  \t\t// Wait for the CPU to finish some basic setup in mp_main()\n  \t\twhile(c->cpu_status != CPU_STARTED)\n  \t\t\t;\n  \t}\n}\n```\n\n#### 练习2\n问\n> 修改`page_init`函数(`kern/page.c`)的实现，来避免将`MPENTRY_PADDR`处的物理页加入到空闲链表中,使得能安全地拷贝和运行AP的启动代码。\n\n解：\n> 在`boot_aps`函数中将启动代码放到了`MPENTRY_PADDR`处，而代码的来源则是在`kern/mpentry.S`中，功能与`boot.S`中的非常类似，主要就是开启分页模式，转到内核栈上去，实际上这时内核栈还没建好。在执行完`mpentry.S`中的代码之后，将会跳转到`mp_main`函数中去。而这里需要提前做的，就是将`MPENTRY_PADDR`处的物理页表标识为已用，这样不会将这一页放在空闲链表中分配出去。只需要在`page_init`中添加一个判断就可以。\n``` c\n//kern/pmap.c\nvoid page_init(void)\n{\n    ......\n    for (i = 0; i < npages; i++) {\n        ......\n        else if (i == MPENTRY_PADDR / PGSIEZ)\n            continue;\n        ......\n    }\n}\n```\n\n### 问题1\n问\n> 仔细比较`kern/mpentry.S`与`boot/boot.S`，`kern/mpentry.S`是被编译链接来运行在`KERNBASE`之上的，那么定义`MPBOOTPHYS宏``的目的是什么？为什么在kern/mpentry.S中是必要的，在boot/boot.S中不是呢？换句话说，如果在kern/mpentry.S中忽略它，会出现什么错误？\n\n解\n>\n```\n#define MPBOOTPHYS(s) ((s) - mpentry_start + MPENTRY_PADDR))))\n// MPBOOTPHYS is to calculate symobl address relative to MPENTRY_PADDR. The ASM is executed in the load address above KERNBASE, but JOS need to run mp_main at 0x7000 address! Of course 0x7000’s page is reserved at pmap.c.\n```\n> 在AP的保护模式打开之前，是没有办法寻址到3G以上的空间的，因此用`MPBOOTPHYS`是用来计算相应的物理地址的。但是在`boot.S`中，由于尚没有启用分页机制，所以能够指定程序开始执行的地方以及程序加载的地址；但是，在`mpentry.S`的时候，由于主CPU已经处于保护模式下了，因此是不能直接指定物理地址的，而给定线性地址映射到相应的物理地址是允许的。\n\n### CPU的状态和初始化\n在编写多处理器操作系统时，区分每个处理器私有的每个CPU状态以及整个系统共享的全局状态是非常重要的。 `kern / cpu.h`定义了大多数CPU状态，包括`struct CpuInfo`存储CPU变量。 `cpunum()`返回调用它的CPU的ID，可以用作数组的索引`cpus`。\n每个CPU独有的变量应该有：\n* 内核栈\n因为多个CPU可以同时陷入内核，所以我们需要为每个处理器分配一个内核栈，以防止它们干扰对方的执行。数组`percpu_kstacks[NCPU][KSTKSIZE]`为`NCPU`的内核栈提供了空间。\n* TSS和TSS描述符\n每个CPU任务状态段（TSS）也是需要的，以便指定每个CPU内核栈的位置。存储CPU i的`TSS cpus[i].cpu_ts`，并在GDT条目中定义相应的TSS描述符`gdt[(GD_TSS0 >> 3) + i]`。`ts`在`kern / trap.c`中定义的全局变量将不再有用。\n* CPU的当前环境指针\n由于每个CPU可以同时运行不同的用户进程中，因此重新定义了符号`curenv`来指代`cpus[cpunum()].cpu_env`（或`thiscpu->cpu_env`），它指向环境当前的上执行当前CPU（在其上运行代码的CPU）。\n* CPU的系统寄存器\n所有寄存器（包括系统寄存器）对于CPU都是专用的。因此，初始化这些寄存器的指令，例如`lcr3()， ltr()，lgdt()，lidt()`等，必须进行一次各CPU上执行。功能`env_init_percpu()`和`trap_init_percpu()`执行此功能。\n\n#### 练习3\n问\n> 修改`mem_init_mp`函数来映射开始于`KSTACKTOP`的CPU栈。\n\n解\n> 多CPU的内存分布如下：\n```\nKERNBASE ----> +-------------------------+ 0xf0000000\nKSTACKTOP      |   CPU0's Kernel Stack   | RW/-- KSTKSIZE\n               |-------------------------|\n               |   Invalid Memory(*)     | --/-- KSTKGAP\n               +-------------------------+\n               |    CPU1's Kernel STACK  | RW/-- KSTKSIZE\n               |-------------------------|\n               |   Invalid Memory(*)     | --/-- KSTKGAP\n               +-------------------------+\n               .             .           .\n               .             .           .\n\n```\n需要为每个核都分配一个内核栈，每个内核栈的大小是`KSTKSIZE`，而内核栈之间的间距是`KSTKGAP`，起到保护作用。\n``` c\n//kern/pmap.c\nstatic void\nmem_init_mp(void)\n{\n    int i;\n    uintptr_t kstacktop_i;\n\n    for (i = 0; i < NCPU; i++) {\n        kstacktop_i = KSTACKTOP - i * (KSTKGAP + KSTKSIZE);\n        boot_map_region(kern_pgdir,\n                        kstacktop_i - KSTKSIZE,\n                        ROUNDUP(KSTKSIZE, PGSIZE),\n                        PADDR(&percpu_kstacks[i]),\n                        PTE_W | PTE_P);\n        }\n}\n```\n\n#### 练习4\n问：\n> 在`trap_init_percpu`函数中为BSP初始化TSS和TSS描述符，这在Lab3中是可行的，但是在这里会有问题，修改代码使它可以运行在所有CPU上。\n\n解：\n> 由于有多个CPU，所以在这里不能使用原先的全局变量`ts`，应该利用`thiscpu`指向的`CpuInfo`结构体和`cpunum`函数来为每个核的`TSS`进行初始化。\n``` c\nvoid\ntrap_init_percpu(void)\n{\n    thiscpu->cpu_ts.ts_esp0 = KSTACKTOP - cpunum() * (KSTKGAP + KSTKSIZE);\n    thiscpu->cpu_ts.ts_ss0 = GD_KD;\n\n    // Initialize the TSS slot of the gdt.\n    gdt[(GD_TSS0 >> 3) + cpunum()] = SEG16(STS_T32A, (uint32_t) (&thiscpu->cpu_ts), sizeof(struct Taskstate) - 1, 0);\n    gdt[(GD_TSS0 >> 3) + cpunum()].sd_s = 0;\n\n    // Load the TSS selector (like other segment selectors, the\n    // bottom three bits are special; we leave them 0)\n    ltr(GD_TSS0 + sizeof(struct Segdesc) * cpunum());\n\n    // Load the IDT\n    lidt(&idt_pd);\n}\n```\n\n### 锁\n在`mp_main`函数中初始化AP后，代码就会进入自旋。在让AP进行更多操作之前，首先要解决多CPU同时运行在内核时产生的竞争问题。最简单的办法是实现1个大内核锁（big kernel lock)，1次只让一个进程进入内核模式，当CPU离开内核时释放锁。\n在`kern/spinlock.h`中声明了大内核锁，提供了`lock_kernel`和`unlock_kernel`函数来快捷地获得和释放锁。总共有四处用到大内核锁：\n* 在启动的时候，BSP启动其余的CPU之前，BSP需要取得内核锁\n* `mp_main`中，也就是CPU被启动之后执行的第一个函数，这里应该是调用调度函数，选择一个进程来执行的，但是在执行调度函数之前，必须获取锁\n* `trap函数``也要修改，因为可以访问临界区的CPU只能有一个，所以从用户态陷入到内核态的话，要加锁，因为可能多个CPU同时陷入内核态\n* `env_run`函数，也就是启动进程的函数，之前在lab3中实现的，在这个函数执行结束之后，就将跳回到用户态，此时离开内核，也就是需要将内核锁释放\n\n加锁后，将原有的并行执行过程在关键位置变为串行执行过程，整个启动过程大概如下：\n> i386_init–>BSP获得锁–>boot_ap–>(BSP建立为每个cpu建立idle任务、建立用户任务，mp_main)—>BSP的sched_yield–>其中的env_run释放锁–>AP1获得锁–>执行sched_yield–>释放锁–>AP2获得锁–>执行sched_yield–>释放锁…..\n\n#### 练习5\n问\n> 在上述位置应用大内核锁。\n\n解\n``` c\n//i386_init\nlock_kernel();\nboot_aps();\n\n//mp_main\nlock_kernel();\nsched_yield();\n\n//trap\nif ((tf->tf_cs & 3) == 3) {\n    lock_kernel();\n    assert(curenv);\n    ......\n}\n\n//env_run\nlcr3(PADDR(curenv->env_pgdir));\nunlock_kernel();\nenv_pop_tf(&(curenv->env_tf));\n```\n\n### 问题2\n问：\n> 既然大内核锁保证了只有1个CPU能运行在内核，为什么我们还要为每个CPU准备1个内核栈。\n\n解:\n> 因为不同的内核栈上可能保存有不同的信息，当1个CPU从内核退出来之后，有可能在内核栈中留下了一些将来还有用的数据，所以一定要有单独的栈。\n\n### 挑战1\n问:\n> 大内核锁简单便于应用，但是它取消了内核模式的并行。大多数现代操作系统使用不同的锁来保护共享状态的不同部分，这称之为细粒度锁。细粒度锁能有效地提高性能，但是也更困难地去实现和检测错误。所以你可以去掉大内核锁，在JOS中实现内核并发。\n\n解\n> 思路:实验指导中提供了一些JOS内核中的共享结构，具体实现就是在保证在使用这些结构体时保证互斥。\n　　\n### 循环调度(Round-Robin Scheduling)\n接下来的任务是改变JOS内核，实现`round-robin`调度算法。\n主要是在`sched_yield`函数内实现，从该CPU上一次运行的进程开始，在进程描述符表中寻找下一个可以运行的进程，如果没找到而且上一个进程依然是可以运行的，那么就可以继续运行上一个进程，同时将这个算法实现为了一个系统调用，使得进程可以主动放弃CPU。\n\n#### 练习6\n问:\n> 实现`sched_yield`函数，并添加系统调用。\n\n解:\n> 修改代码如下.然后修改`kern/syscall.c`,添加相关的系统调用机制。\n```\nvoid\nsched_yield(void)\n{\n        uint32_t i, j, start;\n        struct Env *runenv;\n\n        idle = thiscpu->cpu_env;\n        start = (idle != NULL) ? ENVX(idle->env_id) : 0;\n        runenv = NULL;\n\n        for (i = 0; i < NENV; i++) {\n                j = (start + i) % NENV;\n                if (envs[j].env_status == ENV_RUNNABLE) {\n                        if (runenv == NULL || envs[j].env_priority < runenv->env_priority)\n                                runenv = &envs[j];\n                }\n        }\n        if ((idle && idle->env_status == ENV_RUNNING) && (runenv == NULL || idle->env_priority < runenv->env_priority)){\n                env_run(idle);\n                return;\n        }\n        if (runenv) {\n                env_run(runenv);\n                return;\n        }\n        // sched_halt never returns\n        sched_halt();\n}\n```\n　　\n#### 问题3\n问:\n> 在`lcr3()`运行之后，这个CPU对应的页表就立刻被换掉了，但是这个时候的参数e，也就是现在的`curenv`，为什么还是能正确的解引用？\n\n解:\n> 因为当前是运行在系统内核中的，而每个进程的页表中都是存在内核映射的。每个进程页表中虚拟地址高于`UTOP`之上的地方，只有`UVPT`不一样，其余的都是一样的，只不过在用户态下是看不到的。所以虽然这个时候的页表换成了下一个要运行的进程的页表，但是`curenv`的地址没变，映射也没变，还是依然有效的。\n\n#### 问题4\n问:\n> 在用户环境进行切换时，为什么旧进程的寄存器一定要被保存以便之后重新装载？在哪里发生这样的操作？\n\n解:\n> 因为如果不进行保存，旧进程运行时的状态就丢失了，运行就不正确了。每次进入到内核态的时候，当前的运行状态都是在一进入的时候就保存了的。如果没有发生调度，那么之前`trapframe`中的信息还是会恢复回去，如果发生了调度，恢复的就是被调度运行的进程的上下文了。\n\n#### 挑战2\n问:\n> 添加固定优先级的调度策略，确保高优先级的进程总是先于低优先级的进程。\n\n解：\n> 思路:为每个进程的结构体添加1个标志优先级的变量，在`sched_yield`时遍历链表选取优先级最高的可运行进程作为下一个运行进程。\n> 1. 在`inc/env.h`中给`Env`结构添加1个成员`int env_priority`\n> 2. 在`kern/env.c`中的`env_alloc`中给进程赋值为默认优先级`ENV_PRIOR_DEFAULT`，一共设立了四个基本的优先级，数字越小优先级越高\n``` c\n//inc/env.h\n#define ENV_PRIOR_SUPER 0\n#define ENV_PRIOR_HIGH 10\n#define ENV_PRIOR_NORMAL 100\n#define ENV_PRIOR_LOW 1000\n```\n> 3. 修改`kern/sched.c`中`sched_yield`函数的调度策略\n``` c\n//kern/sched.c  sched_yield()\n        idle = thiscpu->cpu_env;\n        start = (idle != NULL) ? ENVX(idle->env_id) : 0;\n        runenv = NULL;\n\n        for (i = 0; i < NENV; i++) {\n                j = (start + i) % NENV;\n                if (envs[j].env_status == ENV_RUNNABLE) {\n                        if (runenv == NULL || envs[j].env_priority < runenv->env_priority)\n                                runenv = &envs[j];\n                }\n        }\n        if ((idle && idle->env_status == ENV_RUNNING) && (runenv == NULL || idle->env_priority < runenv->env_priority)){\n                env_run(idle);\n                return;\n        }\n        if (runenv) {\n                env_run(runenv);\n                return;\n        }\n```\n> 4. 添加1个系统调用`sys_env_set_priority(envid, priority)`，允许进程的父进程或者自己修改自己的优先级。这里的修改与前面添加系统调用类似。\n``` c\nstatic int\nsys_env_set_priority(envid_t envid, int priority)\n{\n        int ret;\n        struct Env *env;\n\n        if ((ret = envid2env(envid, &env, 1)) < 0)\n                return ret;\n        env->env_priority = priority;\n        return 0;\n}\n```\n\n#### 挑战3\n问:\n> 现在的JOS内核不支持应用来使用x86处理器的浮点数单元(FPU)，MMX指令和SSE扩展指令。扩展Env结构提供保存处理器浮点数状态的空间，扩展进程上下文交换代码来保存和恢复浮点数状态 。\n\n解:\n> 给中断加入保存浮点寄存器的功能。\n> 1. 给`inc/trap.h`文件中的`Trapframe`结构新增`char tf_fpus[512]``成员，并增加`uint32_t tf_padding0[3]``来对齐\n> 2. 修改`kern/trapentry.S`文件中的`_alltraps`函数，加入保存`fpu`寄存器的功能\n```c\n_alltraps:\n        pushl %ds\n        pushl %es\n        pushal\n\n        // save FPU\n        subl $524, %esp\n        fxsave (%esp)\n\n        movl $GD_KD, %eax\n        movl %eax, %ds\n        movl %eax, %es\n\n        push %esp\n        call trap\n```\n> 3. 修改`kern/env.c`文件中的`env_pop_tf`函数，加入恢复`fpu`功能\n``` c\n __asm __volatile(\"movl %0,%%esp\\n\"\n                \"\\tfxrstor (%%esp)\\n\"\n                \"\\taddl $524,%%esp\\n\"\n                \"\\tpopal\\n\"\n                \"\\tpopl %%es\\n\"\n                \"\\tpopl %%ds\\n\"\n                \"\\taddl $0x8,%%esp\\n\" /* skip tf_trapno and tf_errcode */\n                \"\\tiret\"\n                : : \"g\" (tf) : \"memory\");\n```\n\n### 创建环境的系统调用\n虽然当前内核现在有能力运行和切换多用户级进程，但是它仍然只能跑内核初始创建的进程。现在将实现必要的JOS系统调用来运行用户进程来创建和启动其它新的用户进程。\nUnix提供了`fork`系统调用来创建进程，它拷贝父进程的整个地址空间到新创建的子进程。两个进程之间唯一的区别是它们的进程ID，在父进程fork返回的是子进程ID，而在子进程fork返回的是0。\n参照Unix,实现1个不同的更原始的JOS系统调用来创建进程。利用这些系统调用能实现类似Unix的fork函数。\n用户级fork函数在`user/dumbfork.c`中的`dumbfork()`中，该函数将父进程中所有页的内容全部复制过来，唯一不同的地方就是返回值不同。\n\n### 练习7\n问:\n> 实现`ker/syscall.c`中的系统调用。\n\n解:\n> 首先是`sys_exofork`函数，这个系统调用将创建1个新的空白进程，没有映射的用户空间且无法运行。在调用函数时新进程的寄存器状态与父进程相同，但是在父进程会返回子进程的ID，而子进程会返回0。通过设置子进程的eax为0，来让系统调用的返回值为0。\n``` c\nstatic envid_t\nsys_exofork(void)\n{\n        int ret;\n        struct Env *env;\n\n        if ((ret = env_alloc(&env, sys_getenvid())) < 0)\n                return ret;\n        env->env_status = ENV_NOT_RUNNABLE;\n        env->env_tf = curenv->env_tf;\n        env->env_tf.tf_regs.reg_eax = 0;\n        return env->env_id;\n}\n```\n接着是`sys_env_set_status`函数，设置进程的状态为`ENV_RUNNABLE`或者`ENV_NOT_RUNNABLE`。\n``` c\nstatic int\nsys_env_set_status(envid_t envid, int status)\n{\nimplemented\");\n        int ret;\n        struct Env *env;\n\n        if (status != ENV_RUNNABLE && status != ENV_RUNNING)\n                return -E_INVAL;\n        if ((ret = envid2env(envid, &env, 1)) < 0)\n                return ret;\n        env->env_status = status;\n        return 0;\n}\n```\n然后是`env_page_alloc`函数，分配1个物理页并映射到给定进程的进程空间的虚拟地址。\n``` c\nstatic int\nsys_page_alloc(envid_t envid, void *va, int perm)\n{\n        struct Env *env;\n        struct PageInfo *pp;\n\n        if (envid2env(envid, &env, 1) < 0)\n                return -E_BAD_ENV;\n        if ((uintptr_t)va >= UTOP || PGOFF(va))\n                return -E_INVAL;\n        if ((perm & PTE_U) == 0 || (perm & PTE_P) == 0)\n                return -E_INVAL;\n        if ((perm & ~(PTE_U | PTE_P | PTE_W | PTE_AVAIL)) != 0)\n                return -E_INVAL;\n        if ((pp = page_alloc(ALLOC_ZERO)) == NULL)\n                return -E_NO_MEM;\n        if (page_insert(env->env_pgdir, pp, va, perm) < 0) {\n                page_free(pp);\n                return -E_NO_MEM;\n        }\n        return 0;\n}\n```\n最后是s`ys_page_unmap`函数，解除指定进程中的1个页映射。\n```\nstatic int\nsys_page_unmap(envid_t envid, void *va)\n{\n        struct Env *env;\n\n        if (envid2env(envid, &env, 1) < 0)\n                return -E_BAD_ENV;\n        if ((uintptr_t)va >= UTOP || PGOFF(va))\n                return -E_INVAL;\n\n        page_remove(env->env_pgdir, va);\n        return 0;\n}\n```\n至此所有系统调用都完成了，可以运行一下`usr/umbfork.c`。首先看一下主函数，逻辑是父进程创建1个子进程，然后每次打印1条信息后交出控制权，并且让父进程重复10次而子进程重复20次。\n``` c\nvoid\numain(int argc, char **argv)\n{\n        envid_t who;\n        int i;\n\n        // fork a child process\n        who = dumbfork();\n\n        // print a message and yield to the other a few times\n        for (i = 0; i < (who ? 10 : 20); i++) {\n                cprintf(\"%d: I am the %s!\\n\", i, who ? \"parent\" : \"child\");\n                sys_yield();\n        }\n}\n```\n","source":"_posts/lab4.md","raw":"title: lab4-Preemptive Multitasking\ndate: 2017/05/04\ntags:\n- xv6\n- os\n\n---\n# Lab4 抢占式多进程\n## 摘要\nLab4目标是在多用户环境下实现抢占式多进程的支持，分解为三个部分：\n* part1: 在JOS中添加对多处理器的支持，实现循环调度算法，并添加基本的环境管理的系统调用（创建/销毁环境，分配/映射内存）\n* part2：实现类似Unix的`fork`机制，允许在用户模式下创建副本\n* part3：添加对进程间通信(IPC)的支持，允许不同的用户环境进行进程间的通信和同步。并添加对硬件时钟中断和进程抢占的支持。\n\n## 准备\n下载实验代码：\n``` bash\ngit pull\ngit chekout -b lab4 origin/lab4\ngit merge Lab3\n```\nLab4 新增的文件：\n```\nkern/cpu.h\t多处理器支持的内核私有定义\nkern/mpconfig.c\t读取多处理器配置的代码\nkern/lapic.c\t驱动处理器中的本地APIC单元的内核代码\nkern/mpentry.S\t非启动CPU的汇编代码入口\nkern/spinlock.h\t包括大内核锁在内的自旋锁的内和私有定义\nkern/spinlock.c\t自旋锁的内核代码实现\nkern/sched.c\t调度器的代码框架\n```\n\n<!-- more -->\n\n## part1 多处理器支持和多任务协同\nLab4 part1将首先扩展JOS以在多处理器系统上运行，然后实现新的JOS内核系统调用，以允许用户级环境创建其他新的环境。另外实现协同循环调度，当当前环境自动放弃CPU（或退出）时，允许内核从一个环境切换到另一个环境。之后在part3中，还会实现抢占式调度，即使在环境不允许的情况下，允许内核在一定时间内重新从环境中重新控制CPU。\n\n### 多处理器支持\n目标使JOS支持对称多处理器(SMP)。`SMP`是一种多处理器架构，所有的CPU对等地访问系统资源。在SMP中所有CPU的功能是相同的，但是在启动过程中会被分为2类：引导处理器(`BSP`)负责初始化系统来启动操作系统，当操作系统被启动后，应用处理器(`AP`)被引导处理器激活。引导处理器是由硬件和BIOS决定的，目前所有的代码都是运行在BSP上。\n在个SMP系统中，每个CPU有1个附属的`Local APIC（LAPIC）`单元。LAPIC单元负责处理系统中的中断，同时为它关联的CPU提供独一无二的标识符。在part1，将使用LAPIC单元以下基本功能(在`/kern/lapic.c`)：\n* 读取LAPIC的标识符(APIC ID)来告诉我们正在哪个CPU上运行代码(`cpunum()`).\n* 从BSP发送STARTUP的处理器间中断(`IPI`) 到APs来唤醒其它CPU(`lapic_startup()`).\n* 在part3部分，将编程LAPIC内置的计时器来触发时钟中断来支持多任务抢占(`apic_init()`).\n\n处理器访通过内存映射I/O(MMIO)的方式访问它的LAPIC。在MMIO中，一部分物理地址被硬连接到一些IO设备的寄存器上，导致操作内存的指令`load/store`可以直接操作设备的寄存器。我们已经看到过1个`IO hole`在物理地址`0xA0000`(用来写入VGA显示缓存)。LAPIC的hole开始于物理地址`0xFE000000`(4GB之下地32MB)，但是这地址过高，导致无法访问通过过去的直接映射(虚拟地址`0xF0000000`映射0x0，即只有256MB)。但是JOS虚拟地址映射预留了4MB空间在`MMIOBASE`处，需要分配空间一映射设备。\n\n#### 练习1\n问\n> 在`kern/pmap.c`中实现`mmio_map_region`。查看`lapic_init`函数(`kern/lapic.c`)来确定使用方式\n\n解：\n> 在`lapic_init`函数的开头就会调用`mmio_map_region`\n``` c\n// lapicaddr is the physical address of the LAPIC's 4K MMIO\n// region.  Map it in to virtual memory so we can access it.\nlapic = mmio_map_region(lapicaddr, 4096);\n```\n> 在`kern/pmap.c`中，有具体的提示，设置个静态变量记录每次变化后的虚拟基地址，使用`boot_map_region`函数将`[pa,pa+size)的`物理地址映射到`[base,base+size)`，把`size`向上进位到`PGSIZE`。由于这是设备内存并不是正常的DRAM，所以使用cache缓存访问是不安全的，可以用页的标志位来实现。\n``` c\n//kern/pmap.c\nvoid *\nmmio_map_region(physaddr_t pa, size_t size)\n{\n    static uintptr_t base = MMIOBASE;\n    void *ret = (void *)base;\n\n    size = ROUNDUP(size, PGSIZE);\n    if (base + size > MMIOLIM || base + size < base)\n                panic(\"mmio_map_region: reservation overflow\\n\");\n\n    boot_map_region(kern_pgdir, base, size, pa, PTE_P | PTE_PCD | PTE_PWT);\n    base += size;\n\n    return ret;\n}\n```\n\n### 引导应用处理器(Application Processor)\n在启动AP之前，BSP应该先收集关于多处理器系统的配置信息，比如CPU总数，CPUs的APIC ID和LAPIC单元的MMIO地址等。在`kern/mpconfig`文件中的`mp_init()`函数通过读BIOS设定的`MP配置表`获取这些信息。\n`boot_aps(kern/init.c)`函数驱动AP引导程序。AP开始于实模式，跟BSP的开始相同，故此`boot_aps`函数拷贝AP入口代码(`kern/mpentry.S`)到实模式下的内存寻址空间。但是跟BSP不一样的是，当AP开始执行时，需要有一些控制将拷贝入口代码到`0x7000(MPENTRY_PADDR)`。\n之后，`boot_aps`函数通过发送`STARTUP的IPI`(处理器间中断)信号到AP的LAPIC单元来一个个地激活AP。在`kern/mpentry.S`中的入口代码跟`boot/boot.S`中的代码类似。在一些简短的配置后，它使AP进入开启分页机制的保护模式，调用C语言的setup函数`mp_main`（`kern/init.c`)。`boot_aps()`等待AP `CPU_STARTED`在`cpu_status`其字段中设定出一个flag，设定`struct CpuInfo`然后继续唤醒下一个。\n\n结合前几个lab，在i386 `init`函数中进行BSP启动的一些配置，经由lab2的`mem_init`，lab3的`env_init`和`trap_init`，lab4的`mp_init`和`lapic_init`，然后`boot_aps`函数启动所有的CPU\n``` c\n// lab2 memory management initialization functions\nmem_init();\n\n// lab3 user environment initialization functions\nenv_init();\ntrap_init();\n\n// lab4 multiprocessor initialization functions\nmp_init();\nlapic_init();\n\n// lab4 multitasking initialization functions\npic_init();\n\n// Acquire the bit kernel lock before waiting AP\nlock_kernel();\n\n// starting non-boot APs\nboot_aps();\n```\n多核处理器的初始化都在mp_init函数中完成，首先是调用mpconfig函数，主要功能是寻找一个MP 配置条目，然后对所有的CPU进行配置，找到启动的处理器。\n``` c\nvoid\nmp_init(void)\n{\n    struct mp *mp;\n    struct mpconf *conf;\n    struct mpproc *proc;\n    uint8_t *p;\n    unsigned int i;\n\n    bootcpu = &cpus[0];\n    if ((conf = mpconfig(&mp)) == 0)\n        return;\n    ismp = 1;\n    lapicaddr = conf->lapicaddr;\n\n    for (p = conf->entries, i = 0; i < conf->entry; i++) {\n        switch (*p) {\n\t\t    case MPPROC:\n        proc = (struct mpproc *)p;\n\t\t\t  if (proc->flags & MPPROC_BOOT)\n\t\t\t\t    bootcpu = &cpus[ncpu];\n\t\t\t  if (ncpu < NCPU) {\n\t\t\t\t    cpus[ncpu].cpu_id = ncpu;\n\t\t\t\t    ncpu++;\n\t\t\t  } else {\n            cprintf(\"SMP: too many CPUs, CPU %d disabled\\n\",\n            proc->apicid);\n\t\t\t  }\n        p += sizeof(struct mpproc);\n        continue;\n        case MPBUS:\n        case MPIOAPIC:\n        case MPIOINTR:\n        case MPLINTR:\n        p += 8;\n        continue;\n        default:\n            cprintf(\"mpinit: unknown config type %x\\n\", *p);\n        ismp = 0;\n        i = conf->entry;\n\t      }\n\t }\n```\n在启动过程中，`mp_init`和`lapic_init`是和硬件以及体系架构紧密相关的，通过读取某个特殊内存地址（当然前提是能读取的到，所以在`mem_init`中需要修改进行相应映射），来获取CPU的信息，根据这些信息初始化CPU结构。\n在`boot_aps`函数中首先找到一段用于启动的汇编代码，该代码和lab3是嵌入在内核代码段之上的一部分，其中`mpentry_start`和`mpentry_end`是编译器导出符号，代表这段代码在内存（虚拟地址）中的起止位置，接着把代码复制到`MPENTRY_PADDR`处。随后调用`lapic_startap`来命令特定的AP去执行这段代码。\n``` c\n// Start the non-boot (AP) processors.\nstatic void\nboot_aps(void)\n{\n    extern unsigned char mpentry_start[], mpentry_end[];\n  \tvoid *code;\n  \tstruct CpuInfo *c;\n\n  \t// Write entry code to unused memory at MPENTRY_PADDR\n  \tcode = KADDR(MPENTRY_PADDR);\n  \tmemmove(code, mpentry_start, mpentry_end - mpentry_start);\n\n  \t// Boot each AP one at a time\n  \tfor (c = cpus; c < cpus + ncpu; c++) {\n  \t\tif (c == cpus + cpunum())  // We've started already.\n  \t\t\tcontinue;\n\n  \t\t// Tell mpentry.S what stack to use\n  \t\tmpentry_kstack = percpu_kstacks[c - cpus] + KSTKSIZE;\n  \t\t// Start the CPU at mpentry_start\n  \t\tlapic_startap(c->cpu_id, PADDR(code));\n  \t\t// Wait for the CPU to finish some basic setup in mp_main()\n  \t\twhile(c->cpu_status != CPU_STARTED)\n  \t\t\t;\n  \t}\n}\n```\n\n#### 练习2\n问\n> 修改`page_init`函数(`kern/page.c`)的实现，来避免将`MPENTRY_PADDR`处的物理页加入到空闲链表中,使得能安全地拷贝和运行AP的启动代码。\n\n解：\n> 在`boot_aps`函数中将启动代码放到了`MPENTRY_PADDR`处，而代码的来源则是在`kern/mpentry.S`中，功能与`boot.S`中的非常类似，主要就是开启分页模式，转到内核栈上去，实际上这时内核栈还没建好。在执行完`mpentry.S`中的代码之后，将会跳转到`mp_main`函数中去。而这里需要提前做的，就是将`MPENTRY_PADDR`处的物理页表标识为已用，这样不会将这一页放在空闲链表中分配出去。只需要在`page_init`中添加一个判断就可以。\n``` c\n//kern/pmap.c\nvoid page_init(void)\n{\n    ......\n    for (i = 0; i < npages; i++) {\n        ......\n        else if (i == MPENTRY_PADDR / PGSIEZ)\n            continue;\n        ......\n    }\n}\n```\n\n### 问题1\n问\n> 仔细比较`kern/mpentry.S`与`boot/boot.S`，`kern/mpentry.S`是被编译链接来运行在`KERNBASE`之上的，那么定义`MPBOOTPHYS宏``的目的是什么？为什么在kern/mpentry.S中是必要的，在boot/boot.S中不是呢？换句话说，如果在kern/mpentry.S中忽略它，会出现什么错误？\n\n解\n>\n```\n#define MPBOOTPHYS(s) ((s) - mpentry_start + MPENTRY_PADDR))))\n// MPBOOTPHYS is to calculate symobl address relative to MPENTRY_PADDR. The ASM is executed in the load address above KERNBASE, but JOS need to run mp_main at 0x7000 address! Of course 0x7000’s page is reserved at pmap.c.\n```\n> 在AP的保护模式打开之前，是没有办法寻址到3G以上的空间的，因此用`MPBOOTPHYS`是用来计算相应的物理地址的。但是在`boot.S`中，由于尚没有启用分页机制，所以能够指定程序开始执行的地方以及程序加载的地址；但是，在`mpentry.S`的时候，由于主CPU已经处于保护模式下了，因此是不能直接指定物理地址的，而给定线性地址映射到相应的物理地址是允许的。\n\n### CPU的状态和初始化\n在编写多处理器操作系统时，区分每个处理器私有的每个CPU状态以及整个系统共享的全局状态是非常重要的。 `kern / cpu.h`定义了大多数CPU状态，包括`struct CpuInfo`存储CPU变量。 `cpunum()`返回调用它的CPU的ID，可以用作数组的索引`cpus`。\n每个CPU独有的变量应该有：\n* 内核栈\n因为多个CPU可以同时陷入内核，所以我们需要为每个处理器分配一个内核栈，以防止它们干扰对方的执行。数组`percpu_kstacks[NCPU][KSTKSIZE]`为`NCPU`的内核栈提供了空间。\n* TSS和TSS描述符\n每个CPU任务状态段（TSS）也是需要的，以便指定每个CPU内核栈的位置。存储CPU i的`TSS cpus[i].cpu_ts`，并在GDT条目中定义相应的TSS描述符`gdt[(GD_TSS0 >> 3) + i]`。`ts`在`kern / trap.c`中定义的全局变量将不再有用。\n* CPU的当前环境指针\n由于每个CPU可以同时运行不同的用户进程中，因此重新定义了符号`curenv`来指代`cpus[cpunum()].cpu_env`（或`thiscpu->cpu_env`），它指向环境当前的上执行当前CPU（在其上运行代码的CPU）。\n* CPU的系统寄存器\n所有寄存器（包括系统寄存器）对于CPU都是专用的。因此，初始化这些寄存器的指令，例如`lcr3()， ltr()，lgdt()，lidt()`等，必须进行一次各CPU上执行。功能`env_init_percpu()`和`trap_init_percpu()`执行此功能。\n\n#### 练习3\n问\n> 修改`mem_init_mp`函数来映射开始于`KSTACKTOP`的CPU栈。\n\n解\n> 多CPU的内存分布如下：\n```\nKERNBASE ----> +-------------------------+ 0xf0000000\nKSTACKTOP      |   CPU0's Kernel Stack   | RW/-- KSTKSIZE\n               |-------------------------|\n               |   Invalid Memory(*)     | --/-- KSTKGAP\n               +-------------------------+\n               |    CPU1's Kernel STACK  | RW/-- KSTKSIZE\n               |-------------------------|\n               |   Invalid Memory(*)     | --/-- KSTKGAP\n               +-------------------------+\n               .             .           .\n               .             .           .\n\n```\n需要为每个核都分配一个内核栈，每个内核栈的大小是`KSTKSIZE`，而内核栈之间的间距是`KSTKGAP`，起到保护作用。\n``` c\n//kern/pmap.c\nstatic void\nmem_init_mp(void)\n{\n    int i;\n    uintptr_t kstacktop_i;\n\n    for (i = 0; i < NCPU; i++) {\n        kstacktop_i = KSTACKTOP - i * (KSTKGAP + KSTKSIZE);\n        boot_map_region(kern_pgdir,\n                        kstacktop_i - KSTKSIZE,\n                        ROUNDUP(KSTKSIZE, PGSIZE),\n                        PADDR(&percpu_kstacks[i]),\n                        PTE_W | PTE_P);\n        }\n}\n```\n\n#### 练习4\n问：\n> 在`trap_init_percpu`函数中为BSP初始化TSS和TSS描述符，这在Lab3中是可行的，但是在这里会有问题，修改代码使它可以运行在所有CPU上。\n\n解：\n> 由于有多个CPU，所以在这里不能使用原先的全局变量`ts`，应该利用`thiscpu`指向的`CpuInfo`结构体和`cpunum`函数来为每个核的`TSS`进行初始化。\n``` c\nvoid\ntrap_init_percpu(void)\n{\n    thiscpu->cpu_ts.ts_esp0 = KSTACKTOP - cpunum() * (KSTKGAP + KSTKSIZE);\n    thiscpu->cpu_ts.ts_ss0 = GD_KD;\n\n    // Initialize the TSS slot of the gdt.\n    gdt[(GD_TSS0 >> 3) + cpunum()] = SEG16(STS_T32A, (uint32_t) (&thiscpu->cpu_ts), sizeof(struct Taskstate) - 1, 0);\n    gdt[(GD_TSS0 >> 3) + cpunum()].sd_s = 0;\n\n    // Load the TSS selector (like other segment selectors, the\n    // bottom three bits are special; we leave them 0)\n    ltr(GD_TSS0 + sizeof(struct Segdesc) * cpunum());\n\n    // Load the IDT\n    lidt(&idt_pd);\n}\n```\n\n### 锁\n在`mp_main`函数中初始化AP后，代码就会进入自旋。在让AP进行更多操作之前，首先要解决多CPU同时运行在内核时产生的竞争问题。最简单的办法是实现1个大内核锁（big kernel lock)，1次只让一个进程进入内核模式，当CPU离开内核时释放锁。\n在`kern/spinlock.h`中声明了大内核锁，提供了`lock_kernel`和`unlock_kernel`函数来快捷地获得和释放锁。总共有四处用到大内核锁：\n* 在启动的时候，BSP启动其余的CPU之前，BSP需要取得内核锁\n* `mp_main`中，也就是CPU被启动之后执行的第一个函数，这里应该是调用调度函数，选择一个进程来执行的，但是在执行调度函数之前，必须获取锁\n* `trap函数``也要修改，因为可以访问临界区的CPU只能有一个，所以从用户态陷入到内核态的话，要加锁，因为可能多个CPU同时陷入内核态\n* `env_run`函数，也就是启动进程的函数，之前在lab3中实现的，在这个函数执行结束之后，就将跳回到用户态，此时离开内核，也就是需要将内核锁释放\n\n加锁后，将原有的并行执行过程在关键位置变为串行执行过程，整个启动过程大概如下：\n> i386_init–>BSP获得锁–>boot_ap–>(BSP建立为每个cpu建立idle任务、建立用户任务，mp_main)—>BSP的sched_yield–>其中的env_run释放锁–>AP1获得锁–>执行sched_yield–>释放锁–>AP2获得锁–>执行sched_yield–>释放锁…..\n\n#### 练习5\n问\n> 在上述位置应用大内核锁。\n\n解\n``` c\n//i386_init\nlock_kernel();\nboot_aps();\n\n//mp_main\nlock_kernel();\nsched_yield();\n\n//trap\nif ((tf->tf_cs & 3) == 3) {\n    lock_kernel();\n    assert(curenv);\n    ......\n}\n\n//env_run\nlcr3(PADDR(curenv->env_pgdir));\nunlock_kernel();\nenv_pop_tf(&(curenv->env_tf));\n```\n\n### 问题2\n问：\n> 既然大内核锁保证了只有1个CPU能运行在内核，为什么我们还要为每个CPU准备1个内核栈。\n\n解:\n> 因为不同的内核栈上可能保存有不同的信息，当1个CPU从内核退出来之后，有可能在内核栈中留下了一些将来还有用的数据，所以一定要有单独的栈。\n\n### 挑战1\n问:\n> 大内核锁简单便于应用，但是它取消了内核模式的并行。大多数现代操作系统使用不同的锁来保护共享状态的不同部分，这称之为细粒度锁。细粒度锁能有效地提高性能，但是也更困难地去实现和检测错误。所以你可以去掉大内核锁，在JOS中实现内核并发。\n\n解\n> 思路:实验指导中提供了一些JOS内核中的共享结构，具体实现就是在保证在使用这些结构体时保证互斥。\n　　\n### 循环调度(Round-Robin Scheduling)\n接下来的任务是改变JOS内核，实现`round-robin`调度算法。\n主要是在`sched_yield`函数内实现，从该CPU上一次运行的进程开始，在进程描述符表中寻找下一个可以运行的进程，如果没找到而且上一个进程依然是可以运行的，那么就可以继续运行上一个进程，同时将这个算法实现为了一个系统调用，使得进程可以主动放弃CPU。\n\n#### 练习6\n问:\n> 实现`sched_yield`函数，并添加系统调用。\n\n解:\n> 修改代码如下.然后修改`kern/syscall.c`,添加相关的系统调用机制。\n```\nvoid\nsched_yield(void)\n{\n        uint32_t i, j, start;\n        struct Env *runenv;\n\n        idle = thiscpu->cpu_env;\n        start = (idle != NULL) ? ENVX(idle->env_id) : 0;\n        runenv = NULL;\n\n        for (i = 0; i < NENV; i++) {\n                j = (start + i) % NENV;\n                if (envs[j].env_status == ENV_RUNNABLE) {\n                        if (runenv == NULL || envs[j].env_priority < runenv->env_priority)\n                                runenv = &envs[j];\n                }\n        }\n        if ((idle && idle->env_status == ENV_RUNNING) && (runenv == NULL || idle->env_priority < runenv->env_priority)){\n                env_run(idle);\n                return;\n        }\n        if (runenv) {\n                env_run(runenv);\n                return;\n        }\n        // sched_halt never returns\n        sched_halt();\n}\n```\n　　\n#### 问题3\n问:\n> 在`lcr3()`运行之后，这个CPU对应的页表就立刻被换掉了，但是这个时候的参数e，也就是现在的`curenv`，为什么还是能正确的解引用？\n\n解:\n> 因为当前是运行在系统内核中的，而每个进程的页表中都是存在内核映射的。每个进程页表中虚拟地址高于`UTOP`之上的地方，只有`UVPT`不一样，其余的都是一样的，只不过在用户态下是看不到的。所以虽然这个时候的页表换成了下一个要运行的进程的页表，但是`curenv`的地址没变，映射也没变，还是依然有效的。\n\n#### 问题4\n问:\n> 在用户环境进行切换时，为什么旧进程的寄存器一定要被保存以便之后重新装载？在哪里发生这样的操作？\n\n解:\n> 因为如果不进行保存，旧进程运行时的状态就丢失了，运行就不正确了。每次进入到内核态的时候，当前的运行状态都是在一进入的时候就保存了的。如果没有发生调度，那么之前`trapframe`中的信息还是会恢复回去，如果发生了调度，恢复的就是被调度运行的进程的上下文了。\n\n#### 挑战2\n问:\n> 添加固定优先级的调度策略，确保高优先级的进程总是先于低优先级的进程。\n\n解：\n> 思路:为每个进程的结构体添加1个标志优先级的变量，在`sched_yield`时遍历链表选取优先级最高的可运行进程作为下一个运行进程。\n> 1. 在`inc/env.h`中给`Env`结构添加1个成员`int env_priority`\n> 2. 在`kern/env.c`中的`env_alloc`中给进程赋值为默认优先级`ENV_PRIOR_DEFAULT`，一共设立了四个基本的优先级，数字越小优先级越高\n``` c\n//inc/env.h\n#define ENV_PRIOR_SUPER 0\n#define ENV_PRIOR_HIGH 10\n#define ENV_PRIOR_NORMAL 100\n#define ENV_PRIOR_LOW 1000\n```\n> 3. 修改`kern/sched.c`中`sched_yield`函数的调度策略\n``` c\n//kern/sched.c  sched_yield()\n        idle = thiscpu->cpu_env;\n        start = (idle != NULL) ? ENVX(idle->env_id) : 0;\n        runenv = NULL;\n\n        for (i = 0; i < NENV; i++) {\n                j = (start + i) % NENV;\n                if (envs[j].env_status == ENV_RUNNABLE) {\n                        if (runenv == NULL || envs[j].env_priority < runenv->env_priority)\n                                runenv = &envs[j];\n                }\n        }\n        if ((idle && idle->env_status == ENV_RUNNING) && (runenv == NULL || idle->env_priority < runenv->env_priority)){\n                env_run(idle);\n                return;\n        }\n        if (runenv) {\n                env_run(runenv);\n                return;\n        }\n```\n> 4. 添加1个系统调用`sys_env_set_priority(envid, priority)`，允许进程的父进程或者自己修改自己的优先级。这里的修改与前面添加系统调用类似。\n``` c\nstatic int\nsys_env_set_priority(envid_t envid, int priority)\n{\n        int ret;\n        struct Env *env;\n\n        if ((ret = envid2env(envid, &env, 1)) < 0)\n                return ret;\n        env->env_priority = priority;\n        return 0;\n}\n```\n\n#### 挑战3\n问:\n> 现在的JOS内核不支持应用来使用x86处理器的浮点数单元(FPU)，MMX指令和SSE扩展指令。扩展Env结构提供保存处理器浮点数状态的空间，扩展进程上下文交换代码来保存和恢复浮点数状态 。\n\n解:\n> 给中断加入保存浮点寄存器的功能。\n> 1. 给`inc/trap.h`文件中的`Trapframe`结构新增`char tf_fpus[512]``成员，并增加`uint32_t tf_padding0[3]``来对齐\n> 2. 修改`kern/trapentry.S`文件中的`_alltraps`函数，加入保存`fpu`寄存器的功能\n```c\n_alltraps:\n        pushl %ds\n        pushl %es\n        pushal\n\n        // save FPU\n        subl $524, %esp\n        fxsave (%esp)\n\n        movl $GD_KD, %eax\n        movl %eax, %ds\n        movl %eax, %es\n\n        push %esp\n        call trap\n```\n> 3. 修改`kern/env.c`文件中的`env_pop_tf`函数，加入恢复`fpu`功能\n``` c\n __asm __volatile(\"movl %0,%%esp\\n\"\n                \"\\tfxrstor (%%esp)\\n\"\n                \"\\taddl $524,%%esp\\n\"\n                \"\\tpopal\\n\"\n                \"\\tpopl %%es\\n\"\n                \"\\tpopl %%ds\\n\"\n                \"\\taddl $0x8,%%esp\\n\" /* skip tf_trapno and tf_errcode */\n                \"\\tiret\"\n                : : \"g\" (tf) : \"memory\");\n```\n\n### 创建环境的系统调用\n虽然当前内核现在有能力运行和切换多用户级进程，但是它仍然只能跑内核初始创建的进程。现在将实现必要的JOS系统调用来运行用户进程来创建和启动其它新的用户进程。\nUnix提供了`fork`系统调用来创建进程，它拷贝父进程的整个地址空间到新创建的子进程。两个进程之间唯一的区别是它们的进程ID，在父进程fork返回的是子进程ID，而在子进程fork返回的是0。\n参照Unix,实现1个不同的更原始的JOS系统调用来创建进程。利用这些系统调用能实现类似Unix的fork函数。\n用户级fork函数在`user/dumbfork.c`中的`dumbfork()`中，该函数将父进程中所有页的内容全部复制过来，唯一不同的地方就是返回值不同。\n\n### 练习7\n问:\n> 实现`ker/syscall.c`中的系统调用。\n\n解:\n> 首先是`sys_exofork`函数，这个系统调用将创建1个新的空白进程，没有映射的用户空间且无法运行。在调用函数时新进程的寄存器状态与父进程相同，但是在父进程会返回子进程的ID，而子进程会返回0。通过设置子进程的eax为0，来让系统调用的返回值为0。\n``` c\nstatic envid_t\nsys_exofork(void)\n{\n        int ret;\n        struct Env *env;\n\n        if ((ret = env_alloc(&env, sys_getenvid())) < 0)\n                return ret;\n        env->env_status = ENV_NOT_RUNNABLE;\n        env->env_tf = curenv->env_tf;\n        env->env_tf.tf_regs.reg_eax = 0;\n        return env->env_id;\n}\n```\n接着是`sys_env_set_status`函数，设置进程的状态为`ENV_RUNNABLE`或者`ENV_NOT_RUNNABLE`。\n``` c\nstatic int\nsys_env_set_status(envid_t envid, int status)\n{\nimplemented\");\n        int ret;\n        struct Env *env;\n\n        if (status != ENV_RUNNABLE && status != ENV_RUNNING)\n                return -E_INVAL;\n        if ((ret = envid2env(envid, &env, 1)) < 0)\n                return ret;\n        env->env_status = status;\n        return 0;\n}\n```\n然后是`env_page_alloc`函数，分配1个物理页并映射到给定进程的进程空间的虚拟地址。\n``` c\nstatic int\nsys_page_alloc(envid_t envid, void *va, int perm)\n{\n        struct Env *env;\n        struct PageInfo *pp;\n\n        if (envid2env(envid, &env, 1) < 0)\n                return -E_BAD_ENV;\n        if ((uintptr_t)va >= UTOP || PGOFF(va))\n                return -E_INVAL;\n        if ((perm & PTE_U) == 0 || (perm & PTE_P) == 0)\n                return -E_INVAL;\n        if ((perm & ~(PTE_U | PTE_P | PTE_W | PTE_AVAIL)) != 0)\n                return -E_INVAL;\n        if ((pp = page_alloc(ALLOC_ZERO)) == NULL)\n                return -E_NO_MEM;\n        if (page_insert(env->env_pgdir, pp, va, perm) < 0) {\n                page_free(pp);\n                return -E_NO_MEM;\n        }\n        return 0;\n}\n```\n最后是s`ys_page_unmap`函数，解除指定进程中的1个页映射。\n```\nstatic int\nsys_page_unmap(envid_t envid, void *va)\n{\n        struct Env *env;\n\n        if (envid2env(envid, &env, 1) < 0)\n                return -E_BAD_ENV;\n        if ((uintptr_t)va >= UTOP || PGOFF(va))\n                return -E_INVAL;\n\n        page_remove(env->env_pgdir, va);\n        return 0;\n}\n```\n至此所有系统调用都完成了，可以运行一下`usr/umbfork.c`。首先看一下主函数，逻辑是父进程创建1个子进程，然后每次打印1条信息后交出控制权，并且让父进程重复10次而子进程重复20次。\n``` c\nvoid\numain(int argc, char **argv)\n{\n        envid_t who;\n        int i;\n\n        // fork a child process\n        who = dumbfork();\n\n        // print a message and yield to the other a few times\n        for (i = 0; i < (who ? 10 : 20); i++) {\n                cprintf(\"%d: I am the %s!\\n\", i, who ? \"parent\" : \"child\");\n                sys_yield();\n        }\n}\n```\n","slug":"lab4","published":1,"updated":"2017-08-26T03:38:21.602Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6sslhbc00183gamaavs9yn3","content":"<h1 id=\"Lab4-抢占式多进程\"><a href=\"#Lab4-抢占式多进程\" class=\"headerlink\" title=\"Lab4 抢占式多进程\"></a>Lab4 抢占式多进程</h1><h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><p>Lab4目标是在多用户环境下实现抢占式多进程的支持，分解为三个部分：</p>\n<ul>\n<li>part1: 在JOS中添加对多处理器的支持，实现循环调度算法，并添加基本的环境管理的系统调用（创建/销毁环境，分配/映射内存）</li>\n<li>part2：实现类似Unix的<code>fork</code>机制，允许在用户模式下创建副本</li>\n<li>part3：添加对进程间通信(IPC)的支持，允许不同的用户环境进行进程间的通信和同步。并添加对硬件时钟中断和进程抢占的支持。</li>\n</ul>\n<h2 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h2><p>下载实验代码：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git pull</div><div class=\"line\">git chekout -b lab4 origin/lab4</div><div class=\"line\">git merge Lab3</div></pre></td></tr></table></figure></p>\n<p>Lab4 新增的文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">kern/cpu.h\t多处理器支持的内核私有定义</div><div class=\"line\">kern/mpconfig.c\t读取多处理器配置的代码</div><div class=\"line\">kern/lapic.c\t驱动处理器中的本地APIC单元的内核代码</div><div class=\"line\">kern/mpentry.S\t非启动CPU的汇编代码入口</div><div class=\"line\">kern/spinlock.h\t包括大内核锁在内的自旋锁的内和私有定义</div><div class=\"line\">kern/spinlock.c\t自旋锁的内核代码实现</div><div class=\"line\">kern/sched.c\t调度器的代码框架</div></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<h2 id=\"part1-多处理器支持和多任务协同\"><a href=\"#part1-多处理器支持和多任务协同\" class=\"headerlink\" title=\"part1 多处理器支持和多任务协同\"></a>part1 多处理器支持和多任务协同</h2><p>Lab4 part1将首先扩展JOS以在多处理器系统上运行，然后实现新的JOS内核系统调用，以允许用户级环境创建其他新的环境。另外实现协同循环调度，当当前环境自动放弃CPU（或退出）时，允许内核从一个环境切换到另一个环境。之后在part3中，还会实现抢占式调度，即使在环境不允许的情况下，允许内核在一定时间内重新从环境中重新控制CPU。</p>\n<h3 id=\"多处理器支持\"><a href=\"#多处理器支持\" class=\"headerlink\" title=\"多处理器支持\"></a>多处理器支持</h3><p>目标使JOS支持对称多处理器(SMP)。<code>SMP</code>是一种多处理器架构，所有的CPU对等地访问系统资源。在SMP中所有CPU的功能是相同的，但是在启动过程中会被分为2类：引导处理器(<code>BSP</code>)负责初始化系统来启动操作系统，当操作系统被启动后，应用处理器(<code>AP</code>)被引导处理器激活。引导处理器是由硬件和BIOS决定的，目前所有的代码都是运行在BSP上。<br>在个SMP系统中，每个CPU有1个附属的<code>Local APIC（LAPIC）</code>单元。LAPIC单元负责处理系统中的中断，同时为它关联的CPU提供独一无二的标识符。在part1，将使用LAPIC单元以下基本功能(在<code>/kern/lapic.c</code>)：</p>\n<ul>\n<li>读取LAPIC的标识符(APIC ID)来告诉我们正在哪个CPU上运行代码(<code>cpunum()</code>).</li>\n<li>从BSP发送STARTUP的处理器间中断(<code>IPI</code>) 到APs来唤醒其它CPU(<code>lapic_startup()</code>).</li>\n<li>在part3部分，将编程LAPIC内置的计时器来触发时钟中断来支持多任务抢占(<code>apic_init()</code>).</li>\n</ul>\n<p>处理器访通过内存映射I/O(MMIO)的方式访问它的LAPIC。在MMIO中，一部分物理地址被硬连接到一些IO设备的寄存器上，导致操作内存的指令<code>load/store</code>可以直接操作设备的寄存器。我们已经看到过1个<code>IO hole</code>在物理地址<code>0xA0000</code>(用来写入VGA显示缓存)。LAPIC的hole开始于物理地址<code>0xFE000000</code>(4GB之下地32MB)，但是这地址过高，导致无法访问通过过去的直接映射(虚拟地址<code>0xF0000000</code>映射0x0，即只有256MB)。但是JOS虚拟地址映射预留了4MB空间在<code>MMIOBASE</code>处，需要分配空间一映射设备。</p>\n<h4 id=\"练习1\"><a href=\"#练习1\" class=\"headerlink\" title=\"练习1\"></a>练习1</h4><p>问</p>\n<blockquote>\n<p>在<code>kern/pmap.c</code>中实现<code>mmio_map_region</code>。查看<code>lapic_init</code>函数(<code>kern/lapic.c</code>)来确定使用方式</p>\n</blockquote>\n<p>解：</p>\n<blockquote>\n<p>在<code>lapic_init</code>函数的开头就会调用<code>mmio_map_region</code><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// lapicaddr is the physical address of the LAPIC's 4K MMIO</span></div><div class=\"line\"><span class=\"comment\">// region.  Map it in to virtual memory so we can access it.</span></div><div class=\"line\">lapic = mmio_map_region(lapicaddr, <span class=\"number\">4096</span>);</div></pre></td></tr></table></figure></p>\n<p>在<code>kern/pmap.c</code>中，有具体的提示，设置个静态变量记录每次变化后的虚拟基地址，使用<code>boot_map_region</code>函数将<code>[pa,pa+size)的</code>物理地址映射到<code>[base,base+size)</code>，把<code>size</code>向上进位到<code>PGSIZE</code>。由于这是设备内存并不是正常的DRAM，所以使用cache缓存访问是不安全的，可以用页的标志位来实现。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//kern/pmap.c</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *</span></div><div class=\"line\"><span class=\"title\">mmio_map_region</span><span class=\"params\">(<span class=\"keyword\">physaddr_t</span> pa, <span class=\"keyword\">size_t</span> size)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">uintptr_t</span> base = MMIOBASE;</div><div class=\"line\">    <span class=\"keyword\">void</span> *ret = (<span class=\"keyword\">void</span> *)base;</div><div class=\"line\"></div><div class=\"line\">    size = ROUNDUP(size, PGSIZE);</div><div class=\"line\">    <span class=\"keyword\">if</span> (base + size &gt; MMIOLIM || base + size &lt; base)</div><div class=\"line\">                panic(<span class=\"string\">\"mmio_map_region: reservation overflow\\n\"</span>);</div><div class=\"line\"></div><div class=\"line\">    boot_map_region(kern_pgdir, base, size, pa, PTE_P | PTE_PCD | PTE_PWT);</div><div class=\"line\">    base += size;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> ret;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"引导应用处理器-Application-Processor\"><a href=\"#引导应用处理器-Application-Processor\" class=\"headerlink\" title=\"引导应用处理器(Application Processor)\"></a>引导应用处理器(Application Processor)</h3><p>在启动AP之前，BSP应该先收集关于多处理器系统的配置信息，比如CPU总数，CPUs的APIC ID和LAPIC单元的MMIO地址等。在<code>kern/mpconfig</code>文件中的<code>mp_init()</code>函数通过读BIOS设定的<code>MP配置表</code>获取这些信息。<br><code>boot_aps(kern/init.c)</code>函数驱动AP引导程序。AP开始于实模式，跟BSP的开始相同，故此<code>boot_aps</code>函数拷贝AP入口代码(<code>kern/mpentry.S</code>)到实模式下的内存寻址空间。但是跟BSP不一样的是，当AP开始执行时，需要有一些控制将拷贝入口代码到<code>0x7000(MPENTRY_PADDR)</code>。<br>之后，<code>boot_aps</code>函数通过发送<code>STARTUP的IPI</code>(处理器间中断)信号到AP的LAPIC单元来一个个地激活AP。在<code>kern/mpentry.S</code>中的入口代码跟<code>boot/boot.S</code>中的代码类似。在一些简短的配置后，它使AP进入开启分页机制的保护模式，调用C语言的setup函数<code>mp_main</code>（<code>kern/init.c</code>)。<code>boot_aps()</code>等待AP <code>CPU_STARTED</code>在<code>cpu_status</code>其字段中设定出一个flag，设定<code>struct CpuInfo</code>然后继续唤醒下一个。</p>\n<p>结合前几个lab，在i386 <code>init</code>函数中进行BSP启动的一些配置，经由lab2的<code>mem_init</code>，lab3的<code>env_init</code>和<code>trap_init</code>，lab4的<code>mp_init</code>和<code>lapic_init</code>，然后<code>boot_aps</code>函数启动所有的CPU<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// lab2 memory management initialization functions</span></div><div class=\"line\">mem_init();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// lab3 user environment initialization functions</span></div><div class=\"line\">env_init();</div><div class=\"line\">trap_init();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// lab4 multiprocessor initialization functions</span></div><div class=\"line\">mp_init();</div><div class=\"line\">lapic_init();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// lab4 multitasking initialization functions</span></div><div class=\"line\">pic_init();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Acquire the bit kernel lock before waiting AP</span></div><div class=\"line\">lock_kernel();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// starting non-boot APs</span></div><div class=\"line\">boot_aps();</div></pre></td></tr></table></figure></p>\n<p>多核处理器的初始化都在mp_init函数中完成，首先是调用mpconfig函数，主要功能是寻找一个MP 配置条目，然后对所有的CPU进行配置，找到启动的处理器。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">mp_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">struct</span> mp *mp;</div><div class=\"line\">    <span class=\"keyword\">struct</span> mpconf *conf;</div><div class=\"line\">    <span class=\"keyword\">struct</span> mpproc *proc;</div><div class=\"line\">    <span class=\"keyword\">uint8_t</span> *p;</div><div class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> i;</div><div class=\"line\"></div><div class=\"line\">    bootcpu = &amp;cpus[<span class=\"number\">0</span>];</div><div class=\"line\">    <span class=\"keyword\">if</span> ((conf = mpconfig(&amp;mp)) == <span class=\"number\">0</span>)</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    ismp = <span class=\"number\">1</span>;</div><div class=\"line\">    lapicaddr = conf-&gt;lapicaddr;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (p = conf-&gt;entries, i = <span class=\"number\">0</span>; i &lt; conf-&gt;entry; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">switch</span> (*p) &#123;</div><div class=\"line\">\t\t    <span class=\"keyword\">case</span> MPPROC:</div><div class=\"line\">        proc = (<span class=\"keyword\">struct</span> mpproc *)p;</div><div class=\"line\">\t\t\t  <span class=\"keyword\">if</span> (proc-&gt;flags &amp; MPPROC_BOOT)</div><div class=\"line\">\t\t\t\t    bootcpu = &amp;cpus[ncpu];</div><div class=\"line\">\t\t\t  <span class=\"keyword\">if</span> (ncpu &lt; NCPU) &#123;</div><div class=\"line\">\t\t\t\t    cpus[ncpu].cpu_id = ncpu;</div><div class=\"line\">\t\t\t\t    ncpu++;</div><div class=\"line\">\t\t\t  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            cprintf(<span class=\"string\">\"SMP: too many CPUs, CPU %d disabled\\n\"</span>,</div><div class=\"line\">            proc-&gt;apicid);</div><div class=\"line\">\t\t\t  &#125;</div><div class=\"line\">        p += <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> mpproc);</div><div class=\"line\">        <span class=\"keyword\">continue</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> MPBUS:</div><div class=\"line\">        <span class=\"keyword\">case</span> MPIOAPIC:</div><div class=\"line\">        <span class=\"keyword\">case</span> MPIOINTR:</div><div class=\"line\">        <span class=\"keyword\">case</span> MPLINTR:</div><div class=\"line\">        p += <span class=\"number\">8</span>;</div><div class=\"line\">        <span class=\"keyword\">continue</span>;</div><div class=\"line\">        <span class=\"keyword\">default</span>:</div><div class=\"line\">            cprintf(<span class=\"string\">\"mpinit: unknown config type %x\\n\"</span>, *p);</div><div class=\"line\">        ismp = <span class=\"number\">0</span>;</div><div class=\"line\">        i = conf-&gt;entry;</div><div class=\"line\">\t      &#125;</div><div class=\"line\">\t &#125;</div></pre></td></tr></table></figure></p>\n<p>在启动过程中，<code>mp_init</code>和<code>lapic_init</code>是和硬件以及体系架构紧密相关的，通过读取某个特殊内存地址（当然前提是能读取的到，所以在<code>mem_init</code>中需要修改进行相应映射），来获取CPU的信息，根据这些信息初始化CPU结构。<br>在<code>boot_aps</code>函数中首先找到一段用于启动的汇编代码，该代码和lab3是嵌入在内核代码段之上的一部分，其中<code>mpentry_start</code>和<code>mpentry_end</code>是编译器导出符号，代表这段代码在内存（虚拟地址）中的起止位置，接着把代码复制到<code>MPENTRY_PADDR</code>处。随后调用<code>lapic_startap</code>来命令特定的AP去执行这段代码。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Start the non-boot (AP) processors.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">boot_aps</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">extern</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> mpentry_start[], mpentry_end[];</div><div class=\"line\">  \t<span class=\"keyword\">void</span> *code;</div><div class=\"line\">  \t<span class=\"keyword\">struct</span> CpuInfo *c;</div><div class=\"line\"></div><div class=\"line\">  \t<span class=\"comment\">// Write entry code to unused memory at MPENTRY_PADDR</span></div><div class=\"line\">  \tcode = KADDR(MPENTRY_PADDR);</div><div class=\"line\">  \tmemmove(code, mpentry_start, mpentry_end - mpentry_start);</div><div class=\"line\"></div><div class=\"line\">  \t<span class=\"comment\">// Boot each AP one at a time</span></div><div class=\"line\">  \t<span class=\"keyword\">for</span> (c = cpus; c &lt; cpus + ncpu; c++) &#123;</div><div class=\"line\">  \t\t<span class=\"keyword\">if</span> (c == cpus + cpunum())  <span class=\"comment\">// We've started already.</span></div><div class=\"line\">  \t\t\t<span class=\"keyword\">continue</span>;</div><div class=\"line\"></div><div class=\"line\">  \t\t<span class=\"comment\">// Tell mpentry.S what stack to use</span></div><div class=\"line\">  \t\tmpentry_kstack = percpu_kstacks[c - cpus] + KSTKSIZE;</div><div class=\"line\">  \t\t<span class=\"comment\">// Start the CPU at mpentry_start</span></div><div class=\"line\">  \t\tlapic_startap(c-&gt;cpu_id, PADDR(code));</div><div class=\"line\">  \t\t<span class=\"comment\">// Wait for the CPU to finish some basic setup in mp_main()</span></div><div class=\"line\">  \t\t<span class=\"keyword\">while</span>(c-&gt;cpu_status != CPU_STARTED)</div><div class=\"line\">  \t\t\t;</div><div class=\"line\">  \t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"练习2\"><a href=\"#练习2\" class=\"headerlink\" title=\"练习2\"></a>练习2</h4><p>问</p>\n<blockquote>\n<p>修改<code>page_init</code>函数(<code>kern/page.c</code>)的实现，来避免将<code>MPENTRY_PADDR</code>处的物理页加入到空闲链表中,使得能安全地拷贝和运行AP的启动代码。</p>\n</blockquote>\n<p>解：</p>\n<blockquote>\n<p>在<code>boot_aps</code>函数中将启动代码放到了<code>MPENTRY_PADDR</code>处，而代码的来源则是在<code>kern/mpentry.S</code>中，功能与<code>boot.S</code>中的非常类似，主要就是开启分页模式，转到内核栈上去，实际上这时内核栈还没建好。在执行完<code>mpentry.S</code>中的代码之后，将会跳转到<code>mp_main</code>函数中去。而这里需要提前做的，就是将<code>MPENTRY_PADDR</code>处的物理页表标识为已用，这样不会将这一页放在空闲链表中分配出去。只需要在<code>page_init</code>中添加一个判断就可以。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//kern/pmap.c</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">page_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    ......</div><div class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; npages; i++) &#123;</div><div class=\"line\">        ......</div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i == MPENTRY_PADDR / PGSIEZ)</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        ......</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"问题1\"><a href=\"#问题1\" class=\"headerlink\" title=\"问题1\"></a>问题1</h3><p>问</p>\n<blockquote>\n<p>仔细比较<code>kern/mpentry.S</code>与<code>boot/boot.S</code>，<code>kern/mpentry.S</code>是被编译链接来运行在<code>KERNBASE</code>之上的，那么定义`MPBOOTPHYS宏``的目的是什么？为什么在kern/mpentry.S中是必要的，在boot/boot.S中不是呢？换句话说，如果在kern/mpentry.S中忽略它，会出现什么错误？</p>\n</blockquote>\n<p>解<br>&gt;<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">#define MPBOOTPHYS(s) ((s) - mpentry_start + MPENTRY_PADDR))))</div><div class=\"line\">// MPBOOTPHYS is to calculate symobl address relative to MPENTRY_PADDR. The ASM is executed in the load address above KERNBASE, but JOS need to run mp_main at 0x7000 address! Of course 0x7000’s page is reserved at pmap.c.</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>在AP的保护模式打开之前，是没有办法寻址到3G以上的空间的，因此用<code>MPBOOTPHYS</code>是用来计算相应的物理地址的。但是在<code>boot.S</code>中，由于尚没有启用分页机制，所以能够指定程序开始执行的地方以及程序加载的地址；但是，在<code>mpentry.S</code>的时候，由于主CPU已经处于保护模式下了，因此是不能直接指定物理地址的，而给定线性地址映射到相应的物理地址是允许的。</p>\n</blockquote>\n<h3 id=\"CPU的状态和初始化\"><a href=\"#CPU的状态和初始化\" class=\"headerlink\" title=\"CPU的状态和初始化\"></a>CPU的状态和初始化</h3><p>在编写多处理器操作系统时，区分每个处理器私有的每个CPU状态以及整个系统共享的全局状态是非常重要的。 <code>kern / cpu.h</code>定义了大多数CPU状态，包括<code>struct CpuInfo</code>存储CPU变量。 <code>cpunum()</code>返回调用它的CPU的ID，可以用作数组的索引<code>cpus</code>。<br>每个CPU独有的变量应该有：</p>\n<ul>\n<li>内核栈<br>因为多个CPU可以同时陷入内核，所以我们需要为每个处理器分配一个内核栈，以防止它们干扰对方的执行。数组<code>percpu_kstacks[NCPU][KSTKSIZE]</code>为<code>NCPU</code>的内核栈提供了空间。</li>\n<li>TSS和TSS描述符<br>每个CPU任务状态段（TSS）也是需要的，以便指定每个CPU内核栈的位置。存储CPU i的<code>TSS cpus[i].cpu_ts</code>，并在GDT条目中定义相应的TSS描述符<code>gdt[(GD_TSS0 &gt;&gt; 3) + i]</code>。<code>ts</code>在<code>kern / trap.c</code>中定义的全局变量将不再有用。</li>\n<li>CPU的当前环境指针<br>由于每个CPU可以同时运行不同的用户进程中，因此重新定义了符号<code>curenv</code>来指代<code>cpus[cpunum()].cpu_env</code>（或<code>thiscpu-&gt;cpu_env</code>），它指向环境当前的上执行当前CPU（在其上运行代码的CPU）。</li>\n<li>CPU的系统寄存器<br>所有寄存器（包括系统寄存器）对于CPU都是专用的。因此，初始化这些寄存器的指令，例如<code>lcr3()， ltr()，lgdt()，lidt()</code>等，必须进行一次各CPU上执行。功能<code>env_init_percpu()</code>和<code>trap_init_percpu()</code>执行此功能。</li>\n</ul>\n<h4 id=\"练习3\"><a href=\"#练习3\" class=\"headerlink\" title=\"练习3\"></a>练习3</h4><p>问</p>\n<blockquote>\n<p>修改<code>mem_init_mp</code>函数来映射开始于<code>KSTACKTOP</code>的CPU栈。</p>\n</blockquote>\n<p>解</p>\n<blockquote>\n<p>多CPU的内存分布如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">KERNBASE ----&gt; +-------------------------+ 0xf0000000</div><div class=\"line\">KSTACKTOP      |   CPU0&apos;s Kernel Stack   | RW/-- KSTKSIZE</div><div class=\"line\">               |-------------------------|</div><div class=\"line\">               |   Invalid Memory(*)     | --/-- KSTKGAP</div><div class=\"line\">               +-------------------------+</div><div class=\"line\">               |    CPU1&apos;s Kernel STACK  | RW/-- KSTKSIZE</div><div class=\"line\">               |-------------------------|</div><div class=\"line\">               |   Invalid Memory(*)     | --/-- KSTKGAP</div><div class=\"line\">               +-------------------------+</div><div class=\"line\">               .             .           .</div><div class=\"line\">               .             .           .</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>需要为每个核都分配一个内核栈，每个内核栈的大小是<code>KSTKSIZE</code>，而内核栈之间的间距是<code>KSTKGAP</code>，起到保护作用。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//kern/pmap.c</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">mem_init_mp</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> i;</div><div class=\"line\">    <span class=\"keyword\">uintptr_t</span> kstacktop_i;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; NCPU; i++) &#123;</div><div class=\"line\">        kstacktop_i = KSTACKTOP - i * (KSTKGAP + KSTKSIZE);</div><div class=\"line\">        boot_map_region(kern_pgdir,</div><div class=\"line\">                        kstacktop_i - KSTKSIZE,</div><div class=\"line\">                        ROUNDUP(KSTKSIZE, PGSIZE),</div><div class=\"line\">                        PADDR(&amp;percpu_kstacks[i]),</div><div class=\"line\">                        PTE_W | PTE_P);</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"练习4\"><a href=\"#练习4\" class=\"headerlink\" title=\"练习4\"></a>练习4</h4><p>问：</p>\n<blockquote>\n<p>在<code>trap_init_percpu</code>函数中为BSP初始化TSS和TSS描述符，这在Lab3中是可行的，但是在这里会有问题，修改代码使它可以运行在所有CPU上。</p>\n</blockquote>\n<p>解：</p>\n<blockquote>\n<p>由于有多个CPU，所以在这里不能使用原先的全局变量<code>ts</code>，应该利用<code>thiscpu</code>指向的<code>CpuInfo</code>结构体和<code>cpunum</code>函数来为每个核的<code>TSS</code>进行初始化。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">trap_init_percpu</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    thiscpu-&gt;cpu_ts.ts_esp0 = KSTACKTOP - cpunum() * (KSTKGAP + KSTKSIZE);</div><div class=\"line\">    thiscpu-&gt;cpu_ts.ts_ss0 = GD_KD;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Initialize the TSS slot of the gdt.</span></div><div class=\"line\">    gdt[(GD_TSS0 &gt;&gt; <span class=\"number\">3</span>) + cpunum()] = SEG16(STS_T32A, (<span class=\"keyword\">uint32_t</span>) (&amp;thiscpu-&gt;cpu_ts), <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> Taskstate) - <span class=\"number\">1</span>, <span class=\"number\">0</span>);</div><div class=\"line\">    gdt[(GD_TSS0 &gt;&gt; <span class=\"number\">3</span>) + cpunum()].sd_s = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Load the TSS selector (like other segment selectors, the</span></div><div class=\"line\">    <span class=\"comment\">// bottom three bits are special; we leave them 0)</span></div><div class=\"line\">    ltr(GD_TSS0 + <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> Segdesc) * cpunum());</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Load the IDT</span></div><div class=\"line\">    lidt(&amp;idt_pd);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h3><p>在<code>mp_main</code>函数中初始化AP后，代码就会进入自旋。在让AP进行更多操作之前，首先要解决多CPU同时运行在内核时产生的竞争问题。最简单的办法是实现1个大内核锁（big kernel lock)，1次只让一个进程进入内核模式，当CPU离开内核时释放锁。<br>在<code>kern/spinlock.h</code>中声明了大内核锁，提供了<code>lock_kernel</code>和<code>unlock_kernel</code>函数来快捷地获得和释放锁。总共有四处用到大内核锁：</p>\n<ul>\n<li>在启动的时候，BSP启动其余的CPU之前，BSP需要取得内核锁</li>\n<li><code>mp_main</code>中，也就是CPU被启动之后执行的第一个函数，这里应该是调用调度函数，选择一个进程来执行的，但是在执行调度函数之前，必须获取锁</li>\n<li>`trap函数``也要修改，因为可以访问临界区的CPU只能有一个，所以从用户态陷入到内核态的话，要加锁，因为可能多个CPU同时陷入内核态</li>\n<li><code>env_run</code>函数，也就是启动进程的函数，之前在lab3中实现的，在这个函数执行结束之后，就将跳回到用户态，此时离开内核，也就是需要将内核锁释放</li>\n</ul>\n<p>加锁后，将原有的并行执行过程在关键位置变为串行执行过程，整个启动过程大概如下：</p>\n<blockquote>\n<p>i386_init–&gt;BSP获得锁–&gt;boot_ap–&gt;(BSP建立为每个cpu建立idle任务、建立用户任务，mp_main)—&gt;BSP的sched_yield–&gt;其中的env_run释放锁–&gt;AP1获得锁–&gt;执行sched_yield–&gt;释放锁–&gt;AP2获得锁–&gt;执行sched_yield–&gt;释放锁…..</p>\n</blockquote>\n<h4 id=\"练习5\"><a href=\"#练习5\" class=\"headerlink\" title=\"练习5\"></a>练习5</h4><p>问</p>\n<blockquote>\n<p>在上述位置应用大内核锁。</p>\n</blockquote>\n<p>解<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//i386_init</span></div><div class=\"line\">lock_kernel();</div><div class=\"line\">boot_aps();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//mp_main</span></div><div class=\"line\">lock_kernel();</div><div class=\"line\">sched_yield();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//trap</span></div><div class=\"line\"><span class=\"keyword\">if</span> ((tf-&gt;tf_cs &amp; <span class=\"number\">3</span>) == <span class=\"number\">3</span>) &#123;</div><div class=\"line\">    lock_kernel();</div><div class=\"line\">    assert(curenv);</div><div class=\"line\">    ......</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//env_run</span></div><div class=\"line\">lcr3(PADDR(curenv-&gt;env_pgdir));</div><div class=\"line\">unlock_kernel();</div><div class=\"line\">env_pop_tf(&amp;(curenv-&gt;env_tf));</div></pre></td></tr></table></figure></p>\n<h3 id=\"问题2\"><a href=\"#问题2\" class=\"headerlink\" title=\"问题2\"></a>问题2</h3><p>问：</p>\n<blockquote>\n<p>既然大内核锁保证了只有1个CPU能运行在内核，为什么我们还要为每个CPU准备1个内核栈。</p>\n</blockquote>\n<p>解:</p>\n<blockquote>\n<p>因为不同的内核栈上可能保存有不同的信息，当1个CPU从内核退出来之后，有可能在内核栈中留下了一些将来还有用的数据，所以一定要有单独的栈。</p>\n</blockquote>\n<h3 id=\"挑战1\"><a href=\"#挑战1\" class=\"headerlink\" title=\"挑战1\"></a>挑战1</h3><p>问:</p>\n<blockquote>\n<p>大内核锁简单便于应用，但是它取消了内核模式的并行。大多数现代操作系统使用不同的锁来保护共享状态的不同部分，这称之为细粒度锁。细粒度锁能有效地提高性能，但是也更困难地去实现和检测错误。所以你可以去掉大内核锁，在JOS中实现内核并发。</p>\n</blockquote>\n<p>解</p>\n<blockquote>\n<p>思路:实验指导中提供了一些JOS内核中的共享结构，具体实现就是在保证在使用这些结构体时保证互斥。\n　　</p>\n<h3 id=\"循环调度-Round-Robin-Scheduling\"><a href=\"#循环调度-Round-Robin-Scheduling\" class=\"headerlink\" title=\"循环调度(Round-Robin Scheduling)\"></a>循环调度(Round-Robin Scheduling)</h3><p>接下来的任务是改变JOS内核，实现<code>round-robin</code>调度算法。<br>主要是在<code>sched_yield</code>函数内实现，从该CPU上一次运行的进程开始，在进程描述符表中寻找下一个可以运行的进程，如果没找到而且上一个进程依然是可以运行的，那么就可以继续运行上一个进程，同时将这个算法实现为了一个系统调用，使得进程可以主动放弃CPU。</p>\n</blockquote>\n<h4 id=\"练习6\"><a href=\"#练习6\" class=\"headerlink\" title=\"练习6\"></a>练习6</h4><p>问:</p>\n<blockquote>\n<p>实现<code>sched_yield</code>函数，并添加系统调用。</p>\n</blockquote>\n<p>解:</p>\n<blockquote>\n<p>修改代码如下.然后修改<code>kern/syscall.c</code>,添加相关的系统调用机制。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">void</div><div class=\"line\">sched_yield(void)</div><div class=\"line\">&#123;</div><div class=\"line\">        uint32_t i, j, start;</div><div class=\"line\">        struct Env *runenv;</div><div class=\"line\"></div><div class=\"line\">        idle = thiscpu-&gt;cpu_env;</div><div class=\"line\">        start = (idle != NULL) ? ENVX(idle-&gt;env_id) : 0;</div><div class=\"line\">        runenv = NULL;</div><div class=\"line\"></div><div class=\"line\">        for (i = 0; i &lt; NENV; i++) &#123;</div><div class=\"line\">                j = (start + i) % NENV;</div><div class=\"line\">                if (envs[j].env_status == ENV_RUNNABLE) &#123;</div><div class=\"line\">                        if (runenv == NULL || envs[j].env_priority &lt; runenv-&gt;env_priority)</div><div class=\"line\">                                runenv = &amp;envs[j];</div><div class=\"line\">                &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if ((idle &amp;&amp; idle-&gt;env_status == ENV_RUNNING) &amp;&amp; (runenv == NULL || idle-&gt;env_priority &lt; runenv-&gt;env_priority))&#123;</div><div class=\"line\">                env_run(idle);</div><div class=\"line\">                return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (runenv) &#123;</div><div class=\"line\">                env_run(runenv);</div><div class=\"line\">                return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        // sched_halt never returns</div><div class=\"line\">        sched_halt();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>　　</p>\n<h4 id=\"问题3\"><a href=\"#问题3\" class=\"headerlink\" title=\"问题3\"></a>问题3</h4><p>问:</p>\n<blockquote>\n<p>在<code>lcr3()</code>运行之后，这个CPU对应的页表就立刻被换掉了，但是这个时候的参数e，也就是现在的<code>curenv</code>，为什么还是能正确的解引用？</p>\n</blockquote>\n<p>解:</p>\n<blockquote>\n<p>因为当前是运行在系统内核中的，而每个进程的页表中都是存在内核映射的。每个进程页表中虚拟地址高于<code>UTOP</code>之上的地方，只有<code>UVPT</code>不一样，其余的都是一样的，只不过在用户态下是看不到的。所以虽然这个时候的页表换成了下一个要运行的进程的页表，但是<code>curenv</code>的地址没变，映射也没变，还是依然有效的。</p>\n</blockquote>\n<h4 id=\"问题4\"><a href=\"#问题4\" class=\"headerlink\" title=\"问题4\"></a>问题4</h4><p>问:</p>\n<blockquote>\n<p>在用户环境进行切换时，为什么旧进程的寄存器一定要被保存以便之后重新装载？在哪里发生这样的操作？</p>\n</blockquote>\n<p>解:</p>\n<blockquote>\n<p>因为如果不进行保存，旧进程运行时的状态就丢失了，运行就不正确了。每次进入到内核态的时候，当前的运行状态都是在一进入的时候就保存了的。如果没有发生调度，那么之前<code>trapframe</code>中的信息还是会恢复回去，如果发生了调度，恢复的就是被调度运行的进程的上下文了。</p>\n</blockquote>\n<h4 id=\"挑战2\"><a href=\"#挑战2\" class=\"headerlink\" title=\"挑战2\"></a>挑战2</h4><p>问:</p>\n<blockquote>\n<p>添加固定优先级的调度策略，确保高优先级的进程总是先于低优先级的进程。</p>\n</blockquote>\n<p>解：</p>\n<blockquote>\n<p>思路:为每个进程的结构体添加1个标志优先级的变量，在<code>sched_yield</code>时遍历链表选取优先级最高的可运行进程作为下一个运行进程。</p>\n<ol>\n<li>在<code>inc/env.h</code>中给<code>Env</code>结构添加1个成员<code>int env_priority</code></li>\n<li><p>在<code>kern/env.c</code>中的<code>env_alloc</code>中给进程赋值为默认优先级<code>ENV_PRIOR_DEFAULT</code>，一共设立了四个基本的优先级，数字越小优先级越高</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//inc/env.h</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ENV_PRIOR_SUPER 0</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ENV_PRIOR_HIGH 10</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ENV_PRIOR_NORMAL 100</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ENV_PRIOR_LOW 1000</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>修改<code>kern/sched.c</code>中<code>sched_yield</code>函数的调度策略</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//kern/sched.c  sched_yield()</span></div><div class=\"line\">        idle = thiscpu-&gt;cpu_env;</div><div class=\"line\">        start = (idle != <span class=\"literal\">NULL</span>) ? ENVX(idle-&gt;env_id) : <span class=\"number\">0</span>;</div><div class=\"line\">        runenv = <span class=\"literal\">NULL</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; NENV; i++) &#123;</div><div class=\"line\">                j = (start + i) % NENV;</div><div class=\"line\">                <span class=\"keyword\">if</span> (envs[j].env_status == ENV_RUNNABLE) &#123;</div><div class=\"line\">                        <span class=\"keyword\">if</span> (runenv == <span class=\"literal\">NULL</span> || envs[j].env_priority &lt; runenv-&gt;env_priority)</div><div class=\"line\">                                runenv = &amp;envs[j];</div><div class=\"line\">                &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> ((idle &amp;&amp; idle-&gt;env_status == ENV_RUNNING) &amp;&amp; (runenv == <span class=\"literal\">NULL</span> || idle-&gt;env_priority &lt; runenv-&gt;env_priority))&#123;</div><div class=\"line\">                env_run(idle);</div><div class=\"line\">                <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (runenv) &#123;</div><div class=\"line\">                env_run(runenv);</div><div class=\"line\">                <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>添加1个系统调用<code>sys_env_set_priority(envid, priority)</code>，允许进程的父进程或者自己修改自己的优先级。这里的修改与前面添加系统调用类似。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span></span></div><div class=\"line\"><span class=\"title\">sys_env_set_priority</span><span class=\"params\">(<span class=\"keyword\">envid_t</span> envid, <span class=\"keyword\">int</span> priority)</span></div><div class=\"line\">&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> ret;</div><div class=\"line\">        <span class=\"keyword\">struct</span> Env *env;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> ((ret = envid2env(envid, &amp;env, <span class=\"number\">1</span>)) &lt; <span class=\"number\">0</span>)</div><div class=\"line\">                <span class=\"keyword\">return</span> ret;</div><div class=\"line\">        env-&gt;env_priority = priority;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n</blockquote>\n<h4 id=\"挑战3\"><a href=\"#挑战3\" class=\"headerlink\" title=\"挑战3\"></a>挑战3</h4><p>问:</p>\n<blockquote>\n<p>现在的JOS内核不支持应用来使用x86处理器的浮点数单元(FPU)，MMX指令和SSE扩展指令。扩展Env结构提供保存处理器浮点数状态的空间，扩展进程上下文交换代码来保存和恢复浮点数状态 。</p>\n</blockquote>\n<p>解:</p>\n<blockquote>\n<p>给中断加入保存浮点寄存器的功能。</p>\n<ol>\n<li>给<code>inc/trap.h</code>文件中的<code>Trapframe</code>结构新增<code>char tf_fpus[512]``成员，并增加</code>uint32_t tf_padding0[3]``来对齐</li>\n<li><p>修改<code>kern/trapentry.S</code>文件中的<code>_alltraps</code>函数，加入保存<code>fpu</code>寄存器的功能</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">_alltraps:</div><div class=\"line\">        pushl %ds</div><div class=\"line\">        pushl %es</div><div class=\"line\">        pushal</div><div class=\"line\"></div><div class=\"line\">        // save FPU</div><div class=\"line\">        subl $524, %esp</div><div class=\"line\">        fxsave (%esp)</div><div class=\"line\"></div><div class=\"line\">        movl $GD_KD, %eax</div><div class=\"line\">        movl %eax, %ds</div><div class=\"line\">        movl %eax, %es</div><div class=\"line\"></div><div class=\"line\">        push %esp</div><div class=\"line\">        call trap</div></pre></td></tr></table></figure>\n</li>\n<li><p>修改<code>kern/env.c</code>文件中的<code>env_pop_tf</code>函数，加入恢复<code>fpu</code>功能</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">__asm __volatile(<span class=\"string\">\"movl %0,%%esp\\n\"</span></div><div class=\"line\">               <span class=\"string\">\"\\tfxrstor (%%esp)\\n\"</span></div><div class=\"line\">               <span class=\"string\">\"\\taddl $524,%%esp\\n\"</span></div><div class=\"line\">               <span class=\"string\">\"\\tpopal\\n\"</span></div><div class=\"line\">               <span class=\"string\">\"\\tpopl %%es\\n\"</span></div><div class=\"line\">               <span class=\"string\">\"\\tpopl %%ds\\n\"</span></div><div class=\"line\">               <span class=\"string\">\"\\taddl $0x8,%%esp\\n\"</span> <span class=\"comment\">/* skip tf_trapno and tf_errcode */</span></div><div class=\"line\">               <span class=\"string\">\"\\tiret\"</span></div><div class=\"line\">               : : <span class=\"string\">\"g\"</span> (tf) : <span class=\"string\">\"memory\"</span>);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"创建环境的系统调用\"><a href=\"#创建环境的系统调用\" class=\"headerlink\" title=\"创建环境的系统调用\"></a>创建环境的系统调用</h3><p>虽然当前内核现在有能力运行和切换多用户级进程，但是它仍然只能跑内核初始创建的进程。现在将实现必要的JOS系统调用来运行用户进程来创建和启动其它新的用户进程。<br>Unix提供了<code>fork</code>系统调用来创建进程，它拷贝父进程的整个地址空间到新创建的子进程。两个进程之间唯一的区别是它们的进程ID，在父进程fork返回的是子进程ID，而在子进程fork返回的是0。<br>参照Unix,实现1个不同的更原始的JOS系统调用来创建进程。利用这些系统调用能实现类似Unix的fork函数。<br>用户级fork函数在<code>user/dumbfork.c</code>中的<code>dumbfork()</code>中，该函数将父进程中所有页的内容全部复制过来，唯一不同的地方就是返回值不同。</p>\n<h3 id=\"练习7\"><a href=\"#练习7\" class=\"headerlink\" title=\"练习7\"></a>练习7</h3><p>问:</p>\n<blockquote>\n<p>实现<code>ker/syscall.c</code>中的系统调用。</p>\n</blockquote>\n<p>解:</p>\n<blockquote>\n<p>首先是<code>sys_exofork</code>函数，这个系统调用将创建1个新的空白进程，没有映射的用户空间且无法运行。在调用函数时新进程的寄存器状态与父进程相同，但是在父进程会返回子进程的ID，而子进程会返回0。通过设置子进程的eax为0，来让系统调用的返回值为0。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> envid_t</span></div><div class=\"line\"><span class=\"title\">sys_exofork</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></div><div class=\"line\">&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> ret;</div><div class=\"line\">        <span class=\"keyword\">struct</span> Env *env;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> ((ret = env_alloc(&amp;env, sys_getenvid())) &lt; <span class=\"number\">0</span>)</div><div class=\"line\">                <span class=\"keyword\">return</span> ret;</div><div class=\"line\">        env-&gt;env_status = ENV_NOT_RUNNABLE;</div><div class=\"line\">        env-&gt;env_tf = curenv-&gt;env_tf;</div><div class=\"line\">        env-&gt;env_tf.tf_regs.reg_eax = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> env-&gt;env_id;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>接着是<code>sys_env_set_status</code>函数，设置进程的状态为<code>ENV_RUNNABLE</code>或者<code>ENV_NOT_RUNNABLE</code>。<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">static int</div><div class=\"line\">sys_env_set_status(envid_t envid, int status)</div><div class=\"line\">&#123;</div><div class=\"line\">implemented\");</div><div class=\"line\">        int ret;</div><div class=\"line\">        struct Env *env;</div><div class=\"line\"></div><div class=\"line\">        if (status != ENV_RUNNABLE &amp;&amp; status != ENV_RUNNING)</div><div class=\"line\">                return -E_INVAL;</div><div class=\"line\">        if ((ret = envid2env(envid, &amp;env, 1)) &lt; 0)</div><div class=\"line\">                return ret;</div><div class=\"line\">        env-&gt;env_status = status;</div><div class=\"line\">        return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>然后是<code>env_page_alloc</code>函数，分配1个物理页并映射到给定进程的进程空间的虚拟地址。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span></span></div><div class=\"line\"><span class=\"title\">sys_page_alloc</span><span class=\"params\">(<span class=\"keyword\">envid_t</span> envid, <span class=\"keyword\">void</span> *va, <span class=\"keyword\">int</span> perm)</span></div><div class=\"line\">&#123;</div><div class=\"line\">        <span class=\"keyword\">struct</span> Env *env;</div><div class=\"line\">        <span class=\"keyword\">struct</span> PageInfo *pp;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (envid2env(envid, &amp;env, <span class=\"number\">1</span>) &lt; <span class=\"number\">0</span>)</div><div class=\"line\">                <span class=\"keyword\">return</span> -E_BAD_ENV;</div><div class=\"line\">        <span class=\"keyword\">if</span> ((<span class=\"keyword\">uintptr_t</span>)va &gt;= UTOP || PGOFF(va))</div><div class=\"line\">                <span class=\"keyword\">return</span> -E_INVAL;</div><div class=\"line\">        <span class=\"keyword\">if</span> ((perm &amp; PTE_U) == <span class=\"number\">0</span> || (perm &amp; PTE_P) == <span class=\"number\">0</span>)</div><div class=\"line\">                <span class=\"keyword\">return</span> -E_INVAL;</div><div class=\"line\">        <span class=\"keyword\">if</span> ((perm &amp; ~(PTE_U | PTE_P | PTE_W | PTE_AVAIL)) != <span class=\"number\">0</span>)</div><div class=\"line\">                <span class=\"keyword\">return</span> -E_INVAL;</div><div class=\"line\">        <span class=\"keyword\">if</span> ((pp = page_alloc(ALLOC_ZERO)) == <span class=\"literal\">NULL</span>)</div><div class=\"line\">                <span class=\"keyword\">return</span> -E_NO_MEM;</div><div class=\"line\">        <span class=\"keyword\">if</span> (page_insert(env-&gt;env_pgdir, pp, va, perm) &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                page_free(pp);</div><div class=\"line\">                <span class=\"keyword\">return</span> -E_NO_MEM;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>最后是s<code>ys_page_unmap</code>函数，解除指定进程中的1个页映射。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">static int</div><div class=\"line\">sys_page_unmap(envid_t envid, void *va)</div><div class=\"line\">&#123;</div><div class=\"line\">        struct Env *env;</div><div class=\"line\"></div><div class=\"line\">        if (envid2env(envid, &amp;env, 1) &lt; 0)</div><div class=\"line\">                return -E_BAD_ENV;</div><div class=\"line\">        if ((uintptr_t)va &gt;= UTOP || PGOFF(va))</div><div class=\"line\">                return -E_INVAL;</div><div class=\"line\"></div><div class=\"line\">        page_remove(env-&gt;env_pgdir, va);</div><div class=\"line\">        return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>至此所有系统调用都完成了，可以运行一下<code>usr/umbfork.c</code>。首先看一下主函数，逻辑是父进程创建1个子进程，然后每次打印1条信息后交出控制权，并且让父进程重复10次而子进程重复20次。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">umain</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> **argv)</span></div><div class=\"line\">&#123;</div><div class=\"line\">        <span class=\"keyword\">envid_t</span> who;</div><div class=\"line\">        <span class=\"keyword\">int</span> i;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// fork a child process</span></div><div class=\"line\">        who = dumbfork();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// print a message and yield to the other a few times</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; (who ? <span class=\"number\">10</span> : <span class=\"number\">20</span>); i++) &#123;</div><div class=\"line\">                cprintf(<span class=\"string\">\"%d: I am the %s!\\n\"</span>, i, who ? <span class=\"string\">\"parent\"</span> : <span class=\"string\">\"child\"</span>);</div><div class=\"line\">                sys_yield();</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Lab4-抢占式多进程\"><a href=\"#Lab4-抢占式多进程\" class=\"headerlink\" title=\"Lab4 抢占式多进程\"></a>Lab4 抢占式多进程</h1><h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><p>Lab4目标是在多用户环境下实现抢占式多进程的支持，分解为三个部分：</p>\n<ul>\n<li>part1: 在JOS中添加对多处理器的支持，实现循环调度算法，并添加基本的环境管理的系统调用（创建/销毁环境，分配/映射内存）</li>\n<li>part2：实现类似Unix的<code>fork</code>机制，允许在用户模式下创建副本</li>\n<li>part3：添加对进程间通信(IPC)的支持，允许不同的用户环境进行进程间的通信和同步。并添加对硬件时钟中断和进程抢占的支持。</li>\n</ul>\n<h2 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h2><p>下载实验代码：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">git pull</div><div class=\"line\">git chekout -b lab4 origin/lab4</div><div class=\"line\">git merge Lab3</div></pre></td></tr></table></figure></p>\n<p>Lab4 新增的文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">kern/cpu.h\t多处理器支持的内核私有定义</div><div class=\"line\">kern/mpconfig.c\t读取多处理器配置的代码</div><div class=\"line\">kern/lapic.c\t驱动处理器中的本地APIC单元的内核代码</div><div class=\"line\">kern/mpentry.S\t非启动CPU的汇编代码入口</div><div class=\"line\">kern/spinlock.h\t包括大内核锁在内的自旋锁的内和私有定义</div><div class=\"line\">kern/spinlock.c\t自旋锁的内核代码实现</div><div class=\"line\">kern/sched.c\t调度器的代码框架</div></pre></td></tr></table></figure></p>","more":"<h2 id=\"part1-多处理器支持和多任务协同\"><a href=\"#part1-多处理器支持和多任务协同\" class=\"headerlink\" title=\"part1 多处理器支持和多任务协同\"></a>part1 多处理器支持和多任务协同</h2><p>Lab4 part1将首先扩展JOS以在多处理器系统上运行，然后实现新的JOS内核系统调用，以允许用户级环境创建其他新的环境。另外实现协同循环调度，当当前环境自动放弃CPU（或退出）时，允许内核从一个环境切换到另一个环境。之后在part3中，还会实现抢占式调度，即使在环境不允许的情况下，允许内核在一定时间内重新从环境中重新控制CPU。</p>\n<h3 id=\"多处理器支持\"><a href=\"#多处理器支持\" class=\"headerlink\" title=\"多处理器支持\"></a>多处理器支持</h3><p>目标使JOS支持对称多处理器(SMP)。<code>SMP</code>是一种多处理器架构，所有的CPU对等地访问系统资源。在SMP中所有CPU的功能是相同的，但是在启动过程中会被分为2类：引导处理器(<code>BSP</code>)负责初始化系统来启动操作系统，当操作系统被启动后，应用处理器(<code>AP</code>)被引导处理器激活。引导处理器是由硬件和BIOS决定的，目前所有的代码都是运行在BSP上。<br>在个SMP系统中，每个CPU有1个附属的<code>Local APIC（LAPIC）</code>单元。LAPIC单元负责处理系统中的中断，同时为它关联的CPU提供独一无二的标识符。在part1，将使用LAPIC单元以下基本功能(在<code>/kern/lapic.c</code>)：</p>\n<ul>\n<li>读取LAPIC的标识符(APIC ID)来告诉我们正在哪个CPU上运行代码(<code>cpunum()</code>).</li>\n<li>从BSP发送STARTUP的处理器间中断(<code>IPI</code>) 到APs来唤醒其它CPU(<code>lapic_startup()</code>).</li>\n<li>在part3部分，将编程LAPIC内置的计时器来触发时钟中断来支持多任务抢占(<code>apic_init()</code>).</li>\n</ul>\n<p>处理器访通过内存映射I/O(MMIO)的方式访问它的LAPIC。在MMIO中，一部分物理地址被硬连接到一些IO设备的寄存器上，导致操作内存的指令<code>load/store</code>可以直接操作设备的寄存器。我们已经看到过1个<code>IO hole</code>在物理地址<code>0xA0000</code>(用来写入VGA显示缓存)。LAPIC的hole开始于物理地址<code>0xFE000000</code>(4GB之下地32MB)，但是这地址过高，导致无法访问通过过去的直接映射(虚拟地址<code>0xF0000000</code>映射0x0，即只有256MB)。但是JOS虚拟地址映射预留了4MB空间在<code>MMIOBASE</code>处，需要分配空间一映射设备。</p>\n<h4 id=\"练习1\"><a href=\"#练习1\" class=\"headerlink\" title=\"练习1\"></a>练习1</h4><p>问</p>\n<blockquote>\n<p>在<code>kern/pmap.c</code>中实现<code>mmio_map_region</code>。查看<code>lapic_init</code>函数(<code>kern/lapic.c</code>)来确定使用方式</p>\n</blockquote>\n<p>解：</p>\n<blockquote>\n<p>在<code>lapic_init</code>函数的开头就会调用<code>mmio_map_region</code><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// lapicaddr is the physical address of the LAPIC's 4K MMIO</span></div><div class=\"line\"><span class=\"comment\">// region.  Map it in to virtual memory so we can access it.</span></div><div class=\"line\">lapic = mmio_map_region(lapicaddr, <span class=\"number\">4096</span>);</div></pre></td></tr></table></figure></p>\n<p>在<code>kern/pmap.c</code>中，有具体的提示，设置个静态变量记录每次变化后的虚拟基地址，使用<code>boot_map_region</code>函数将<code>[pa,pa+size)的</code>物理地址映射到<code>[base,base+size)</code>，把<code>size</code>向上进位到<code>PGSIZE</code>。由于这是设备内存并不是正常的DRAM，所以使用cache缓存访问是不安全的，可以用页的标志位来实现。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//kern/pmap.c</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> *</span></div><div class=\"line\"><span class=\"title\">mmio_map_region</span><span class=\"params\">(<span class=\"keyword\">physaddr_t</span> pa, <span class=\"keyword\">size_t</span> size)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">uintptr_t</span> base = MMIOBASE;</div><div class=\"line\">    <span class=\"keyword\">void</span> *ret = (<span class=\"keyword\">void</span> *)base;</div><div class=\"line\"></div><div class=\"line\">    size = ROUNDUP(size, PGSIZE);</div><div class=\"line\">    <span class=\"keyword\">if</span> (base + size &gt; MMIOLIM || base + size &lt; base)</div><div class=\"line\">                panic(<span class=\"string\">\"mmio_map_region: reservation overflow\\n\"</span>);</div><div class=\"line\"></div><div class=\"line\">    boot_map_region(kern_pgdir, base, size, pa, PTE_P | PTE_PCD | PTE_PWT);</div><div class=\"line\">    base += size;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">return</span> ret;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"引导应用处理器-Application-Processor\"><a href=\"#引导应用处理器-Application-Processor\" class=\"headerlink\" title=\"引导应用处理器(Application Processor)\"></a>引导应用处理器(Application Processor)</h3><p>在启动AP之前，BSP应该先收集关于多处理器系统的配置信息，比如CPU总数，CPUs的APIC ID和LAPIC单元的MMIO地址等。在<code>kern/mpconfig</code>文件中的<code>mp_init()</code>函数通过读BIOS设定的<code>MP配置表</code>获取这些信息。<br><code>boot_aps(kern/init.c)</code>函数驱动AP引导程序。AP开始于实模式，跟BSP的开始相同，故此<code>boot_aps</code>函数拷贝AP入口代码(<code>kern/mpentry.S</code>)到实模式下的内存寻址空间。但是跟BSP不一样的是，当AP开始执行时，需要有一些控制将拷贝入口代码到<code>0x7000(MPENTRY_PADDR)</code>。<br>之后，<code>boot_aps</code>函数通过发送<code>STARTUP的IPI</code>(处理器间中断)信号到AP的LAPIC单元来一个个地激活AP。在<code>kern/mpentry.S</code>中的入口代码跟<code>boot/boot.S</code>中的代码类似。在一些简短的配置后，它使AP进入开启分页机制的保护模式，调用C语言的setup函数<code>mp_main</code>（<code>kern/init.c</code>)。<code>boot_aps()</code>等待AP <code>CPU_STARTED</code>在<code>cpu_status</code>其字段中设定出一个flag，设定<code>struct CpuInfo</code>然后继续唤醒下一个。</p>\n<p>结合前几个lab，在i386 <code>init</code>函数中进行BSP启动的一些配置，经由lab2的<code>mem_init</code>，lab3的<code>env_init</code>和<code>trap_init</code>，lab4的<code>mp_init</code>和<code>lapic_init</code>，然后<code>boot_aps</code>函数启动所有的CPU<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// lab2 memory management initialization functions</span></div><div class=\"line\">mem_init();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// lab3 user environment initialization functions</span></div><div class=\"line\">env_init();</div><div class=\"line\">trap_init();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// lab4 multiprocessor initialization functions</span></div><div class=\"line\">mp_init();</div><div class=\"line\">lapic_init();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// lab4 multitasking initialization functions</span></div><div class=\"line\">pic_init();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Acquire the bit kernel lock before waiting AP</span></div><div class=\"line\">lock_kernel();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// starting non-boot APs</span></div><div class=\"line\">boot_aps();</div></pre></td></tr></table></figure></p>\n<p>多核处理器的初始化都在mp_init函数中完成，首先是调用mpconfig函数，主要功能是寻找一个MP 配置条目，然后对所有的CPU进行配置，找到启动的处理器。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">mp_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">struct</span> mp *mp;</div><div class=\"line\">    <span class=\"keyword\">struct</span> mpconf *conf;</div><div class=\"line\">    <span class=\"keyword\">struct</span> mpproc *proc;</div><div class=\"line\">    <span class=\"keyword\">uint8_t</span> *p;</div><div class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> i;</div><div class=\"line\"></div><div class=\"line\">    bootcpu = &amp;cpus[<span class=\"number\">0</span>];</div><div class=\"line\">    <span class=\"keyword\">if</span> ((conf = mpconfig(&amp;mp)) == <span class=\"number\">0</span>)</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    ismp = <span class=\"number\">1</span>;</div><div class=\"line\">    lapicaddr = conf-&gt;lapicaddr;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (p = conf-&gt;entries, i = <span class=\"number\">0</span>; i &lt; conf-&gt;entry; i++) &#123;</div><div class=\"line\">        <span class=\"keyword\">switch</span> (*p) &#123;</div><div class=\"line\">\t\t    <span class=\"keyword\">case</span> MPPROC:</div><div class=\"line\">        proc = (<span class=\"keyword\">struct</span> mpproc *)p;</div><div class=\"line\">\t\t\t  <span class=\"keyword\">if</span> (proc-&gt;flags &amp; MPPROC_BOOT)</div><div class=\"line\">\t\t\t\t    bootcpu = &amp;cpus[ncpu];</div><div class=\"line\">\t\t\t  <span class=\"keyword\">if</span> (ncpu &lt; NCPU) &#123;</div><div class=\"line\">\t\t\t\t    cpus[ncpu].cpu_id = ncpu;</div><div class=\"line\">\t\t\t\t    ncpu++;</div><div class=\"line\">\t\t\t  &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            cprintf(<span class=\"string\">\"SMP: too many CPUs, CPU %d disabled\\n\"</span>,</div><div class=\"line\">            proc-&gt;apicid);</div><div class=\"line\">\t\t\t  &#125;</div><div class=\"line\">        p += <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> mpproc);</div><div class=\"line\">        <span class=\"keyword\">continue</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> MPBUS:</div><div class=\"line\">        <span class=\"keyword\">case</span> MPIOAPIC:</div><div class=\"line\">        <span class=\"keyword\">case</span> MPIOINTR:</div><div class=\"line\">        <span class=\"keyword\">case</span> MPLINTR:</div><div class=\"line\">        p += <span class=\"number\">8</span>;</div><div class=\"line\">        <span class=\"keyword\">continue</span>;</div><div class=\"line\">        <span class=\"keyword\">default</span>:</div><div class=\"line\">            cprintf(<span class=\"string\">\"mpinit: unknown config type %x\\n\"</span>, *p);</div><div class=\"line\">        ismp = <span class=\"number\">0</span>;</div><div class=\"line\">        i = conf-&gt;entry;</div><div class=\"line\">\t      &#125;</div><div class=\"line\">\t &#125;</div></pre></td></tr></table></figure></p>\n<p>在启动过程中，<code>mp_init</code>和<code>lapic_init</code>是和硬件以及体系架构紧密相关的，通过读取某个特殊内存地址（当然前提是能读取的到，所以在<code>mem_init</code>中需要修改进行相应映射），来获取CPU的信息，根据这些信息初始化CPU结构。<br>在<code>boot_aps</code>函数中首先找到一段用于启动的汇编代码，该代码和lab3是嵌入在内核代码段之上的一部分，其中<code>mpentry_start</code>和<code>mpentry_end</code>是编译器导出符号，代表这段代码在内存（虚拟地址）中的起止位置，接着把代码复制到<code>MPENTRY_PADDR</code>处。随后调用<code>lapic_startap</code>来命令特定的AP去执行这段代码。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// Start the non-boot (AP) processors.</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">boot_aps</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">extern</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> mpentry_start[], mpentry_end[];</div><div class=\"line\">  \t<span class=\"keyword\">void</span> *code;</div><div class=\"line\">  \t<span class=\"keyword\">struct</span> CpuInfo *c;</div><div class=\"line\"></div><div class=\"line\">  \t<span class=\"comment\">// Write entry code to unused memory at MPENTRY_PADDR</span></div><div class=\"line\">  \tcode = KADDR(MPENTRY_PADDR);</div><div class=\"line\">  \tmemmove(code, mpentry_start, mpentry_end - mpentry_start);</div><div class=\"line\"></div><div class=\"line\">  \t<span class=\"comment\">// Boot each AP one at a time</span></div><div class=\"line\">  \t<span class=\"keyword\">for</span> (c = cpus; c &lt; cpus + ncpu; c++) &#123;</div><div class=\"line\">  \t\t<span class=\"keyword\">if</span> (c == cpus + cpunum())  <span class=\"comment\">// We've started already.</span></div><div class=\"line\">  \t\t\t<span class=\"keyword\">continue</span>;</div><div class=\"line\"></div><div class=\"line\">  \t\t<span class=\"comment\">// Tell mpentry.S what stack to use</span></div><div class=\"line\">  \t\tmpentry_kstack = percpu_kstacks[c - cpus] + KSTKSIZE;</div><div class=\"line\">  \t\t<span class=\"comment\">// Start the CPU at mpentry_start</span></div><div class=\"line\">  \t\tlapic_startap(c-&gt;cpu_id, PADDR(code));</div><div class=\"line\">  \t\t<span class=\"comment\">// Wait for the CPU to finish some basic setup in mp_main()</span></div><div class=\"line\">  \t\t<span class=\"keyword\">while</span>(c-&gt;cpu_status != CPU_STARTED)</div><div class=\"line\">  \t\t\t;</div><div class=\"line\">  \t&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"练习2\"><a href=\"#练习2\" class=\"headerlink\" title=\"练习2\"></a>练习2</h4><p>问</p>\n<blockquote>\n<p>修改<code>page_init</code>函数(<code>kern/page.c</code>)的实现，来避免将<code>MPENTRY_PADDR</code>处的物理页加入到空闲链表中,使得能安全地拷贝和运行AP的启动代码。</p>\n</blockquote>\n<p>解：</p>\n<blockquote>\n<p>在<code>boot_aps</code>函数中将启动代码放到了<code>MPENTRY_PADDR</code>处，而代码的来源则是在<code>kern/mpentry.S</code>中，功能与<code>boot.S</code>中的非常类似，主要就是开启分页模式，转到内核栈上去，实际上这时内核栈还没建好。在执行完<code>mpentry.S</code>中的代码之后，将会跳转到<code>mp_main</code>函数中去。而这里需要提前做的，就是将<code>MPENTRY_PADDR</code>处的物理页表标识为已用，这样不会将这一页放在空闲链表中分配出去。只需要在<code>page_init</code>中添加一个判断就可以。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//kern/pmap.c</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">page_init</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    ......</div><div class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; npages; i++) &#123;</div><div class=\"line\">        ......</div><div class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (i == MPENTRY_PADDR / PGSIEZ)</div><div class=\"line\">            <span class=\"keyword\">continue</span>;</div><div class=\"line\">        ......</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"问题1\"><a href=\"#问题1\" class=\"headerlink\" title=\"问题1\"></a>问题1</h3><p>问</p>\n<blockquote>\n<p>仔细比较<code>kern/mpentry.S</code>与<code>boot/boot.S</code>，<code>kern/mpentry.S</code>是被编译链接来运行在<code>KERNBASE</code>之上的，那么定义`MPBOOTPHYS宏``的目的是什么？为什么在kern/mpentry.S中是必要的，在boot/boot.S中不是呢？换句话说，如果在kern/mpentry.S中忽略它，会出现什么错误？</p>\n</blockquote>\n<p>解<br>&gt;<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">#define MPBOOTPHYS(s) ((s) - mpentry_start + MPENTRY_PADDR))))</div><div class=\"line\">// MPBOOTPHYS is to calculate symobl address relative to MPENTRY_PADDR. The ASM is executed in the load address above KERNBASE, but JOS need to run mp_main at 0x7000 address! Of course 0x7000’s page is reserved at pmap.c.</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>在AP的保护模式打开之前，是没有办法寻址到3G以上的空间的，因此用<code>MPBOOTPHYS</code>是用来计算相应的物理地址的。但是在<code>boot.S</code>中，由于尚没有启用分页机制，所以能够指定程序开始执行的地方以及程序加载的地址；但是，在<code>mpentry.S</code>的时候，由于主CPU已经处于保护模式下了，因此是不能直接指定物理地址的，而给定线性地址映射到相应的物理地址是允许的。</p>\n</blockquote>\n<h3 id=\"CPU的状态和初始化\"><a href=\"#CPU的状态和初始化\" class=\"headerlink\" title=\"CPU的状态和初始化\"></a>CPU的状态和初始化</h3><p>在编写多处理器操作系统时，区分每个处理器私有的每个CPU状态以及整个系统共享的全局状态是非常重要的。 <code>kern / cpu.h</code>定义了大多数CPU状态，包括<code>struct CpuInfo</code>存储CPU变量。 <code>cpunum()</code>返回调用它的CPU的ID，可以用作数组的索引<code>cpus</code>。<br>每个CPU独有的变量应该有：</p>\n<ul>\n<li>内核栈<br>因为多个CPU可以同时陷入内核，所以我们需要为每个处理器分配一个内核栈，以防止它们干扰对方的执行。数组<code>percpu_kstacks[NCPU][KSTKSIZE]</code>为<code>NCPU</code>的内核栈提供了空间。</li>\n<li>TSS和TSS描述符<br>每个CPU任务状态段（TSS）也是需要的，以便指定每个CPU内核栈的位置。存储CPU i的<code>TSS cpus[i].cpu_ts</code>，并在GDT条目中定义相应的TSS描述符<code>gdt[(GD_TSS0 &gt;&gt; 3) + i]</code>。<code>ts</code>在<code>kern / trap.c</code>中定义的全局变量将不再有用。</li>\n<li>CPU的当前环境指针<br>由于每个CPU可以同时运行不同的用户进程中，因此重新定义了符号<code>curenv</code>来指代<code>cpus[cpunum()].cpu_env</code>（或<code>thiscpu-&gt;cpu_env</code>），它指向环境当前的上执行当前CPU（在其上运行代码的CPU）。</li>\n<li>CPU的系统寄存器<br>所有寄存器（包括系统寄存器）对于CPU都是专用的。因此，初始化这些寄存器的指令，例如<code>lcr3()， ltr()，lgdt()，lidt()</code>等，必须进行一次各CPU上执行。功能<code>env_init_percpu()</code>和<code>trap_init_percpu()</code>执行此功能。</li>\n</ul>\n<h4 id=\"练习3\"><a href=\"#练习3\" class=\"headerlink\" title=\"练习3\"></a>练习3</h4><p>问</p>\n<blockquote>\n<p>修改<code>mem_init_mp</code>函数来映射开始于<code>KSTACKTOP</code>的CPU栈。</p>\n</blockquote>\n<p>解</p>\n<blockquote>\n<p>多CPU的内存分布如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">KERNBASE ----&gt; +-------------------------+ 0xf0000000</div><div class=\"line\">KSTACKTOP      |   CPU0&apos;s Kernel Stack   | RW/-- KSTKSIZE</div><div class=\"line\">               |-------------------------|</div><div class=\"line\">               |   Invalid Memory(*)     | --/-- KSTKGAP</div><div class=\"line\">               +-------------------------+</div><div class=\"line\">               |    CPU1&apos;s Kernel STACK  | RW/-- KSTKSIZE</div><div class=\"line\">               |-------------------------|</div><div class=\"line\">               |   Invalid Memory(*)     | --/-- KSTKGAP</div><div class=\"line\">               +-------------------------+</div><div class=\"line\">               .             .           .</div><div class=\"line\">               .             .           .</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>需要为每个核都分配一个内核栈，每个内核栈的大小是<code>KSTKSIZE</code>，而内核栈之间的间距是<code>KSTKGAP</code>，起到保护作用。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//kern/pmap.c</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">mem_init_mp</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">int</span> i;</div><div class=\"line\">    <span class=\"keyword\">uintptr_t</span> kstacktop_i;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; NCPU; i++) &#123;</div><div class=\"line\">        kstacktop_i = KSTACKTOP - i * (KSTKGAP + KSTKSIZE);</div><div class=\"line\">        boot_map_region(kern_pgdir,</div><div class=\"line\">                        kstacktop_i - KSTKSIZE,</div><div class=\"line\">                        ROUNDUP(KSTKSIZE, PGSIZE),</div><div class=\"line\">                        PADDR(&amp;percpu_kstacks[i]),</div><div class=\"line\">                        PTE_W | PTE_P);</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h4 id=\"练习4\"><a href=\"#练习4\" class=\"headerlink\" title=\"练习4\"></a>练习4</h4><p>问：</p>\n<blockquote>\n<p>在<code>trap_init_percpu</code>函数中为BSP初始化TSS和TSS描述符，这在Lab3中是可行的，但是在这里会有问题，修改代码使它可以运行在所有CPU上。</p>\n</blockquote>\n<p>解：</p>\n<blockquote>\n<p>由于有多个CPU，所以在这里不能使用原先的全局变量<code>ts</code>，应该利用<code>thiscpu</code>指向的<code>CpuInfo</code>结构体和<code>cpunum</code>函数来为每个核的<code>TSS</code>进行初始化。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">trap_init_percpu</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></div><div class=\"line\">&#123;</div><div class=\"line\">    thiscpu-&gt;cpu_ts.ts_esp0 = KSTACKTOP - cpunum() * (KSTKGAP + KSTKSIZE);</div><div class=\"line\">    thiscpu-&gt;cpu_ts.ts_ss0 = GD_KD;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Initialize the TSS slot of the gdt.</span></div><div class=\"line\">    gdt[(GD_TSS0 &gt;&gt; <span class=\"number\">3</span>) + cpunum()] = SEG16(STS_T32A, (<span class=\"keyword\">uint32_t</span>) (&amp;thiscpu-&gt;cpu_ts), <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> Taskstate) - <span class=\"number\">1</span>, <span class=\"number\">0</span>);</div><div class=\"line\">    gdt[(GD_TSS0 &gt;&gt; <span class=\"number\">3</span>) + cpunum()].sd_s = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Load the TSS selector (like other segment selectors, the</span></div><div class=\"line\">    <span class=\"comment\">// bottom three bits are special; we leave them 0)</span></div><div class=\"line\">    ltr(GD_TSS0 + <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> Segdesc) * cpunum());</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">// Load the IDT</span></div><div class=\"line\">    lidt(&amp;idt_pd);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h3><p>在<code>mp_main</code>函数中初始化AP后，代码就会进入自旋。在让AP进行更多操作之前，首先要解决多CPU同时运行在内核时产生的竞争问题。最简单的办法是实现1个大内核锁（big kernel lock)，1次只让一个进程进入内核模式，当CPU离开内核时释放锁。<br>在<code>kern/spinlock.h</code>中声明了大内核锁，提供了<code>lock_kernel</code>和<code>unlock_kernel</code>函数来快捷地获得和释放锁。总共有四处用到大内核锁：</p>\n<ul>\n<li>在启动的时候，BSP启动其余的CPU之前，BSP需要取得内核锁</li>\n<li><code>mp_main</code>中，也就是CPU被启动之后执行的第一个函数，这里应该是调用调度函数，选择一个进程来执行的，但是在执行调度函数之前，必须获取锁</li>\n<li>`trap函数``也要修改，因为可以访问临界区的CPU只能有一个，所以从用户态陷入到内核态的话，要加锁，因为可能多个CPU同时陷入内核态</li>\n<li><code>env_run</code>函数，也就是启动进程的函数，之前在lab3中实现的，在这个函数执行结束之后，就将跳回到用户态，此时离开内核，也就是需要将内核锁释放</li>\n</ul>\n<p>加锁后，将原有的并行执行过程在关键位置变为串行执行过程，整个启动过程大概如下：</p>\n<blockquote>\n<p>i386_init–&gt;BSP获得锁–&gt;boot_ap–&gt;(BSP建立为每个cpu建立idle任务、建立用户任务，mp_main)—&gt;BSP的sched_yield–&gt;其中的env_run释放锁–&gt;AP1获得锁–&gt;执行sched_yield–&gt;释放锁–&gt;AP2获得锁–&gt;执行sched_yield–&gt;释放锁…..</p>\n</blockquote>\n<h4 id=\"练习5\"><a href=\"#练习5\" class=\"headerlink\" title=\"练习5\"></a>练习5</h4><p>问</p>\n<blockquote>\n<p>在上述位置应用大内核锁。</p>\n</blockquote>\n<p>解<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//i386_init</span></div><div class=\"line\">lock_kernel();</div><div class=\"line\">boot_aps();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//mp_main</span></div><div class=\"line\">lock_kernel();</div><div class=\"line\">sched_yield();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//trap</span></div><div class=\"line\"><span class=\"keyword\">if</span> ((tf-&gt;tf_cs &amp; <span class=\"number\">3</span>) == <span class=\"number\">3</span>) &#123;</div><div class=\"line\">    lock_kernel();</div><div class=\"line\">    assert(curenv);</div><div class=\"line\">    ......</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//env_run</span></div><div class=\"line\">lcr3(PADDR(curenv-&gt;env_pgdir));</div><div class=\"line\">unlock_kernel();</div><div class=\"line\">env_pop_tf(&amp;(curenv-&gt;env_tf));</div></pre></td></tr></table></figure></p>\n<h3 id=\"问题2\"><a href=\"#问题2\" class=\"headerlink\" title=\"问题2\"></a>问题2</h3><p>问：</p>\n<blockquote>\n<p>既然大内核锁保证了只有1个CPU能运行在内核，为什么我们还要为每个CPU准备1个内核栈。</p>\n</blockquote>\n<p>解:</p>\n<blockquote>\n<p>因为不同的内核栈上可能保存有不同的信息，当1个CPU从内核退出来之后，有可能在内核栈中留下了一些将来还有用的数据，所以一定要有单独的栈。</p>\n</blockquote>\n<h3 id=\"挑战1\"><a href=\"#挑战1\" class=\"headerlink\" title=\"挑战1\"></a>挑战1</h3><p>问:</p>\n<blockquote>\n<p>大内核锁简单便于应用，但是它取消了内核模式的并行。大多数现代操作系统使用不同的锁来保护共享状态的不同部分，这称之为细粒度锁。细粒度锁能有效地提高性能，但是也更困难地去实现和检测错误。所以你可以去掉大内核锁，在JOS中实现内核并发。</p>\n</blockquote>\n<p>解</p>\n<blockquote>\n<p>思路:实验指导中提供了一些JOS内核中的共享结构，具体实现就是在保证在使用这些结构体时保证互斥。\n　　</p>\n<h3 id=\"循环调度-Round-Robin-Scheduling\"><a href=\"#循环调度-Round-Robin-Scheduling\" class=\"headerlink\" title=\"循环调度(Round-Robin Scheduling)\"></a>循环调度(Round-Robin Scheduling)</h3><p>接下来的任务是改变JOS内核，实现<code>round-robin</code>调度算法。<br>主要是在<code>sched_yield</code>函数内实现，从该CPU上一次运行的进程开始，在进程描述符表中寻找下一个可以运行的进程，如果没找到而且上一个进程依然是可以运行的，那么就可以继续运行上一个进程，同时将这个算法实现为了一个系统调用，使得进程可以主动放弃CPU。</p>\n</blockquote>\n<h4 id=\"练习6\"><a href=\"#练习6\" class=\"headerlink\" title=\"练习6\"></a>练习6</h4><p>问:</p>\n<blockquote>\n<p>实现<code>sched_yield</code>函数，并添加系统调用。</p>\n</blockquote>\n<p>解:</p>\n<blockquote>\n<p>修改代码如下.然后修改<code>kern/syscall.c</code>,添加相关的系统调用机制。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">void</div><div class=\"line\">sched_yield(void)</div><div class=\"line\">&#123;</div><div class=\"line\">        uint32_t i, j, start;</div><div class=\"line\">        struct Env *runenv;</div><div class=\"line\"></div><div class=\"line\">        idle = thiscpu-&gt;cpu_env;</div><div class=\"line\">        start = (idle != NULL) ? ENVX(idle-&gt;env_id) : 0;</div><div class=\"line\">        runenv = NULL;</div><div class=\"line\"></div><div class=\"line\">        for (i = 0; i &lt; NENV; i++) &#123;</div><div class=\"line\">                j = (start + i) % NENV;</div><div class=\"line\">                if (envs[j].env_status == ENV_RUNNABLE) &#123;</div><div class=\"line\">                        if (runenv == NULL || envs[j].env_priority &lt; runenv-&gt;env_priority)</div><div class=\"line\">                                runenv = &amp;envs[j];</div><div class=\"line\">                &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if ((idle &amp;&amp; idle-&gt;env_status == ENV_RUNNING) &amp;&amp; (runenv == NULL || idle-&gt;env_priority &lt; runenv-&gt;env_priority))&#123;</div><div class=\"line\">                env_run(idle);</div><div class=\"line\">                return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        if (runenv) &#123;</div><div class=\"line\">                env_run(runenv);</div><div class=\"line\">                return;</div><div class=\"line\">        &#125;</div><div class=\"line\">        // sched_halt never returns</div><div class=\"line\">        sched_halt();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>　　</p>\n<h4 id=\"问题3\"><a href=\"#问题3\" class=\"headerlink\" title=\"问题3\"></a>问题3</h4><p>问:</p>\n<blockquote>\n<p>在<code>lcr3()</code>运行之后，这个CPU对应的页表就立刻被换掉了，但是这个时候的参数e，也就是现在的<code>curenv</code>，为什么还是能正确的解引用？</p>\n</blockquote>\n<p>解:</p>\n<blockquote>\n<p>因为当前是运行在系统内核中的，而每个进程的页表中都是存在内核映射的。每个进程页表中虚拟地址高于<code>UTOP</code>之上的地方，只有<code>UVPT</code>不一样，其余的都是一样的，只不过在用户态下是看不到的。所以虽然这个时候的页表换成了下一个要运行的进程的页表，但是<code>curenv</code>的地址没变，映射也没变，还是依然有效的。</p>\n</blockquote>\n<h4 id=\"问题4\"><a href=\"#问题4\" class=\"headerlink\" title=\"问题4\"></a>问题4</h4><p>问:</p>\n<blockquote>\n<p>在用户环境进行切换时，为什么旧进程的寄存器一定要被保存以便之后重新装载？在哪里发生这样的操作？</p>\n</blockquote>\n<p>解:</p>\n<blockquote>\n<p>因为如果不进行保存，旧进程运行时的状态就丢失了，运行就不正确了。每次进入到内核态的时候，当前的运行状态都是在一进入的时候就保存了的。如果没有发生调度，那么之前<code>trapframe</code>中的信息还是会恢复回去，如果发生了调度，恢复的就是被调度运行的进程的上下文了。</p>\n</blockquote>\n<h4 id=\"挑战2\"><a href=\"#挑战2\" class=\"headerlink\" title=\"挑战2\"></a>挑战2</h4><p>问:</p>\n<blockquote>\n<p>添加固定优先级的调度策略，确保高优先级的进程总是先于低优先级的进程。</p>\n</blockquote>\n<p>解：</p>\n<blockquote>\n<p>思路:为每个进程的结构体添加1个标志优先级的变量，在<code>sched_yield</code>时遍历链表选取优先级最高的可运行进程作为下一个运行进程。</p>\n<ol>\n<li>在<code>inc/env.h</code>中给<code>Env</code>结构添加1个成员<code>int env_priority</code></li>\n<li><p>在<code>kern/env.c</code>中的<code>env_alloc</code>中给进程赋值为默认优先级<code>ENV_PRIOR_DEFAULT</code>，一共设立了四个基本的优先级，数字越小优先级越高</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//inc/env.h</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ENV_PRIOR_SUPER 0</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ENV_PRIOR_HIGH 10</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ENV_PRIOR_NORMAL 100</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ENV_PRIOR_LOW 1000</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>修改<code>kern/sched.c</code>中<code>sched_yield</code>函数的调度策略</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//kern/sched.c  sched_yield()</span></div><div class=\"line\">        idle = thiscpu-&gt;cpu_env;</div><div class=\"line\">        start = (idle != <span class=\"literal\">NULL</span>) ? ENVX(idle-&gt;env_id) : <span class=\"number\">0</span>;</div><div class=\"line\">        runenv = <span class=\"literal\">NULL</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; NENV; i++) &#123;</div><div class=\"line\">                j = (start + i) % NENV;</div><div class=\"line\">                <span class=\"keyword\">if</span> (envs[j].env_status == ENV_RUNNABLE) &#123;</div><div class=\"line\">                        <span class=\"keyword\">if</span> (runenv == <span class=\"literal\">NULL</span> || envs[j].env_priority &lt; runenv-&gt;env_priority)</div><div class=\"line\">                                runenv = &amp;envs[j];</div><div class=\"line\">                &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> ((idle &amp;&amp; idle-&gt;env_status == ENV_RUNNING) &amp;&amp; (runenv == <span class=\"literal\">NULL</span> || idle-&gt;env_priority &lt; runenv-&gt;env_priority))&#123;</div><div class=\"line\">                env_run(idle);</div><div class=\"line\">                <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (runenv) &#123;</div><div class=\"line\">                env_run(runenv);</div><div class=\"line\">                <span class=\"keyword\">return</span>;</div><div class=\"line\">        &#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>添加1个系统调用<code>sys_env_set_priority(envid, priority)</code>，允许进程的父进程或者自己修改自己的优先级。这里的修改与前面添加系统调用类似。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span></span></div><div class=\"line\"><span class=\"title\">sys_env_set_priority</span><span class=\"params\">(<span class=\"keyword\">envid_t</span> envid, <span class=\"keyword\">int</span> priority)</span></div><div class=\"line\">&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> ret;</div><div class=\"line\">        <span class=\"keyword\">struct</span> Env *env;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> ((ret = envid2env(envid, &amp;env, <span class=\"number\">1</span>)) &lt; <span class=\"number\">0</span>)</div><div class=\"line\">                <span class=\"keyword\">return</span> ret;</div><div class=\"line\">        env-&gt;env_priority = priority;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n</blockquote>\n<h4 id=\"挑战3\"><a href=\"#挑战3\" class=\"headerlink\" title=\"挑战3\"></a>挑战3</h4><p>问:</p>\n<blockquote>\n<p>现在的JOS内核不支持应用来使用x86处理器的浮点数单元(FPU)，MMX指令和SSE扩展指令。扩展Env结构提供保存处理器浮点数状态的空间，扩展进程上下文交换代码来保存和恢复浮点数状态 。</p>\n</blockquote>\n<p>解:</p>\n<blockquote>\n<p>给中断加入保存浮点寄存器的功能。</p>\n<ol>\n<li>给<code>inc/trap.h</code>文件中的<code>Trapframe</code>结构新增<code>char tf_fpus[512]``成员，并增加</code>uint32_t tf_padding0[3]``来对齐</li>\n<li><p>修改<code>kern/trapentry.S</code>文件中的<code>_alltraps</code>函数，加入保存<code>fpu</code>寄存器的功能</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">_alltraps:</div><div class=\"line\">        pushl %ds</div><div class=\"line\">        pushl %es</div><div class=\"line\">        pushal</div><div class=\"line\"></div><div class=\"line\">        // save FPU</div><div class=\"line\">        subl $524, %esp</div><div class=\"line\">        fxsave (%esp)</div><div class=\"line\"></div><div class=\"line\">        movl $GD_KD, %eax</div><div class=\"line\">        movl %eax, %ds</div><div class=\"line\">        movl %eax, %es</div><div class=\"line\"></div><div class=\"line\">        push %esp</div><div class=\"line\">        call trap</div></pre></td></tr></table></figure>\n</li>\n<li><p>修改<code>kern/env.c</code>文件中的<code>env_pop_tf</code>函数，加入恢复<code>fpu</code>功能</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">__asm __volatile(<span class=\"string\">\"movl %0,%%esp\\n\"</span></div><div class=\"line\">               <span class=\"string\">\"\\tfxrstor (%%esp)\\n\"</span></div><div class=\"line\">               <span class=\"string\">\"\\taddl $524,%%esp\\n\"</span></div><div class=\"line\">               <span class=\"string\">\"\\tpopal\\n\"</span></div><div class=\"line\">               <span class=\"string\">\"\\tpopl %%es\\n\"</span></div><div class=\"line\">               <span class=\"string\">\"\\tpopl %%ds\\n\"</span></div><div class=\"line\">               <span class=\"string\">\"\\taddl $0x8,%%esp\\n\"</span> <span class=\"comment\">/* skip tf_trapno and tf_errcode */</span></div><div class=\"line\">               <span class=\"string\">\"\\tiret\"</span></div><div class=\"line\">               : : <span class=\"string\">\"g\"</span> (tf) : <span class=\"string\">\"memory\"</span>);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n</blockquote>\n<h3 id=\"创建环境的系统调用\"><a href=\"#创建环境的系统调用\" class=\"headerlink\" title=\"创建环境的系统调用\"></a>创建环境的系统调用</h3><p>虽然当前内核现在有能力运行和切换多用户级进程，但是它仍然只能跑内核初始创建的进程。现在将实现必要的JOS系统调用来运行用户进程来创建和启动其它新的用户进程。<br>Unix提供了<code>fork</code>系统调用来创建进程，它拷贝父进程的整个地址空间到新创建的子进程。两个进程之间唯一的区别是它们的进程ID，在父进程fork返回的是子进程ID，而在子进程fork返回的是0。<br>参照Unix,实现1个不同的更原始的JOS系统调用来创建进程。利用这些系统调用能实现类似Unix的fork函数。<br>用户级fork函数在<code>user/dumbfork.c</code>中的<code>dumbfork()</code>中，该函数将父进程中所有页的内容全部复制过来，唯一不同的地方就是返回值不同。</p>\n<h3 id=\"练习7\"><a href=\"#练习7\" class=\"headerlink\" title=\"练习7\"></a>练习7</h3><p>问:</p>\n<blockquote>\n<p>实现<code>ker/syscall.c</code>中的系统调用。</p>\n</blockquote>\n<p>解:</p>\n<blockquote>\n<p>首先是<code>sys_exofork</code>函数，这个系统调用将创建1个新的空白进程，没有映射的用户空间且无法运行。在调用函数时新进程的寄存器状态与父进程相同，但是在父进程会返回子进程的ID，而子进程会返回0。通过设置子进程的eax为0，来让系统调用的返回值为0。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> envid_t</span></div><div class=\"line\"><span class=\"title\">sys_exofork</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></div><div class=\"line\">&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> ret;</div><div class=\"line\">        <span class=\"keyword\">struct</span> Env *env;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> ((ret = env_alloc(&amp;env, sys_getenvid())) &lt; <span class=\"number\">0</span>)</div><div class=\"line\">                <span class=\"keyword\">return</span> ret;</div><div class=\"line\">        env-&gt;env_status = ENV_NOT_RUNNABLE;</div><div class=\"line\">        env-&gt;env_tf = curenv-&gt;env_tf;</div><div class=\"line\">        env-&gt;env_tf.tf_regs.reg_eax = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> env-&gt;env_id;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>接着是<code>sys_env_set_status</code>函数，设置进程的状态为<code>ENV_RUNNABLE</code>或者<code>ENV_NOT_RUNNABLE</code>。<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">static int</div><div class=\"line\">sys_env_set_status(envid_t envid, int status)</div><div class=\"line\">&#123;</div><div class=\"line\">implemented\");</div><div class=\"line\">        int ret;</div><div class=\"line\">        struct Env *env;</div><div class=\"line\"></div><div class=\"line\">        if (status != ENV_RUNNABLE &amp;&amp; status != ENV_RUNNING)</div><div class=\"line\">                return -E_INVAL;</div><div class=\"line\">        if ((ret = envid2env(envid, &amp;env, 1)) &lt; 0)</div><div class=\"line\">                return ret;</div><div class=\"line\">        env-&gt;env_status = status;</div><div class=\"line\">        return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>然后是<code>env_page_alloc</code>函数，分配1个物理页并映射到给定进程的进程空间的虚拟地址。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span></span></div><div class=\"line\"><span class=\"title\">sys_page_alloc</span><span class=\"params\">(<span class=\"keyword\">envid_t</span> envid, <span class=\"keyword\">void</span> *va, <span class=\"keyword\">int</span> perm)</span></div><div class=\"line\">&#123;</div><div class=\"line\">        <span class=\"keyword\">struct</span> Env *env;</div><div class=\"line\">        <span class=\"keyword\">struct</span> PageInfo *pp;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (envid2env(envid, &amp;env, <span class=\"number\">1</span>) &lt; <span class=\"number\">0</span>)</div><div class=\"line\">                <span class=\"keyword\">return</span> -E_BAD_ENV;</div><div class=\"line\">        <span class=\"keyword\">if</span> ((<span class=\"keyword\">uintptr_t</span>)va &gt;= UTOP || PGOFF(va))</div><div class=\"line\">                <span class=\"keyword\">return</span> -E_INVAL;</div><div class=\"line\">        <span class=\"keyword\">if</span> ((perm &amp; PTE_U) == <span class=\"number\">0</span> || (perm &amp; PTE_P) == <span class=\"number\">0</span>)</div><div class=\"line\">                <span class=\"keyword\">return</span> -E_INVAL;</div><div class=\"line\">        <span class=\"keyword\">if</span> ((perm &amp; ~(PTE_U | PTE_P | PTE_W | PTE_AVAIL)) != <span class=\"number\">0</span>)</div><div class=\"line\">                <span class=\"keyword\">return</span> -E_INVAL;</div><div class=\"line\">        <span class=\"keyword\">if</span> ((pp = page_alloc(ALLOC_ZERO)) == <span class=\"literal\">NULL</span>)</div><div class=\"line\">                <span class=\"keyword\">return</span> -E_NO_MEM;</div><div class=\"line\">        <span class=\"keyword\">if</span> (page_insert(env-&gt;env_pgdir, pp, va, perm) &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                page_free(pp);</div><div class=\"line\">                <span class=\"keyword\">return</span> -E_NO_MEM;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>最后是s<code>ys_page_unmap</code>函数，解除指定进程中的1个页映射。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">static int</div><div class=\"line\">sys_page_unmap(envid_t envid, void *va)</div><div class=\"line\">&#123;</div><div class=\"line\">        struct Env *env;</div><div class=\"line\"></div><div class=\"line\">        if (envid2env(envid, &amp;env, 1) &lt; 0)</div><div class=\"line\">                return -E_BAD_ENV;</div><div class=\"line\">        if ((uintptr_t)va &gt;= UTOP || PGOFF(va))</div><div class=\"line\">                return -E_INVAL;</div><div class=\"line\"></div><div class=\"line\">        page_remove(env-&gt;env_pgdir, va);</div><div class=\"line\">        return 0;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>至此所有系统调用都完成了，可以运行一下<code>usr/umbfork.c</code>。首先看一下主函数，逻辑是父进程创建1个子进程，然后每次打印1条信息后交出控制权，并且让父进程重复10次而子进程重复20次。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">umain</span><span class=\"params\">(<span class=\"keyword\">int</span> argc, <span class=\"keyword\">char</span> **argv)</span></div><div class=\"line\">&#123;</div><div class=\"line\">        <span class=\"keyword\">envid_t</span> who;</div><div class=\"line\">        <span class=\"keyword\">int</span> i;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// fork a child process</span></div><div class=\"line\">        who = dumbfork();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// print a message and yield to the other a few times</span></div><div class=\"line\">        <span class=\"keyword\">for</span> (i = <span class=\"number\">0</span>; i &lt; (who ? <span class=\"number\">10</span> : <span class=\"number\">20</span>); i++) &#123;</div><div class=\"line\">                cprintf(<span class=\"string\">\"%d: I am the %s!\\n\"</span>, i, who ? <span class=\"string\">\"parent\"</span> : <span class=\"string\">\"child\"</span>);</div><div class=\"line\">                sys_yield();</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>"},{"title":"lab4-Preemptive Multitasking part23","date":"2017-05-12T16:00:00.000Z","_content":"# Lab4 抢占式多进程\n## Part2 写入时复制 copy-on-write fork\n如前所述,Unix将fork()系统调用作为进程创建原语.fork()系统调用将调用进程的地址空间（父进程）创建一个新的进程（子进程）.\nxv6 Unix `fork()`通过将父进程页面中的所有数据复制到为子进程分配的新页面中,这个机制基本和`dumbfork()`相同.复制父进程的地址空间到子进程是`fork()`中代价最大的操作.\n但是,调用`fork()`后经常在子进程中跟随`exec()`调用, 其会用加载新程序到子进程的内存.例如, 这是shell的常用机制.在这种情况下,复制父进程地址空间的时间大部分被浪费,因为子进程在调用`exec()`之前只使用很少的内存.\n\n因此,Unix的更高版本利用虚拟内存硬件,允许父子进程**共享**映射到其各自地址空间的内存,直到其中一个进程实际修改这段内存.这种技术被称为**写时复制(copy-on-fork)**.为了做到这一点,调用`fork()`时,内核上将复制父进程的地址空间映射到进程,而不是复制映射页的内容,同时标记现在共享的页面为只读.当两个进程中的一个尝试写入其中一个共享页面时,该进程将出现页面错误.在这一点上,Unix内核意识到该页面真的是一个“虚拟”或“写时复制”的副本,因此它创建一个新的/私有的故障页面的可写副本.这样,单个页面的内容在实际写入之前实际上并不被复制.`fork()`的这种优化使随后的`exec()`代价小很多：在子进程调用`exec()`之前,可能只需要复制一个页面（它的堆栈的当前页面）.\n\n在part2,实现一个 Unix `fork()`,其具有写时复制功能,并作为一个用户空间库例程来.另外,使得单个用户模式程序定义自己的`fork()`:一个程序想要一个稍微不同的`fork()`（如总是复制的`dumbfork()`,或者父子进程共享内存）可以很容易修改而实现.\n\n### 用户级页面错误处理\n用户级的写时复制`fork()`首先需要知道发生在写保护页面上的页面错误,这是首先要实现的.写时复制只是用户级页面故障处理的许多可能用途之一.\n一般实现方式是:设置一个地址空间,以便页面错误指示出何时需要执行操作.例如,大多数Unix内核最初仅在新进程的堆栈区域中映射单个页面,并且随着进程的堆栈增加而随后分配和映射额外的堆栈页面,并导致尚未映射的堆栈地址发生页面错误,对此典型的Unix内核必须跟踪在进程空间的每个区域中出现页面错误时要执行的操作.又例如,堆栈区域中的故障通常会导致分配和映射物理内存新页面.程序BSS区域的故障通常会分配一个新的页面,以0填充,并在进行映射.\n以上是内核需要跟踪的信息.不采用传统的Unix方法,而更好地处理用户空间中的每个页面错误,使得bug破坏性更小.这种设计具有额外的优点,允许程序在定义其内存区域方面具有很大的灵活性.\n<!-- more -->\n\n#### 设置页面错误处理器\n为了处理自己的页面错误,用户环境将需要向JOS内核注册页面错误处理程序`entrypoint`.用户环境通过新的`sys_env_set_pgfault_upcall`系统调用注册其页面错误入口点.增加一个新成员`Env`结构`env_pgfault_upcall`来记录这些信息.\n\n#### 练习8\n问:\n> 实现`sys_env_set_pgfault_upcall`系统调用.注:因为这个系统调用危险性很高,所以在查找目标环境的环境ID时要启用权限检查,\n\n解:\n> 实现如下:\n``` c\nstatic int\nsys_env_set_pgfault_upcall(envid_t envid, void *func)\n{\n        struct Env *env;\n\n        if (envid2env(envid, &env, 1) < 0)\n                return -E_BAD_ENV;\n        env->env_pgfault_upcall = func;\n        return 0;\n}\n```\n\n#### 用户环境的正常/异常堆栈\n在正常运行期间,用户进程运行在用户栈上,栈顶寄存器`ESP`指向`USTACKTOP`处,堆栈数据位于`USTACKTOP-PGSIZE 与USTACKTOP-1`之间的页.当在用户模式发生页面错误时,内核将在专门处理页面错误的用户异常栈上重新启动进程. 异常栈正是为了上面设置的异常处理例程设立的.当异常发生时,而且该用户进程注册了该异常的处理例程,那么就会转到异常栈上,运行异常处理例程.\n到目前位置出现了三个栈：\n* 内核态系统栈 [KSTACKTOP, KSTACKTOP-KSTKSIZE]\n* 用户态错误处理栈 [UXSTACKTOP, UXSTACKTOP - PGSIZE]\n* 用户态运行栈 [USTACKTOP, UTEXT]\n\n内核态系统栈是运行内核相关程序的栈,在有中断被触发之后,CPU会将栈自动切换到内核栈上来,而内核栈的设置是在`kern/trap.c`的`trap_init_percpu()`中设置的.\n``` c\nvoid\ntrap_init_percpu(void)\n{\n        // Setup a TSS so that we get the right stack\n        // when we trap to the kernel.\n        thiscpu->cpu_ts.ts_esp0 = KSTACKTOP - cpunum() * (KSTKGAP + KSTKSIZE);\n        thiscpu->cpu_ts.ts_ss0 = GD_KD;\n\n        // Initialize the TSS slot of the gdt.\n        gdt[(GD_TSS0 >> 3) + cpunum()] = SEG16(STS_T32A, (uint32_t) (&thiscpu->cpu_ts),\n                                        sizeof(struct Taskstate) - 1, 0);\n        gdt[(GD_TSS0 >> 3) + cpunum()].sd_s = 0;\n\n        // Load the TSS selector (like other segment selectors, the\n        // bottom three bits are special; we leave them 0)\n        ltr(GD_TSS0 + sizeof(struct Segdesc) * cpunum());\n\n        // Load the IDT\n        lidt(&idt_pd);\n}\n```\n而用户态错误处理栈是用户定义注册了自己的中断处理程序之后,相应的例程运行时的栈.整个过程如下：\n> 首先陷入到内核,栈位置从用户运行栈切换到内核栈,进入到`trap`中,进行中断处理分发,进入到`page_fault_handler()`.当确认是用户程序触发的`page fault`的时候(如果是内核触发的,会直接`panic`),为其在用户错误栈里分配一个`UTrapframe`的大小.把栈切换到用户错误栈,运行响应的用户中断处理程序中断处理程序可能会触发另外一个同类型的中断,这个时候就会产生递归式的中断嵌套处理.处理完成之后,返回到用户运行栈.\n\n#### 调用用户页面故障处理程序\n将用户自己定义的页面故障处理进程当作是一次函数调用看待,当错误发生的时候,调用一个函数,但实际上还是当前这个进程,并没有发生变化.所以当切换到异常栈的时候,依然运行当前进程,但只是运行的是中断处理函数,所以说此时的栈指针发生了变化,而且程序计数器`eip`也发生了变化,同时还需要知道的是引发错误的地址在哪.这些都是要在切换到异常栈的时候需要传递的信息.和之前从用户栈切换到内核栈一样,这里是通过在栈上构造结构体,传递指针完成的.\n在`inc / trap.h`新定义了一个类似`struct Trapframe`结构体`struct UTrapframe`用来记录出现页面错误时候的信息：\n``` c\nstruct UTrapframe {\n        /* information about the fault */\n        uint32_t utf_fault_va;  /* va for T_PGFLT, 0 otherwise */\n        uint32_t utf_err;\n        /* trap-time return state */\n        struct PushRegs utf_regs;\n        uintptr_t utf_eip;\n        uint32_t utf_eflags;\n        /* the trap-time stack to return to */\n        uintptr_t utf_esp;\n} __attribute__((packed));\n```\n相比于`Trapframe`,这里多了`utf_fault_va`,因为要记录触发错误的内存地址,同时还少了`es,ds,ss`等段记录.因为从用户态栈切换到异常栈,或者从异常栈再切换回去,实际上都是一个用户进程,所以不涉及到段的切换,不用记录.在实际使用中,`Trapframe`是作为记录进程状态的结构体存在的,也作为函数参数进行传递；而`UTrapframe`只在处理用户定义的异常时用到.\n整体上讲,当正常执行过程中发生了页面错误,那么栈的切换是\n**用户运行栈—>内核栈—>异常栈**\n而如果在异常处理程序中发生了页面错误,那么栈的切换是\n**异常栈—>内核栈—>异常栈**\n\n#### 练习9\n问:\n> 实现`kern/trap.c`中`page_fault_handler`函数, 把页面错误分发到对应的用户态异常处理函数.\n\n解:\n> 如果当前已经在用户错误栈上了,那么需要留出4个字节,否则不需要,具体和跳转机制有关系.简单说就是在当前的异常栈栈顶的位置向下留出保存`UTrapframe`的空间,然后将`tf`中的参数复制过来.修改当前进程的程序计数器和栈指针,然后重启这个进程,此时就会在用户错误栈上运行中断处理程序了.中断处理程序运行结束之后,需要再回到用户运行栈中,这是异常处理程序需要做的.\n``` c\nvoid\npage_fault_handler(struct Trapframe *tf)\n{\n        uint32_t fault_va;\n\n        // Read processor's CR2 register to find the faulting address\n        fault_va = rcr2();\n\n        // Handle kernel-mode page faults.\n        if (tf->tf_cs == GD_KT)\n                panic(\"page_fault in kernel mode, fault address: %d\\n\", fault_va);\n\n        struct UTrapframe *utf;\n\n        if (curenv->env_pgfault_upcall) {\n                if (UXSTACKTOP - PGSIZE <= tf->tf_esp && tf->tf_esp <= UXSTACKTOP - 1)\n                        utf = (struct UTrapframe *)(tf->tf_esp - sizeof(struct UTrapframe) - 4);\n                else\n                        utf = (struct UTrapframe *)(UXSTACKTOP - sizeof(struct UTrapframe));\n                user_mem_assert(curenv, (void *)utf, sizeof(struct UTrapframe), PTE_U | PTE_W);\n\n                utf->utf_fault_va = fault_va;\n                utf->utf_err = tf->tf_trapno;\n                utf->utf_eip = tf->tf_eip;\n                utf->utf_eflags = tf->tf_eflags;\n                utf->utf_esp = tf->tf_esp;\n                utf->utf_regs = tf->tf_regs;\n                tf->tf_eip = (uint32_t)curenv->env_pgfault_upcall;\n                tf->tf_esp = (uint32_t)utf;\n                env_run(curenv);\n        }\n\n        // Destroy the environment that caused the fault.\n        cprintf(\"[%08x] user fault va %08x ip %08x\\n\",\n                curenv->env_id, fault_va, tf->tf_eip);\n        print_trapframe(tf);\n        env_destroy(curenv);\n}\n```\n\n#### 用户模式页面错误的入口\n接下来需要实现汇编程序,该程序将负责调用页面错误处理程序,并在原始故障指令下继续执行,其将调用处理程序`sys_env_set_pgfault_upcall()`向内核注册.\n\n#### 练习10\n问:\n> 实现在`lib/pfentry.S`中的`_pgfault_upcall`调用.\n\n解:\n> `_pgfault_upcall`是所有用户页错误处理程序的入口,在这里调用用户自定义的处理程序,并在处理完成后,从异常栈中保存的`UTrapframe`结构体中恢复相应信息,然后跳回到发生错误之前的指令,恢复原来的进程运行.具体过程如下:\n调用`_pgfault_handler`返回时的操作,此时的异常栈结构如下：\n![UStack1](/images/lab4/UStack1.png)\n这里`trap-time esp`上的空间有1个4字节的保留空间,是做为中断递归的情形. 然后将栈中的`trap-time esp`取出减去4,再存回栈中.此时如果是中断递归中,`esp-4`即是保留的4字节地址；如果不是则是用户运行栈的栈顶. 再将原来出错程序的`trap-time eip`取出放入保留的4字节,以便后来恢复运行.此时的异常栈布局如下：\n![UStack2](/images/lab4/UStack2.png)\n紧接着恢复通用寄存器和EFLAG标志寄存器,此时的异常栈结构如下：\n![UStack3](/images/lab4/UStack3.png)\n最后`pop esp`切换为原来出错程序的运行栈,最后使用`ret`返回出错程序.\n``` c\n.text\n.globl _pgfault_upcall\n_pgfault_upcall:\n        // Call the C page fault handler.\n        pushl %esp                      // function argument: pointer to UTF\n        movl _pgfault_handler, %eax\n        call *%eax\n        addl $4, %esp                   // pop function argument\n\n        movl 48(%esp), %ebp\n        subl $4, %ebp\n        movl %ebp, 48(%esp)\n        movl 40(%esp), %eax\n        movl %eax, (%ebp)\n\n        // Restore the trap-time registers.  After you do this, you can no longer modify any general-purpose registers.\n        addl $8, %esp\n        popal\n\n        // Restore eflags from the stack.  After you do this, you can\n        // no longer use arithmetic operations or anything else that\n        // modifies eflags.\n        addl $4, %esp\n        popfl\n\n        // Switch back to the adjusted trap-time stack.\n\n        popl %esp\n\n        // Return to re-execute the instruction that faulted.\n        ret\n```\n\n#### 练习11\n问:\n> 在`lib / pgfault.c`中完成`set_pgfault_handler()`,即实现用户级页面故障处理机制的C语言库函数.\n\n解:\n> 进程在运行前注册自己的页错误处理程序,重点是申请用户异常栈空间,最后添加上系统调用号.\n``` c\nvoid\nset_pgfault_handler(void (*handler)(struct UTrapframe *utf))\n{\n        int r;\n\n        if (_pgfault_handler == 0) {\n                // First time through!\n                if ((r = sys_page_alloc(thisenv->env_id, (void *)(UXSTACKTOP - PGSIZE), PTE_P | PTE_W | PTE_U)) < 0)\n                        panic(\"set_pgfault_handler: %e\", r);\n                sys_env_set_pgfault_upcall(thisenv->env_id, _pgfault_upcall);\n\n        }\n\n        // Save handler pointer for assembly to call.\n        _pgfault_handler = handler;\n}\n```\n\n### 实现写入时复制 fork\n接下来就是最重要的部分：实现`copy-on-write fork`.\n与之前的`dumbfork()`不同,`fork()`出一个子进程之后,首先要进行的就是将父进程的页表的全部映射拷贝到子进程的地址空间中去.这个时候物理页会被两个进程同时映射,但是在写的时候是应该隔离的.采取的方法是在子进程映射的时候,将父进程空间中所有可以写的页表的部分全部标记为可读且COW(copy-on-write).而当父进程或者子进程任意一个发生了写的时候,因为页表现在都是不可写的,所以会触发异常,进入到我们设定的page fault处理例程,当检测到是对COW页的写操作的情况下,就可以将要写入的页的内容全部拷贝一份,重新映射.\n\n#### 练习12\n问:\n> 实现在`lib/fork.c`的`fork,duppage和pgfault`.\n\n解:\n> 首先需要为父进程设定错误处理例程.调用`set_pgfault_handler()`是因为当前并不知道父进程是否已经建立了异常栈,没有的话就会建立一个,而`sys_env_set_pgfault_upcall`则不会建立异常栈.\n接着调用`sys_exofork`准备一个和父进程状态相同的子进程,状态暂时设置为`ENV_NOT_RUNNABLE`.然后进行拷贝映射的部分,在当前进程的页表中所有标记为`PTE_P`的页的映射都需要拷贝到子进程空间中去.但是有一个例外,是必须要新申请一页来拷贝内容的,就是用户异常栈.因为copy-on-write就是依靠用户异常栈实现的,所以说这个栈要在fork完成的时候每个进程都有一个,要硬拷贝过来.\n主要流程就是：\n> 1. 申请新的物理页,映射到子进程的(UXSTACKTOP-PGSIZE)位置上去.\n> 2. 父进程的PFTEMP位置也映射到子进程新申请的物理页上去,这样父进程也可以访问这一页.\n> 3. 在父进程空间中,将用户错误栈全部拷贝到子进程的错误栈上去,也就是刚刚申请的那一页.\n> 4. 然后父进程解除对PFTEMP的映射.\n> 5. 最后把子进程的状态设置为可运行\n\n具体实现如下:\n首先是`pgfault`处理`page fault`时的写时复制.\n``` c\nstatic void\npgfault(struct UTrapframe *utf)\n{\n        int r;\n        void *addr = (void *) utf->utf_fault_va;\n        uint32_t err = utf->utf_err;\n\n        if ((err & FEC_WR) == 0 || (uvpt[PGNUM(addr)] & PTE_COW) == 0)\n                panic(\"pgfault: it's not writable or attempt to access a non-cow page!\");\n        // Allocate a new page, map it at a temporary location (PFTEMP),\n        // copy the data from the old page to the new page, then move the new\n        // page to the old page's address.\n\n        envid_t envid = sys_getenvid();\n        if ((r = sys_page_alloc(envid, (void *)PFTEMP, PTE_P | PTE_W | PTE_U)) < 0)\n                panic(\"pgfault: page allocation failed %e\", r);\n\n        addr = ROUNDDOWN(addr, PGSIZE);\n        memmove(PFTEMP, addr, PGSIZE);\n        if ((r = sys_page_unmap(envid, addr)) < 0)\n                panic(\"pgfault: page unmap failed %e\", r);\n        if ((r = sys_page_map(envid, PFTEMP, envid, addr, PTE_P | PTE_W |PTE_U)) < 0)\n                panic(\"pgfault: page map failed %e\", r);\n        if ((r = sys_page_unmap(envid, PFTEMP)) < 0)\n                panic(\"pgfault: page unmap failed %e\", r);\n}\n```\n在`pgfault()`中先判断是否页错误是由写时拷贝造成的,如果不是则`panic`.借用了一个一定不会被用到的位置`PFTEMP`,专门用来发生`page fault`的时候拷贝内容用的.先解除`addr`原先的页映射关系,然后将`addr`映射到`PFTEMP`映射的页,最后解除`PFTEMP`的页映射关系.\n接下来是`duppage`函数,负责进行COW方式的页复制,将当前进程的第pn页对应的物理页的映射到`envid`的第pn页上去,同时将这一页都标记为COW.\n``` c\nstatic int\nduppage(envid_t envid, unsigned pn)\n{\n        int r;\n\n        void *addr;\n        pte_t pte;\n        int perm;\n\n        addr = (void *)((uint32_t)pn * PGSIZE);\n        pte = uvpt[pn];\n        perm = PTE_P | PTE_U;\n        if ((pte & PTE_W) || (pte & PTE_COW))\n                perm |= PTE_COW;\n        if ((r = sys_page_map(thisenv->env_id, addr, envid, addr, perm)) < 0) {\n                panic(\"duppage: page remapping failed %e\", r);\n                return r;\n        }\n        if (perm & PTE_COW) {\n                if ((r = sys_page_map(thisenv->env_id, addr, thisenv->env_id, addr, perm)) < 0) {\n                        panic(\"duppage: page remapping failed %e\", r);\n                        return r;\n                }\n        }\n\n        return 0;\n}\n```\n最后是fork函数,将页映射拷贝过去,这里需要考虑的地址范围就是`从UTEXT到UXSTACKTOP`为止,而在此之上的范围因为都是相同的,在`env_alloc`的时候已经设置好了.\n``` c\nenvid_t\nfork(void)\n{\n        uint32_t addr;\n        int i, j, pn, r;\n        extern void _pgfault_upcall(void);\n        if ((envid = sys_exofork()) < 0) {\n                panic(\"sys_exofork failed: %e\", envid);\n                return envid;\n        }\n        if (envid == 0) {\n                thisenv = &envs[ENVX(sys_getenvid())];\n                return 0;\n        }\n\n        for (i = PDX(UTEXT); i < PDX(UXSTACKTOP); i++) {\n                if (uvpd[i] & PTE_P) {\n                        for (j = 0; j < NPTENTRIES; j++) {\n                                pn = PGNUM(PGADDR(i, j, 0));\n                                if (pn == PGNUM(UXSTACKTOP - PGSIZE))\n                                        break;\n                                if (uvpt[pn] & PTE_P)\n                                        duppage(envid, pn);\n                        }\n                }\n\n        }\n\n        if ((r = sys_page_alloc(envid, (void *)(UXSTACKTOP - PGSIZE), PTE_P | PTE_U | PTE_W)) < 0) {\n                panic(\"fork: page alloc failed %e\", r);\n                return r;\n        }\n        if ((r = sys_page_map(envid, (void *)(UXSTACKTOP - PGSIZE), thisenv->env_id, PFTEMP, PTE_P | PTE_U | PTE_W)) < 0) {\n                panic(\"fork: page map failed %e\", r);\n                return r;\n        }\n        memmove((void *)(UXSTACKTOP - PGSIZE), PFTEMP, PGSIZE);\n        if ((r = sys_page_unmap(thisenv->env_id, PFTEMP)) < 0) {\n                panic(\"fork: page unmap failed %e\", r);\n                return r;\n        }\n        sys_env_set_pgfault_upcall(envid, _pgfault_upcall);\n        if ((r = sys_env_set_status(envid, ENV_RUNNABLE)) < 0) {\n                panic(\"fork: set child env status failed %e\", r);\n                return r;\n        }\n\n        return envid;\n}\n```\n\n## Part3 抢占式调度和进程间通信\nLab4的最后一部分就是实现抢占式调度和进程间通信。\n\n### 时钟中断和抢占\n先前的调度是进程资源放弃CPU，但是实际中没有进程会这样做的，而为了不让某一进程耗尽CPU资源，需要抢占式调度，也就需要硬件定时。但是外部硬件定时在Bootloader的时候就关闭了，至今都没有开启。而JOS采取的策略是，在内核中的时候，外部中断是始终关闭的，在用户态的时候，需要开启中断。\n\n#### 中断原则\n外部中断称为IRQ。一共有16个可能的IRQ，编号为0到15.从IRQ号到IDT条目的映射不是固定的, `picirq.c`中的`pic_init`将IRQ 0-15映射到到IDT的`[IRQ_OFFSET,IRQ_OFFSET+15]`.\n在`inc / trap.h`中， `IRQ_OFFSET`定义为十进制数32.因此IDT条目32-47对应于IRQ 0-15。例如，时钟中断是IRQ 0.因此，`IDT[IRQ_OFFSET + 0]`（即`IDT[32]`）包含内核中时钟的中断处理程序例程的地址。选择正确的`IRQ_OFFSET`使得设备中断不与处理器异常重叠,可以避免异常处理的混乱.\n在JOS中，与xv6 Unix相比，做了一个关键的简化。在内核中，外部设备中断始终被禁用（和xv6一样，在用户空间中启用）。外部中断由寄存器的`FL_IF标志位%eflags`控制（见`inc/mmu.h`）。当该位置1时，外部中断被使能。虽然可以通过几种方式修改该位，但由于简化，可以通过在`%eflags`进入和离开用户模式时保存和恢复寄存器的过程来处理该位。必须确保`FL_IF`标志在用户环境中运行，以便当中断到达时，它将被传递到处理器并由中断代码处理。否则，中断会被屏蔽或忽略，直到重新启用中断。Lab1中用`bootloaded`的第一个指令屏蔽了中断，到目前为止还没开启过.\n\n#### 练习12\n问:\n> 修改`kern/trapentry.S`和`kern/trap.c`来初始化`IDT中IRQs0-15`的入口和处理函数。然后修改`env_alloc`函数来确保进程在用户态运行时中断是打开的。\n\n解:\n> 模仿原先设置的默认中断向量即可，在`kern/trapentry.S`中定义`IRQ0-15`的处理例程。\n``` c\nTRAPHANDLER(irq0_entry, IRQ_OFFSET + 0, 0, 0);\nTRAPHANDLER(irq1_entry, IRQ_OFFSET + 1, 0, 0);\nTRAPHANDLER(irq2_entry, IRQ_OFFSET + 2, 0, 0);\nTRAPHANDLER(irq3_entry, IRQ_OFFSET + 3, 0, 0);\nTRAPHANDLER(irq4_entry, IRQ_OFFSET + 4, 0, 0);\nTRAPHANDLER(irq5_entry, IRQ_OFFSET + 5, 0, 0);\nTRAPHANDLER(irq6_entry, IRQ_OFFSET + 6, 0, 0);\nTRAPHANDLER(irq7_entry, IRQ_OFFSET + 7, 0, 0);\nTRAPHANDLER(irq8_entry, IRQ_OFFSET + 8, 0, 0);\nTRAPHANDLER(irq9_entry, IRQ_OFFSET + 9, 0, 0);\nTRAPHANDLER(irq10_entry, IRQ_OFFSET + 10, 0, 0);\nTRAPHANDLER(irq11_entry, IRQ_OFFSET + 11, 0, 0);\nTRAPHANDLER(irq12_entry, IRQ_OFFSET + 12, 0, 0);\nTRAPHANDLER(irq13_entry, IRQ_OFFSET + 13, 0, 0);\nTRAPHANDLER(irq14_entry, IRQ_OFFSET + 14, 0, 0);\nTRAPHANDLER(irq15_entry, IRQ_OFFSET + 15, 0, 0);\n```\n然后在IDT中注册，修改`trap_init`，由于先前已经实现简化，故此无需做处理。\n最后在`env_alloc`函数中打开中断。\n``` c\n        // kern/env_alloc.c\n        // Also clear the IPC receiving flag.\n        e->env_ipc_recving = 0;\n\n        // Set FL_IF so that user environments run with interrupts enabled\n        e->env_tf.tf_eflags |= FL_IF;\n\n        // commit the allocation\n        env_free_list = e->env_link;\n        *newenv_store = e;\n```\n\n#### 处理时钟中断\n现在虽然中断使能已经打开，在用户态进程运行的时候，外部中断会产生并进入内核，但是现在还没有能处理这类中断。所以需要修改`trap_dispatch`，在发生外部定时中断的时候，调用调度器，调度另外一个可运行的进程。\n\n#### 练习14\n问:\n> 修改`trap_dispatch`h函数，当发生时钟中断时调用`sched_yield`函数来调度下一个进程。\n\n解:\n> 添加对应函数即可\n```\n// kern/trap.c\n\n// Handle clock interrupts. Don't forget to acknowledge the\n// interrupt using lapic_eoi() before calling the scheduler!\nif (tf->tf_trapno == IRQ_OFFSET + IRQ_TIMER) {\n                lapic_eoi();\n                sched_yield();\n                return;\n }\n```\n\n#### 进程间通信(IPC)\nIPC是计算机系统中非常重要的一部分。在JOS实现IPC的方式是当两个进程需要通信的话，一方要发起`recv`，然后阻塞，直到有一个进程调用`send`向正在接受的进程发送了信息，阻塞的进程才会被唤醒。在JOS中，可以允许传递两种信息，一是一个32位整数，另外一个就是传递页的映射，在这个过程中，接收方和发送方将同时映射到一个相同的物理页，此时也就实现了内存共享。最后将这两个功能实现为一个系统调用。\n　　\n#### 实现IPC\n在JOS的IPC实现机制中，修改`Env`结构体如下：\n``` c\nstruct Env {\n        struct Trapframe env_tf;        // Saved registers\n        struct Env *env_link;           // Next free Env\n        envid_t env_id;                 // Unique environment identifier\n        envid_t env_parent_id;          // env_id of this env's parent\n        enum EnvType env_type;          // Indicates special system environments\n        unsigned env_status;            // Status of the environment\n        uint32_t env_runs;              // Number of times environment has run\n        int env_cpunum;                 // The CPU that the env is running on\n\n        // Address space\n        pde_t *env_pgdir;               // Kernel virtual address of page dir\n\n        // Exception handling\n        void *env_pgfault_upcall;       // Page fault upcall entry point\n\n        // Lab 4 IPC\n        bool env_ipc_recving;           // Env is blocked receiving\n        void *env_ipc_dstva;            // VA at which to map received page\n        uint32_t env_ipc_value;         // Data value sent to us\n        envid_t env_ipc_from;           // envid of the sender\n        int env_ipc_perm;               // Perm of page mapping received\n};\n```\n其中增加了5个成员：\n* env_ipc_recving：\n当进程使用env_ipc_recv函数等待信息时，会将这个成员设置为1，然后堵塞等待；当一个进程向它发消息解除堵塞后，发送进程将此成员修改为0。\n* env_ipc_dstva：\n如果进程要接受消息并且是传送页，保存页映射的地址，且该地址<=UTOP。\n* env_ipc_value：\n若等待消息的进程接收到消息，发送方将接收方此成员设置为消息值。\n* env_ipc_from：\n发送方负责设置该成员为自己的envid号。\n* env_ipc_perm：\n如果进程要接收消息并且传送页，那么发送方发送页之后将传送的页权限赋给这个成员\n\n#### 练习15\n问:\n> 实现在`kern/syscall.c`中的`sys_ipc_recv和sys_ipc_try_send`函数。最后实现用户态的`ipc_recv和ipc_send`。\n\n解:\n> 首先是`sys_ipc_recv`函数，其功能是当一个进程试图去接收信息的时候，应该将自己标记为正在接收信息，而且为了不浪费CPU资源，应该同时标记自己为`ENV_NOT_RUNNABLE`，只有当有进程向自己发了信息之后，才会重新恢复可运行。最后将自己标记为不可运行之后，调用调度器运行其他进程。\n``` c\nstatic int\nsys_ipc_recv(void *dstva)\n{\n        if (dstva < (void *)UTOP && PGOFF(dstva))\n                return -E_INVAL;\n        curenv->env_ipc_recving = true;\n        curenv->env_ipc_dstva = dstva;\n        curenv->env_status = ENV_NOT_RUNNABLE;\n        curenv->env_ipc_from = 0;\n        sched_yield();\n        return 0;\n}\n```\n接着是`sys_ipc_try_send`函数，其实现相对来说麻烦很多，因为有很多的检测项，包括权限是否符合要求，要传送的页有没有，能不能将这一页映射到对方页表中去等等。如果`srcva`是在`UTOP`之下，那么说明是要共享内存，那就首先要在发送方的页表中找到`srcva`对应的页表项，然后在接收方给定的虚地址处插入这个页表项。接收完成之后，重新将当前进程设置为可运行，同时把`env_ipc_recving`设置为0，以防止其他的进程再发送，覆盖掉当前的内容。\n``` c\nstatic int\nsys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)\n{\n        int r;\n        pte_t *pte;\n        struct PageInfo *pp;\n        struct Env *env;\n\n        if ((r = envid2env(envid, &env, 0)) < 0)\n                return -E_BAD_ENV;\n        if (env->env_ipc_recving != true || env->env_ipc_from != 0)\n                return -E_IPC_NOT_RECV;\n        if (srcva < (void *)UTOP && PGOFF(srcva))\n                return -E_INVAL;\n        if (srcva < (void *)UTOP) {\n                if ((perm & PTE_P) == 0 || (perm & PTE_U) == 0)\n                        return -E_INVAL;\n                if ((perm & ~(PTE_P | PTE_U | PTE_W | PTE_AVAIL)) != 0)\n                        return -E_INVAL;\n        }\n        if (srcva < (void *)UTOP && (pp = page_lookup(curenv->env_pgdir, srcva, &pte)) == NULL)\n                return -E_INVAL;\n        if (srcva < (void *)UTOP && (perm & PTE_W) != 0 && (*pte & PTE_W) == 0)\n                return -E_INVAL;\n        if (srcva < (void *)UTOP && env->env_ipc_dstva != 0) {\n                if ((r = page_insert(env->env_pgdir, pp, env->env_ipc_dstva, perm)) < 0)\n                        return -E_NO_MEM;\n                env->env_ipc_perm = perm;\n        }\n\n        env->env_ipc_from = curenv->env_id;\n        env->env_ipc_recving = false;\n        env->env_ipc_value = value;\n        env->env_status = ENV_RUNNABLE;\n        env->env_tf.tf_regs.reg_eax = 0;\n        return 0;\n}\n```\n完成后需要要加上分发机制，将调用号加上。\n最后是2个用户态库函数的实现。\n``` c\nint32_t\nipc_recv(envid_t *from_env_store, void *pg, int *perm_store)\n{\n        int r;\n\n        if (pg == NULL)\n                r = sys_ipc_recv((void *)UTOP);\n        else\n                r = sys_ipc_recv(pg);\n        if (from_env_store != NULL)\n                *from_env_store = r < 0 ? 0 : thisenv->env_ipc_from;\n        if (perm_store != NULL)\n                *perm_store = r < 0 ? 0 : thisenv->env_ipc_perm;\n        if (r < 0)\n                return r;\n        else\n                return thisenv->env_ipc_value;\n}\n\nvoid\nipc_send(envid_t to_env, uint32_t val, void *pg, int perm)\n{\n        int r;\n        void *dstpg;\n\n        dstpg = pg != NULL ? pg : (void *)UTOP;\n        while((r = sys_ipc_try_send(to_env, val, dstpg, perm)) < 0) {\n                if (r != -E_IPC_NOT_RECV)\n                        panic(\"ipc_send: send message error %e\", r);\n                sys_yield();\n        }\n}\n```\n","source":"_posts/lab4_part23.md","raw":"title: lab4-Preemptive Multitasking part23\ndate: 2017/05/13\ntags:\n- xv6\n- os\n\n---\n# Lab4 抢占式多进程\n## Part2 写入时复制 copy-on-write fork\n如前所述,Unix将fork()系统调用作为进程创建原语.fork()系统调用将调用进程的地址空间（父进程）创建一个新的进程（子进程）.\nxv6 Unix `fork()`通过将父进程页面中的所有数据复制到为子进程分配的新页面中,这个机制基本和`dumbfork()`相同.复制父进程的地址空间到子进程是`fork()`中代价最大的操作.\n但是,调用`fork()`后经常在子进程中跟随`exec()`调用, 其会用加载新程序到子进程的内存.例如, 这是shell的常用机制.在这种情况下,复制父进程地址空间的时间大部分被浪费,因为子进程在调用`exec()`之前只使用很少的内存.\n\n因此,Unix的更高版本利用虚拟内存硬件,允许父子进程**共享**映射到其各自地址空间的内存,直到其中一个进程实际修改这段内存.这种技术被称为**写时复制(copy-on-fork)**.为了做到这一点,调用`fork()`时,内核上将复制父进程的地址空间映射到进程,而不是复制映射页的内容,同时标记现在共享的页面为只读.当两个进程中的一个尝试写入其中一个共享页面时,该进程将出现页面错误.在这一点上,Unix内核意识到该页面真的是一个“虚拟”或“写时复制”的副本,因此它创建一个新的/私有的故障页面的可写副本.这样,单个页面的内容在实际写入之前实际上并不被复制.`fork()`的这种优化使随后的`exec()`代价小很多：在子进程调用`exec()`之前,可能只需要复制一个页面（它的堆栈的当前页面）.\n\n在part2,实现一个 Unix `fork()`,其具有写时复制功能,并作为一个用户空间库例程来.另外,使得单个用户模式程序定义自己的`fork()`:一个程序想要一个稍微不同的`fork()`（如总是复制的`dumbfork()`,或者父子进程共享内存）可以很容易修改而实现.\n\n### 用户级页面错误处理\n用户级的写时复制`fork()`首先需要知道发生在写保护页面上的页面错误,这是首先要实现的.写时复制只是用户级页面故障处理的许多可能用途之一.\n一般实现方式是:设置一个地址空间,以便页面错误指示出何时需要执行操作.例如,大多数Unix内核最初仅在新进程的堆栈区域中映射单个页面,并且随着进程的堆栈增加而随后分配和映射额外的堆栈页面,并导致尚未映射的堆栈地址发生页面错误,对此典型的Unix内核必须跟踪在进程空间的每个区域中出现页面错误时要执行的操作.又例如,堆栈区域中的故障通常会导致分配和映射物理内存新页面.程序BSS区域的故障通常会分配一个新的页面,以0填充,并在进行映射.\n以上是内核需要跟踪的信息.不采用传统的Unix方法,而更好地处理用户空间中的每个页面错误,使得bug破坏性更小.这种设计具有额外的优点,允许程序在定义其内存区域方面具有很大的灵活性.\n<!-- more -->\n\n#### 设置页面错误处理器\n为了处理自己的页面错误,用户环境将需要向JOS内核注册页面错误处理程序`entrypoint`.用户环境通过新的`sys_env_set_pgfault_upcall`系统调用注册其页面错误入口点.增加一个新成员`Env`结构`env_pgfault_upcall`来记录这些信息.\n\n#### 练习8\n问:\n> 实现`sys_env_set_pgfault_upcall`系统调用.注:因为这个系统调用危险性很高,所以在查找目标环境的环境ID时要启用权限检查,\n\n解:\n> 实现如下:\n``` c\nstatic int\nsys_env_set_pgfault_upcall(envid_t envid, void *func)\n{\n        struct Env *env;\n\n        if (envid2env(envid, &env, 1) < 0)\n                return -E_BAD_ENV;\n        env->env_pgfault_upcall = func;\n        return 0;\n}\n```\n\n#### 用户环境的正常/异常堆栈\n在正常运行期间,用户进程运行在用户栈上,栈顶寄存器`ESP`指向`USTACKTOP`处,堆栈数据位于`USTACKTOP-PGSIZE 与USTACKTOP-1`之间的页.当在用户模式发生页面错误时,内核将在专门处理页面错误的用户异常栈上重新启动进程. 异常栈正是为了上面设置的异常处理例程设立的.当异常发生时,而且该用户进程注册了该异常的处理例程,那么就会转到异常栈上,运行异常处理例程.\n到目前位置出现了三个栈：\n* 内核态系统栈 [KSTACKTOP, KSTACKTOP-KSTKSIZE]\n* 用户态错误处理栈 [UXSTACKTOP, UXSTACKTOP - PGSIZE]\n* 用户态运行栈 [USTACKTOP, UTEXT]\n\n内核态系统栈是运行内核相关程序的栈,在有中断被触发之后,CPU会将栈自动切换到内核栈上来,而内核栈的设置是在`kern/trap.c`的`trap_init_percpu()`中设置的.\n``` c\nvoid\ntrap_init_percpu(void)\n{\n        // Setup a TSS so that we get the right stack\n        // when we trap to the kernel.\n        thiscpu->cpu_ts.ts_esp0 = KSTACKTOP - cpunum() * (KSTKGAP + KSTKSIZE);\n        thiscpu->cpu_ts.ts_ss0 = GD_KD;\n\n        // Initialize the TSS slot of the gdt.\n        gdt[(GD_TSS0 >> 3) + cpunum()] = SEG16(STS_T32A, (uint32_t) (&thiscpu->cpu_ts),\n                                        sizeof(struct Taskstate) - 1, 0);\n        gdt[(GD_TSS0 >> 3) + cpunum()].sd_s = 0;\n\n        // Load the TSS selector (like other segment selectors, the\n        // bottom three bits are special; we leave them 0)\n        ltr(GD_TSS0 + sizeof(struct Segdesc) * cpunum());\n\n        // Load the IDT\n        lidt(&idt_pd);\n}\n```\n而用户态错误处理栈是用户定义注册了自己的中断处理程序之后,相应的例程运行时的栈.整个过程如下：\n> 首先陷入到内核,栈位置从用户运行栈切换到内核栈,进入到`trap`中,进行中断处理分发,进入到`page_fault_handler()`.当确认是用户程序触发的`page fault`的时候(如果是内核触发的,会直接`panic`),为其在用户错误栈里分配一个`UTrapframe`的大小.把栈切换到用户错误栈,运行响应的用户中断处理程序中断处理程序可能会触发另外一个同类型的中断,这个时候就会产生递归式的中断嵌套处理.处理完成之后,返回到用户运行栈.\n\n#### 调用用户页面故障处理程序\n将用户自己定义的页面故障处理进程当作是一次函数调用看待,当错误发生的时候,调用一个函数,但实际上还是当前这个进程,并没有发生变化.所以当切换到异常栈的时候,依然运行当前进程,但只是运行的是中断处理函数,所以说此时的栈指针发生了变化,而且程序计数器`eip`也发生了变化,同时还需要知道的是引发错误的地址在哪.这些都是要在切换到异常栈的时候需要传递的信息.和之前从用户栈切换到内核栈一样,这里是通过在栈上构造结构体,传递指针完成的.\n在`inc / trap.h`新定义了一个类似`struct Trapframe`结构体`struct UTrapframe`用来记录出现页面错误时候的信息：\n``` c\nstruct UTrapframe {\n        /* information about the fault */\n        uint32_t utf_fault_va;  /* va for T_PGFLT, 0 otherwise */\n        uint32_t utf_err;\n        /* trap-time return state */\n        struct PushRegs utf_regs;\n        uintptr_t utf_eip;\n        uint32_t utf_eflags;\n        /* the trap-time stack to return to */\n        uintptr_t utf_esp;\n} __attribute__((packed));\n```\n相比于`Trapframe`,这里多了`utf_fault_va`,因为要记录触发错误的内存地址,同时还少了`es,ds,ss`等段记录.因为从用户态栈切换到异常栈,或者从异常栈再切换回去,实际上都是一个用户进程,所以不涉及到段的切换,不用记录.在实际使用中,`Trapframe`是作为记录进程状态的结构体存在的,也作为函数参数进行传递；而`UTrapframe`只在处理用户定义的异常时用到.\n整体上讲,当正常执行过程中发生了页面错误,那么栈的切换是\n**用户运行栈—>内核栈—>异常栈**\n而如果在异常处理程序中发生了页面错误,那么栈的切换是\n**异常栈—>内核栈—>异常栈**\n\n#### 练习9\n问:\n> 实现`kern/trap.c`中`page_fault_handler`函数, 把页面错误分发到对应的用户态异常处理函数.\n\n解:\n> 如果当前已经在用户错误栈上了,那么需要留出4个字节,否则不需要,具体和跳转机制有关系.简单说就是在当前的异常栈栈顶的位置向下留出保存`UTrapframe`的空间,然后将`tf`中的参数复制过来.修改当前进程的程序计数器和栈指针,然后重启这个进程,此时就会在用户错误栈上运行中断处理程序了.中断处理程序运行结束之后,需要再回到用户运行栈中,这是异常处理程序需要做的.\n``` c\nvoid\npage_fault_handler(struct Trapframe *tf)\n{\n        uint32_t fault_va;\n\n        // Read processor's CR2 register to find the faulting address\n        fault_va = rcr2();\n\n        // Handle kernel-mode page faults.\n        if (tf->tf_cs == GD_KT)\n                panic(\"page_fault in kernel mode, fault address: %d\\n\", fault_va);\n\n        struct UTrapframe *utf;\n\n        if (curenv->env_pgfault_upcall) {\n                if (UXSTACKTOP - PGSIZE <= tf->tf_esp && tf->tf_esp <= UXSTACKTOP - 1)\n                        utf = (struct UTrapframe *)(tf->tf_esp - sizeof(struct UTrapframe) - 4);\n                else\n                        utf = (struct UTrapframe *)(UXSTACKTOP - sizeof(struct UTrapframe));\n                user_mem_assert(curenv, (void *)utf, sizeof(struct UTrapframe), PTE_U | PTE_W);\n\n                utf->utf_fault_va = fault_va;\n                utf->utf_err = tf->tf_trapno;\n                utf->utf_eip = tf->tf_eip;\n                utf->utf_eflags = tf->tf_eflags;\n                utf->utf_esp = tf->tf_esp;\n                utf->utf_regs = tf->tf_regs;\n                tf->tf_eip = (uint32_t)curenv->env_pgfault_upcall;\n                tf->tf_esp = (uint32_t)utf;\n                env_run(curenv);\n        }\n\n        // Destroy the environment that caused the fault.\n        cprintf(\"[%08x] user fault va %08x ip %08x\\n\",\n                curenv->env_id, fault_va, tf->tf_eip);\n        print_trapframe(tf);\n        env_destroy(curenv);\n}\n```\n\n#### 用户模式页面错误的入口\n接下来需要实现汇编程序,该程序将负责调用页面错误处理程序,并在原始故障指令下继续执行,其将调用处理程序`sys_env_set_pgfault_upcall()`向内核注册.\n\n#### 练习10\n问:\n> 实现在`lib/pfentry.S`中的`_pgfault_upcall`调用.\n\n解:\n> `_pgfault_upcall`是所有用户页错误处理程序的入口,在这里调用用户自定义的处理程序,并在处理完成后,从异常栈中保存的`UTrapframe`结构体中恢复相应信息,然后跳回到发生错误之前的指令,恢复原来的进程运行.具体过程如下:\n调用`_pgfault_handler`返回时的操作,此时的异常栈结构如下：\n![UStack1](/images/lab4/UStack1.png)\n这里`trap-time esp`上的空间有1个4字节的保留空间,是做为中断递归的情形. 然后将栈中的`trap-time esp`取出减去4,再存回栈中.此时如果是中断递归中,`esp-4`即是保留的4字节地址；如果不是则是用户运行栈的栈顶. 再将原来出错程序的`trap-time eip`取出放入保留的4字节,以便后来恢复运行.此时的异常栈布局如下：\n![UStack2](/images/lab4/UStack2.png)\n紧接着恢复通用寄存器和EFLAG标志寄存器,此时的异常栈结构如下：\n![UStack3](/images/lab4/UStack3.png)\n最后`pop esp`切换为原来出错程序的运行栈,最后使用`ret`返回出错程序.\n``` c\n.text\n.globl _pgfault_upcall\n_pgfault_upcall:\n        // Call the C page fault handler.\n        pushl %esp                      // function argument: pointer to UTF\n        movl _pgfault_handler, %eax\n        call *%eax\n        addl $4, %esp                   // pop function argument\n\n        movl 48(%esp), %ebp\n        subl $4, %ebp\n        movl %ebp, 48(%esp)\n        movl 40(%esp), %eax\n        movl %eax, (%ebp)\n\n        // Restore the trap-time registers.  After you do this, you can no longer modify any general-purpose registers.\n        addl $8, %esp\n        popal\n\n        // Restore eflags from the stack.  After you do this, you can\n        // no longer use arithmetic operations or anything else that\n        // modifies eflags.\n        addl $4, %esp\n        popfl\n\n        // Switch back to the adjusted trap-time stack.\n\n        popl %esp\n\n        // Return to re-execute the instruction that faulted.\n        ret\n```\n\n#### 练习11\n问:\n> 在`lib / pgfault.c`中完成`set_pgfault_handler()`,即实现用户级页面故障处理机制的C语言库函数.\n\n解:\n> 进程在运行前注册自己的页错误处理程序,重点是申请用户异常栈空间,最后添加上系统调用号.\n``` c\nvoid\nset_pgfault_handler(void (*handler)(struct UTrapframe *utf))\n{\n        int r;\n\n        if (_pgfault_handler == 0) {\n                // First time through!\n                if ((r = sys_page_alloc(thisenv->env_id, (void *)(UXSTACKTOP - PGSIZE), PTE_P | PTE_W | PTE_U)) < 0)\n                        panic(\"set_pgfault_handler: %e\", r);\n                sys_env_set_pgfault_upcall(thisenv->env_id, _pgfault_upcall);\n\n        }\n\n        // Save handler pointer for assembly to call.\n        _pgfault_handler = handler;\n}\n```\n\n### 实现写入时复制 fork\n接下来就是最重要的部分：实现`copy-on-write fork`.\n与之前的`dumbfork()`不同,`fork()`出一个子进程之后,首先要进行的就是将父进程的页表的全部映射拷贝到子进程的地址空间中去.这个时候物理页会被两个进程同时映射,但是在写的时候是应该隔离的.采取的方法是在子进程映射的时候,将父进程空间中所有可以写的页表的部分全部标记为可读且COW(copy-on-write).而当父进程或者子进程任意一个发生了写的时候,因为页表现在都是不可写的,所以会触发异常,进入到我们设定的page fault处理例程,当检测到是对COW页的写操作的情况下,就可以将要写入的页的内容全部拷贝一份,重新映射.\n\n#### 练习12\n问:\n> 实现在`lib/fork.c`的`fork,duppage和pgfault`.\n\n解:\n> 首先需要为父进程设定错误处理例程.调用`set_pgfault_handler()`是因为当前并不知道父进程是否已经建立了异常栈,没有的话就会建立一个,而`sys_env_set_pgfault_upcall`则不会建立异常栈.\n接着调用`sys_exofork`准备一个和父进程状态相同的子进程,状态暂时设置为`ENV_NOT_RUNNABLE`.然后进行拷贝映射的部分,在当前进程的页表中所有标记为`PTE_P`的页的映射都需要拷贝到子进程空间中去.但是有一个例外,是必须要新申请一页来拷贝内容的,就是用户异常栈.因为copy-on-write就是依靠用户异常栈实现的,所以说这个栈要在fork完成的时候每个进程都有一个,要硬拷贝过来.\n主要流程就是：\n> 1. 申请新的物理页,映射到子进程的(UXSTACKTOP-PGSIZE)位置上去.\n> 2. 父进程的PFTEMP位置也映射到子进程新申请的物理页上去,这样父进程也可以访问这一页.\n> 3. 在父进程空间中,将用户错误栈全部拷贝到子进程的错误栈上去,也就是刚刚申请的那一页.\n> 4. 然后父进程解除对PFTEMP的映射.\n> 5. 最后把子进程的状态设置为可运行\n\n具体实现如下:\n首先是`pgfault`处理`page fault`时的写时复制.\n``` c\nstatic void\npgfault(struct UTrapframe *utf)\n{\n        int r;\n        void *addr = (void *) utf->utf_fault_va;\n        uint32_t err = utf->utf_err;\n\n        if ((err & FEC_WR) == 0 || (uvpt[PGNUM(addr)] & PTE_COW) == 0)\n                panic(\"pgfault: it's not writable or attempt to access a non-cow page!\");\n        // Allocate a new page, map it at a temporary location (PFTEMP),\n        // copy the data from the old page to the new page, then move the new\n        // page to the old page's address.\n\n        envid_t envid = sys_getenvid();\n        if ((r = sys_page_alloc(envid, (void *)PFTEMP, PTE_P | PTE_W | PTE_U)) < 0)\n                panic(\"pgfault: page allocation failed %e\", r);\n\n        addr = ROUNDDOWN(addr, PGSIZE);\n        memmove(PFTEMP, addr, PGSIZE);\n        if ((r = sys_page_unmap(envid, addr)) < 0)\n                panic(\"pgfault: page unmap failed %e\", r);\n        if ((r = sys_page_map(envid, PFTEMP, envid, addr, PTE_P | PTE_W |PTE_U)) < 0)\n                panic(\"pgfault: page map failed %e\", r);\n        if ((r = sys_page_unmap(envid, PFTEMP)) < 0)\n                panic(\"pgfault: page unmap failed %e\", r);\n}\n```\n在`pgfault()`中先判断是否页错误是由写时拷贝造成的,如果不是则`panic`.借用了一个一定不会被用到的位置`PFTEMP`,专门用来发生`page fault`的时候拷贝内容用的.先解除`addr`原先的页映射关系,然后将`addr`映射到`PFTEMP`映射的页,最后解除`PFTEMP`的页映射关系.\n接下来是`duppage`函数,负责进行COW方式的页复制,将当前进程的第pn页对应的物理页的映射到`envid`的第pn页上去,同时将这一页都标记为COW.\n``` c\nstatic int\nduppage(envid_t envid, unsigned pn)\n{\n        int r;\n\n        void *addr;\n        pte_t pte;\n        int perm;\n\n        addr = (void *)((uint32_t)pn * PGSIZE);\n        pte = uvpt[pn];\n        perm = PTE_P | PTE_U;\n        if ((pte & PTE_W) || (pte & PTE_COW))\n                perm |= PTE_COW;\n        if ((r = sys_page_map(thisenv->env_id, addr, envid, addr, perm)) < 0) {\n                panic(\"duppage: page remapping failed %e\", r);\n                return r;\n        }\n        if (perm & PTE_COW) {\n                if ((r = sys_page_map(thisenv->env_id, addr, thisenv->env_id, addr, perm)) < 0) {\n                        panic(\"duppage: page remapping failed %e\", r);\n                        return r;\n                }\n        }\n\n        return 0;\n}\n```\n最后是fork函数,将页映射拷贝过去,这里需要考虑的地址范围就是`从UTEXT到UXSTACKTOP`为止,而在此之上的范围因为都是相同的,在`env_alloc`的时候已经设置好了.\n``` c\nenvid_t\nfork(void)\n{\n        uint32_t addr;\n        int i, j, pn, r;\n        extern void _pgfault_upcall(void);\n        if ((envid = sys_exofork()) < 0) {\n                panic(\"sys_exofork failed: %e\", envid);\n                return envid;\n        }\n        if (envid == 0) {\n                thisenv = &envs[ENVX(sys_getenvid())];\n                return 0;\n        }\n\n        for (i = PDX(UTEXT); i < PDX(UXSTACKTOP); i++) {\n                if (uvpd[i] & PTE_P) {\n                        for (j = 0; j < NPTENTRIES; j++) {\n                                pn = PGNUM(PGADDR(i, j, 0));\n                                if (pn == PGNUM(UXSTACKTOP - PGSIZE))\n                                        break;\n                                if (uvpt[pn] & PTE_P)\n                                        duppage(envid, pn);\n                        }\n                }\n\n        }\n\n        if ((r = sys_page_alloc(envid, (void *)(UXSTACKTOP - PGSIZE), PTE_P | PTE_U | PTE_W)) < 0) {\n                panic(\"fork: page alloc failed %e\", r);\n                return r;\n        }\n        if ((r = sys_page_map(envid, (void *)(UXSTACKTOP - PGSIZE), thisenv->env_id, PFTEMP, PTE_P | PTE_U | PTE_W)) < 0) {\n                panic(\"fork: page map failed %e\", r);\n                return r;\n        }\n        memmove((void *)(UXSTACKTOP - PGSIZE), PFTEMP, PGSIZE);\n        if ((r = sys_page_unmap(thisenv->env_id, PFTEMP)) < 0) {\n                panic(\"fork: page unmap failed %e\", r);\n                return r;\n        }\n        sys_env_set_pgfault_upcall(envid, _pgfault_upcall);\n        if ((r = sys_env_set_status(envid, ENV_RUNNABLE)) < 0) {\n                panic(\"fork: set child env status failed %e\", r);\n                return r;\n        }\n\n        return envid;\n}\n```\n\n## Part3 抢占式调度和进程间通信\nLab4的最后一部分就是实现抢占式调度和进程间通信。\n\n### 时钟中断和抢占\n先前的调度是进程资源放弃CPU，但是实际中没有进程会这样做的，而为了不让某一进程耗尽CPU资源，需要抢占式调度，也就需要硬件定时。但是外部硬件定时在Bootloader的时候就关闭了，至今都没有开启。而JOS采取的策略是，在内核中的时候，外部中断是始终关闭的，在用户态的时候，需要开启中断。\n\n#### 中断原则\n外部中断称为IRQ。一共有16个可能的IRQ，编号为0到15.从IRQ号到IDT条目的映射不是固定的, `picirq.c`中的`pic_init`将IRQ 0-15映射到到IDT的`[IRQ_OFFSET,IRQ_OFFSET+15]`.\n在`inc / trap.h`中， `IRQ_OFFSET`定义为十进制数32.因此IDT条目32-47对应于IRQ 0-15。例如，时钟中断是IRQ 0.因此，`IDT[IRQ_OFFSET + 0]`（即`IDT[32]`）包含内核中时钟的中断处理程序例程的地址。选择正确的`IRQ_OFFSET`使得设备中断不与处理器异常重叠,可以避免异常处理的混乱.\n在JOS中，与xv6 Unix相比，做了一个关键的简化。在内核中，外部设备中断始终被禁用（和xv6一样，在用户空间中启用）。外部中断由寄存器的`FL_IF标志位%eflags`控制（见`inc/mmu.h`）。当该位置1时，外部中断被使能。虽然可以通过几种方式修改该位，但由于简化，可以通过在`%eflags`进入和离开用户模式时保存和恢复寄存器的过程来处理该位。必须确保`FL_IF`标志在用户环境中运行，以便当中断到达时，它将被传递到处理器并由中断代码处理。否则，中断会被屏蔽或忽略，直到重新启用中断。Lab1中用`bootloaded`的第一个指令屏蔽了中断，到目前为止还没开启过.\n\n#### 练习12\n问:\n> 修改`kern/trapentry.S`和`kern/trap.c`来初始化`IDT中IRQs0-15`的入口和处理函数。然后修改`env_alloc`函数来确保进程在用户态运行时中断是打开的。\n\n解:\n> 模仿原先设置的默认中断向量即可，在`kern/trapentry.S`中定义`IRQ0-15`的处理例程。\n``` c\nTRAPHANDLER(irq0_entry, IRQ_OFFSET + 0, 0, 0);\nTRAPHANDLER(irq1_entry, IRQ_OFFSET + 1, 0, 0);\nTRAPHANDLER(irq2_entry, IRQ_OFFSET + 2, 0, 0);\nTRAPHANDLER(irq3_entry, IRQ_OFFSET + 3, 0, 0);\nTRAPHANDLER(irq4_entry, IRQ_OFFSET + 4, 0, 0);\nTRAPHANDLER(irq5_entry, IRQ_OFFSET + 5, 0, 0);\nTRAPHANDLER(irq6_entry, IRQ_OFFSET + 6, 0, 0);\nTRAPHANDLER(irq7_entry, IRQ_OFFSET + 7, 0, 0);\nTRAPHANDLER(irq8_entry, IRQ_OFFSET + 8, 0, 0);\nTRAPHANDLER(irq9_entry, IRQ_OFFSET + 9, 0, 0);\nTRAPHANDLER(irq10_entry, IRQ_OFFSET + 10, 0, 0);\nTRAPHANDLER(irq11_entry, IRQ_OFFSET + 11, 0, 0);\nTRAPHANDLER(irq12_entry, IRQ_OFFSET + 12, 0, 0);\nTRAPHANDLER(irq13_entry, IRQ_OFFSET + 13, 0, 0);\nTRAPHANDLER(irq14_entry, IRQ_OFFSET + 14, 0, 0);\nTRAPHANDLER(irq15_entry, IRQ_OFFSET + 15, 0, 0);\n```\n然后在IDT中注册，修改`trap_init`，由于先前已经实现简化，故此无需做处理。\n最后在`env_alloc`函数中打开中断。\n``` c\n        // kern/env_alloc.c\n        // Also clear the IPC receiving flag.\n        e->env_ipc_recving = 0;\n\n        // Set FL_IF so that user environments run with interrupts enabled\n        e->env_tf.tf_eflags |= FL_IF;\n\n        // commit the allocation\n        env_free_list = e->env_link;\n        *newenv_store = e;\n```\n\n#### 处理时钟中断\n现在虽然中断使能已经打开，在用户态进程运行的时候，外部中断会产生并进入内核，但是现在还没有能处理这类中断。所以需要修改`trap_dispatch`，在发生外部定时中断的时候，调用调度器，调度另外一个可运行的进程。\n\n#### 练习14\n问:\n> 修改`trap_dispatch`h函数，当发生时钟中断时调用`sched_yield`函数来调度下一个进程。\n\n解:\n> 添加对应函数即可\n```\n// kern/trap.c\n\n// Handle clock interrupts. Don't forget to acknowledge the\n// interrupt using lapic_eoi() before calling the scheduler!\nif (tf->tf_trapno == IRQ_OFFSET + IRQ_TIMER) {\n                lapic_eoi();\n                sched_yield();\n                return;\n }\n```\n\n#### 进程间通信(IPC)\nIPC是计算机系统中非常重要的一部分。在JOS实现IPC的方式是当两个进程需要通信的话，一方要发起`recv`，然后阻塞，直到有一个进程调用`send`向正在接受的进程发送了信息，阻塞的进程才会被唤醒。在JOS中，可以允许传递两种信息，一是一个32位整数，另外一个就是传递页的映射，在这个过程中，接收方和发送方将同时映射到一个相同的物理页，此时也就实现了内存共享。最后将这两个功能实现为一个系统调用。\n　　\n#### 实现IPC\n在JOS的IPC实现机制中，修改`Env`结构体如下：\n``` c\nstruct Env {\n        struct Trapframe env_tf;        // Saved registers\n        struct Env *env_link;           // Next free Env\n        envid_t env_id;                 // Unique environment identifier\n        envid_t env_parent_id;          // env_id of this env's parent\n        enum EnvType env_type;          // Indicates special system environments\n        unsigned env_status;            // Status of the environment\n        uint32_t env_runs;              // Number of times environment has run\n        int env_cpunum;                 // The CPU that the env is running on\n\n        // Address space\n        pde_t *env_pgdir;               // Kernel virtual address of page dir\n\n        // Exception handling\n        void *env_pgfault_upcall;       // Page fault upcall entry point\n\n        // Lab 4 IPC\n        bool env_ipc_recving;           // Env is blocked receiving\n        void *env_ipc_dstva;            // VA at which to map received page\n        uint32_t env_ipc_value;         // Data value sent to us\n        envid_t env_ipc_from;           // envid of the sender\n        int env_ipc_perm;               // Perm of page mapping received\n};\n```\n其中增加了5个成员：\n* env_ipc_recving：\n当进程使用env_ipc_recv函数等待信息时，会将这个成员设置为1，然后堵塞等待；当一个进程向它发消息解除堵塞后，发送进程将此成员修改为0。\n* env_ipc_dstva：\n如果进程要接受消息并且是传送页，保存页映射的地址，且该地址<=UTOP。\n* env_ipc_value：\n若等待消息的进程接收到消息，发送方将接收方此成员设置为消息值。\n* env_ipc_from：\n发送方负责设置该成员为自己的envid号。\n* env_ipc_perm：\n如果进程要接收消息并且传送页，那么发送方发送页之后将传送的页权限赋给这个成员\n\n#### 练习15\n问:\n> 实现在`kern/syscall.c`中的`sys_ipc_recv和sys_ipc_try_send`函数。最后实现用户态的`ipc_recv和ipc_send`。\n\n解:\n> 首先是`sys_ipc_recv`函数，其功能是当一个进程试图去接收信息的时候，应该将自己标记为正在接收信息，而且为了不浪费CPU资源，应该同时标记自己为`ENV_NOT_RUNNABLE`，只有当有进程向自己发了信息之后，才会重新恢复可运行。最后将自己标记为不可运行之后，调用调度器运行其他进程。\n``` c\nstatic int\nsys_ipc_recv(void *dstva)\n{\n        if (dstva < (void *)UTOP && PGOFF(dstva))\n                return -E_INVAL;\n        curenv->env_ipc_recving = true;\n        curenv->env_ipc_dstva = dstva;\n        curenv->env_status = ENV_NOT_RUNNABLE;\n        curenv->env_ipc_from = 0;\n        sched_yield();\n        return 0;\n}\n```\n接着是`sys_ipc_try_send`函数，其实现相对来说麻烦很多，因为有很多的检测项，包括权限是否符合要求，要传送的页有没有，能不能将这一页映射到对方页表中去等等。如果`srcva`是在`UTOP`之下，那么说明是要共享内存，那就首先要在发送方的页表中找到`srcva`对应的页表项，然后在接收方给定的虚地址处插入这个页表项。接收完成之后，重新将当前进程设置为可运行，同时把`env_ipc_recving`设置为0，以防止其他的进程再发送，覆盖掉当前的内容。\n``` c\nstatic int\nsys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, unsigned perm)\n{\n        int r;\n        pte_t *pte;\n        struct PageInfo *pp;\n        struct Env *env;\n\n        if ((r = envid2env(envid, &env, 0)) < 0)\n                return -E_BAD_ENV;\n        if (env->env_ipc_recving != true || env->env_ipc_from != 0)\n                return -E_IPC_NOT_RECV;\n        if (srcva < (void *)UTOP && PGOFF(srcva))\n                return -E_INVAL;\n        if (srcva < (void *)UTOP) {\n                if ((perm & PTE_P) == 0 || (perm & PTE_U) == 0)\n                        return -E_INVAL;\n                if ((perm & ~(PTE_P | PTE_U | PTE_W | PTE_AVAIL)) != 0)\n                        return -E_INVAL;\n        }\n        if (srcva < (void *)UTOP && (pp = page_lookup(curenv->env_pgdir, srcva, &pte)) == NULL)\n                return -E_INVAL;\n        if (srcva < (void *)UTOP && (perm & PTE_W) != 0 && (*pte & PTE_W) == 0)\n                return -E_INVAL;\n        if (srcva < (void *)UTOP && env->env_ipc_dstva != 0) {\n                if ((r = page_insert(env->env_pgdir, pp, env->env_ipc_dstva, perm)) < 0)\n                        return -E_NO_MEM;\n                env->env_ipc_perm = perm;\n        }\n\n        env->env_ipc_from = curenv->env_id;\n        env->env_ipc_recving = false;\n        env->env_ipc_value = value;\n        env->env_status = ENV_RUNNABLE;\n        env->env_tf.tf_regs.reg_eax = 0;\n        return 0;\n}\n```\n完成后需要要加上分发机制，将调用号加上。\n最后是2个用户态库函数的实现。\n``` c\nint32_t\nipc_recv(envid_t *from_env_store, void *pg, int *perm_store)\n{\n        int r;\n\n        if (pg == NULL)\n                r = sys_ipc_recv((void *)UTOP);\n        else\n                r = sys_ipc_recv(pg);\n        if (from_env_store != NULL)\n                *from_env_store = r < 0 ? 0 : thisenv->env_ipc_from;\n        if (perm_store != NULL)\n                *perm_store = r < 0 ? 0 : thisenv->env_ipc_perm;\n        if (r < 0)\n                return r;\n        else\n                return thisenv->env_ipc_value;\n}\n\nvoid\nipc_send(envid_t to_env, uint32_t val, void *pg, int perm)\n{\n        int r;\n        void *dstpg;\n\n        dstpg = pg != NULL ? pg : (void *)UTOP;\n        while((r = sys_ipc_try_send(to_env, val, dstpg, perm)) < 0) {\n                if (r != -E_IPC_NOT_RECV)\n                        panic(\"ipc_send: send message error %e\", r);\n                sys_yield();\n        }\n}\n```\n","slug":"lab4_part23","published":1,"updated":"2017-08-26T03:38:21.606Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj6sslhbe001a3gamk7f2y506","content":"<h1 id=\"Lab4-抢占式多进程\"><a href=\"#Lab4-抢占式多进程\" class=\"headerlink\" title=\"Lab4 抢占式多进程\"></a>Lab4 抢占式多进程</h1><h2 id=\"Part2-写入时复制-copy-on-write-fork\"><a href=\"#Part2-写入时复制-copy-on-write-fork\" class=\"headerlink\" title=\"Part2 写入时复制 copy-on-write fork\"></a>Part2 写入时复制 copy-on-write fork</h2><p>如前所述,Unix将fork()系统调用作为进程创建原语.fork()系统调用将调用进程的地址空间（父进程）创建一个新的进程（子进程）.<br>xv6 Unix <code>fork()</code>通过将父进程页面中的所有数据复制到为子进程分配的新页面中,这个机制基本和<code>dumbfork()</code>相同.复制父进程的地址空间到子进程是<code>fork()</code>中代价最大的操作.<br>但是,调用<code>fork()</code>后经常在子进程中跟随<code>exec()</code>调用, 其会用加载新程序到子进程的内存.例如, 这是shell的常用机制.在这种情况下,复制父进程地址空间的时间大部分被浪费,因为子进程在调用<code>exec()</code>之前只使用很少的内存.</p>\n<p>因此,Unix的更高版本利用虚拟内存硬件,允许父子进程<strong>共享</strong>映射到其各自地址空间的内存,直到其中一个进程实际修改这段内存.这种技术被称为<strong>写时复制(copy-on-fork)</strong>.为了做到这一点,调用<code>fork()</code>时,内核上将复制父进程的地址空间映射到进程,而不是复制映射页的内容,同时标记现在共享的页面为只读.当两个进程中的一个尝试写入其中一个共享页面时,该进程将出现页面错误.在这一点上,Unix内核意识到该页面真的是一个“虚拟”或“写时复制”的副本,因此它创建一个新的/私有的故障页面的可写副本.这样,单个页面的内容在实际写入之前实际上并不被复制.<code>fork()</code>的这种优化使随后的<code>exec()</code>代价小很多：在子进程调用<code>exec()</code>之前,可能只需要复制一个页面（它的堆栈的当前页面）.</p>\n<p>在part2,实现一个 Unix <code>fork()</code>,其具有写时复制功能,并作为一个用户空间库例程来.另外,使得单个用户模式程序定义自己的<code>fork()</code>:一个程序想要一个稍微不同的<code>fork()</code>（如总是复制的<code>dumbfork()</code>,或者父子进程共享内存）可以很容易修改而实现.</p>\n<h3 id=\"用户级页面错误处理\"><a href=\"#用户级页面错误处理\" class=\"headerlink\" title=\"用户级页面错误处理\"></a>用户级页面错误处理</h3><p>用户级的写时复制<code>fork()</code>首先需要知道发生在写保护页面上的页面错误,这是首先要实现的.写时复制只是用户级页面故障处理的许多可能用途之一.<br>一般实现方式是:设置一个地址空间,以便页面错误指示出何时需要执行操作.例如,大多数Unix内核最初仅在新进程的堆栈区域中映射单个页面,并且随着进程的堆栈增加而随后分配和映射额外的堆栈页面,并导致尚未映射的堆栈地址发生页面错误,对此典型的Unix内核必须跟踪在进程空间的每个区域中出现页面错误时要执行的操作.又例如,堆栈区域中的故障通常会导致分配和映射物理内存新页面.程序BSS区域的故障通常会分配一个新的页面,以0填充,并在进行映射.<br>以上是内核需要跟踪的信息.不采用传统的Unix方法,而更好地处理用户空间中的每个页面错误,使得bug破坏性更小.这种设计具有额外的优点,允许程序在定义其内存区域方面具有很大的灵活性.<br><a id=\"more\"></a></p>\n<h4 id=\"设置页面错误处理器\"><a href=\"#设置页面错误处理器\" class=\"headerlink\" title=\"设置页面错误处理器\"></a>设置页面错误处理器</h4><p>为了处理自己的页面错误,用户环境将需要向JOS内核注册页面错误处理程序<code>entrypoint</code>.用户环境通过新的<code>sys_env_set_pgfault_upcall</code>系统调用注册其页面错误入口点.增加一个新成员<code>Env</code>结构<code>env_pgfault_upcall</code>来记录这些信息.</p>\n<h4 id=\"练习8\"><a href=\"#练习8\" class=\"headerlink\" title=\"练习8\"></a>练习8</h4><p>问:</p>\n<blockquote>\n<p>实现<code>sys_env_set_pgfault_upcall</code>系统调用.注:因为这个系统调用危险性很高,所以在查找目标环境的环境ID时要启用权限检查,</p>\n</blockquote>\n<p>解:</p>\n<blockquote>\n<p>实现如下:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span></span></div><div class=\"line\"><span class=\"title\">sys_env_set_pgfault_upcall</span><span class=\"params\">(<span class=\"keyword\">envid_t</span> envid, <span class=\"keyword\">void</span> *func)</span></div><div class=\"line\">&#123;</div><div class=\"line\">        <span class=\"keyword\">struct</span> Env *env;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (envid2env(envid, &amp;env, <span class=\"number\">1</span>) &lt; <span class=\"number\">0</span>)</div><div class=\"line\">                <span class=\"keyword\">return</span> -E_BAD_ENV;</div><div class=\"line\">        env-&gt;env_pgfault_upcall = func;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h4 id=\"用户环境的正常-异常堆栈\"><a href=\"#用户环境的正常-异常堆栈\" class=\"headerlink\" title=\"用户环境的正常/异常堆栈\"></a>用户环境的正常/异常堆栈</h4><p>在正常运行期间,用户进程运行在用户栈上,栈顶寄存器<code>ESP</code>指向<code>USTACKTOP</code>处,堆栈数据位于<code>USTACKTOP-PGSIZE 与USTACKTOP-1</code>之间的页.当在用户模式发生页面错误时,内核将在专门处理页面错误的用户异常栈上重新启动进程. 异常栈正是为了上面设置的异常处理例程设立的.当异常发生时,而且该用户进程注册了该异常的处理例程,那么就会转到异常栈上,运行异常处理例程.<br>到目前位置出现了三个栈：</p>\n<ul>\n<li>内核态系统栈 [KSTACKTOP, KSTACKTOP-KSTKSIZE]</li>\n<li>用户态错误处理栈 [UXSTACKTOP, UXSTACKTOP - PGSIZE]</li>\n<li>用户态运行栈 [USTACKTOP, UTEXT]</li>\n</ul>\n<p>内核态系统栈是运行内核相关程序的栈,在有中断被触发之后,CPU会将栈自动切换到内核栈上来,而内核栈的设置是在<code>kern/trap.c</code>的<code>trap_init_percpu()</code>中设置的.<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">trap_init_percpu</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></div><div class=\"line\">&#123;</div><div class=\"line\">        <span class=\"comment\">// Setup a TSS so that we get the right stack</span></div><div class=\"line\">        <span class=\"comment\">// when we trap to the kernel.</span></div><div class=\"line\">        thiscpu-&gt;cpu_ts.ts_esp0 = KSTACKTOP - cpunum() * (KSTKGAP + KSTKSIZE);</div><div class=\"line\">        thiscpu-&gt;cpu_ts.ts_ss0 = GD_KD;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Initialize the TSS slot of the gdt.</span></div><div class=\"line\">        gdt[(GD_TSS0 &gt;&gt; <span class=\"number\">3</span>) + cpunum()] = SEG16(STS_T32A, (<span class=\"keyword\">uint32_t</span>) (&amp;thiscpu-&gt;cpu_ts),</div><div class=\"line\">                                        <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> Taskstate) - <span class=\"number\">1</span>, <span class=\"number\">0</span>);</div><div class=\"line\">        gdt[(GD_TSS0 &gt;&gt; <span class=\"number\">3</span>) + cpunum()].sd_s = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Load the TSS selector (like other segment selectors, the</span></div><div class=\"line\">        <span class=\"comment\">// bottom three bits are special; we leave them 0)</span></div><div class=\"line\">        ltr(GD_TSS0 + <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> Segdesc) * cpunum());</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Load the IDT</span></div><div class=\"line\">        lidt(&amp;idt_pd);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>而用户态错误处理栈是用户定义注册了自己的中断处理程序之后,相应的例程运行时的栈.整个过程如下：</p>\n<blockquote>\n<p>首先陷入到内核,栈位置从用户运行栈切换到内核栈,进入到<code>trap</code>中,进行中断处理分发,进入到<code>page_fault_handler()</code>.当确认是用户程序触发的<code>page fault</code>的时候(如果是内核触发的,会直接<code>panic</code>),为其在用户错误栈里分配一个<code>UTrapframe</code>的大小.把栈切换到用户错误栈,运行响应的用户中断处理程序中断处理程序可能会触发另外一个同类型的中断,这个时候就会产生递归式的中断嵌套处理.处理完成之后,返回到用户运行栈.</p>\n</blockquote>\n<h4 id=\"调用用户页面故障处理程序\"><a href=\"#调用用户页面故障处理程序\" class=\"headerlink\" title=\"调用用户页面故障处理程序\"></a>调用用户页面故障处理程序</h4><p>将用户自己定义的页面故障处理进程当作是一次函数调用看待,当错误发生的时候,调用一个函数,但实际上还是当前这个进程,并没有发生变化.所以当切换到异常栈的时候,依然运行当前进程,但只是运行的是中断处理函数,所以说此时的栈指针发生了变化,而且程序计数器<code>eip</code>也发生了变化,同时还需要知道的是引发错误的地址在哪.这些都是要在切换到异常栈的时候需要传递的信息.和之前从用户栈切换到内核栈一样,这里是通过在栈上构造结构体,传递指针完成的.<br>在<code>inc / trap.h</code>新定义了一个类似<code>struct Trapframe</code>结构体<code>struct UTrapframe</code>用来记录出现页面错误时候的信息：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> UTrapframe &#123;</div><div class=\"line\">        <span class=\"comment\">/* information about the fault */</span></div><div class=\"line\">        <span class=\"keyword\">uint32_t</span> utf_fault_va;  <span class=\"comment\">/* va for T_PGFLT, 0 otherwise */</span></div><div class=\"line\">        <span class=\"keyword\">uint32_t</span> utf_err;</div><div class=\"line\">        <span class=\"comment\">/* trap-time return state */</span></div><div class=\"line\">        <span class=\"keyword\">struct</span> PushRegs utf_regs;</div><div class=\"line\">        <span class=\"keyword\">uintptr_t</span> utf_eip;</div><div class=\"line\">        <span class=\"keyword\">uint32_t</span> utf_eflags;</div><div class=\"line\">        <span class=\"comment\">/* the trap-time stack to return to */</span></div><div class=\"line\">        <span class=\"keyword\">uintptr_t</span> utf_esp;</div><div class=\"line\">&#125; __attribute__((packed));</div></pre></td></tr></table></figure></p>\n<p>相比于<code>Trapframe</code>,这里多了<code>utf_fault_va</code>,因为要记录触发错误的内存地址,同时还少了<code>es,ds,ss</code>等段记录.因为从用户态栈切换到异常栈,或者从异常栈再切换回去,实际上都是一个用户进程,所以不涉及到段的切换,不用记录.在实际使用中,<code>Trapframe</code>是作为记录进程状态的结构体存在的,也作为函数参数进行传递；而<code>UTrapframe</code>只在处理用户定义的异常时用到.<br>整体上讲,当正常执行过程中发生了页面错误,那么栈的切换是<br><strong>用户运行栈—&gt;内核栈—&gt;异常栈</strong><br>而如果在异常处理程序中发生了页面错误,那么栈的切换是<br><strong>异常栈—&gt;内核栈—&gt;异常栈</strong></p>\n<h4 id=\"练习9\"><a href=\"#练习9\" class=\"headerlink\" title=\"练习9\"></a>练习9</h4><p>问:</p>\n<blockquote>\n<p>实现<code>kern/trap.c</code>中<code>page_fault_handler</code>函数, 把页面错误分发到对应的用户态异常处理函数.</p>\n</blockquote>\n<p>解:</p>\n<blockquote>\n<p>如果当前已经在用户错误栈上了,那么需要留出4个字节,否则不需要,具体和跳转机制有关系.简单说就是在当前的异常栈栈顶的位置向下留出保存<code>UTrapframe</code>的空间,然后将<code>tf</code>中的参数复制过来.修改当前进程的程序计数器和栈指针,然后重启这个进程,此时就会在用户错误栈上运行中断处理程序了.中断处理程序运行结束之后,需要再回到用户运行栈中,这是异常处理程序需要做的.<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">page_fault_handler</span><span class=\"params\">(<span class=\"keyword\">struct</span> Trapframe *tf)</span></div><div class=\"line\">&#123;</div><div class=\"line\">        <span class=\"keyword\">uint32_t</span> fault_va;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Read processor's CR2 register to find the faulting address</span></div><div class=\"line\">        fault_va = rcr2();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Handle kernel-mode page faults.</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (tf-&gt;tf_cs == GD_KT)</div><div class=\"line\">                panic(<span class=\"string\">\"page_fault in kernel mode, fault address: %d\\n\"</span>, fault_va);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">struct</span> UTrapframe *utf;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (curenv-&gt;env_pgfault_upcall) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (UXSTACKTOP - PGSIZE &lt;= tf-&gt;tf_esp &amp;&amp; tf-&gt;tf_esp &lt;= UXSTACKTOP - <span class=\"number\">1</span>)</div><div class=\"line\">                        utf = (<span class=\"keyword\">struct</span> UTrapframe *)(tf-&gt;tf_esp - <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> UTrapframe) - <span class=\"number\">4</span>);</div><div class=\"line\">                <span class=\"keyword\">else</span></div><div class=\"line\">                        utf = (<span class=\"keyword\">struct</span> UTrapframe *)(UXSTACKTOP - <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> UTrapframe));</div><div class=\"line\">                user_mem_assert(curenv, (<span class=\"keyword\">void</span> *)utf, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> UTrapframe), PTE_U | PTE_W);</div><div class=\"line\"></div><div class=\"line\">                utf-&gt;utf_fault_va = fault_va;</div><div class=\"line\">                utf-&gt;utf_err = tf-&gt;tf_trapno;</div><div class=\"line\">                utf-&gt;utf_eip = tf-&gt;tf_eip;</div><div class=\"line\">                utf-&gt;utf_eflags = tf-&gt;tf_eflags;</div><div class=\"line\">                utf-&gt;utf_esp = tf-&gt;tf_esp;</div><div class=\"line\">                utf-&gt;utf_regs = tf-&gt;tf_regs;</div><div class=\"line\">                tf-&gt;tf_eip = (<span class=\"keyword\">uint32_t</span>)curenv-&gt;env_pgfault_upcall;</div><div class=\"line\">                tf-&gt;tf_esp = (<span class=\"keyword\">uint32_t</span>)utf;</div><div class=\"line\">                env_run(curenv);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Destroy the environment that caused the fault.</span></div><div class=\"line\">        cprintf(<span class=\"string\">\"[%08x] user fault va %08x ip %08x\\n\"</span>,</div><div class=\"line\">                curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);</div><div class=\"line\">        print_trapframe(tf);</div><div class=\"line\">        env_destroy(curenv);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h4 id=\"用户模式页面错误的入口\"><a href=\"#用户模式页面错误的入口\" class=\"headerlink\" title=\"用户模式页面错误的入口\"></a>用户模式页面错误的入口</h4><p>接下来需要实现汇编程序,该程序将负责调用页面错误处理程序,并在原始故障指令下继续执行,其将调用处理程序<code>sys_env_set_pgfault_upcall()</code>向内核注册.</p>\n<h4 id=\"练习10\"><a href=\"#练习10\" class=\"headerlink\" title=\"练习10\"></a>练习10</h4><p>问:</p>\n<blockquote>\n<p>实现在<code>lib/pfentry.S</code>中的<code>_pgfault_upcall</code>调用.</p>\n</blockquote>\n<p>解:</p>\n<blockquote>\n<p><code>_pgfault_upcall</code>是所有用户页错误处理程序的入口,在这里调用用户自定义的处理程序,并在处理完成后,从异常栈中保存的<code>UTrapframe</code>结构体中恢复相应信息,然后跳回到发生错误之前的指令,恢复原来的进程运行.具体过程如下:<br>调用<code>_pgfault_handler</code>返回时的操作,此时的异常栈结构如下：<br><img src=\"/images/lab4/UStack1.png\" alt=\"UStack1\"><br>这里<code>trap-time esp</code>上的空间有1个4字节的保留空间,是做为中断递归的情形. 然后将栈中的<code>trap-time esp</code>取出减去4,再存回栈中.此时如果是中断递归中,<code>esp-4</code>即是保留的4字节地址；如果不是则是用户运行栈的栈顶. 再将原来出错程序的<code>trap-time eip</code>取出放入保留的4字节,以便后来恢复运行.此时的异常栈布局如下：<br><img src=\"/images/lab4/UStack2.png\" alt=\"UStack2\"><br>紧接着恢复通用寄存器和EFLAG标志寄存器,此时的异常栈结构如下：<br><img src=\"/images/lab4/UStack3.png\" alt=\"UStack3\"><br>最后<code>pop esp</code>切换为原来出错程序的运行栈,最后使用<code>ret</code>返回出错程序.<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">.text</div><div class=\"line\">.globl _pgfault_upcall</div><div class=\"line\">_pgfault_upcall:</div><div class=\"line\">        <span class=\"comment\">// Call the C page fault handler.</span></div><div class=\"line\">        pushl %esp                      <span class=\"comment\">// function argument: pointer to UTF</span></div><div class=\"line\">        movl _pgfault_handler, %eax</div><div class=\"line\">        call *%eax</div><div class=\"line\">        addl $<span class=\"number\">4</span>, %esp                   <span class=\"comment\">// pop function argument</span></div><div class=\"line\"></div><div class=\"line\">        movl <span class=\"number\">48</span>(%esp), %ebp</div><div class=\"line\">        subl $<span class=\"number\">4</span>, %ebp</div><div class=\"line\">        movl %ebp, <span class=\"number\">48</span>(%esp)</div><div class=\"line\">        movl <span class=\"number\">40</span>(%esp), %eax</div><div class=\"line\">        movl %eax, (%ebp)</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Restore the trap-time registers.  After you do this, you can no longer modify any general-purpose registers.</span></div><div class=\"line\">        addl $<span class=\"number\">8</span>, %esp</div><div class=\"line\">        popal</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Restore eflags from the stack.  After you do this, you can</span></div><div class=\"line\">        <span class=\"comment\">// no longer use arithmetic operations or anything else that</span></div><div class=\"line\">        <span class=\"comment\">// modifies eflags.</span></div><div class=\"line\">        addl $<span class=\"number\">4</span>, %esp</div><div class=\"line\">        popfl</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Switch back to the adjusted trap-time stack.</span></div><div class=\"line\"></div><div class=\"line\">        popl %esp</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Return to re-execute the instruction that faulted.</span></div><div class=\"line\">        ret</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h4 id=\"练习11\"><a href=\"#练习11\" class=\"headerlink\" title=\"练习11\"></a>练习11</h4><p>问:</p>\n<blockquote>\n<p>在<code>lib / pgfault.c</code>中完成<code>set_pgfault_handler()</code>,即实现用户级页面故障处理机制的C语言库函数.</p>\n</blockquote>\n<p>解:</p>\n<blockquote>\n<p>进程在运行前注册自己的页错误处理程序,重点是申请用户异常栈空间,最后添加上系统调用号.<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">void</div><div class=\"line\">set_pgfault_handler(void (*handler)(struct UTrapframe *utf))</div><div class=\"line\">&#123;</div><div class=\"line\">        int r;</div><div class=\"line\"></div><div class=\"line\">        if (_pgfault_handler == 0) &#123;</div><div class=\"line\">                // First time through!</div><div class=\"line\">                if ((r = sys_page_alloc(thisenv-&gt;env_id, (void *)(UXSTACKTOP - PGSIZE), PTE_P | PTE_W | PTE_U)) &lt; 0)</div><div class=\"line\">                        panic(\"set_pgfault_handler: %e\", r);</div><div class=\"line\">                sys_env_set_pgfault_upcall(thisenv-&gt;env_id, _pgfault_upcall);</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Save handler pointer for assembly to call.</div><div class=\"line\">        _pgfault_handler = handler;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"实现写入时复制-fork\"><a href=\"#实现写入时复制-fork\" class=\"headerlink\" title=\"实现写入时复制 fork\"></a>实现写入时复制 fork</h3><p>接下来就是最重要的部分：实现<code>copy-on-write fork</code>.<br>与之前的<code>dumbfork()</code>不同,<code>fork()</code>出一个子进程之后,首先要进行的就是将父进程的页表的全部映射拷贝到子进程的地址空间中去.这个时候物理页会被两个进程同时映射,但是在写的时候是应该隔离的.采取的方法是在子进程映射的时候,将父进程空间中所有可以写的页表的部分全部标记为可读且COW(copy-on-write).而当父进程或者子进程任意一个发生了写的时候,因为页表现在都是不可写的,所以会触发异常,进入到我们设定的page fault处理例程,当检测到是对COW页的写操作的情况下,就可以将要写入的页的内容全部拷贝一份,重新映射.</p>\n<h4 id=\"练习12\"><a href=\"#练习12\" class=\"headerlink\" title=\"练习12\"></a>练习12</h4><p>问:</p>\n<blockquote>\n<p>实现在<code>lib/fork.c</code>的<code>fork,duppage和pgfault</code>.</p>\n</blockquote>\n<p>解:</p>\n<blockquote>\n<p>首先需要为父进程设定错误处理例程.调用<code>set_pgfault_handler()</code>是因为当前并不知道父进程是否已经建立了异常栈,没有的话就会建立一个,而<code>sys_env_set_pgfault_upcall</code>则不会建立异常栈.<br>接着调用<code>sys_exofork</code>准备一个和父进程状态相同的子进程,状态暂时设置为<code>ENV_NOT_RUNNABLE</code>.然后进行拷贝映射的部分,在当前进程的页表中所有标记为<code>PTE_P</code>的页的映射都需要拷贝到子进程空间中去.但是有一个例外,是必须要新申请一页来拷贝内容的,就是用户异常栈.因为copy-on-write就是依靠用户异常栈实现的,所以说这个栈要在fork完成的时候每个进程都有一个,要硬拷贝过来.<br>主要流程就是：</p>\n<ol>\n<li>申请新的物理页,映射到子进程的(UXSTACKTOP-PGSIZE)位置上去.</li>\n<li>父进程的PFTEMP位置也映射到子进程新申请的物理页上去,这样父进程也可以访问这一页.</li>\n<li>在父进程空间中,将用户错误栈全部拷贝到子进程的错误栈上去,也就是刚刚申请的那一页.</li>\n<li>然后父进程解除对PFTEMP的映射.</li>\n<li>最后把子进程的状态设置为可运行</li>\n</ol>\n</blockquote>\n<p>具体实现如下:<br>首先是<code>pgfault</code>处理<code>page fault</code>时的写时复制.<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">pgfault</span><span class=\"params\">(<span class=\"keyword\">struct</span> UTrapframe *utf)</span></div><div class=\"line\">&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> r;</div><div class=\"line\">        <span class=\"keyword\">void</span> *addr = (<span class=\"keyword\">void</span> *) utf-&gt;utf_fault_va;</div><div class=\"line\">        <span class=\"keyword\">uint32_t</span> err = utf-&gt;utf_err;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> ((err &amp; FEC_WR) == <span class=\"number\">0</span> || (uvpt[PGNUM(addr)] &amp; PTE_COW) == <span class=\"number\">0</span>)</div><div class=\"line\">                panic(<span class=\"string\">\"pgfault: it's not writable or attempt to access a non-cow page!\"</span>);</div><div class=\"line\">        <span class=\"comment\">// Allocate a new page, map it at a temporary location (PFTEMP),</span></div><div class=\"line\">        <span class=\"comment\">// copy the data from the old page to the new page, then move the new</span></div><div class=\"line\">        <span class=\"comment\">// page to the old page's address.</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">envid_t</span> envid = sys_getenvid();</div><div class=\"line\">        <span class=\"keyword\">if</span> ((r = sys_page_alloc(envid, (<span class=\"keyword\">void</span> *)PFTEMP, PTE_P | PTE_W | PTE_U)) &lt; <span class=\"number\">0</span>)</div><div class=\"line\">                panic(<span class=\"string\">\"pgfault: page allocation failed %e\"</span>, r);</div><div class=\"line\"></div><div class=\"line\">        addr = ROUNDDOWN(addr, PGSIZE);</div><div class=\"line\">        memmove(PFTEMP, addr, PGSIZE);</div><div class=\"line\">        <span class=\"keyword\">if</span> ((r = sys_page_unmap(envid, addr)) &lt; <span class=\"number\">0</span>)</div><div class=\"line\">                panic(<span class=\"string\">\"pgfault: page unmap failed %e\"</span>, r);</div><div class=\"line\">        <span class=\"keyword\">if</span> ((r = sys_page_map(envid, PFTEMP, envid, addr, PTE_P | PTE_W |PTE_U)) &lt; <span class=\"number\">0</span>)</div><div class=\"line\">                panic(<span class=\"string\">\"pgfault: page map failed %e\"</span>, r);</div><div class=\"line\">        <span class=\"keyword\">if</span> ((r = sys_page_unmap(envid, PFTEMP)) &lt; <span class=\"number\">0</span>)</div><div class=\"line\">                panic(<span class=\"string\">\"pgfault: page unmap failed %e\"</span>, r);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在<code>pgfault()</code>中先判断是否页错误是由写时拷贝造成的,如果不是则<code>panic</code>.借用了一个一定不会被用到的位置<code>PFTEMP</code>,专门用来发生<code>page fault</code>的时候拷贝内容用的.先解除<code>addr</code>原先的页映射关系,然后将<code>addr</code>映射到<code>PFTEMP</code>映射的页,最后解除<code>PFTEMP</code>的页映射关系.<br>接下来是<code>duppage</code>函数,负责进行COW方式的页复制,将当前进程的第pn页对应的物理页的映射到<code>envid</code>的第pn页上去,同时将这一页都标记为COW.<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span></span></div><div class=\"line\"><span class=\"title\">duppage</span><span class=\"params\">(<span class=\"keyword\">envid_t</span> envid, <span class=\"keyword\">unsigned</span> pn)</span></div><div class=\"line\">&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> r;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">void</span> *addr;</div><div class=\"line\">        <span class=\"keyword\">pte_t</span> pte;</div><div class=\"line\">        <span class=\"keyword\">int</span> perm;</div><div class=\"line\"></div><div class=\"line\">        addr = (<span class=\"keyword\">void</span> *)((<span class=\"keyword\">uint32_t</span>)pn * PGSIZE);</div><div class=\"line\">        pte = uvpt[pn];</div><div class=\"line\">        perm = PTE_P | PTE_U;</div><div class=\"line\">        <span class=\"keyword\">if</span> ((pte &amp; PTE_W) || (pte &amp; PTE_COW))</div><div class=\"line\">                perm |= PTE_COW;</div><div class=\"line\">        <span class=\"keyword\">if</span> ((r = sys_page_map(thisenv-&gt;env_id, addr, envid, addr, perm)) &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                panic(<span class=\"string\">\"duppage: page remapping failed %e\"</span>, r);</div><div class=\"line\">                <span class=\"keyword\">return</span> r;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (perm &amp; PTE_COW) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> ((r = sys_page_map(thisenv-&gt;env_id, addr, thisenv-&gt;env_id, addr, perm)) &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                        panic(<span class=\"string\">\"duppage: page remapping failed %e\"</span>, r);</div><div class=\"line\">                        <span class=\"keyword\">return</span> r;</div><div class=\"line\">                &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>最后是fork函数,将页映射拷贝过去,这里需要考虑的地址范围就是<code>从UTEXT到UXSTACKTOP</code>为止,而在此之上的范围因为都是相同的,在<code>env_alloc</code>的时候已经设置好了.<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">envid_t</span></div><div class=\"line\">fork(<span class=\"keyword\">void</span>)</div><div class=\"line\">&#123;</div><div class=\"line\">        <span class=\"keyword\">uint32_t</span> addr;</div><div class=\"line\">        <span class=\"keyword\">int</span> i, j, pn, r;</div><div class=\"line\">        <span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> _pgfault_upcall(<span class=\"keyword\">void</span>);</div><div class=\"line\">        <span class=\"keyword\">if</span> ((envid = sys_exofork()) &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                panic(<span class=\"string\">\"sys_exofork failed: %e\"</span>, envid);</div><div class=\"line\">                <span class=\"keyword\">return</span> envid;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (envid == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                thisenv = &amp;envs[ENVX(sys_getenvid())];</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (i = PDX(UTEXT); i &lt; PDX(UXSTACKTOP); i++) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (uvpd[i] &amp; PTE_P) &#123;</div><div class=\"line\">                        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; NPTENTRIES; j++) &#123;</div><div class=\"line\">                                pn = PGNUM(PGADDR(i, j, <span class=\"number\">0</span>));</div><div class=\"line\">                                <span class=\"keyword\">if</span> (pn == PGNUM(UXSTACKTOP - PGSIZE))</div><div class=\"line\">                                        <span class=\"keyword\">break</span>;</div><div class=\"line\">                                <span class=\"keyword\">if</span> (uvpt[pn] &amp; PTE_P)</div><div class=\"line\">                                        duppage(envid, pn);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> ((r = sys_page_alloc(envid, (<span class=\"keyword\">void</span> *)(UXSTACKTOP - PGSIZE), PTE_P | PTE_U | PTE_W)) &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                panic(<span class=\"string\">\"fork: page alloc failed %e\"</span>, r);</div><div class=\"line\">                <span class=\"keyword\">return</span> r;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> ((r = sys_page_map(envid, (<span class=\"keyword\">void</span> *)(UXSTACKTOP - PGSIZE), thisenv-&gt;env_id, PFTEMP, PTE_P | PTE_U | PTE_W)) &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                panic(<span class=\"string\">\"fork: page map failed %e\"</span>, r);</div><div class=\"line\">                <span class=\"keyword\">return</span> r;</div><div class=\"line\">        &#125;</div><div class=\"line\">        memmove((<span class=\"keyword\">void</span> *)(UXSTACKTOP - PGSIZE), PFTEMP, PGSIZE);</div><div class=\"line\">        <span class=\"keyword\">if</span> ((r = sys_page_unmap(thisenv-&gt;env_id, PFTEMP)) &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                panic(<span class=\"string\">\"fork: page unmap failed %e\"</span>, r);</div><div class=\"line\">                <span class=\"keyword\">return</span> r;</div><div class=\"line\">        &#125;</div><div class=\"line\">        sys_env_set_pgfault_upcall(envid, _pgfault_upcall);</div><div class=\"line\">        <span class=\"keyword\">if</span> ((r = sys_env_set_status(envid, ENV_RUNNABLE)) &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                panic(<span class=\"string\">\"fork: set child env status failed %e\"</span>, r);</div><div class=\"line\">                <span class=\"keyword\">return</span> r;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> envid;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"Part3-抢占式调度和进程间通信\"><a href=\"#Part3-抢占式调度和进程间通信\" class=\"headerlink\" title=\"Part3 抢占式调度和进程间通信\"></a>Part3 抢占式调度和进程间通信</h2><p>Lab4的最后一部分就是实现抢占式调度和进程间通信。</p>\n<h3 id=\"时钟中断和抢占\"><a href=\"#时钟中断和抢占\" class=\"headerlink\" title=\"时钟中断和抢占\"></a>时钟中断和抢占</h3><p>先前的调度是进程资源放弃CPU，但是实际中没有进程会这样做的，而为了不让某一进程耗尽CPU资源，需要抢占式调度，也就需要硬件定时。但是外部硬件定时在Bootloader的时候就关闭了，至今都没有开启。而JOS采取的策略是，在内核中的时候，外部中断是始终关闭的，在用户态的时候，需要开启中断。</p>\n<h4 id=\"中断原则\"><a href=\"#中断原则\" class=\"headerlink\" title=\"中断原则\"></a>中断原则</h4><p>外部中断称为IRQ。一共有16个可能的IRQ，编号为0到15.从IRQ号到IDT条目的映射不是固定的, <code>picirq.c</code>中的<code>pic_init</code>将IRQ 0-15映射到到IDT的<code>[IRQ_OFFSET,IRQ_OFFSET+15]</code>.<br>在<code>inc / trap.h</code>中， <code>IRQ_OFFSET</code>定义为十进制数32.因此IDT条目32-47对应于IRQ 0-15。例如，时钟中断是IRQ 0.因此，<code>IDT[IRQ_OFFSET + 0]</code>（即<code>IDT[32]</code>）包含内核中时钟的中断处理程序例程的地址。选择正确的<code>IRQ_OFFSET</code>使得设备中断不与处理器异常重叠,可以避免异常处理的混乱.<br>在JOS中，与xv6 Unix相比，做了一个关键的简化。在内核中，外部设备中断始终被禁用（和xv6一样，在用户空间中启用）。外部中断由寄存器的<code>FL_IF标志位%eflags</code>控制（见<code>inc/mmu.h</code>）。当该位置1时，外部中断被使能。虽然可以通过几种方式修改该位，但由于简化，可以通过在<code>%eflags</code>进入和离开用户模式时保存和恢复寄存器的过程来处理该位。必须确保<code>FL_IF</code>标志在用户环境中运行，以便当中断到达时，它将被传递到处理器并由中断代码处理。否则，中断会被屏蔽或忽略，直到重新启用中断。Lab1中用<code>bootloaded</code>的第一个指令屏蔽了中断，到目前为止还没开启过.</p>\n<h4 id=\"练习12-1\"><a href=\"#练习12-1\" class=\"headerlink\" title=\"练习12\"></a>练习12</h4><p>问:</p>\n<blockquote>\n<p>修改<code>kern/trapentry.S</code>和<code>kern/trap.c</code>来初始化<code>IDT中IRQs0-15</code>的入口和处理函数。然后修改<code>env_alloc</code>函数来确保进程在用户态运行时中断是打开的。</p>\n</blockquote>\n<p>解:</p>\n<blockquote>\n<p>模仿原先设置的默认中断向量即可，在<code>kern/trapentry.S</code>中定义<code>IRQ0-15</code>的处理例程。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">TRAPHANDLER(irq0_entry, IRQ_OFFSET + <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">TRAPHANDLER(irq1_entry, IRQ_OFFSET + <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">TRAPHANDLER(irq2_entry, IRQ_OFFSET + <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">TRAPHANDLER(irq3_entry, IRQ_OFFSET + <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">TRAPHANDLER(irq4_entry, IRQ_OFFSET + <span class=\"number\">4</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">TRAPHANDLER(irq5_entry, IRQ_OFFSET + <span class=\"number\">5</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">TRAPHANDLER(irq6_entry, IRQ_OFFSET + <span class=\"number\">6</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">TRAPHANDLER(irq7_entry, IRQ_OFFSET + <span class=\"number\">7</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">TRAPHANDLER(irq8_entry, IRQ_OFFSET + <span class=\"number\">8</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">TRAPHANDLER(irq9_entry, IRQ_OFFSET + <span class=\"number\">9</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">TRAPHANDLER(irq10_entry, IRQ_OFFSET + <span class=\"number\">10</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">TRAPHANDLER(irq11_entry, IRQ_OFFSET + <span class=\"number\">11</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">TRAPHANDLER(irq12_entry, IRQ_OFFSET + <span class=\"number\">12</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">TRAPHANDLER(irq13_entry, IRQ_OFFSET + <span class=\"number\">13</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">TRAPHANDLER(irq14_entry, IRQ_OFFSET + <span class=\"number\">14</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">TRAPHANDLER(irq15_entry, IRQ_OFFSET + <span class=\"number\">15</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>然后在IDT中注册，修改<code>trap_init</code>，由于先前已经实现简化，故此无需做处理。<br>最后在<code>env_alloc</code>函数中打开中断。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// kern/env_alloc.c</span></div><div class=\"line\"><span class=\"comment\">// Also clear the IPC receiving flag.</span></div><div class=\"line\">e-&gt;env_ipc_recving = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Set FL_IF so that user environments run with interrupts enabled</span></div><div class=\"line\">e-&gt;env_tf.tf_eflags |= FL_IF;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// commit the allocation</span></div><div class=\"line\">env_free_list = e-&gt;env_link;</div><div class=\"line\">*newenv_store = e;</div></pre></td></tr></table></figure></p>\n<h4 id=\"处理时钟中断\"><a href=\"#处理时钟中断\" class=\"headerlink\" title=\"处理时钟中断\"></a>处理时钟中断</h4><p>现在虽然中断使能已经打开，在用户态进程运行的时候，外部中断会产生并进入内核，但是现在还没有能处理这类中断。所以需要修改<code>trap_dispatch</code>，在发生外部定时中断的时候，调用调度器，调度另外一个可运行的进程。</p>\n<h4 id=\"练习14\"><a href=\"#练习14\" class=\"headerlink\" title=\"练习14\"></a>练习14</h4><p>问:</p>\n<blockquote>\n<p>修改<code>trap_dispatch</code>h函数，当发生时钟中断时调用<code>sched_yield</code>函数来调度下一个进程。</p>\n</blockquote>\n<p>解:</p>\n<blockquote>\n<p>添加对应函数即可<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// kern/trap.c</div><div class=\"line\"></div><div class=\"line\">// Handle clock interrupts. Don&apos;t forget to acknowledge the</div><div class=\"line\">// interrupt using lapic_eoi() before calling the scheduler!</div><div class=\"line\">if (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_TIMER) &#123;</div><div class=\"line\">                lapic_eoi();</div><div class=\"line\">                sched_yield();</div><div class=\"line\">                return;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h4 id=\"进程间通信-IPC\"><a href=\"#进程间通信-IPC\" class=\"headerlink\" title=\"进程间通信(IPC)\"></a>进程间通信(IPC)</h4><p>IPC是计算机系统中非常重要的一部分。在JOS实现IPC的方式是当两个进程需要通信的话，一方要发起<code>recv</code>，然后阻塞，直到有一个进程调用<code>send</code>向正在接受的进程发送了信息，阻塞的进程才会被唤醒。在JOS中，可以允许传递两种信息，一是一个32位整数，另外一个就是传递页的映射，在这个过程中，接收方和发送方将同时映射到一个相同的物理页，此时也就实现了内存共享。最后将这两个功能实现为一个系统调用。\n　　</p>\n<h4 id=\"实现IPC\"><a href=\"#实现IPC\" class=\"headerlink\" title=\"实现IPC\"></a>实现IPC</h4><p>在JOS的IPC实现机制中，修改<code>Env</code>结构体如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> Env &#123;</div><div class=\"line\">        <span class=\"keyword\">struct</span> Trapframe env_tf;        <span class=\"comment\">// Saved registers</span></div><div class=\"line\">        <span class=\"keyword\">struct</span> Env *env_link;           <span class=\"comment\">// Next free Env</span></div><div class=\"line\">        <span class=\"keyword\">envid_t</span> env_id;                 <span class=\"comment\">// Unique environment identifier</span></div><div class=\"line\">        <span class=\"keyword\">envid_t</span> env_parent_id;          <span class=\"comment\">// env_id of this env's parent</span></div><div class=\"line\">        <span class=\"keyword\">enum</span> EnvType env_type;          <span class=\"comment\">// Indicates special system environments</span></div><div class=\"line\">        <span class=\"keyword\">unsigned</span> env_status;            <span class=\"comment\">// Status of the environment</span></div><div class=\"line\">        <span class=\"keyword\">uint32_t</span> env_runs;              <span class=\"comment\">// Number of times environment has run</span></div><div class=\"line\">        <span class=\"keyword\">int</span> env_cpunum;                 <span class=\"comment\">// The CPU that the env is running on</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Address space</span></div><div class=\"line\">        <span class=\"keyword\">pde_t</span> *env_pgdir;               <span class=\"comment\">// Kernel virtual address of page dir</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Exception handling</span></div><div class=\"line\">        <span class=\"keyword\">void</span> *env_pgfault_upcall;       <span class=\"comment\">// Page fault upcall entry point</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Lab 4 IPC</span></div><div class=\"line\">        <span class=\"keyword\">bool</span> env_ipc_recving;           <span class=\"comment\">// Env is blocked receiving</span></div><div class=\"line\">        <span class=\"keyword\">void</span> *env_ipc_dstva;            <span class=\"comment\">// VA at which to map received page</span></div><div class=\"line\">        <span class=\"keyword\">uint32_t</span> env_ipc_value;         <span class=\"comment\">// Data value sent to us</span></div><div class=\"line\">        <span class=\"keyword\">envid_t</span> env_ipc_from;           <span class=\"comment\">// envid of the sender</span></div><div class=\"line\">        <span class=\"keyword\">int</span> env_ipc_perm;               <span class=\"comment\">// Perm of page mapping received</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>其中增加了5个成员：</p>\n<ul>\n<li>env_ipc_recving：<br>当进程使用env_ipc_recv函数等待信息时，会将这个成员设置为1，然后堵塞等待；当一个进程向它发消息解除堵塞后，发送进程将此成员修改为0。</li>\n<li>env_ipc_dstva：<br>如果进程要接受消息并且是传送页，保存页映射的地址，且该地址&lt;=UTOP。</li>\n<li>env_ipc_value：<br>若等待消息的进程接收到消息，发送方将接收方此成员设置为消息值。</li>\n<li>env_ipc_from：<br>发送方负责设置该成员为自己的envid号。</li>\n<li>env_ipc_perm：<br>如果进程要接收消息并且传送页，那么发送方发送页之后将传送的页权限赋给这个成员</li>\n</ul>\n<h4 id=\"练习15\"><a href=\"#练习15\" class=\"headerlink\" title=\"练习15\"></a>练习15</h4><p>问:</p>\n<blockquote>\n<p>实现在<code>kern/syscall.c</code>中的<code>sys_ipc_recv和sys_ipc_try_send</code>函数。最后实现用户态的<code>ipc_recv和ipc_send</code>。</p>\n</blockquote>\n<p>解:</p>\n<blockquote>\n<p>首先是<code>sys_ipc_recv</code>函数，其功能是当一个进程试图去接收信息的时候，应该将自己标记为正在接收信息，而且为了不浪费CPU资源，应该同时标记自己为<code>ENV_NOT_RUNNABLE</code>，只有当有进程向自己发了信息之后，才会重新恢复可运行。最后将自己标记为不可运行之后，调用调度器运行其他进程。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span></span></div><div class=\"line\"><span class=\"title\">sys_ipc_recv</span><span class=\"params\">(<span class=\"keyword\">void</span> *dstva)</span></div><div class=\"line\">&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (dstva &lt; (<span class=\"keyword\">void</span> *)UTOP &amp;&amp; PGOFF(dstva))</div><div class=\"line\">                <span class=\"keyword\">return</span> -E_INVAL;</div><div class=\"line\">        curenv-&gt;env_ipc_recving = <span class=\"literal\">true</span>;</div><div class=\"line\">        curenv-&gt;env_ipc_dstva = dstva;</div><div class=\"line\">        curenv-&gt;env_status = ENV_NOT_RUNNABLE;</div><div class=\"line\">        curenv-&gt;env_ipc_from = <span class=\"number\">0</span>;</div><div class=\"line\">        sched_yield();</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>接着是<code>sys_ipc_try_send</code>函数，其实现相对来说麻烦很多，因为有很多的检测项，包括权限是否符合要求，要传送的页有没有，能不能将这一页映射到对方页表中去等等。如果<code>srcva</code>是在<code>UTOP</code>之下，那么说明是要共享内存，那就首先要在发送方的页表中找到<code>srcva</code>对应的页表项，然后在接收方给定的虚地址处插入这个页表项。接收完成之后，重新将当前进程设置为可运行，同时把<code>env_ipc_recving</code>设置为0，以防止其他的进程再发送，覆盖掉当前的内容。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span></span></div><div class=\"line\"><span class=\"title\">sys_ipc_try_send</span><span class=\"params\">(<span class=\"keyword\">envid_t</span> envid, <span class=\"keyword\">uint32_t</span> value, <span class=\"keyword\">void</span> *srcva, <span class=\"keyword\">unsigned</span> perm)</span></div><div class=\"line\">&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> r;</div><div class=\"line\">        <span class=\"keyword\">pte_t</span> *pte;</div><div class=\"line\">        <span class=\"keyword\">struct</span> PageInfo *pp;</div><div class=\"line\">        <span class=\"keyword\">struct</span> Env *env;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> ((r = envid2env(envid, &amp;env, <span class=\"number\">0</span>)) &lt; <span class=\"number\">0</span>)</div><div class=\"line\">                <span class=\"keyword\">return</span> -E_BAD_ENV;</div><div class=\"line\">        <span class=\"keyword\">if</span> (env-&gt;env_ipc_recving != <span class=\"literal\">true</span> || env-&gt;env_ipc_from != <span class=\"number\">0</span>)</div><div class=\"line\">                <span class=\"keyword\">return</span> -E_IPC_NOT_RECV;</div><div class=\"line\">        <span class=\"keyword\">if</span> (srcva &lt; (<span class=\"keyword\">void</span> *)UTOP &amp;&amp; PGOFF(srcva))</div><div class=\"line\">                <span class=\"keyword\">return</span> -E_INVAL;</div><div class=\"line\">        <span class=\"keyword\">if</span> (srcva &lt; (<span class=\"keyword\">void</span> *)UTOP) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> ((perm &amp; PTE_P) == <span class=\"number\">0</span> || (perm &amp; PTE_U) == <span class=\"number\">0</span>)</div><div class=\"line\">                        <span class=\"keyword\">return</span> -E_INVAL;</div><div class=\"line\">                <span class=\"keyword\">if</span> ((perm &amp; ~(PTE_P | PTE_U | PTE_W | PTE_AVAIL)) != <span class=\"number\">0</span>)</div><div class=\"line\">                        <span class=\"keyword\">return</span> -E_INVAL;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (srcva &lt; (<span class=\"keyword\">void</span> *)UTOP &amp;&amp; (pp = page_lookup(curenv-&gt;env_pgdir, srcva, &amp;pte)) == <span class=\"literal\">NULL</span>)</div><div class=\"line\">                <span class=\"keyword\">return</span> -E_INVAL;</div><div class=\"line\">        <span class=\"keyword\">if</span> (srcva &lt; (<span class=\"keyword\">void</span> *)UTOP &amp;&amp; (perm &amp; PTE_W) != <span class=\"number\">0</span> &amp;&amp; (*pte &amp; PTE_W) == <span class=\"number\">0</span>)</div><div class=\"line\">                <span class=\"keyword\">return</span> -E_INVAL;</div><div class=\"line\">        <span class=\"keyword\">if</span> (srcva &lt; (<span class=\"keyword\">void</span> *)UTOP &amp;&amp; env-&gt;env_ipc_dstva != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> ((r = page_insert(env-&gt;env_pgdir, pp, env-&gt;env_ipc_dstva, perm)) &lt; <span class=\"number\">0</span>)</div><div class=\"line\">                        <span class=\"keyword\">return</span> -E_NO_MEM;</div><div class=\"line\">                env-&gt;env_ipc_perm = perm;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        env-&gt;env_ipc_from = curenv-&gt;env_id;</div><div class=\"line\">        env-&gt;env_ipc_recving = <span class=\"literal\">false</span>;</div><div class=\"line\">        env-&gt;env_ipc_value = value;</div><div class=\"line\">        env-&gt;env_status = ENV_RUNNABLE;</div><div class=\"line\">        env-&gt;env_tf.tf_regs.reg_eax = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>完成后需要要加上分发机制，将调用号加上。<br>最后是2个用户态库函数的实现。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int32_t</span></div><div class=\"line\">ipc_recv(<span class=\"keyword\">envid_t</span> *from_env_store, <span class=\"keyword\">void</span> *pg, <span class=\"keyword\">int</span> *perm_store)</div><div class=\"line\">&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> r;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (pg == <span class=\"literal\">NULL</span>)</div><div class=\"line\">                r = sys_ipc_recv((<span class=\"keyword\">void</span> *)UTOP);</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">                r = sys_ipc_recv(pg);</div><div class=\"line\">        <span class=\"keyword\">if</span> (from_env_store != <span class=\"literal\">NULL</span>)</div><div class=\"line\">                *from_env_store = r &lt; <span class=\"number\">0</span> ? <span class=\"number\">0</span> : thisenv-&gt;env_ipc_from;</div><div class=\"line\">        <span class=\"keyword\">if</span> (perm_store != <span class=\"literal\">NULL</span>)</div><div class=\"line\">                *perm_store = r &lt; <span class=\"number\">0</span> ? <span class=\"number\">0</span> : thisenv-&gt;env_ipc_perm;</div><div class=\"line\">        <span class=\"keyword\">if</span> (r &lt; <span class=\"number\">0</span>)</div><div class=\"line\">                <span class=\"keyword\">return</span> r;</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">                <span class=\"keyword\">return</span> thisenv-&gt;env_ipc_value;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">ipc_send</span><span class=\"params\">(<span class=\"keyword\">envid_t</span> to_env, <span class=\"keyword\">uint32_t</span> val, <span class=\"keyword\">void</span> *pg, <span class=\"keyword\">int</span> perm)</span></div><div class=\"line\">&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> r;</div><div class=\"line\">        <span class=\"keyword\">void</span> *dstpg;</div><div class=\"line\"></div><div class=\"line\">        dstpg = pg != <span class=\"literal\">NULL</span> ? pg : (<span class=\"keyword\">void</span> *)UTOP;</div><div class=\"line\">        <span class=\"keyword\">while</span>((r = sys_ipc_try_send(to_env, val, dstpg, perm)) &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (r != -E_IPC_NOT_RECV)</div><div class=\"line\">                        panic(<span class=\"string\">\"ipc_send: send message error %e\"</span>, r);</div><div class=\"line\">                sys_yield();</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Lab4-抢占式多进程\"><a href=\"#Lab4-抢占式多进程\" class=\"headerlink\" title=\"Lab4 抢占式多进程\"></a>Lab4 抢占式多进程</h1><h2 id=\"Part2-写入时复制-copy-on-write-fork\"><a href=\"#Part2-写入时复制-copy-on-write-fork\" class=\"headerlink\" title=\"Part2 写入时复制 copy-on-write fork\"></a>Part2 写入时复制 copy-on-write fork</h2><p>如前所述,Unix将fork()系统调用作为进程创建原语.fork()系统调用将调用进程的地址空间（父进程）创建一个新的进程（子进程）.<br>xv6 Unix <code>fork()</code>通过将父进程页面中的所有数据复制到为子进程分配的新页面中,这个机制基本和<code>dumbfork()</code>相同.复制父进程的地址空间到子进程是<code>fork()</code>中代价最大的操作.<br>但是,调用<code>fork()</code>后经常在子进程中跟随<code>exec()</code>调用, 其会用加载新程序到子进程的内存.例如, 这是shell的常用机制.在这种情况下,复制父进程地址空间的时间大部分被浪费,因为子进程在调用<code>exec()</code>之前只使用很少的内存.</p>\n<p>因此,Unix的更高版本利用虚拟内存硬件,允许父子进程<strong>共享</strong>映射到其各自地址空间的内存,直到其中一个进程实际修改这段内存.这种技术被称为<strong>写时复制(copy-on-fork)</strong>.为了做到这一点,调用<code>fork()</code>时,内核上将复制父进程的地址空间映射到进程,而不是复制映射页的内容,同时标记现在共享的页面为只读.当两个进程中的一个尝试写入其中一个共享页面时,该进程将出现页面错误.在这一点上,Unix内核意识到该页面真的是一个“虚拟”或“写时复制”的副本,因此它创建一个新的/私有的故障页面的可写副本.这样,单个页面的内容在实际写入之前实际上并不被复制.<code>fork()</code>的这种优化使随后的<code>exec()</code>代价小很多：在子进程调用<code>exec()</code>之前,可能只需要复制一个页面（它的堆栈的当前页面）.</p>\n<p>在part2,实现一个 Unix <code>fork()</code>,其具有写时复制功能,并作为一个用户空间库例程来.另外,使得单个用户模式程序定义自己的<code>fork()</code>:一个程序想要一个稍微不同的<code>fork()</code>（如总是复制的<code>dumbfork()</code>,或者父子进程共享内存）可以很容易修改而实现.</p>\n<h3 id=\"用户级页面错误处理\"><a href=\"#用户级页面错误处理\" class=\"headerlink\" title=\"用户级页面错误处理\"></a>用户级页面错误处理</h3><p>用户级的写时复制<code>fork()</code>首先需要知道发生在写保护页面上的页面错误,这是首先要实现的.写时复制只是用户级页面故障处理的许多可能用途之一.<br>一般实现方式是:设置一个地址空间,以便页面错误指示出何时需要执行操作.例如,大多数Unix内核最初仅在新进程的堆栈区域中映射单个页面,并且随着进程的堆栈增加而随后分配和映射额外的堆栈页面,并导致尚未映射的堆栈地址发生页面错误,对此典型的Unix内核必须跟踪在进程空间的每个区域中出现页面错误时要执行的操作.又例如,堆栈区域中的故障通常会导致分配和映射物理内存新页面.程序BSS区域的故障通常会分配一个新的页面,以0填充,并在进行映射.<br>以上是内核需要跟踪的信息.不采用传统的Unix方法,而更好地处理用户空间中的每个页面错误,使得bug破坏性更小.这种设计具有额外的优点,允许程序在定义其内存区域方面具有很大的灵活性.<br>","more":"</p>\n<h4 id=\"设置页面错误处理器\"><a href=\"#设置页面错误处理器\" class=\"headerlink\" title=\"设置页面错误处理器\"></a>设置页面错误处理器</h4><p>为了处理自己的页面错误,用户环境将需要向JOS内核注册页面错误处理程序<code>entrypoint</code>.用户环境通过新的<code>sys_env_set_pgfault_upcall</code>系统调用注册其页面错误入口点.增加一个新成员<code>Env</code>结构<code>env_pgfault_upcall</code>来记录这些信息.</p>\n<h4 id=\"练习8\"><a href=\"#练习8\" class=\"headerlink\" title=\"练习8\"></a>练习8</h4><p>问:</p>\n<blockquote>\n<p>实现<code>sys_env_set_pgfault_upcall</code>系统调用.注:因为这个系统调用危险性很高,所以在查找目标环境的环境ID时要启用权限检查,</p>\n</blockquote>\n<p>解:</p>\n<blockquote>\n<p>实现如下:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span></span></div><div class=\"line\"><span class=\"title\">sys_env_set_pgfault_upcall</span><span class=\"params\">(<span class=\"keyword\">envid_t</span> envid, <span class=\"keyword\">void</span> *func)</span></div><div class=\"line\">&#123;</div><div class=\"line\">        <span class=\"keyword\">struct</span> Env *env;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (envid2env(envid, &amp;env, <span class=\"number\">1</span>) &lt; <span class=\"number\">0</span>)</div><div class=\"line\">                <span class=\"keyword\">return</span> -E_BAD_ENV;</div><div class=\"line\">        env-&gt;env_pgfault_upcall = func;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h4 id=\"用户环境的正常-异常堆栈\"><a href=\"#用户环境的正常-异常堆栈\" class=\"headerlink\" title=\"用户环境的正常/异常堆栈\"></a>用户环境的正常/异常堆栈</h4><p>在正常运行期间,用户进程运行在用户栈上,栈顶寄存器<code>ESP</code>指向<code>USTACKTOP</code>处,堆栈数据位于<code>USTACKTOP-PGSIZE 与USTACKTOP-1</code>之间的页.当在用户模式发生页面错误时,内核将在专门处理页面错误的用户异常栈上重新启动进程. 异常栈正是为了上面设置的异常处理例程设立的.当异常发生时,而且该用户进程注册了该异常的处理例程,那么就会转到异常栈上,运行异常处理例程.<br>到目前位置出现了三个栈：</p>\n<ul>\n<li>内核态系统栈 [KSTACKTOP, KSTACKTOP-KSTKSIZE]</li>\n<li>用户态错误处理栈 [UXSTACKTOP, UXSTACKTOP - PGSIZE]</li>\n<li>用户态运行栈 [USTACKTOP, UTEXT]</li>\n</ul>\n<p>内核态系统栈是运行内核相关程序的栈,在有中断被触发之后,CPU会将栈自动切换到内核栈上来,而内核栈的设置是在<code>kern/trap.c</code>的<code>trap_init_percpu()</code>中设置的.<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">trap_init_percpu</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></div><div class=\"line\">&#123;</div><div class=\"line\">        <span class=\"comment\">// Setup a TSS so that we get the right stack</span></div><div class=\"line\">        <span class=\"comment\">// when we trap to the kernel.</span></div><div class=\"line\">        thiscpu-&gt;cpu_ts.ts_esp0 = KSTACKTOP - cpunum() * (KSTKGAP + KSTKSIZE);</div><div class=\"line\">        thiscpu-&gt;cpu_ts.ts_ss0 = GD_KD;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Initialize the TSS slot of the gdt.</span></div><div class=\"line\">        gdt[(GD_TSS0 &gt;&gt; <span class=\"number\">3</span>) + cpunum()] = SEG16(STS_T32A, (<span class=\"keyword\">uint32_t</span>) (&amp;thiscpu-&gt;cpu_ts),</div><div class=\"line\">                                        <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> Taskstate) - <span class=\"number\">1</span>, <span class=\"number\">0</span>);</div><div class=\"line\">        gdt[(GD_TSS0 &gt;&gt; <span class=\"number\">3</span>) + cpunum()].sd_s = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Load the TSS selector (like other segment selectors, the</span></div><div class=\"line\">        <span class=\"comment\">// bottom three bits are special; we leave them 0)</span></div><div class=\"line\">        ltr(GD_TSS0 + <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> Segdesc) * cpunum());</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Load the IDT</span></div><div class=\"line\">        lidt(&amp;idt_pd);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>而用户态错误处理栈是用户定义注册了自己的中断处理程序之后,相应的例程运行时的栈.整个过程如下：</p>\n<blockquote>\n<p>首先陷入到内核,栈位置从用户运行栈切换到内核栈,进入到<code>trap</code>中,进行中断处理分发,进入到<code>page_fault_handler()</code>.当确认是用户程序触发的<code>page fault</code>的时候(如果是内核触发的,会直接<code>panic</code>),为其在用户错误栈里分配一个<code>UTrapframe</code>的大小.把栈切换到用户错误栈,运行响应的用户中断处理程序中断处理程序可能会触发另外一个同类型的中断,这个时候就会产生递归式的中断嵌套处理.处理完成之后,返回到用户运行栈.</p>\n</blockquote>\n<h4 id=\"调用用户页面故障处理程序\"><a href=\"#调用用户页面故障处理程序\" class=\"headerlink\" title=\"调用用户页面故障处理程序\"></a>调用用户页面故障处理程序</h4><p>将用户自己定义的页面故障处理进程当作是一次函数调用看待,当错误发生的时候,调用一个函数,但实际上还是当前这个进程,并没有发生变化.所以当切换到异常栈的时候,依然运行当前进程,但只是运行的是中断处理函数,所以说此时的栈指针发生了变化,而且程序计数器<code>eip</code>也发生了变化,同时还需要知道的是引发错误的地址在哪.这些都是要在切换到异常栈的时候需要传递的信息.和之前从用户栈切换到内核栈一样,这里是通过在栈上构造结构体,传递指针完成的.<br>在<code>inc / trap.h</code>新定义了一个类似<code>struct Trapframe</code>结构体<code>struct UTrapframe</code>用来记录出现页面错误时候的信息：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> UTrapframe &#123;</div><div class=\"line\">        <span class=\"comment\">/* information about the fault */</span></div><div class=\"line\">        <span class=\"keyword\">uint32_t</span> utf_fault_va;  <span class=\"comment\">/* va for T_PGFLT, 0 otherwise */</span></div><div class=\"line\">        <span class=\"keyword\">uint32_t</span> utf_err;</div><div class=\"line\">        <span class=\"comment\">/* trap-time return state */</span></div><div class=\"line\">        <span class=\"keyword\">struct</span> PushRegs utf_regs;</div><div class=\"line\">        <span class=\"keyword\">uintptr_t</span> utf_eip;</div><div class=\"line\">        <span class=\"keyword\">uint32_t</span> utf_eflags;</div><div class=\"line\">        <span class=\"comment\">/* the trap-time stack to return to */</span></div><div class=\"line\">        <span class=\"keyword\">uintptr_t</span> utf_esp;</div><div class=\"line\">&#125; __attribute__((packed));</div></pre></td></tr></table></figure></p>\n<p>相比于<code>Trapframe</code>,这里多了<code>utf_fault_va</code>,因为要记录触发错误的内存地址,同时还少了<code>es,ds,ss</code>等段记录.因为从用户态栈切换到异常栈,或者从异常栈再切换回去,实际上都是一个用户进程,所以不涉及到段的切换,不用记录.在实际使用中,<code>Trapframe</code>是作为记录进程状态的结构体存在的,也作为函数参数进行传递；而<code>UTrapframe</code>只在处理用户定义的异常时用到.<br>整体上讲,当正常执行过程中发生了页面错误,那么栈的切换是<br><strong>用户运行栈—&gt;内核栈—&gt;异常栈</strong><br>而如果在异常处理程序中发生了页面错误,那么栈的切换是<br><strong>异常栈—&gt;内核栈—&gt;异常栈</strong></p>\n<h4 id=\"练习9\"><a href=\"#练习9\" class=\"headerlink\" title=\"练习9\"></a>练习9</h4><p>问:</p>\n<blockquote>\n<p>实现<code>kern/trap.c</code>中<code>page_fault_handler</code>函数, 把页面错误分发到对应的用户态异常处理函数.</p>\n</blockquote>\n<p>解:</p>\n<blockquote>\n<p>如果当前已经在用户错误栈上了,那么需要留出4个字节,否则不需要,具体和跳转机制有关系.简单说就是在当前的异常栈栈顶的位置向下留出保存<code>UTrapframe</code>的空间,然后将<code>tf</code>中的参数复制过来.修改当前进程的程序计数器和栈指针,然后重启这个进程,此时就会在用户错误栈上运行中断处理程序了.中断处理程序运行结束之后,需要再回到用户运行栈中,这是异常处理程序需要做的.<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">page_fault_handler</span><span class=\"params\">(<span class=\"keyword\">struct</span> Trapframe *tf)</span></div><div class=\"line\">&#123;</div><div class=\"line\">        <span class=\"keyword\">uint32_t</span> fault_va;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Read processor's CR2 register to find the faulting address</span></div><div class=\"line\">        fault_va = rcr2();</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Handle kernel-mode page faults.</span></div><div class=\"line\">        <span class=\"keyword\">if</span> (tf-&gt;tf_cs == GD_KT)</div><div class=\"line\">                panic(<span class=\"string\">\"page_fault in kernel mode, fault address: %d\\n\"</span>, fault_va);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">struct</span> UTrapframe *utf;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (curenv-&gt;env_pgfault_upcall) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (UXSTACKTOP - PGSIZE &lt;= tf-&gt;tf_esp &amp;&amp; tf-&gt;tf_esp &lt;= UXSTACKTOP - <span class=\"number\">1</span>)</div><div class=\"line\">                        utf = (<span class=\"keyword\">struct</span> UTrapframe *)(tf-&gt;tf_esp - <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> UTrapframe) - <span class=\"number\">4</span>);</div><div class=\"line\">                <span class=\"keyword\">else</span></div><div class=\"line\">                        utf = (<span class=\"keyword\">struct</span> UTrapframe *)(UXSTACKTOP - <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> UTrapframe));</div><div class=\"line\">                user_mem_assert(curenv, (<span class=\"keyword\">void</span> *)utf, <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> UTrapframe), PTE_U | PTE_W);</div><div class=\"line\"></div><div class=\"line\">                utf-&gt;utf_fault_va = fault_va;</div><div class=\"line\">                utf-&gt;utf_err = tf-&gt;tf_trapno;</div><div class=\"line\">                utf-&gt;utf_eip = tf-&gt;tf_eip;</div><div class=\"line\">                utf-&gt;utf_eflags = tf-&gt;tf_eflags;</div><div class=\"line\">                utf-&gt;utf_esp = tf-&gt;tf_esp;</div><div class=\"line\">                utf-&gt;utf_regs = tf-&gt;tf_regs;</div><div class=\"line\">                tf-&gt;tf_eip = (<span class=\"keyword\">uint32_t</span>)curenv-&gt;env_pgfault_upcall;</div><div class=\"line\">                tf-&gt;tf_esp = (<span class=\"keyword\">uint32_t</span>)utf;</div><div class=\"line\">                env_run(curenv);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Destroy the environment that caused the fault.</span></div><div class=\"line\">        cprintf(<span class=\"string\">\"[%08x] user fault va %08x ip %08x\\n\"</span>,</div><div class=\"line\">                curenv-&gt;env_id, fault_va, tf-&gt;tf_eip);</div><div class=\"line\">        print_trapframe(tf);</div><div class=\"line\">        env_destroy(curenv);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h4 id=\"用户模式页面错误的入口\"><a href=\"#用户模式页面错误的入口\" class=\"headerlink\" title=\"用户模式页面错误的入口\"></a>用户模式页面错误的入口</h4><p>接下来需要实现汇编程序,该程序将负责调用页面错误处理程序,并在原始故障指令下继续执行,其将调用处理程序<code>sys_env_set_pgfault_upcall()</code>向内核注册.</p>\n<h4 id=\"练习10\"><a href=\"#练习10\" class=\"headerlink\" title=\"练习10\"></a>练习10</h4><p>问:</p>\n<blockquote>\n<p>实现在<code>lib/pfentry.S</code>中的<code>_pgfault_upcall</code>调用.</p>\n</blockquote>\n<p>解:</p>\n<blockquote>\n<p><code>_pgfault_upcall</code>是所有用户页错误处理程序的入口,在这里调用用户自定义的处理程序,并在处理完成后,从异常栈中保存的<code>UTrapframe</code>结构体中恢复相应信息,然后跳回到发生错误之前的指令,恢复原来的进程运行.具体过程如下:<br>调用<code>_pgfault_handler</code>返回时的操作,此时的异常栈结构如下：<br><img src=\"/images/lab4/UStack1.png\" alt=\"UStack1\"><br>这里<code>trap-time esp</code>上的空间有1个4字节的保留空间,是做为中断递归的情形. 然后将栈中的<code>trap-time esp</code>取出减去4,再存回栈中.此时如果是中断递归中,<code>esp-4</code>即是保留的4字节地址；如果不是则是用户运行栈的栈顶. 再将原来出错程序的<code>trap-time eip</code>取出放入保留的4字节,以便后来恢复运行.此时的异常栈布局如下：<br><img src=\"/images/lab4/UStack2.png\" alt=\"UStack2\"><br>紧接着恢复通用寄存器和EFLAG标志寄存器,此时的异常栈结构如下：<br><img src=\"/images/lab4/UStack3.png\" alt=\"UStack3\"><br>最后<code>pop esp</code>切换为原来出错程序的运行栈,最后使用<code>ret</code>返回出错程序.<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">.text</div><div class=\"line\">.globl _pgfault_upcall</div><div class=\"line\">_pgfault_upcall:</div><div class=\"line\">        <span class=\"comment\">// Call the C page fault handler.</span></div><div class=\"line\">        pushl %esp                      <span class=\"comment\">// function argument: pointer to UTF</span></div><div class=\"line\">        movl _pgfault_handler, %eax</div><div class=\"line\">        call *%eax</div><div class=\"line\">        addl $<span class=\"number\">4</span>, %esp                   <span class=\"comment\">// pop function argument</span></div><div class=\"line\"></div><div class=\"line\">        movl <span class=\"number\">48</span>(%esp), %ebp</div><div class=\"line\">        subl $<span class=\"number\">4</span>, %ebp</div><div class=\"line\">        movl %ebp, <span class=\"number\">48</span>(%esp)</div><div class=\"line\">        movl <span class=\"number\">40</span>(%esp), %eax</div><div class=\"line\">        movl %eax, (%ebp)</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Restore the trap-time registers.  After you do this, you can no longer modify any general-purpose registers.</span></div><div class=\"line\">        addl $<span class=\"number\">8</span>, %esp</div><div class=\"line\">        popal</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Restore eflags from the stack.  After you do this, you can</span></div><div class=\"line\">        <span class=\"comment\">// no longer use arithmetic operations or anything else that</span></div><div class=\"line\">        <span class=\"comment\">// modifies eflags.</span></div><div class=\"line\">        addl $<span class=\"number\">4</span>, %esp</div><div class=\"line\">        popfl</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Switch back to the adjusted trap-time stack.</span></div><div class=\"line\"></div><div class=\"line\">        popl %esp</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Return to re-execute the instruction that faulted.</span></div><div class=\"line\">        ret</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h4 id=\"练习11\"><a href=\"#练习11\" class=\"headerlink\" title=\"练习11\"></a>练习11</h4><p>问:</p>\n<blockquote>\n<p>在<code>lib / pgfault.c</code>中完成<code>set_pgfault_handler()</code>,即实现用户级页面故障处理机制的C语言库函数.</p>\n</blockquote>\n<p>解:</p>\n<blockquote>\n<p>进程在运行前注册自己的页错误处理程序,重点是申请用户异常栈空间,最后添加上系统调用号.<br><figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">void</div><div class=\"line\">set_pgfault_handler(void (*handler)(struct UTrapframe *utf))</div><div class=\"line\">&#123;</div><div class=\"line\">        int r;</div><div class=\"line\"></div><div class=\"line\">        if (_pgfault_handler == 0) &#123;</div><div class=\"line\">                // First time through!</div><div class=\"line\">                if ((r = sys_page_alloc(thisenv-&gt;env_id, (void *)(UXSTACKTOP - PGSIZE), PTE_P | PTE_W | PTE_U)) &lt; 0)</div><div class=\"line\">                        panic(\"set_pgfault_handler: %e\", r);</div><div class=\"line\">                sys_env_set_pgfault_upcall(thisenv-&gt;env_id, _pgfault_upcall);</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        // Save handler pointer for assembly to call.</div><div class=\"line\">        _pgfault_handler = handler;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h3 id=\"实现写入时复制-fork\"><a href=\"#实现写入时复制-fork\" class=\"headerlink\" title=\"实现写入时复制 fork\"></a>实现写入时复制 fork</h3><p>接下来就是最重要的部分：实现<code>copy-on-write fork</code>.<br>与之前的<code>dumbfork()</code>不同,<code>fork()</code>出一个子进程之后,首先要进行的就是将父进程的页表的全部映射拷贝到子进程的地址空间中去.这个时候物理页会被两个进程同时映射,但是在写的时候是应该隔离的.采取的方法是在子进程映射的时候,将父进程空间中所有可以写的页表的部分全部标记为可读且COW(copy-on-write).而当父进程或者子进程任意一个发生了写的时候,因为页表现在都是不可写的,所以会触发异常,进入到我们设定的page fault处理例程,当检测到是对COW页的写操作的情况下,就可以将要写入的页的内容全部拷贝一份,重新映射.</p>\n<h4 id=\"练习12\"><a href=\"#练习12\" class=\"headerlink\" title=\"练习12\"></a>练习12</h4><p>问:</p>\n<blockquote>\n<p>实现在<code>lib/fork.c</code>的<code>fork,duppage和pgfault</code>.</p>\n</blockquote>\n<p>解:</p>\n<blockquote>\n<p>首先需要为父进程设定错误处理例程.调用<code>set_pgfault_handler()</code>是因为当前并不知道父进程是否已经建立了异常栈,没有的话就会建立一个,而<code>sys_env_set_pgfault_upcall</code>则不会建立异常栈.<br>接着调用<code>sys_exofork</code>准备一个和父进程状态相同的子进程,状态暂时设置为<code>ENV_NOT_RUNNABLE</code>.然后进行拷贝映射的部分,在当前进程的页表中所有标记为<code>PTE_P</code>的页的映射都需要拷贝到子进程空间中去.但是有一个例外,是必须要新申请一页来拷贝内容的,就是用户异常栈.因为copy-on-write就是依靠用户异常栈实现的,所以说这个栈要在fork完成的时候每个进程都有一个,要硬拷贝过来.<br>主要流程就是：</p>\n<ol>\n<li>申请新的物理页,映射到子进程的(UXSTACKTOP-PGSIZE)位置上去.</li>\n<li>父进程的PFTEMP位置也映射到子进程新申请的物理页上去,这样父进程也可以访问这一页.</li>\n<li>在父进程空间中,将用户错误栈全部拷贝到子进程的错误栈上去,也就是刚刚申请的那一页.</li>\n<li>然后父进程解除对PFTEMP的映射.</li>\n<li>最后把子进程的状态设置为可运行</li>\n</ol>\n</blockquote>\n<p>具体实现如下:<br>首先是<code>pgfault</code>处理<code>page fault</code>时的写时复制.<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">pgfault</span><span class=\"params\">(<span class=\"keyword\">struct</span> UTrapframe *utf)</span></div><div class=\"line\">&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> r;</div><div class=\"line\">        <span class=\"keyword\">void</span> *addr = (<span class=\"keyword\">void</span> *) utf-&gt;utf_fault_va;</div><div class=\"line\">        <span class=\"keyword\">uint32_t</span> err = utf-&gt;utf_err;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> ((err &amp; FEC_WR) == <span class=\"number\">0</span> || (uvpt[PGNUM(addr)] &amp; PTE_COW) == <span class=\"number\">0</span>)</div><div class=\"line\">                panic(<span class=\"string\">\"pgfault: it's not writable or attempt to access a non-cow page!\"</span>);</div><div class=\"line\">        <span class=\"comment\">// Allocate a new page, map it at a temporary location (PFTEMP),</span></div><div class=\"line\">        <span class=\"comment\">// copy the data from the old page to the new page, then move the new</span></div><div class=\"line\">        <span class=\"comment\">// page to the old page's address.</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">envid_t</span> envid = sys_getenvid();</div><div class=\"line\">        <span class=\"keyword\">if</span> ((r = sys_page_alloc(envid, (<span class=\"keyword\">void</span> *)PFTEMP, PTE_P | PTE_W | PTE_U)) &lt; <span class=\"number\">0</span>)</div><div class=\"line\">                panic(<span class=\"string\">\"pgfault: page allocation failed %e\"</span>, r);</div><div class=\"line\"></div><div class=\"line\">        addr = ROUNDDOWN(addr, PGSIZE);</div><div class=\"line\">        memmove(PFTEMP, addr, PGSIZE);</div><div class=\"line\">        <span class=\"keyword\">if</span> ((r = sys_page_unmap(envid, addr)) &lt; <span class=\"number\">0</span>)</div><div class=\"line\">                panic(<span class=\"string\">\"pgfault: page unmap failed %e\"</span>, r);</div><div class=\"line\">        <span class=\"keyword\">if</span> ((r = sys_page_map(envid, PFTEMP, envid, addr, PTE_P | PTE_W |PTE_U)) &lt; <span class=\"number\">0</span>)</div><div class=\"line\">                panic(<span class=\"string\">\"pgfault: page map failed %e\"</span>, r);</div><div class=\"line\">        <span class=\"keyword\">if</span> ((r = sys_page_unmap(envid, PFTEMP)) &lt; <span class=\"number\">0</span>)</div><div class=\"line\">                panic(<span class=\"string\">\"pgfault: page unmap failed %e\"</span>, r);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>在<code>pgfault()</code>中先判断是否页错误是由写时拷贝造成的,如果不是则<code>panic</code>.借用了一个一定不会被用到的位置<code>PFTEMP</code>,专门用来发生<code>page fault</code>的时候拷贝内容用的.先解除<code>addr</code>原先的页映射关系,然后将<code>addr</code>映射到<code>PFTEMP</code>映射的页,最后解除<code>PFTEMP</code>的页映射关系.<br>接下来是<code>duppage</code>函数,负责进行COW方式的页复制,将当前进程的第pn页对应的物理页的映射到<code>envid</code>的第pn页上去,同时将这一页都标记为COW.<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span></span></div><div class=\"line\"><span class=\"title\">duppage</span><span class=\"params\">(<span class=\"keyword\">envid_t</span> envid, <span class=\"keyword\">unsigned</span> pn)</span></div><div class=\"line\">&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> r;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">void</span> *addr;</div><div class=\"line\">        <span class=\"keyword\">pte_t</span> pte;</div><div class=\"line\">        <span class=\"keyword\">int</span> perm;</div><div class=\"line\"></div><div class=\"line\">        addr = (<span class=\"keyword\">void</span> *)((<span class=\"keyword\">uint32_t</span>)pn * PGSIZE);</div><div class=\"line\">        pte = uvpt[pn];</div><div class=\"line\">        perm = PTE_P | PTE_U;</div><div class=\"line\">        <span class=\"keyword\">if</span> ((pte &amp; PTE_W) || (pte &amp; PTE_COW))</div><div class=\"line\">                perm |= PTE_COW;</div><div class=\"line\">        <span class=\"keyword\">if</span> ((r = sys_page_map(thisenv-&gt;env_id, addr, envid, addr, perm)) &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                panic(<span class=\"string\">\"duppage: page remapping failed %e\"</span>, r);</div><div class=\"line\">                <span class=\"keyword\">return</span> r;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (perm &amp; PTE_COW) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> ((r = sys_page_map(thisenv-&gt;env_id, addr, thisenv-&gt;env_id, addr, perm)) &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                        panic(<span class=\"string\">\"duppage: page remapping failed %e\"</span>, r);</div><div class=\"line\">                        <span class=\"keyword\">return</span> r;</div><div class=\"line\">                &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>最后是fork函数,将页映射拷贝过去,这里需要考虑的地址范围就是<code>从UTEXT到UXSTACKTOP</code>为止,而在此之上的范围因为都是相同的,在<code>env_alloc</code>的时候已经设置好了.<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">envid_t</span></div><div class=\"line\">fork(<span class=\"keyword\">void</span>)</div><div class=\"line\">&#123;</div><div class=\"line\">        <span class=\"keyword\">uint32_t</span> addr;</div><div class=\"line\">        <span class=\"keyword\">int</span> i, j, pn, r;</div><div class=\"line\">        <span class=\"keyword\">extern</span> <span class=\"keyword\">void</span> _pgfault_upcall(<span class=\"keyword\">void</span>);</div><div class=\"line\">        <span class=\"keyword\">if</span> ((envid = sys_exofork()) &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                panic(<span class=\"string\">\"sys_exofork failed: %e\"</span>, envid);</div><div class=\"line\">                <span class=\"keyword\">return</span> envid;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (envid == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                thisenv = &amp;envs[ENVX(sys_getenvid())];</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">for</span> (i = PDX(UTEXT); i &lt; PDX(UXSTACKTOP); i++) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (uvpd[i] &amp; PTE_P) &#123;</div><div class=\"line\">                        <span class=\"keyword\">for</span> (j = <span class=\"number\">0</span>; j &lt; NPTENTRIES; j++) &#123;</div><div class=\"line\">                                pn = PGNUM(PGADDR(i, j, <span class=\"number\">0</span>));</div><div class=\"line\">                                <span class=\"keyword\">if</span> (pn == PGNUM(UXSTACKTOP - PGSIZE))</div><div class=\"line\">                                        <span class=\"keyword\">break</span>;</div><div class=\"line\">                                <span class=\"keyword\">if</span> (uvpt[pn] &amp; PTE_P)</div><div class=\"line\">                                        duppage(envid, pn);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\"></div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> ((r = sys_page_alloc(envid, (<span class=\"keyword\">void</span> *)(UXSTACKTOP - PGSIZE), PTE_P | PTE_U | PTE_W)) &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                panic(<span class=\"string\">\"fork: page alloc failed %e\"</span>, r);</div><div class=\"line\">                <span class=\"keyword\">return</span> r;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> ((r = sys_page_map(envid, (<span class=\"keyword\">void</span> *)(UXSTACKTOP - PGSIZE), thisenv-&gt;env_id, PFTEMP, PTE_P | PTE_U | PTE_W)) &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                panic(<span class=\"string\">\"fork: page map failed %e\"</span>, r);</div><div class=\"line\">                <span class=\"keyword\">return</span> r;</div><div class=\"line\">        &#125;</div><div class=\"line\">        memmove((<span class=\"keyword\">void</span> *)(UXSTACKTOP - PGSIZE), PFTEMP, PGSIZE);</div><div class=\"line\">        <span class=\"keyword\">if</span> ((r = sys_page_unmap(thisenv-&gt;env_id, PFTEMP)) &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                panic(<span class=\"string\">\"fork: page unmap failed %e\"</span>, r);</div><div class=\"line\">                <span class=\"keyword\">return</span> r;</div><div class=\"line\">        &#125;</div><div class=\"line\">        sys_env_set_pgfault_upcall(envid, _pgfault_upcall);</div><div class=\"line\">        <span class=\"keyword\">if</span> ((r = sys_env_set_status(envid, ENV_RUNNABLE)) &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                panic(<span class=\"string\">\"fork: set child env status failed %e\"</span>, r);</div><div class=\"line\">                <span class=\"keyword\">return</span> r;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> envid;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"Part3-抢占式调度和进程间通信\"><a href=\"#Part3-抢占式调度和进程间通信\" class=\"headerlink\" title=\"Part3 抢占式调度和进程间通信\"></a>Part3 抢占式调度和进程间通信</h2><p>Lab4的最后一部分就是实现抢占式调度和进程间通信。</p>\n<h3 id=\"时钟中断和抢占\"><a href=\"#时钟中断和抢占\" class=\"headerlink\" title=\"时钟中断和抢占\"></a>时钟中断和抢占</h3><p>先前的调度是进程资源放弃CPU，但是实际中没有进程会这样做的，而为了不让某一进程耗尽CPU资源，需要抢占式调度，也就需要硬件定时。但是外部硬件定时在Bootloader的时候就关闭了，至今都没有开启。而JOS采取的策略是，在内核中的时候，外部中断是始终关闭的，在用户态的时候，需要开启中断。</p>\n<h4 id=\"中断原则\"><a href=\"#中断原则\" class=\"headerlink\" title=\"中断原则\"></a>中断原则</h4><p>外部中断称为IRQ。一共有16个可能的IRQ，编号为0到15.从IRQ号到IDT条目的映射不是固定的, <code>picirq.c</code>中的<code>pic_init</code>将IRQ 0-15映射到到IDT的<code>[IRQ_OFFSET,IRQ_OFFSET+15]</code>.<br>在<code>inc / trap.h</code>中， <code>IRQ_OFFSET</code>定义为十进制数32.因此IDT条目32-47对应于IRQ 0-15。例如，时钟中断是IRQ 0.因此，<code>IDT[IRQ_OFFSET + 0]</code>（即<code>IDT[32]</code>）包含内核中时钟的中断处理程序例程的地址。选择正确的<code>IRQ_OFFSET</code>使得设备中断不与处理器异常重叠,可以避免异常处理的混乱.<br>在JOS中，与xv6 Unix相比，做了一个关键的简化。在内核中，外部设备中断始终被禁用（和xv6一样，在用户空间中启用）。外部中断由寄存器的<code>FL_IF标志位%eflags</code>控制（见<code>inc/mmu.h</code>）。当该位置1时，外部中断被使能。虽然可以通过几种方式修改该位，但由于简化，可以通过在<code>%eflags</code>进入和离开用户模式时保存和恢复寄存器的过程来处理该位。必须确保<code>FL_IF</code>标志在用户环境中运行，以便当中断到达时，它将被传递到处理器并由中断代码处理。否则，中断会被屏蔽或忽略，直到重新启用中断。Lab1中用<code>bootloaded</code>的第一个指令屏蔽了中断，到目前为止还没开启过.</p>\n<h4 id=\"练习12-1\"><a href=\"#练习12-1\" class=\"headerlink\" title=\"练习12\"></a>练习12</h4><p>问:</p>\n<blockquote>\n<p>修改<code>kern/trapentry.S</code>和<code>kern/trap.c</code>来初始化<code>IDT中IRQs0-15</code>的入口和处理函数。然后修改<code>env_alloc</code>函数来确保进程在用户态运行时中断是打开的。</p>\n</blockquote>\n<p>解:</p>\n<blockquote>\n<p>模仿原先设置的默认中断向量即可，在<code>kern/trapentry.S</code>中定义<code>IRQ0-15</code>的处理例程。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">TRAPHANDLER(irq0_entry, IRQ_OFFSET + <span class=\"number\">0</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">TRAPHANDLER(irq1_entry, IRQ_OFFSET + <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">TRAPHANDLER(irq2_entry, IRQ_OFFSET + <span class=\"number\">2</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">TRAPHANDLER(irq3_entry, IRQ_OFFSET + <span class=\"number\">3</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">TRAPHANDLER(irq4_entry, IRQ_OFFSET + <span class=\"number\">4</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">TRAPHANDLER(irq5_entry, IRQ_OFFSET + <span class=\"number\">5</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">TRAPHANDLER(irq6_entry, IRQ_OFFSET + <span class=\"number\">6</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">TRAPHANDLER(irq7_entry, IRQ_OFFSET + <span class=\"number\">7</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">TRAPHANDLER(irq8_entry, IRQ_OFFSET + <span class=\"number\">8</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">TRAPHANDLER(irq9_entry, IRQ_OFFSET + <span class=\"number\">9</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">TRAPHANDLER(irq10_entry, IRQ_OFFSET + <span class=\"number\">10</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">TRAPHANDLER(irq11_entry, IRQ_OFFSET + <span class=\"number\">11</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">TRAPHANDLER(irq12_entry, IRQ_OFFSET + <span class=\"number\">12</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">TRAPHANDLER(irq13_entry, IRQ_OFFSET + <span class=\"number\">13</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">TRAPHANDLER(irq14_entry, IRQ_OFFSET + <span class=\"number\">14</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div><div class=\"line\">TRAPHANDLER(irq15_entry, IRQ_OFFSET + <span class=\"number\">15</span>, <span class=\"number\">0</span>, <span class=\"number\">0</span>);</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>然后在IDT中注册，修改<code>trap_init</code>，由于先前已经实现简化，故此无需做处理。<br>最后在<code>env_alloc</code>函数中打开中断。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// kern/env_alloc.c</span></div><div class=\"line\"><span class=\"comment\">// Also clear the IPC receiving flag.</span></div><div class=\"line\">e-&gt;env_ipc_recving = <span class=\"number\">0</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Set FL_IF so that user environments run with interrupts enabled</span></div><div class=\"line\">e-&gt;env_tf.tf_eflags |= FL_IF;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// commit the allocation</span></div><div class=\"line\">env_free_list = e-&gt;env_link;</div><div class=\"line\">*newenv_store = e;</div></pre></td></tr></table></figure></p>\n<h4 id=\"处理时钟中断\"><a href=\"#处理时钟中断\" class=\"headerlink\" title=\"处理时钟中断\"></a>处理时钟中断</h4><p>现在虽然中断使能已经打开，在用户态进程运行的时候，外部中断会产生并进入内核，但是现在还没有能处理这类中断。所以需要修改<code>trap_dispatch</code>，在发生外部定时中断的时候，调用调度器，调度另外一个可运行的进程。</p>\n<h4 id=\"练习14\"><a href=\"#练习14\" class=\"headerlink\" title=\"练习14\"></a>练习14</h4><p>问:</p>\n<blockquote>\n<p>修改<code>trap_dispatch</code>h函数，当发生时钟中断时调用<code>sched_yield</code>函数来调度下一个进程。</p>\n</blockquote>\n<p>解:</p>\n<blockquote>\n<p>添加对应函数即可<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">// kern/trap.c</div><div class=\"line\"></div><div class=\"line\">// Handle clock interrupts. Don&apos;t forget to acknowledge the</div><div class=\"line\">// interrupt using lapic_eoi() before calling the scheduler!</div><div class=\"line\">if (tf-&gt;tf_trapno == IRQ_OFFSET + IRQ_TIMER) &#123;</div><div class=\"line\">                lapic_eoi();</div><div class=\"line\">                sched_yield();</div><div class=\"line\">                return;</div><div class=\"line\"> &#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<h4 id=\"进程间通信-IPC\"><a href=\"#进程间通信-IPC\" class=\"headerlink\" title=\"进程间通信(IPC)\"></a>进程间通信(IPC)</h4><p>IPC是计算机系统中非常重要的一部分。在JOS实现IPC的方式是当两个进程需要通信的话，一方要发起<code>recv</code>，然后阻塞，直到有一个进程调用<code>send</code>向正在接受的进程发送了信息，阻塞的进程才会被唤醒。在JOS中，可以允许传递两种信息，一是一个32位整数，另外一个就是传递页的映射，在这个过程中，接收方和发送方将同时映射到一个相同的物理页，此时也就实现了内存共享。最后将这两个功能实现为一个系统调用。\n　　</p>\n<h4 id=\"实现IPC\"><a href=\"#实现IPC\" class=\"headerlink\" title=\"实现IPC\"></a>实现IPC</h4><p>在JOS的IPC实现机制中，修改<code>Env</code>结构体如下：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> Env &#123;</div><div class=\"line\">        <span class=\"keyword\">struct</span> Trapframe env_tf;        <span class=\"comment\">// Saved registers</span></div><div class=\"line\">        <span class=\"keyword\">struct</span> Env *env_link;           <span class=\"comment\">// Next free Env</span></div><div class=\"line\">        <span class=\"keyword\">envid_t</span> env_id;                 <span class=\"comment\">// Unique environment identifier</span></div><div class=\"line\">        <span class=\"keyword\">envid_t</span> env_parent_id;          <span class=\"comment\">// env_id of this env's parent</span></div><div class=\"line\">        <span class=\"keyword\">enum</span> EnvType env_type;          <span class=\"comment\">// Indicates special system environments</span></div><div class=\"line\">        <span class=\"keyword\">unsigned</span> env_status;            <span class=\"comment\">// Status of the environment</span></div><div class=\"line\">        <span class=\"keyword\">uint32_t</span> env_runs;              <span class=\"comment\">// Number of times environment has run</span></div><div class=\"line\">        <span class=\"keyword\">int</span> env_cpunum;                 <span class=\"comment\">// The CPU that the env is running on</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Address space</span></div><div class=\"line\">        <span class=\"keyword\">pde_t</span> *env_pgdir;               <span class=\"comment\">// Kernel virtual address of page dir</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Exception handling</span></div><div class=\"line\">        <span class=\"keyword\">void</span> *env_pgfault_upcall;       <span class=\"comment\">// Page fault upcall entry point</span></div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">// Lab 4 IPC</span></div><div class=\"line\">        <span class=\"keyword\">bool</span> env_ipc_recving;           <span class=\"comment\">// Env is blocked receiving</span></div><div class=\"line\">        <span class=\"keyword\">void</span> *env_ipc_dstva;            <span class=\"comment\">// VA at which to map received page</span></div><div class=\"line\">        <span class=\"keyword\">uint32_t</span> env_ipc_value;         <span class=\"comment\">// Data value sent to us</span></div><div class=\"line\">        <span class=\"keyword\">envid_t</span> env_ipc_from;           <span class=\"comment\">// envid of the sender</span></div><div class=\"line\">        <span class=\"keyword\">int</span> env_ipc_perm;               <span class=\"comment\">// Perm of page mapping received</span></div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n<p>其中增加了5个成员：</p>\n<ul>\n<li>env_ipc_recving：<br>当进程使用env_ipc_recv函数等待信息时，会将这个成员设置为1，然后堵塞等待；当一个进程向它发消息解除堵塞后，发送进程将此成员修改为0。</li>\n<li>env_ipc_dstva：<br>如果进程要接受消息并且是传送页，保存页映射的地址，且该地址&lt;=UTOP。</li>\n<li>env_ipc_value：<br>若等待消息的进程接收到消息，发送方将接收方此成员设置为消息值。</li>\n<li>env_ipc_from：<br>发送方负责设置该成员为自己的envid号。</li>\n<li>env_ipc_perm：<br>如果进程要接收消息并且传送页，那么发送方发送页之后将传送的页权限赋给这个成员</li>\n</ul>\n<h4 id=\"练习15\"><a href=\"#练习15\" class=\"headerlink\" title=\"练习15\"></a>练习15</h4><p>问:</p>\n<blockquote>\n<p>实现在<code>kern/syscall.c</code>中的<code>sys_ipc_recv和sys_ipc_try_send</code>函数。最后实现用户态的<code>ipc_recv和ipc_send</code>。</p>\n</blockquote>\n<p>解:</p>\n<blockquote>\n<p>首先是<code>sys_ipc_recv</code>函数，其功能是当一个进程试图去接收信息的时候，应该将自己标记为正在接收信息，而且为了不浪费CPU资源，应该同时标记自己为<code>ENV_NOT_RUNNABLE</code>，只有当有进程向自己发了信息之后，才会重新恢复可运行。最后将自己标记为不可运行之后，调用调度器运行其他进程。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span></span></div><div class=\"line\"><span class=\"title\">sys_ipc_recv</span><span class=\"params\">(<span class=\"keyword\">void</span> *dstva)</span></div><div class=\"line\">&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (dstva &lt; (<span class=\"keyword\">void</span> *)UTOP &amp;&amp; PGOFF(dstva))</div><div class=\"line\">                <span class=\"keyword\">return</span> -E_INVAL;</div><div class=\"line\">        curenv-&gt;env_ipc_recving = <span class=\"literal\">true</span>;</div><div class=\"line\">        curenv-&gt;env_ipc_dstva = dstva;</div><div class=\"line\">        curenv-&gt;env_status = ENV_NOT_RUNNABLE;</div><div class=\"line\">        curenv-&gt;env_ipc_from = <span class=\"number\">0</span>;</div><div class=\"line\">        sched_yield();</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>接着是<code>sys_ipc_try_send</code>函数，其实现相对来说麻烦很多，因为有很多的检测项，包括权限是否符合要求，要传送的页有没有，能不能将这一页映射到对方页表中去等等。如果<code>srcva</code>是在<code>UTOP</code>之下，那么说明是要共享内存，那就首先要在发送方的页表中找到<code>srcva</code>对应的页表项，然后在接收方给定的虚地址处插入这个页表项。接收完成之后，重新将当前进程设置为可运行，同时把<code>env_ipc_recving</code>设置为0，以防止其他的进程再发送，覆盖掉当前的内容。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">static</span> <span class=\"keyword\">int</span></span></div><div class=\"line\"><span class=\"title\">sys_ipc_try_send</span><span class=\"params\">(<span class=\"keyword\">envid_t</span> envid, <span class=\"keyword\">uint32_t</span> value, <span class=\"keyword\">void</span> *srcva, <span class=\"keyword\">unsigned</span> perm)</span></div><div class=\"line\">&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> r;</div><div class=\"line\">        <span class=\"keyword\">pte_t</span> *pte;</div><div class=\"line\">        <span class=\"keyword\">struct</span> PageInfo *pp;</div><div class=\"line\">        <span class=\"keyword\">struct</span> Env *env;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> ((r = envid2env(envid, &amp;env, <span class=\"number\">0</span>)) &lt; <span class=\"number\">0</span>)</div><div class=\"line\">                <span class=\"keyword\">return</span> -E_BAD_ENV;</div><div class=\"line\">        <span class=\"keyword\">if</span> (env-&gt;env_ipc_recving != <span class=\"literal\">true</span> || env-&gt;env_ipc_from != <span class=\"number\">0</span>)</div><div class=\"line\">                <span class=\"keyword\">return</span> -E_IPC_NOT_RECV;</div><div class=\"line\">        <span class=\"keyword\">if</span> (srcva &lt; (<span class=\"keyword\">void</span> *)UTOP &amp;&amp; PGOFF(srcva))</div><div class=\"line\">                <span class=\"keyword\">return</span> -E_INVAL;</div><div class=\"line\">        <span class=\"keyword\">if</span> (srcva &lt; (<span class=\"keyword\">void</span> *)UTOP) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> ((perm &amp; PTE_P) == <span class=\"number\">0</span> || (perm &amp; PTE_U) == <span class=\"number\">0</span>)</div><div class=\"line\">                        <span class=\"keyword\">return</span> -E_INVAL;</div><div class=\"line\">                <span class=\"keyword\">if</span> ((perm &amp; ~(PTE_P | PTE_U | PTE_W | PTE_AVAIL)) != <span class=\"number\">0</span>)</div><div class=\"line\">                        <span class=\"keyword\">return</span> -E_INVAL;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (srcva &lt; (<span class=\"keyword\">void</span> *)UTOP &amp;&amp; (pp = page_lookup(curenv-&gt;env_pgdir, srcva, &amp;pte)) == <span class=\"literal\">NULL</span>)</div><div class=\"line\">                <span class=\"keyword\">return</span> -E_INVAL;</div><div class=\"line\">        <span class=\"keyword\">if</span> (srcva &lt; (<span class=\"keyword\">void</span> *)UTOP &amp;&amp; (perm &amp; PTE_W) != <span class=\"number\">0</span> &amp;&amp; (*pte &amp; PTE_W) == <span class=\"number\">0</span>)</div><div class=\"line\">                <span class=\"keyword\">return</span> -E_INVAL;</div><div class=\"line\">        <span class=\"keyword\">if</span> (srcva &lt; (<span class=\"keyword\">void</span> *)UTOP &amp;&amp; env-&gt;env_ipc_dstva != <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> ((r = page_insert(env-&gt;env_pgdir, pp, env-&gt;env_ipc_dstva, perm)) &lt; <span class=\"number\">0</span>)</div><div class=\"line\">                        <span class=\"keyword\">return</span> -E_NO_MEM;</div><div class=\"line\">                env-&gt;env_ipc_perm = perm;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        env-&gt;env_ipc_from = curenv-&gt;env_id;</div><div class=\"line\">        env-&gt;env_ipc_recving = <span class=\"literal\">false</span>;</div><div class=\"line\">        env-&gt;env_ipc_value = value;</div><div class=\"line\">        env-&gt;env_status = ENV_RUNNABLE;</div><div class=\"line\">        env-&gt;env_tf.tf_regs.reg_eax = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>完成后需要要加上分发机制，将调用号加上。<br>最后是2个用户态库函数的实现。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int32_t</span></div><div class=\"line\">ipc_recv(<span class=\"keyword\">envid_t</span> *from_env_store, <span class=\"keyword\">void</span> *pg, <span class=\"keyword\">int</span> *perm_store)</div><div class=\"line\">&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> r;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (pg == <span class=\"literal\">NULL</span>)</div><div class=\"line\">                r = sys_ipc_recv((<span class=\"keyword\">void</span> *)UTOP);</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">                r = sys_ipc_recv(pg);</div><div class=\"line\">        <span class=\"keyword\">if</span> (from_env_store != <span class=\"literal\">NULL</span>)</div><div class=\"line\">                *from_env_store = r &lt; <span class=\"number\">0</span> ? <span class=\"number\">0</span> : thisenv-&gt;env_ipc_from;</div><div class=\"line\">        <span class=\"keyword\">if</span> (perm_store != <span class=\"literal\">NULL</span>)</div><div class=\"line\">                *perm_store = r &lt; <span class=\"number\">0</span> ? <span class=\"number\">0</span> : thisenv-&gt;env_ipc_perm;</div><div class=\"line\">        <span class=\"keyword\">if</span> (r &lt; <span class=\"number\">0</span>)</div><div class=\"line\">                <span class=\"keyword\">return</span> r;</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">                <span class=\"keyword\">return</span> thisenv-&gt;env_ipc_value;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span></span></div><div class=\"line\"><span class=\"title\">ipc_send</span><span class=\"params\">(<span class=\"keyword\">envid_t</span> to_env, <span class=\"keyword\">uint32_t</span> val, <span class=\"keyword\">void</span> *pg, <span class=\"keyword\">int</span> perm)</span></div><div class=\"line\">&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> r;</div><div class=\"line\">        <span class=\"keyword\">void</span> *dstpg;</div><div class=\"line\"></div><div class=\"line\">        dstpg = pg != <span class=\"literal\">NULL</span> ? pg : (<span class=\"keyword\">void</span> *)UTOP;</div><div class=\"line\">        <span class=\"keyword\">while</span>((r = sys_ipc_try_send(to_env, val, dstpg, perm)) &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (r != -E_IPC_NOT_RECV)</div><div class=\"line\">                        panic(<span class=\"string\">\"ipc_send: send message error %e\"</span>, r);</div><div class=\"line\">                sys_yield();</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cj6sslhaw000a3gamryu1r0la","tag_id":"cj6sslhaq00053gamgnfua53j","_id":"cj6sslhay000d3gamefjkf8uu"},{"post_id":"cj6sslhaw000a3gamryu1r0la","tag_id":"cj6sslhav00093gamuradz7wg","_id":"cj6sslhaz000f3gam2k57zu97"},{"post_id":"cj6sslhah00013game4f4mgya","tag_id":"cj6sslhaq00053gamgnfua53j","_id":"cj6sslhb0000i3gam7eyofhoj"},{"post_id":"cj6sslhah00013game4f4mgya","tag_id":"cj6sslhav00093gamuradz7wg","_id":"cj6sslhb1000k3gamdnt66k15"},{"post_id":"cj6sslhax000b3gamd5om0wu8","tag_id":"cj6sslhaq00053gamgnfua53j","_id":"cj6sslhb2000m3gamz783vwys"},{"post_id":"cj6sslhax000b3gamd5om0wu8","tag_id":"cj6sslhav00093gamuradz7wg","_id":"cj6sslhb4000p3gammjtz6h4x"},{"post_id":"cj6sslhb0000j3gamxa3120jz","tag_id":"cj6sslhax000c3gam5i2k7y8f","_id":"cj6sslhb5000r3gamssyqro77"},{"post_id":"cj6sslhb0000j3gamxa3120jz","tag_id":"cj6sslhb0000h3gam7ltidmlu","_id":"cj6sslhb6000u3gamnvebd1fc"},{"post_id":"cj6sslhan00033gamoc2r9912","tag_id":"cj6sslhax000c3gam5i2k7y8f","_id":"cj6sslhb7000w3gamkcsu97i0"},{"post_id":"cj6sslhan00033gamoc2r9912","tag_id":"cj6sslhb0000h3gam7ltidmlu","_id":"cj6sslhb9000z3gamyyji5pgs"},{"post_id":"cj6sslhb2000o3gam42svhnu1","tag_id":"cj6sslhax000c3gam5i2k7y8f","_id":"cj6sslhba00113gamhe2gcyv3"},{"post_id":"cj6sslhb2000o3gam42svhnu1","tag_id":"cj6sslhb0000h3gam7ltidmlu","_id":"cj6sslhbb00143gam522mk5v9"},{"post_id":"cj6sslhb4000q3gamti1tjs5y","tag_id":"cj6sslhb0000h3gam7ltidmlu","_id":"cj6sslhbc00163gamk00vnwje"},{"post_id":"cj6sslhb4000q3gamti1tjs5y","tag_id":"cj6sslhax000c3gam5i2k7y8f","_id":"cj6sslhbe00193gamv85c1uoc"},{"post_id":"cj6sslhb5000t3gamn6iv0usa","tag_id":"cj6sslhax000c3gam5i2k7y8f","_id":"cj6sslhbf001b3gameilzvilo"},{"post_id":"cj6sslhb5000t3gamn6iv0usa","tag_id":"cj6sslhb0000h3gam7ltidmlu","_id":"cj6sslhbg001d3gamlbjzuszx"},{"post_id":"cj6sslhas00063gamqhyyfepg","tag_id":"cj6sslhaq00053gamgnfua53j","_id":"cj6sslhbg001e3gam61vdkktw"},{"post_id":"cj6sslhas00063gamqhyyfepg","tag_id":"cj6sslhav00093gamuradz7wg","_id":"cj6sslhbh001g3gamyw86q8xr"},{"post_id":"cj6sslhb6000v3gam8axyzqpx","tag_id":"cj6sslhax000c3gam5i2k7y8f","_id":"cj6sslhbh001h3gamsmocj63s"},{"post_id":"cj6sslhb6000v3gam8axyzqpx","tag_id":"cj6sslhb0000h3gam7ltidmlu","_id":"cj6sslhbh001i3gamolzyb6te"},{"post_id":"cj6sslhb8000y3gamg8oxnej7","tag_id":"cj6sslhb0000h3gam7ltidmlu","_id":"cj6sslhbi001j3gamz2agrs49"},{"post_id":"cj6sslhb8000y3gamg8oxnej7","tag_id":"cj6sslhax000c3gam5i2k7y8f","_id":"cj6sslhbi001k3gam7c6gnuaj"},{"post_id":"cj6sslhau00073gamluxzb7kq","tag_id":"cj6sslhaq00053gamgnfua53j","_id":"cj6sslhbi001l3game5te69t0"},{"post_id":"cj6sslhau00073gamluxzb7kq","tag_id":"cj6sslhav00093gamuradz7wg","_id":"cj6sslhbi001m3gam56efkwfn"},{"post_id":"cj6sslhb900103gamxtf877ft","tag_id":"cj6sslhb0000h3gam7ltidmlu","_id":"cj6sslhbj001n3gameg8vn8o8"},{"post_id":"cj6sslhb900103gamxtf877ft","tag_id":"cj6sslhax000c3gam5i2k7y8f","_id":"cj6sslhbj001o3gamyvdv32l6"},{"post_id":"cj6sslhba00133gamnwjkhun9","tag_id":"cj6sslhb0000h3gam7ltidmlu","_id":"cj6sslhbj001p3gamdzkc1r9c"},{"post_id":"cj6sslhba00133gamnwjkhun9","tag_id":"cj6sslhax000c3gam5i2k7y8f","_id":"cj6sslhbj001q3gamtqeddywc"},{"post_id":"cj6sslhav00083gamypcq3who","tag_id":"cj6sslhaq00053gamgnfua53j","_id":"cj6sslhbj001r3gamyzrmxfm2"},{"post_id":"cj6sslhav00083gamypcq3who","tag_id":"cj6sslhav00093gamuradz7wg","_id":"cj6sslhbj001s3gamcehx0q9q"},{"post_id":"cj6sslhbb00153gamxxuhxziu","tag_id":"cj6sslhb0000h3gam7ltidmlu","_id":"cj6sslhbj001t3gamqsxw4m93"},{"post_id":"cj6sslhbb00153gamxxuhxziu","tag_id":"cj6sslhax000c3gam5i2k7y8f","_id":"cj6sslhbk001u3gam2p7h8fkf"},{"post_id":"cj6sslhbc00183gamaavs9yn3","tag_id":"cj6sslhb0000h3gam7ltidmlu","_id":"cj6sslhbk001v3gam9zg9bsyg"},{"post_id":"cj6sslhbc00183gamaavs9yn3","tag_id":"cj6sslhax000c3gam5i2k7y8f","_id":"cj6sslhbk001w3gamd0eov3p2"},{"post_id":"cj6sslhay000e3gamvmb9ap3z","tag_id":"cj6sslhax000c3gam5i2k7y8f","_id":"cj6sslhbk001x3gamqfs911xp"},{"post_id":"cj6sslhay000e3gamvmb9ap3z","tag_id":"cj6sslhb0000h3gam7ltidmlu","_id":"cj6sslhbk001y3gamhchse5e4"},{"post_id":"cj6sslhbe001a3gamk7f2y506","tag_id":"cj6sslhb0000h3gam7ltidmlu","_id":"cj6sslhbk001z3gam6gccauhb"},{"post_id":"cj6sslhbe001a3gamk7f2y506","tag_id":"cj6sslhax000c3gam5i2k7y8f","_id":"cj6sslhbk00203gam52wqy59v"},{"post_id":"cj6sslhaz000g3gam0ukwsdal","tag_id":"cj6sslhax000c3gam5i2k7y8f","_id":"cj6sslhbk00213gamdshn2sbn"},{"post_id":"cj6sslhaz000g3gam0ukwsdal","tag_id":"cj6sslhb0000h3gam7ltidmlu","_id":"cj6sslhbk00223gamk8wt5hpl"},{"post_id":"cj6sslhb1000l3gamopmetrhn","tag_id":"cj6sslhbg001f3gamt3400vz5","_id":"cj6sslhbk00233gamrjimai3o"}],"Tag":[{"name":"algorithm","_id":"cj6sslhaq00053gamgnfua53j"},{"name":"data_structure","_id":"cj6sslhav00093gamuradz7wg"},{"name":"os","_id":"cj6sslhax000c3gam5i2k7y8f"},{"name":"xv6","_id":"cj6sslhb0000h3gam7ltidmlu"},{"name":"CS","_id":"cj6sslhbg001f3gamt3400vz5"}]}}