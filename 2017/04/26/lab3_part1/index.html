<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="os,xv6," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="Lab3 用户环境 Part1摘要os运行分为两个基本状态: 内核态(kernel) 和 用户态(user).对应用进程而言, 运行在用户态下, 通过系统调用接口使用kernel提供的服务.Lab3主要实现的功能是在用户环境下的进程的正常运行.包括三个方面:   实现获得受保护的用户模式环境（即“进程”）运行所需的基本内核功能. 创建数据结构以增强JOS内核,跟踪用户环境,创建单个用户环境,将程序">
<meta name="keywords" content="os,xv6">
<meta property="og:type" content="article">
<meta property="og:title" content="lab3-user-environment-part1">
<meta property="og:url" content="http://yoursite.com/2017/04/26/lab3_part1/index.html">
<meta property="og:site_name" content="Chestnut">
<meta property="og:description" content="Lab3 用户环境 Part1摘要os运行分为两个基本状态: 内核态(kernel) 和 用户态(user).对应用进程而言, 运行在用户态下, 通过系统调用接口使用kernel提供的服务.Lab3主要实现的功能是在用户环境下的进程的正常运行.包括三个方面:   实现获得受保护的用户模式环境（即“进程”）运行所需的基本内核功能. 创建数据结构以增强JOS内核,跟踪用户环境,创建单个用户环境,将程序">
<meta property="og:updated_time" content="2017-04-30T06:58:40.700Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="lab3-user-environment-part1">
<meta name="twitter:description" content="Lab3 用户环境 Part1摘要os运行分为两个基本状态: 内核态(kernel) 和 用户态(user).对应用进程而言, 运行在用户态下, 通过系统调用接口使用kernel提供的服务.Lab3主要实现的功能是在用户环境下的进程的正常运行.包括三个方面:   实现获得受保护的用户模式环境（即“进程”）运行所需的基本内核功能. 创建数据结构以增强JOS内核,跟踪用户环境,创建单个用户环境,将程序">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"right","display":"always","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/04/26/lab3_part1/"/>





  <title> lab3-user-environment-part1 | Chestnut </title><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Chestnut</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/26/lab3_part1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Chestnutme">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chestnut">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                lab3-user-environment-part1
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-26T00:00:00+08:00">
                2017-04-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Lab3-用户环境-Part1"><a href="#Lab3-用户环境-Part1" class="headerlink" title="Lab3 用户环境 Part1"></a>Lab3 用户环境 Part1</h1><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>os运行分为两个基本状态: 内核态(kernel) 和 用户态(user).对应用进程而言, 运行在用户态下, 通过系统调用接口使用kernel提供的服务.<br>Lab3主要实现的功能是在用户环境下的进程的正常运行.包括三个方面:</p>
<blockquote>
<ol>
<li>实现获得受保护的用户模式环境（即“进程”）运行所需的基本内核功能.</li>
<li>创建数据结构以增强JOS内核,跟踪用户环境,创建单个用户环境,将程序映像加载到其中并运行.</li>
<li>使JOS内核能够处理用户环境所产生的任何系统调用,并处理其导致的任何其他异常.</li>
</ol>
</blockquote>
<p>Lab3分为两个部分:</p>
<blockquote>
<p>part1. 用户环境和异常处理<br>part2. 缺页中断, 断点异常和系统调用</p>
</blockquote>
<a id="more"></a>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>下载代码<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git pull</div><div class="line">git checkout -b lab3 origin/Lab3</div><div class="line">git merge lab2</div></pre></td></tr></table></figure></p>
<p>lab3新增的实验相关文件:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">inc/	env.h	      用户模式环境的公共定义</div><div class="line">      trap.h	    陷阱处理的公共定义</div><div class="line">      syscall.h	  从用户环境到内核的系统调用的公共定义</div><div class="line">      lib.h	      用户模式支持库函数的公共定义</div><div class="line">kern/	env.h	      用户模式环境的内核私有定义</div><div class="line">      env.c	      实现用户模式环境的内核代码</div><div class="line">      trap.h	    陷阱处理的内核私有定义</div><div class="line">      trap.c	    陷阱处理代码</div><div class="line">      trapentry.S	汇编陷阱处理程序入口</div><div class="line">      syscall.h	  用于系统调用处理的内核私有定义</div><div class="line">      syscall.c	  系统调用实现代码</div><div class="line">lib/	Makefrag	  构建用户模式的库文件的makefile,obj/lib/libJOS.a</div><div class="line">      entry.S	A   用户环境的汇编入口</div><div class="line">      libmain.c	  从entry.S调用的用户模式库文件的启动代码</div><div class="line">      syscall.c	  用户模式下系统调用的存根函数</div><div class="line">      console.c	  <span class="built_in">putchar</span>和getchar在用户模式下实现 ,提供控制台I/O</div><div class="line">      <span class="built_in">exit</span>.c	    用户模式下实现退出的代码</div><div class="line">user/	*	          各种测试程序</div></pre></td></tr></table></figure></p>
<h2 id="Part1-User-Environment"><a href="#Part1-User-Environment" class="headerlink" title="Part1 User Environment"></a>Part1 User Environment</h2><p>新包含的文件<code>inc/env.h</code>里面包含了JOS内核的有关用户环境(User Environment)的基本定义.用户环境指的就是一个应用程序运行在系统中所需要的一个上下文环境,操作系统内核使用数据结构<code>Env</code>来记录每一个用户环境的信息.Lab3只会建一个用户环境,但是之后会把它拓展成能够支持多用户环境,即多个用户程序并发执行.</p>
<p>在<code>kern/env.c</code>文件中,操作系统一共维护了三个重要的和用户环境相关的全局变量：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> Env *envs = <span class="literal">NULL</span>;    <span class="comment">//所有的 Env 结构体l链表</span></div><div class="line"><span class="keyword">struct</span> Env *curenv = <span class="literal">NULL</span>;   <span class="comment">//目前正在运行的用户环境</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">struct</span> Env *env_free_list;  <span class="comment">//还没有被使用的 Env 结构体链表</span></div></pre></td></tr></table></figure></p>
<p>一旦JOS启动,<code>envs</code>指针便指向了一个<code>Env</code>结构体链表,表示系统中所有的用户环境的<code>env</code>.JOS内核将支持同一时刻最多<code>NENV</code>个活跃的用户环境,系统会为每一个活跃的用户环境在<code>envs</code>链表中维护一个<code>Env</code>结构体.JOS内核用<code>env_free_list</code>链接起来把所有不活跃的<code>Env</code>结构体,方便进行用户环境<code>env</code>的分配和回收.另外,内核也会把<code>curenv</code>指针指向在任意时刻正在执行的用户环境的<code>Env</code>结构体.在内核启动时,并且还没有任何用户环境运行时,<code>curenv</code>的值为<code>NULL</code>.</p>
<h3 id="环境状态-Environment-Status"><a href="#环境状态-Environment-Status" class="headerlink" title="环境状态 Environment Status"></a>环境状态 Environment Status</h3><p><code>Env</code>结构体定义在 inc/env.h`:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> Env &#123;</div><div class="line">　　　　<span class="keyword">struct</span> Trapframe env_tf;      <span class="comment">//saved registers</span></div><div class="line">　　　　<span class="keyword">struct</span> Env * env_link;         <span class="comment">//next free Env</span></div><div class="line">　　　　<span class="keyword">envid_t</span> env_id;　　            <span class="comment">//Unique environment identifier</span></div><div class="line">　　　　<span class="keyword">envid_t</span> env_parent_id;        <span class="comment">//envid of this env's parent</span></div><div class="line">　　　　<span class="keyword">enum</span> EnvType env_type;　　<span class="comment">//Indicates special system environment</span></div><div class="line">　　　　<span class="keyword">unsigned</span> env_status;　　   <span class="comment">//Status of the environment</span></div><div class="line">　　　　<span class="keyword">uint32_t</span> env_runs;         <span class="comment">//Number of the times environment has run</span></div><div class="line">　　　　<span class="keyword">pde_t</span> \*env_pgdir;　　　　<span class="comment">//Kernel virtual address of page dir.</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>具体含义如下:<br><code>env_tf</code>:<br>　　定义在<code>inc/trap.h</code>文件中,里面存放着当用户环境暂停运行时,所有重要寄存器的值.内核也会在系统从用户态切换到内核态时保存这些值,这样的话用户环境可以在之后被恢复,继续执行.<br><code>env_link</code>:<br>　　该指针指向在<code>env_free_list</code>中第一个空闲的<code>Env</code>结构体.前提是这个结构体还没有被分配给任意一个用户环境时.<br><code>env_id</code>:<br>　　唯一的确定使用这个结构体的用户环境.当这个用户环境终止,内核会把这个结构体分配给另外一个不同的环境,这个新的环境会有不同的<code>env_id</code>值.<br><code>env_parent_id</code>:<br>　　创建这个用户环境的父用户环境的<code>env_id</code><br><code>env_type</code>:<br>　　用于区别某个特定的用户环境.对于大多数环境来说,它的值都是 <code>ENV_TYPE_USER</code>.<br><code>env_status</code>:<br>　　表示环境的状态,存放以下可能的值:<br>　　<code>ENV_FREE</code>: 结构体是空闲的,应该在链表<code>env_free_list</code>中.<br>　　<code>ENV_RUNNABLE</code>: 结构体对应的用户环境已经就绪,等待被分配处理机.<br>　　<code>ENV_RUNNING</code>: 结构体对应的用户环境正在运行.<br>　　<code>ENV_NOT_RUNNABLE</code>: 结构体所代表的是一个活跃的用户环境,但是它不能被调度运行,因为它在等待其他环境传递给它的消息.<br>　　<code>ENV_DYING</code>: 代表这个结构体对应的是一个僵尸环境.一个僵尸环境在下一次陷入内核时会被释放回收.<br><code>env_pgdir</code>:<br>　　存放这个环境的页目录的虚拟地址</p>
<p>正如<code>Unix</code>中的进程一样,一个JOS环境中结合了“线程”和“地址空间”的概念.线程通常是由被保存的寄存器的值来定义的,而地址空间则是由<code>env_pgdir</code>所指向的页目录表还有页表来定义的.为了运行一个用户环境,内核必须设置合适的寄存器的值以及合适的地址空间.</p>
<h3 id="分配环境数组"><a href="#分配环境数组" class="headerlink" title="分配环境数组"></a>分配环境数组</h3><p>lab2中<code>mem_init()</code>函数中分配了<code>pages</code>数组的地址空间,用于记录内核中所有的页的信息.lab3需要进一步去修改<code>mem_init()</code>函数,分配<code>Env</code>结构体数组<code>envs</code>.</p>
<h4 id="练习1"><a href="#练习1" class="headerlink" title="练习1:"></a>练习1:</h4><p>问:</p>
<blockquote>
<p>修改<code>mem_init()</code>的代码,让它能够分配<code>envs</code>数组.这个数组是由<code>NENV</code>个<code>Env</code>结构体组成的.<code>envs</code>数组所在的内存空间在用户模式下是只读的,被映射到虚拟地址<code>UENVS</code>处.</p>
</blockquote>
<p>解:</p>
<blockquote>
<p>如同Lab2里面分配pages数组,分配一个<code>Env</code>数组给指针<code>envs</code>即可<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//kern/pmap.c</span></div><div class="line"><span class="comment">//分配内存空间给envs</span></div><div class="line">envs = (<span class="keyword">struct</span> Env*)boot_alloc(NENV*<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Env));</div><div class="line"><span class="built_in">memset</span>(envs, <span class="number">0</span>, NENV * <span class="keyword">sizeof</span>(<span class="keyword">struct</span> Env));</div><div class="line"><span class="comment">//页表中设置envs的映射关系</span></div><div class="line">boot_map_region(kern_pgdir, UENVS, PTSIZE, PADDR(envs), PTE_U);</div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="创建运行环境"><a href="#创建运行环境" class="headerlink" title="创建运行环境"></a>创建运行环境</h3><p>编写 <code>kern/env.c</code>文件来运行一个用户环境了.由于现在没有文件系统,所以必须把内核设置成能够加载内核中的静态二进制程序映像文件.在<code>i386_init()</code>函数中,编码完成运行用户环境的功能.</p>
<h4 id="练习2"><a href="#练习2" class="headerlink" title="练习2:"></a>练习2:</h4><p>问:</p>
<blockquote>
<p>在文件<code>env.c</code>中,完成下列函数：<br><code>env_init()</code>:<br>初始化所有的在<code>envs</code>数组中的<code>Env</code>结构体,并把它们加入到 <code>env_free_list</code>中. 还要调用<code>env_init_percpu</code>,这个函数要配置段式内存管理系统,让它所管理的段具有两种访问优先级的一种,一个是内核运行时的0优先级,以及用户运行时的3优先级.<br><code>env_setup_vm()</code>:<br>为一个新的用户环境分配一个页目录表,并且初始化这个用户环境的地址空间中的和内核相关的部分.<br><code>region_alloc()</code>:<br>为用户环境分配物理地址空间<br><code>load_icode()</code>:<br>分析一个<code>ELF</code>文件,把它的内容加载到用户环境下.<br><code>env_create()</code>:<br>利用<code>env_alloc</code>函数和<code>load_icode</code>函数,加载一个<code>ELF</code>文件到用户环境中<br><code>env_run()</code>:<br>在用户模式下,开始运行一个用户环境.</p>
</blockquote>
<p>解:</p>
<blockquote>
<p><code>env_init</code>函数,通过遍历<code>envs</code>数组中的所有<code>Env</code>结构体,把每一个结构体的 <code>env_id</code>字段置0,因为要求所有的<code>Env</code>在<code>env_free_list</code>中的顺序,要和它在 <code>envs</code>中的顺序一致,采用头插法.　　<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"> <span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">env_init</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="comment">// Set up envs array</span></div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    env_free_list = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">for</span> (i=NENV<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--)&#123;</div><div class="line">        envs[i].env_id = <span class="number">0</span>;</div><div class="line">        envs[i].env_status = ENV_FREE;</div><div class="line">        envs[i].env_link = env_free_list;</div><div class="line">        env_free_list = &amp;envs[i];</div><div class="line">     &#125;</div><div class="line">     <span class="comment">// Per-CPU part of the initialization</span></div><div class="line">     env_init_percpu();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>env_setup_vm()</code>初始化新的用户环境的页目录表,只设置页目录表中和操作系统内核跟内核相关的页目录项,用户环境的页目录项不要设置,因为所有用户环境的页目录表中和操作系统相关的页目录项都是一样的（除了虚拟地址<code>UVPT</code>,单独进行设置）,所以可以参照<code>kern_pgdir</code>中的内容来设置<code>env_pgdir</code>中的内容.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span></span></div><div class="line"><span class="title">env_setup_vm</span><span class="params">(<span class="keyword">struct</span> Env *e)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">struct</span> PageInfo* p = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line">    <span class="comment">// Allocate a page for the page directory</span></div><div class="line">    <span class="keyword">if</span> (!(p = page_alloc(ALLOC_ZERO)))</div><div class="line">        <span class="keyword">return</span> -E_NO_MEM;</div><div class="line"></div><div class="line">     e-&gt;env_pgdir = (<span class="keyword">pde_t</span> *)page2kva(p);</div><div class="line">     p-&gt;pp_ref++;</div><div class="line"></div><div class="line">     <span class="comment">//Map the directory below UTOP.</span></div><div class="line">     <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; PDX(UTOP); i++)</div><div class="line">         e-&gt;env_pgdir[i] = <span class="number">0</span>;        </div><div class="line"></div><div class="line">     <span class="comment">//Map the directory above UTOP</span></div><div class="line">     <span class="keyword">for</span> (i = PDX(UTOP); i &lt; NPDENTRIES; i++) &#123;</div><div class="line">         e-&gt;env_pgdir[i] = kern_pgdir[i];</div><div class="line">     &#125;</div><div class="line"></div><div class="line">     <span class="comment">// UVPT maps the env's own page table read-only.</span></div><div class="line">     <span class="comment">// Permissions: kernel R, user R</span></div><div class="line">     e-&gt;env_pgdir[PDX(UVPT)] = PADDR(e-&gt;env_pgdir) | PTE_P | PTE_U;</div><div class="line"></div><div class="line">     <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p><code>region_alloc()</code>为用户环境分配物理空间,这里注意我们要先把起始地址和终止地址进行页对齐,对其之后我们就可以以页为单位,为其一个页一个页的分配内存,并且修改页目录表和页表.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">region_alloc</span><span class="params">(<span class="keyword">struct</span> Env *e, <span class="keyword">void</span> *va, <span class="keyword">size_t</span> len)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">void</span>* start = (<span class="keyword">void</span> *)ROUNDDOWN((<span class="keyword">uint32_t</span>)va, PGSIZE);</div><div class="line">    <span class="keyword">void</span>* end = (<span class="keyword">void</span> *)ROUNDUP((<span class="keyword">uint32_t</span>)va+len, PGSIZE);</div><div class="line">    <span class="keyword">struct</span> PageInfo *p = <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">void</span>* i;</div><div class="line">    <span class="keyword">int</span> r;</div><div class="line"></div><div class="line">    <span class="keyword">for</span>(i = start; i &lt; end; i += PGSIZE)&#123;</div><div class="line">        p = page_alloc(<span class="number">0</span>);</div><div class="line">        <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</div><div class="line">           panic(<span class="string">" region alloc failed: allocation failed.\n"</span>);</div><div class="line"></div><div class="line">        r = page_insert(e-&gt;env_pgdir, p, i, PTE_W | PTE_U);</div><div class="line">        <span class="keyword">if</span>(r != <span class="number">0</span>)</div><div class="line">            panic(<span class="string">"region alloc failed.\n"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　<code>load_icode()</code>为每一个用户进程设置它的初始代码区,堆栈以及CPU标识.用户程序是<code>ELF</code>文件,解析<code>ELF</code>文件.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span></span></div><div class="line"><span class="title">load_icode</span><span class="params">(<span class="keyword">struct</span> Env *e, <span class="keyword">uint8_t</span> *binary)</span></div><div class="line">&#123;</div><div class="line"></div><div class="line">    <span class="keyword">struct</span> Elf* header = (<span class="keyword">struct</span> Elf*)binary;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (header-&gt;e_magic != ELF_MAGIC)</div><div class="line">        panic(<span class="string">"load_icode failed: The binary we load is not elf.\n"</span>);</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (header-&gt;e_entry == <span class="number">0</span>)</div><div class="line">        panic(<span class="string">"load_icode failed: The elf file can't be excuterd.\n"</span>);</div><div class="line"></div><div class="line">   e-&gt;env_tf.tf_eip = header-&gt;e_entry;</div><div class="line"></div><div class="line">   lcr3(PADDR(e-&gt;env_pgdir));   <span class="comment">//load user pgdir</span></div><div class="line"></div><div class="line">   <span class="keyword">struct</span> Proghdr *ph, *eph;</div><div class="line">   ph = (<span class="keyword">struct</span> Proghdr* )((<span class="keyword">uint8_t</span> *)header + header-&gt;e_phoff);</div><div class="line">   eph = ph + header-&gt;e_phnum;</div><div class="line">    <span class="keyword">for</span>(; ph &lt; eph; ph++) &#123;</div><div class="line">        <span class="keyword">if</span>(ph-&gt;p_type == ELF_PROG_LOAD) &#123;</div><div class="line">            <span class="keyword">if</span>(ph-&gt;p_memsz - ph-&gt;p_filesz &lt; <span class="number">0</span>)</div><div class="line">                panic(<span class="string">"load icode failed : p_memsz &lt; p_filesz.\n"</span>);</div><div class="line"></div><div class="line">           region_alloc(e, (<span class="keyword">void</span> *)ph-&gt;p_va, ph-&gt;p_memsz);</div><div class="line">            memmove((<span class="keyword">void</span> *)ph-&gt;p_va, binary + ph-&gt;p_offset, ph-&gt;p_filesz);</div><div class="line">            <span class="built_in">memset</span>((<span class="keyword">void</span> *)(ph-&gt;p_va + ph-&gt;p_filesz), <span class="number">0</span>, ph-&gt;p_memsz - ph-&gt;p_filesz);</div><div class="line">        &#125;</div><div class="line">     &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>env_create</code>是利用<code>env_alloc</code>函数和<code>load_icode</code>函数,加载一个<code>ELF</code>文件到用户环境中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">env_create</span><span class="params">(<span class="keyword">uint8_t</span> *binary, <span class="keyword">enum</span> EnvType type)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">struct</span> Env *e;</div><div class="line">    <span class="keyword">int</span> rc;</div><div class="line">    <span class="keyword">if</span> ((rc = env_alloc(&amp;e, <span class="number">0</span>)) != <span class="number">0</span>)</div><div class="line">          panic(<span class="string">"env_create failed: env_alloc failed.\n"</span>);</div><div class="line"></div><div class="line">     load_icode(e, binary);</div><div class="line">     e-&gt;env_type = type;</div><div class="line"> &#125;</div></pre></td></tr></table></figure></p>
<p><code>env_run</code>开始运行一个用户环境<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">env_run</span><span class="params">(<span class="keyword">struct</span> Env *e)</span></div><div class="line">&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span>(curenv != <span class="literal">NULL</span> &amp;&amp; curenv-&gt;env_status == ENV_RUNNING)</div><div class="line">        curenv-&gt;env_status = ENV_RUNNABLE;</div><div class="line"></div><div class="line">    curenv = e;</div><div class="line">    curenv-&gt;env_status = ENV_RUNNING;</div><div class="line">    curenv-&gt;env_runs++;</div><div class="line">    lcr3(PADDR(curenv-&gt;env_pgdir));</div><div class="line"></div><div class="line">    env_pop_tf(&amp;curenv-&gt;env_tf);</div><div class="line"></div><div class="line">    panic(<span class="string">"env_run not yet implemented"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<p>用户环境的代码被调用前,操作系统一共按顺序执行了以下几个函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">* start (kern/entry.S)</div><div class="line">* i386_init (kern/init.c)</div><div class="line">cons_init</div><div class="line">mem_init</div><div class="line">env_init</div><div class="line">trap_init （目前还未实现）</div><div class="line">env_create</div><div class="line">env_run</div><div class="line">env_pop_tf</div></pre></td></tr></table></figure></p>
<p>完成上述子函数的代码后,并且在<code>QEMU</code>下编译运行,系统会进入用户空间,并且开始执行<code>hello</code>程序,直到它做出一个系统调用指令<code>int</code>.但是这个系统调用指令不能成功运行,因为到目前为止,JOS还没有设置相关硬件来实现从用户态向内核态的转换功能.当CPU发现,它没有被设置成能够处理这种系统调用中断时,它会触发一个保护异常,然后发现这个保护异常也无法处理,从而又产生一个错误异常,然后又发现仍旧无法解决问题,所以最后放弃,这种异常被称为”triple fault”.通常来说,接下来CPU会复位,系统会重启.</p>
<h3 id="处理中断和异常"><a href="#处理中断和异常" class="headerlink" title="处理中断和异常"></a>处理中断和异常</h3><p>到目前为止,当程序运行到第一个系统调用<code>int $0x30</code>时,就会进入错误的状态,因为现在系统无法从用户态切换到内核态.需要实现一个基本的异常处理机制,使得内核可以从用户态转换为内核态.学习X86的异常中断机制.</p>
<h3 id="受保护的控制转移"><a href="#受保护的控制转移" class="headerlink" title="受保护的控制转移"></a>受保护的控制转移</h3><p>异常(Exception)和中断(Interrupts)都是“受到保护的控制转移方法”,都会使CPU从用户态转移为内核态.在Intel的术语中,一个中断指的是由外部异步事件引起的CPU控制权转移,比如外部IO设备发送来的中断信号.一个异常则是由于当前正在运行的指令所带来的同步的CPU控制权的转移,比如除零异常.</p>
<p>为了能够确保这些控制的转移能够真正被保护起来,CPU的中断/异常机制通常被设计为：用户态的代码无权选择内核中的代码从哪里开始执行.CPU可以确保只有在某些条件下,才能进入内核态.在X86上,有两种机制配合工作来提供这种保护：</p>
<blockquote>
<ol>
<li><p><strong>中断向量表 The Interrupt Descriptor Table</strong>：<br>CPU保证中断和异常只能够引起内核进入到一些特定的,被事先定义好的程序入口,而不是由触发中断的程序来决定中断程序入口.<br>X86有256个不同的中断和异常,对应特定的中断向量.一个向量指的就是0到255中的一个数.一个中断向量的值是根据中断源来决定的：不同设备/错误/对内核的请求,会产生出不同的中断和中断向量的组合.CPU将使用这个向量作为这个中断在中断向量表中的索引,这个表是由内核设置的,放在内核空间中.通过<code>IDT</code>中的任意一个表项,CPU得到以下信息:</p>
<blockquote>
<ul>
<li>加载到<code>EIP</code>寄存器中的值,这个值指向了处理这个中断的中断处理程序的位置.</li>
<li>加载到<code>CS</code>寄存器中的值,里面还包含了这个中断处理程序的运行特权级.</li>
</ul>
</blockquote>
</li>
<li><p><strong>任务状态段 The Task State Segment</strong><br>CPU还需要一个地方来存放异常/中断发生时CPU的状态,比如<code>EIP</code>和<code>CS</code>寄存器的值.这样的话,中断处理程序能够顺利重新返回到原来的程序中.这段内存自然也要保护起来,不能被用户态的程序所篡改.<br>正因为如此,当一个x86CPU要处理一个中断,异常并且使运行特权级从用户态转为内核态时,它也会把它的堆栈切换到内核空间中.一个叫做 “任务状态段（TSS）”的数据结构将会详细记录这个堆栈所在的段的段描述符和地址.CPU把<code>SS,ESP,EFLAGS,CS,EIP</code>以及一个可选错误码等等这些值压入到这个堆栈上.然后加载中断处理程序的<code>CS,EIP</code>值,并且设置<code>ESP,SS</code>寄存器指向新的堆栈.由于JOS中的内核态指的就是特权级0,所以CPU用<code>TSS</code>中的<code>ESP0,SS0</code>字段来指明这个内核堆栈的位置,大小.</p>
</li>
</ol>
</blockquote>
<h3 id="中断-异常的类型"><a href="#中断-异常的类型" class="headerlink" title="中断/异常的类型"></a>中断/异常的类型</h3><p>所有的由X86CPU内部产生的异常的向量值是0到31之间的整数.比如,页表错误所对应的向量值是14.而大于31号的中断向量对应的是软件中断,由int指令生成；或者是外部中断,由外部设备生成.</p>
<p>part1扩展JOS的功能,使它能够处理0~31号内部异常.part2让JOS能够处理48号软件中断,主要被用来做系统调用.在Lab4中会继续扩展JOS使它能够处理外部硬件中断,比如时钟中断.</p>
<p>实例:</p>
<blockquote>
<p>假设CPU正在用户状态下运行代码,但是遇到了一个除法指令,并且除数为0.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">+--------------------+ KSTACKTOP             </div><div class="line">| 0x00000 | old SS   |     &quot; - 4</div><div class="line">|      old ESP       |     &quot; - 8</div><div class="line">|     old EFLAGS     |     &quot; - 12</div><div class="line">| 0x00000 | old CS   |     &quot; - 16</div><div class="line">|      old EIP       |     &quot; - 20 &lt;---- ESP</div><div class="line">+--------------------+</div></pre></td></tr></table></figure></p>
<p>发生除零异常后,CPU运行如下:</p>
<ol>
<li>CPU会首先切换自己的堆栈,切换到由<code>TSS</code>的<code>SS0,ESP0</code>字段所指定的内核堆栈区,这两个字段分别存放着<code>GD_KD</code>和<code>KSTACKTOP</code>的值.</li>
<li>CPU把异常参数压入到内核堆栈中,起始于地址<code>KSTACKTOP</code>：</li>
<li>因为要处理的是除零异常,它的中断向量是0,CPU会读取<code>IDT</code>表中的0号表项,并且把<code>CS:EIP</code>的值设置为0号中断处理函数的地址值.</li>
<li>中断处理函数开始执行,处理中断.</li>
</ol>
<p>对于某些特定的异常,除了中要保存的五个值之外,还要再压入一个字,叫做错误码(error code).比如页表错误,就是其中一个实例.当压入错误码之后,内核堆栈的状态如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">+--------------------+ KSTACKTOP             </div><div class="line">| 0x00000 | old SS   |     &quot; - 4</div><div class="line">|      old ESP       |     &quot; - 8</div><div class="line">|     old EFLAGS     |     &quot; - 12</div><div class="line">| 0x00000 | old CS   |     &quot; - 16</div><div class="line">|      old EIP       |     &quot; - 20</div><div class="line">|     error code     |     &quot; - 24 &lt;---- ESP</div><div class="line">+--------------------+</div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="中断-异常的嵌套"><a href="#中断-异常的嵌套" class="headerlink" title="中断/异常的嵌套"></a>中断/异常的嵌套</h3><p>　　CPU在用户态下和内核态下都可以处理异常或中断.只有当CPU从用户态切换到内核态时,硬件才会自动地切换堆栈,并且把一些寄存器中的原来的值压入到堆栈上,并且触发相应的中断处理函数.但如果CPU已经由于正在处理中断而处在内核态下时,此时CPU会向内核堆栈压入更多的值.通过这种方式,内核就可处理嵌套中断.<br>　　如果CPU已经在内核态下并且遇到嵌套中断,因为它不需要切换堆栈,所以它不需要存储<code>SS,ESP</code>寄存器的值.此时内核堆栈如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">+--------------------+ &lt;---- old ESP</div><div class="line">|     old EFLAGS     |     &quot; - 4</div><div class="line">| 0x00000 | old CS   |     &quot; - 8</div><div class="line">|      old EIP       |     &quot; - 12</div><div class="line">+--------------------+</div></pre></td></tr></table></figure></p>
<p>但可能会发生一个问题: 如果CPU在内核态下捕捉一个异常,而且由于一些原因,比如堆栈空间不足,不能把当前的状态信息（寄存器的值）压入到内核堆栈中时,那么CPU是无法恢复到原来的状态,它会自动重启.</p>
<h3 id="设置IDT"><a href="#设置IDT" class="headerlink" title="设置IDT"></a>设置IDT</h3><p>上文确定了基本信息, 可以设置IDT表,并在JOS处理异常了.Lab3只需要处理内部异常（中断向量号0~31）.在头文件<code>inc/trap.h和kern/trap.h</code>中包含了和中断异常相关的的定义.<br>最后要实现的效果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">IDT                   trapentry.S         trap.c</div><div class="line"></div><div class="line">+----------------+                        </div><div class="line">|   &amp;handler1    |---------&gt; handler1:          trap (struct Trapframe *tf)</div><div class="line">|                |             // do stuff      &#123;</div><div class="line">|                |             call trap          // handle the exception/interrupt</div><div class="line">|                |             // ...           &#125;</div><div class="line">+----------------+</div><div class="line">|   &amp;handler2    |--------&gt; handler2:</div><div class="line">|                |            // do stuff</div><div class="line">|                |            call trap</div><div class="line">|                |            // ...</div><div class="line">+----------------+</div><div class="line"> .</div><div class="line"> .</div><div class="line"> .</div><div class="line">+----------------+</div><div class="line">|   &amp;handlerX    |--------&gt; handlerX:</div><div class="line">|                |             // do stuff</div><div class="line">|                |             call trap</div><div class="line">|                |             // ...</div><div class="line">+----------------+</div></pre></td></tr></table></figure></p>
<p>每一个中断/异常都有它自己的中断处理函数,定义在<code>trapentry.S</code>中.<code>trap_init()</code>将初始化<code>IDT</code>表.每一个处理函数都构建一个结构体 <code>Trapframe</code>在堆栈上,并且调用<code>trap()</code>函数指向这个结构体,<code>trap()</code>然后处理异常/中断,给它分配一个中断处理函数.<br>所以操作系统的中断控制流程为：</p>
<blockquote>
<ol>
<li><code>trap_init()</code>先将所有中断处理函数的起始地址放到中断向量表<code>IDT</code>中.</li>
<li>当中断发生时,不管是外部中断还是内部中断,CPU捕捉到该中断,进入核心态,根据中断向量去查询中断向量表,找到对应的表项</li>
<li>保存被中断的程序的上下文到内核堆栈中,调用这个表项中指明的中断处理函数.</li>
<li>执行中断处理函数.</li>
<li>执行完成后,恢复被中断的进程的上下文,返回用户态,继续运行这个进程.</li>
</ol>
</blockquote>
<h4 id="练习4"><a href="#练习4" class="headerlink" title="练习4"></a>练习4</h4><p>问</p>
<blockquote>
<p>修改<code>trapentry.S</code>和<code>trap.c</code>文件,实现上述的功能.在<code>trapentry.S</code>文件中为在<code>inc/trap.h</code>文件中的每一个<code>trap</code>加入一个入口指针, 修改<code>trap_init()</code>函数来初始化<code>IDT</code>表,使表中每一项指向定义在<code>trapentry.S</code>中的入口指针.<br><code>_alltraps</code>要求:</p>
<ol>
<li>把值压入堆栈,使堆栈结构类似一个结构体<code>Trapframe</code></li>
<li>加载<code>GD_KD</code>的值到<code>%ds, %es</code>寄存器中</li>
<li>压栈<code>%esp</code>的值,并且传递一个指向<code>Trapframe</code>的指针到`trap()``函数中.</li>
<li>调用<code>trap</code><br>解<br>在<code>trapentry.S</code>文件定义了两个宏,<code>TRAPHANDLER</code>,<code>TRAPHANDLER_NOEC</code>.其功能为：声明了一个全局符号name,并且这个符号是函数类型的,代表它是一个中断处理函数名.当系统检测到一个中断/异常时,首先需要完成的一部分操作,包括：中断异常码,中断错误码(error code).因为有些中断有中断错误码,有些没有,所以采用两个宏定义函数.<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TRAPHANDLER(name, num)                        \</span></div><div class="line">        .globl name;            <span class="comment">/* define global symbol for 'name' */</span>   \</div><div class="line">        .type name, @function;  <span class="comment">/* symbol type is function */</span>           \</div><div class="line">        .align 2;               <span class="comment">/* align function definition */</span>         \</div><div class="line">        name:                   <span class="comment">/* function starts here */</span>              \</div><div class="line">        pushl $(num);                                                   \</div><div class="line">        jmp _alltraps</div><div class="line"><span class="comment">/* Use TRAPHANDLER_NOEC for traps where the CPU doesn't push an error code.</span></div><div class="line"> * It pushes a 0 in place of the error code, so the trap frame has the same</div><div class="line"> * format in either case.</div><div class="line"> */</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> TRAPHANDLER_NOEC(name, num)                                     \</span></div><div class="line">        .globl name;                                                    \</div><div class="line">        .type name, @function;                                          \</div><div class="line">        .align 2;                                                       \</div><div class="line">        name:                                                           \</div><div class="line">        pushl $0;                                                       \</div><div class="line">        pushl $(num);                                                   \</div><div class="line">        jmp _alltraps</div><div class="line"></div><div class="line">.text</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"> * Lab 3: Your code here for generating entry points for the different traps.</div><div class="line"> */</div><div class="line">TRAPHANDLER_NOEC(divide_entry, T_DIVIDE);</div><div class="line">TRAPHANDLER_NOEC(debug_entry, T_DEBUG);</div><div class="line">TRAPHANDLER_NOEC(nmi_entry, T_NMI);</div><div class="line">TRAPHANDLER_NOEC(brkpt_entry, T_BRKPT);</div><div class="line">TRAPHANDLER_NOEC(oflow_entry, T_OFLOW);</div><div class="line">TRAPHANDLER_NOEC(bound_entry, T_BOUND);</div><div class="line">TRAPHANDLER_NOEC(illop_entry, T_ILLOP);</div><div class="line">TRAPHANDLER_NOEC(device_entry, T_DEVICE);</div><div class="line">TRAPHANDLER(dblflt_entry, T_DBLFLT);</div><div class="line">TRAPHANDLER(tss_entry, T_TSS);</div><div class="line">TRAPHANDLER(segnp_entry, T_SEGNP);</div><div class="line">TRAPHANDLER(stack_entry, T_STACK);</div><div class="line">TRAPHANDLER(gpflt_entry, T_GPFLT);</div><div class="line">TRAPHANDLER(pgflt_entry, T_PGFLT);</div><div class="line">TRAPHANDLER_NOEC(fperr_entry, T_FPERR);</div><div class="line">TRAPHANDLER(align_entry, T_ALIGN);</div><div class="line">TRAPHANDLER_NOEC(mchk_entry, T_MCHK);</div><div class="line">TRAPHANDLER_NOEC(simderr_entry, T_SIMDERR);</div><div class="line">TRAPHANDLER_NOEC(syscall_entry, T_SYSCALL);</div></pre></td></tr></table></figure>
</li>
</ol>
<p>然后调用<code>_alltraps</code>函数,使程序在之后调用<code>trap.</code>c中的<code>trap</code>函数时,能够正确的访问到输入的参数,即<code>Trapframe</code>指针类型的输入参数<code>tf</code>.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">_alltraps:</div><div class="line">        pushl %ds</div><div class="line">        pushl %es</div><div class="line">        pushal</div><div class="line"></div><div class="line">        movl $GD_KD, %eax</div><div class="line">        movl %eax, %ds</div><div class="line">        movl %eax, %es</div><div class="line"></div><div class="line">        push %esp</div><div class="line">        call trap</div></pre></td></tr></table></figure></p>
<p>最后在<code>trap.c</code>中实现<code>trap_init</code>函数,即在<code>IDT</code>表中插入中断向量描述符,可以使用<code>SETGATE</code>宏实现,其定义如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//gate:IDT表的index入口</span></div><div class="line"><span class="comment">//istrap:判断是异常还是中断</span></div><div class="line"><span class="comment">//sel:代码段选择符</span></div><div class="line"><span class="comment">//off:对应的处理函数地址</span></div><div class="line"><span class="comment">//dpl:触发该异常或中断的用户权限.</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> SETGATE(gate, istrap, sel, off, dpl)</span></div></pre></td></tr></table></figure></p>
<p><code>trap_init</code>实现：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">trap_init</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">extern</span> <span class="keyword">struct</span> Segdesc gdt[];</div><div class="line"></div><div class="line">        SETGATE(idt[T_DIVIDE], <span class="number">0</span>, GD_KT, divide_entry, <span class="number">0</span>);</div><div class="line">        SETGATE(idt[T_DEBUG], <span class="number">0</span>, GD_KT, debug_entry, <span class="number">0</span>);</div><div class="line">        SETGATE(idt[T_NMI], <span class="number">0</span>, GD_KT, nmi_entry, <span class="number">0</span>);</div><div class="line">        SETGATE(idt[T_BRKPT], <span class="number">0</span>, GD_KT, brkpt_entry, <span class="number">3</span>);</div><div class="line">        SETGATE(idt[T_OFLOW], <span class="number">0</span>, GD_KT, oflow_entry, <span class="number">0</span>);</div><div class="line">        SETGATE(idt[T_BOUND], <span class="number">0</span>, GD_KT, bound_entry, <span class="number">0</span>);</div><div class="line">        SETGATE(idt[T_ILLOP], <span class="number">0</span>, GD_KT, illop_entry, <span class="number">0</span>);</div><div class="line">        SETGATE(idt[T_DEVICE], <span class="number">0</span>, GD_KT, device_entry, <span class="number">0</span>);</div><div class="line">        SETGATE(idt[T_DBLFLT], <span class="number">0</span>, GD_KT, dblflt_entry, <span class="number">0</span>);</div><div class="line">        SETGATE(idt[T_TSS], <span class="number">0</span>, GD_KT, tss_entry, <span class="number">0</span>);</div><div class="line">        SETGATE(idt[T_SEGNP], <span class="number">0</span>, GD_KT, segnp_entry, <span class="number">0</span>);</div><div class="line">        SETGATE(idt[T_STACK], <span class="number">0</span>, GD_KT, stack_entry, <span class="number">0</span>);</div><div class="line">        SETGATE(idt[T_GPFLT], <span class="number">0</span>, GD_KT, gpflt_entry, <span class="number">0</span>);</div><div class="line">        SETGATE(idt[T_PGFLT], <span class="number">0</span>, GD_KT, pgflt_entry, <span class="number">0</span>);</div><div class="line">        SETGATE(idt[T_FPERR], <span class="number">0</span>, GD_KT, fperr_entry, <span class="number">0</span>);</div><div class="line">        SETGATE(idt[T_ALIGN], <span class="number">0</span>, GD_KT, align_entry, <span class="number">0</span>);</div><div class="line">        SETGATE(idt[T_MCHK], <span class="number">0</span>, GD_KT, mchk_entry, <span class="number">0</span>);</div><div class="line">        SETGATE(idt[T_SIMDERR], <span class="number">0</span>, GD_KT, simderr_entry, <span class="number">0</span>);</div><div class="line">        SETGATE(idt[T_SYSCALL], <span class="number">0</span>, GD_KT, syscall_entry, <span class="number">3</span>);</div><div class="line"></div><div class="line">        trap_init_percpu();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
</blockquote>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol>
<li><p>每个异常/中断具有特定处理函数的目的是什么?（即如果所有异常/中断都传递给同一个处理程序,那么无法提供当前实现中存在的哪些功能?）<br>解:<br>　　不同的中断或者异常当然需要不同的中断处理函数,因为不同的异常/中断可能需要不同的处理方式,比如有些异常是代表指令有错误,则不会返回被中断的命令.而有些中断可能只是为了处理外部IO事件,此时执行完中断函数还要返回到被中断的程序中继续运行.</p>
</li>
<li><p>对软中断程序,测试程序预计会产生一般的保护错误（陷阱13）,但软中断的代码说<code>int $14</code>.为什么要产生中断向量13?如果内核允许软中断程序的<code>int $14</code>指令调用内核的页面错误处理程序（中断向量14）,会发生什么?<br>解<br>　　因为当前的系统正在运行在用户态下,特权级为3,而<code>INT</code>指令为系统指令,特权级为0.特权级为3的程序不能直接调用特权级为0的程序,会引发一个<code>General Protection Exception</code>,即`trap 13</p>
</li>
</ol>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/os/" rel="tag"># os</a>
          
            <a href="/tags/xv6/" rel="tag"># xv6</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/04/29/lab3_part2/" rel="next" title="lab3-user-environment-part2">
                <i class="fa fa-chevron-left"></i> lab3-user-environment-part2
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/04/24/hw5/" rel="prev" title="hw5-cpu-alarm">
                hw5-cpu-alarm <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.jpg"
               alt="Chestnutme" />
          <p class="site-author-name" itemprop="name">Chestnutme</p>
           
              <p class="site-description motion-element" itemprop="description">In a Nut-Universe</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">18</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/chestnutme" target="_blank" title="Github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Github
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Lab3-用户环境-Part1"><span class="nav-number">1.</span> <span class="nav-text">Lab3 用户环境 Part1</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#摘要"><span class="nav-number">1.1.</span> <span class="nav-text">摘要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#准备"><span class="nav-number">1.2.</span> <span class="nav-text">准备</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Part1-User-Environment"><span class="nav-number">1.3.</span> <span class="nav-text">Part1 User Environment</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#环境状态-Environment-Status"><span class="nav-number">1.3.1.</span> <span class="nav-text">环境状态 Environment Status</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分配环境数组"><span class="nav-number">1.3.2.</span> <span class="nav-text">分配环境数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#练习1"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">练习1:</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建运行环境"><span class="nav-number">1.3.3.</span> <span class="nav-text">创建运行环境</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#练习2"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">练习2:</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理中断和异常"><span class="nav-number">1.3.4.</span> <span class="nav-text">处理中断和异常</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#受保护的控制转移"><span class="nav-number">1.3.5.</span> <span class="nav-text">受保护的控制转移</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中断-异常的类型"><span class="nav-number">1.3.6.</span> <span class="nav-text">中断/异常的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中断-异常的嵌套"><span class="nav-number">1.3.7.</span> <span class="nav-text">中断/异常的嵌套</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设置IDT"><span class="nav-number">1.3.8.</span> <span class="nav-text">设置IDT</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#练习4"><span class="nav-number">1.3.8.1.</span> <span class="nav-text">练习4</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#问题"><span class="nav-number">1.3.9.</span> <span class="nav-text">问题</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chestnutme</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->



  


  




	





  





  





  






  





  

  

  
  


  

</body>
</html>
